(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var EXTRA_PADDING = 12;
var GRID_INTERVALS_PX = [1, 2, 4, 8, 16, 24, 48, 100, 100, 250];
var LABEL_OFFSET = 12;
var TICK_SIZE = 6;

angular.module('AVDStudio').directive('canvasRuler', function () {
  return {
    restrict: 'E',
    scope: {},
    template: '<canvas></canvas>',
    replace: true,
    require: '^studioCanvas',
    link: function link(scope, element, attrs, studioCanvasCtrl) {
      var $canvas = element;
      var canvas = $canvas.get(0);
      var isHorizontal = attrs.orientation == 'horizontal';
      var artworkWidth = void 0,
          artworkHeight = void 0;
      var mouseX = void 0,
          mouseY = void 0;

      $canvas.addClass('canvas-ruler').addClass('orientation-' + attrs.orientation);

      // most scope methods called by canvas

      scope.hideMouse = function () {
        mouseX = -1;
        mouseY = -1;
        scope.redraw();
      };

      scope.showMousePosition = function (x, y) {
        mouseX = x;
        mouseY = y;
        scope.redraw();
      };

      scope.setArtworkSize = function (size) {
        artworkWidth = size.width;
        artworkHeight = size.height;
        scope.redraw();
      };

      scope.redraw = function () {
        var width = $canvas.width();
        var height = $canvas.height();
        $canvas.attr('width', width * window.devicePixelRatio);
        $canvas.attr('height', height * window.devicePixelRatio);

        var ctx = canvas.getContext('2d');
        ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        ctx.translate(isHorizontal ? EXTRA_PADDING : 0, isHorizontal ? 0 : EXTRA_PADDING);

        var zoom = Math.max(1, isHorizontal ? (width - EXTRA_PADDING * 2) / artworkWidth : (height - EXTRA_PADDING * 2) / artworkHeight);

        // compute grid spacing (40 = minimum grid spacing in pixels)
        var interval = 0;
        var spacingArtPx = GRID_INTERVALS_PX[interval];
        while (spacingArtPx * zoom < 40 || interval >= GRID_INTERVALS_PX.length) {
          ++interval;
          spacingArtPx = GRID_INTERVALS_PX[interval];
        }

        var spacingRulerPx = spacingArtPx * zoom;

        // text labels
        ctx.fillStyle = 'rgba(255,255,255,.3)';
        ctx.font = '10px Roboto';
        if (isHorizontal) {
          ctx.textBaseline = 'alphabetic';
          ctx.textAlign = 'center';
          for (var x = 0, t = 0; x <= width - EXTRA_PADDING * 2; x += spacingRulerPx, t += spacingArtPx) {
            ctx.fillText(t, x, height - LABEL_OFFSET);
            ctx.fillRect(x - 0.5, height - TICK_SIZE, 1, TICK_SIZE);
          }
        } else {
          ctx.textBaseline = 'middle';
          ctx.textAlign = 'right';
          for (var y = 0, _t = 0; y <= height - EXTRA_PADDING * 2; y += spacingRulerPx, _t += spacingArtPx) {
            ctx.fillText(_t, width - LABEL_OFFSET, y);
            ctx.fillRect(width - TICK_SIZE, y - 0.5, TICK_SIZE, 1);
          }
        }

        ctx.fillStyle = 'rgba(255,255,255,.7)';
        if (isHorizontal && mouseX >= 0) {
          ctx.fillText(mouseX, mouseX * zoom, height - LABEL_OFFSET);
        } else if (!isHorizontal && mouseY >= 0) {
          ctx.fillText(mouseY, width - LABEL_OFFSET, mouseY * zoom);
        }
      };

      studioCanvasCtrl.registerRuler(scope);
      scope.$on('$destroy', function () {
        return studioCanvasCtrl.unregisterRuler(scope);
      });
    }
  };
});

},{}],2:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _model = require('model');

var _ColorUtil = require('ColorUtil');

var _RenderUtil = require('RenderUtil');

var _ElementResizeWatcher = require('ElementResizeWatcher');

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CANVAS_MARGIN = 72; // pixels


var CanvasController = function () {
  function CanvasController($scope, $element, $attrs, StudioStateService, $timeout) {
    var _this = this;

    _classCallCheck(this, CanvasController);

    this.scope_ = $scope;
    this.element_ = $element;
    this.attrs_ = $attrs;
    this.canvas_ = $element.find('canvas');
    this.offscreenCanvas_ = $(document.createElement('canvas'));
    this.studioState_ = StudioStateService;
    this.registeredRulers_ = [];

    this.isPreviewMode = 'previewMode' in $attrs;
    if (this.isPreviewMode) {
      this.element_.addClass('preview-mode');
    }

    this.setupMouseEventHandlers_();

    var changeHandler_ = function changeHandler_(event, changes) {
      if (changes.playing) {
        if (_this.studioState_.playing) {
          _this.animStart = Number(new Date()) - _this.studioState_.activeTime / _this.studioState_.playbackSpeed;
        }

        _this.drawCanvas_();
      }

      if (changes.activeTime) {
        _this.animTime = _this.studioState_.activeTime;
        _this.drawCanvas_();
      }

      if (changes.selection) {
        _this.drawCanvas_();
      }

      if (changes.artwork || changes.animations || changes.activeAnimation) {
        _this.resizeAndDrawCanvas_();
      }
    };

    changeHandler_(null, { playing: true, activeTime: true, artwork: true });

    this.studioState_.onChange(changeHandler_, $scope);

    if (!this.isPreviewMode) {
      var resizeWatcher = new _ElementResizeWatcher.ElementResizeWatcher(this.element_, function () {
        return _this.resizeAndDrawCanvas_();
      });
      $scope.$on('$destroy', function () {
        return resizeWatcher.destroy();
      });
    }

    $timeout(function () {
      return _this.resizeAndDrawCanvas_();
    }, 0);
  }

  _createClass(CanvasController, [{
    key: 'hitTest_',
    value: function hitTest_(point) {
      var rootLayer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      rootLayer = rootLayer || this.artwork;

      var matrices = [];

      // TODO(alockwood): select clips and/or groups in addition to paths?
      var hitTestLayer_ = function hitTestLayer_(layer) {
        if (layer instanceof _model.LayerGroup) {
          matrices.unshift(_RenderUtil.RenderUtil.transformMatrixForLayer(layer));
          // hitTestLayer || h and not the other way around because of reverse z-order
          var result = layer.layers.reduce(function (h, layer) {
            return hitTestLayer_(layer) || h;
          }, null);
          matrices.shift();
          return result;
        } else if (layer instanceof _model.PathLayer && layer.pathData) {
          var pointTransformerFn = function pointTransformerFn(p) {
            return _RenderUtil.RenderUtil.transformPoint(matrices, p);
          };
          if (layer.fillColor && layer.pathData.hitTestFill(point, pointTransformerFn) || layer.strokeColor && layer.pathData.hitTestStroke(point, pointTransformerFn, layer.strokeWidth)) {
            return layer;
          }

          return null;
        }

        return null;
      };

      return hitTestLayer_(rootLayer);
    }
  }, {
    key: 'setupMouseEventHandlers_',
    value: function setupMouseEventHandlers_() {
      var _this2 = this;

      this.canvas_.on('mousedown', function (event) {
        var canvasOffset = _this2.canvas_.offset();
        var x = (event.pageX - canvasOffset.left) / _this2.scale_;
        var y = (event.pageY - canvasOffset.top) / _this2.scale_;

        var currentArtwork = void 0;
        if (_this2.studioState_.animationRenderer) {
          _this2.studioState_.animationRenderer.setAnimationTime(_this2.animTime || 0);
          currentArtwork = _this2.studioState_.animationRenderer.renderedArtwork;
        } else {
          currentArtwork = _this2.artwork;
        }

        var targetLayer = _this2.hitTest_({ x: x, y: y }, currentArtwork);
        _this2.scope_.$apply(function () {
          if (targetLayer) {
            targetLayer = _this2.artwork.findLayerById(targetLayer.id);
            if (event.metaKey || event.shiftKey) {
              _this2.studioState_.toggleSelected(targetLayer);
            } else {
              _this2.studioState_.selection = [targetLayer];
            }
          } else if (!event.metaKey && !event.shiftKey) {
            _this2.studioState_.selection = [];
          }
        });
      }).on('mousemove', function (event) {
        var canvasOffset = _this2.canvas_.offset();
        var x = Math.round((event.pageX - canvasOffset.left) / _this2.scale_);
        var y = Math.round((event.pageY - canvasOffset.top) / _this2.scale_);
        _this2.registeredRulers_.forEach(function (r) {
          return r.showMousePosition(x, y);
        });
      }).on('mouseleave', function () {
        _this2.registeredRulers_.forEach(function (r) {
          return r.hideMouse();
        });
      });
    }
  }, {
    key: 'registerRuler',
    value: function registerRuler(rulerScope) {
      this.registeredRulers_.push(rulerScope);
      this.redrawRulers_();
    }
  }, {
    key: 'unregisterRuler',
    value: function unregisterRuler(rulerScope) {
      var idx = this.registeredRulers_.indexOf(rulerScope);
      if (idx >= 0) {
        this.registeredRulers_.splice(idx, 1);
      }
    }
  }, {
    key: 'redrawRulers_',
    value: function redrawRulers_() {
      var _this3 = this;

      this.registeredRulers_.forEach(function (r) {
        r.setArtworkSize({
          width: _this3.artwork.width,
          height: _this3.artwork.height
        });
        r.redraw();
      });
    }
  }, {
    key: 'resizeAndDrawCanvas_',
    value: function resizeAndDrawCanvas_() {
      var _this4 = this;

      if (this.isPreviewMode) {
        this.scale_ = 1;
      } else {
        var containerWidth = Math.max(1, this.element_.width() - CANVAS_MARGIN * 2);
        var containerHeight = Math.max(1, this.element_.height() - CANVAS_MARGIN * 2);
        var containerAspectRatio = containerWidth / containerHeight;
        var artworkAspectRatio = this.artwork.width / (this.artwork.height || 1);

        if (artworkAspectRatio > containerAspectRatio) {
          this.scale_ = containerWidth / this.artwork.width;
        } else {
          this.scale_ = containerHeight / this.artwork.height;
        }
      }

      this.scale_ = this.scale_ > 1 ? Math.floor(this.scale_) : Math.max(.1, this.scale_);
      this.backingStoreScale_ = this.scale_ * (window.devicePixelRatio || 1);
      [this.canvas_, this.offscreenCanvas_].forEach(function (canvas) {
        canvas.attr({
          width: _this4.artwork.width * _this4.backingStoreScale_,
          height: _this4.artwork.height * _this4.backingStoreScale_
        }).css({
          width: _this4.artwork.width * _this4.scale_,
          height: _this4.artwork.height * _this4.scale_
        });
      });

      this.drawCanvas_();
      this.redrawRulers_();
    }
  }, {
    key: 'drawCanvas_',
    value: function drawCanvas_() {
      var _this5 = this;

      if (this.animationFrameRequest_) {
        window.cancelAnimationFrame(this.animationFrameRequest_);
        this.animationFrameRequest_ = null;
      }

      if (!this.artwork) {
        return;
      }

      var ctx = this.canvas_.get(0).getContext('2d');
      ctx.save();
      ctx.scale(this.backingStoreScale_, this.backingStoreScale_);
      ctx.clearRect(0, 0, this.artwork.width, this.artwork.height);
      if (this.artwork.canvasColor) {
        ctx.fillStyle = _ColorUtil.ColorUtil.androidToCssColor(this.artwork.canvasColor);
        ctx.fillRect(0, 0, this.artwork.width, this.artwork.height);
      }

      var selectionStroke_ = function selectionStroke_(extraSetupFn) {
        ctx.save();
        // ctx.globalCompositeOperation = 'exclusion';
        extraSetupFn && extraSetupFn();
        ctx.lineWidth = 6 / _this5.scale_; // 2px
        ctx.strokeStyle = '#fff';
        ctx.lineCap = 'round';
        ctx.stroke();
        ctx.strokeStyle = '#2196f3';
        ctx.lineWidth = 3 / _this5.scale_; // 2px
        ctx.stroke();
        ctx.restore();
      };

      var transforms = [];

      var drawLayer_ = function drawLayer_(ctx, layer, selectionMode) {
        if (layer instanceof _model.LayerGroup) {
          if (!selectionMode && !layer.visible) {
            return;
          }

          transforms.unshift(_RenderUtil.RenderUtil.transformMatrixForLayer(layer));

          ctx.save();
          layer.layers.forEach(function (layer) {
            return drawLayer_(ctx, layer, selectionMode);
          });
          ctx.restore();

          if (selectionMode && layer.selected) {
            var bounds = layer.computeBounds();
            if (bounds) {
              ctx.save();
              ctx.transform.apply(ctx, _toConsumableArray(_RenderUtil.RenderUtil.flattenTransforms(transforms)));
              ctx.beginPath();
              ctx.rect(bounds.l, bounds.t, bounds.r - bounds.l, bounds.b - bounds.t);
              ctx.restore();
              selectionStroke_();
            }
          }

          transforms.shift();
        } else if (layer instanceof _model.MaskLayer) {
          ctx.save();
          ctx.transform.apply(ctx, _toConsumableArray(_RenderUtil.RenderUtil.flattenTransforms(transforms)));
          layer.pathData && layer.pathData.execute(ctx);
          ctx.restore();

          if (!selectionMode) {
            // clip further layers
            ctx.clip();
          } else if (selectionMode && layer.selected) {
            // this layer is selected, draw the layer selection stuff
            selectionStroke_(function () {
              return ctx.setLineDash([5 / _this5.scale_, 5 / _this5.scale_]);
            });
          }
        } else {
          if (!selectionMode && !layer.visible) {
            return;
          }

          var flattenedTransforms = _RenderUtil.RenderUtil.flattenTransforms(transforms);

          ctx.save();
          ctx.transform.apply(ctx, _toConsumableArray(flattenedTransforms));
          if (selectionMode) {
            layer.pathData && layer.pathData.execute(ctx);
          } else {
            layer.pathData && layer.pathData.executeTrimmed(ctx, layer.trimPathStart, layer.trimPathEnd, layer.trimPathOffset);
          }
          ctx.restore();

          if (!selectionMode) {
            var strokeWidthMultiplier = _RenderUtil.RenderUtil.computeStrokeWidthMultiplier(flattenedTransforms);

            // draw the actual layer
            ctx.strokeStyle = _ColorUtil.ColorUtil.androidToCssColor(layer.strokeColor, layer.strokeAlpha);
            ctx.lineWidth = layer.strokeWidth * strokeWidthMultiplier;
            ctx.fillStyle = _ColorUtil.ColorUtil.androidToCssColor(layer.fillColor, layer.fillAlpha);
            ctx.lineCap = layer.strokeLinecap || _model.DefaultValues.LINECAP;
            ctx.lineJoin = layer.strokeLinejoin || _model.DefaultValues.LINEJOIN;
            ctx.miterLimit = layer.miterLimit || _model.DefaultValues.MITER_LIMIT;

            if (layer.strokeColor && layer.strokeWidth && layer.trimPathStart != layer.trimPathEnd) {
              ctx.stroke();
            }
            if (layer.fillColor) {
              ctx.fill();
            }
          } else if (selectionMode && layer.selected) {
            // this layer is selected, draw the layer selection stuff
            selectionStroke_();
          }
        }
      };

      // draw artwork
      var offscreenCtx = this.offscreenCanvas_.get(0).getContext('2d');
      var currentArtwork = void 0;
      if (this.studioState_.animationRenderer) {
        this.studioState_.animationRenderer.setAnimationTime(this.animTime || 0);
        currentArtwork = this.studioState_.animationRenderer.renderedArtwork;
      } else {
        currentArtwork = this.artwork;
      }
      var currentAlpha = currentArtwork.alpha;
      if (currentAlpha != 1) {
        offscreenCtx.save();
        offscreenCtx.scale(this.backingStoreScale_, this.backingStoreScale_);
        offscreenCtx.clearRect(0, 0, currentArtwork.width, currentArtwork.height);
      }
      var artworkCtx = currentAlpha == 1 ? ctx : offscreenCtx;
      drawLayer_(artworkCtx, currentArtwork);

      if (currentArtwork.alpha != 1) {
        var oldGlobalAlpha = ctx.globalAlpha;
        ctx.globalAlpha = currentAlpha;
        ctx.scale(1 / this.backingStoreScale_, 1 / this.backingStoreScale_);
        ctx.drawImage(offscreenCtx.canvas, 0, 0);
        ctx.scale(this.backingStoreScale_, this.backingStoreScale_);
        ctx.globalAlpha = oldGlobalAlpha;
        offscreenCtx.restore();
      }
      if (!this.isPreviewMode) {
        drawLayer_(ctx, currentArtwork, true);
      }

      ctx.restore();

      // draw pixel grid
      if (!this.isPreviewMode && this.scale_ > 4) {
        ctx.fillStyle = 'rgba(128, 128, 128, .25)';

        for (var x = 1; x < this.artwork.width; ++x) {
          ctx.fillRect(x * this.backingStoreScale_ - 0.5 * (window.devicePixelRatio || 1), 0, 1 * (window.devicePixelRatio || 1), this.artwork.height * this.backingStoreScale_);
        }

        for (var y = 1; y < this.artwork.height; ++y) {
          ctx.fillRect(0, y * this.backingStoreScale_ - 0.5 * (window.devicePixelRatio || 1), this.artwork.width * this.backingStoreScale_, 1 * (window.devicePixelRatio || 1));
        }
      }

      if (this.studioState_.playing) {
        this.animationFrameRequest_ = window.requestAnimationFrame(function () {
          _this5.animTime = (Number(new Date()) - _this5.animStart) * _this5.studioState_.playbackSpeed % _this5.animation.duration;
          _this5.scope_.$apply(function () {
            return _this5.studioState_.activeTime = _this5.animTime;
          });
          _this5.drawCanvas_();
        });
      }
    }
  }, {
    key: 'artwork',
    get: function get() {
      return this.studioState_.artwork;
    }
  }, {
    key: 'animation',
    get: function get() {
      return this.studioState_.activeAnimation;
    }
  }]);

  return CanvasController;
}();

angular.module('AVDStudio').directive('studioCanvas', function () {
  return {
    restrict: 'E',
    scope: {},
    templateUrl: 'components/canvas/canvas.html',
    replace: true,
    bindToController: true,
    controller: CanvasController,
    controllerAs: 'ctrl'
  };
});

},{"ColorUtil":15,"ElementResizeWatcher":17,"RenderUtil":20,"model":35}],3:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var State = {
  NONE: 0,
  DRAGGING: 1,
  LOADING: 2
};

var FileDropTargetController = function () {
  function FileDropTargetController($scope, $element, $attrs) {
    var _this = this;

    _classCallCheck(this, FileDropTargetController);

    this.scope_ = $scope;
    this.element_ = $element;
    this.element_.addClass('file-drop-target');

    this.onDropFile_ = $attrs.fileDropTarget ? function (fileInfo) {
      return $scope.$eval($attrs.fileDropTarget, { fileInfo: fileInfo });
    } : function () {};

    this.state_ = State.NONE;

    // set up drag event listeners, with debouncing because dragging over/out of each child
    // triggers these events on the element

    var notDraggingTimeout_ = void 0;

    var setDragging_ = function setDragging_(dragging) {
      if (dragging) {
        // when moving from child to child, dragenter is sent before dragleave
        // on previous child
        window.setTimeout(function () {
          if (notDraggingTimeout_) {
            window.clearTimeout(notDraggingTimeout_);
            notDraggingTimeout_ = null;
          }
          _this.setState_(State.DRAGGING);
        }, 0);
      } else {
        if (notDraggingTimeout_) {
          window.clearTimeout(notDraggingTimeout_);
        }
        notDraggingTimeout_ = window.setTimeout(function () {
          return _this.setState_(State.NONE);
        }, 100);
      }
    };

    this.element_.on('dragenter', function (event) {
      event.preventDefault();
      setDragging_(true);
      return false;
    }).on('dragover', function (event) {
      event.preventDefault();
      event.originalEvent.dataTransfer.dropEffect = 'copy';
      return false;
    }).on('dragleave', function (event) {
      event.preventDefault();
      setDragging_(false);
      return false;
    }).on('drop', function (event) {
      event.preventDefault();
      _this.setState_(State.NONE);
      _this.handleDropFiles_(event.originalEvent.dataTransfer.files);
      return false;
    });
  }

  _createClass(FileDropTargetController, [{
    key: 'setState_',
    value: function setState_(state) {
      this.state_ = state;
      this.element_.toggleClass('is-dragging-over', this.state_ === State.DRAGGING);
      this.element_.toggleClass('is-loading', this.state_ === State.LOADING);
    }
  }, {
    key: 'handleDropFiles_',
    value: function handleDropFiles_(fileList) {
      var _this2 = this;

      fileList = Array.from(fileList || []);
      fileList = fileList.filter(function (file) {
        return file.type === 'image/svg+xml' || file.type === 'application/json' || file.type === 'application/xml' || file.type === 'text/xml' || file.name.match(/\.iconanim$/);
      });
      if (!fileList.length) {
        return;
      }

      var file = fileList[0];

      var fileReader = new FileReader();

      fileReader.onload = function (event) {
        _this2.setState_(State.NONE);
        _this2.scope_.$apply(function () {
          return _this2.onDropFile_({
            textContent: event.target.result,
            name: file.name,
            type: file.type
          });
        });
      };

      fileReader.onerror = function (event) {
        _this2.setState_(State.NONE);
        switch (event.target.error.code) {
          case event.target.error.NOT_FOUND_ERR:
            alert('File not found!');
            break;
          case event.target.error.NOT_READABLE_ERR:
            alert('File is not readable');
            break;
          case event.target.error.ABORT_ERR:
            break; // noop
          default:
            alert('An error occurred reading this file.');
        }
      };

      fileReader.onabort = function (e) {
        this.setState_(State.NONE);
        alert('File read cancelled');
      };

      this.setState_(State.LOADING);
      fileReader.readAsText(file);
    }
  }]);

  return FileDropTargetController;
}();

angular.module('AVDStudio').directive('fileDropTarget', function () {
  return {
    restrict: 'A',
    controller: FileDropTargetController
  };
});

},{}],4:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var FileOpenHandlerController = function () {
  function FileOpenHandlerController($scope, $element, $attrs) {
    _classCallCheck(this, FileOpenHandlerController);

    this.scope_ = $scope;
    this.element_ = $element;
    this.element_.addClass('file-open-proxy');

    this.onOpenFile_ = $attrs.fileOpenHandler ? function (fileInfo) {
      return $scope.$eval($attrs.fileOpenHandler, { fileInfo: fileInfo });
    } : function () {};
  }

  _createClass(FileOpenHandlerController, [{
    key: 'onLink',
    value: function onLink() {
      var _this = this;

      this.inputElement_ = this.element_.find('input');
      this.inputElement_.on('change', function () {
        var files = _this.inputElement_.get(0).files;
        if (files.length) {
          _this.handleDropFiles_(files);
        }
      });
    }
  }, {
    key: 'handleDropFiles_',
    value: function handleDropFiles_(fileList) {
      var _this2 = this;

      fileList = Array.from(fileList || []);
      fileList = fileList.filter(function (file) {
        return file.type === 'image/svg+xml' || file.type === 'application/json' || file.type === 'application/xml' || file.type === 'text/xml' || file.name.match(/\.iconanim$/);
      });
      if (!fileList.length) {
        return;
      }

      var file = fileList[0];

      var fileReader = new FileReader();

      fileReader.onload = function (event) {
        _this2.scope_.$apply(function () {
          return _this2.onOpenFile_({
            textContent: event.target.result,
            name: file.name,
            type: file.type
          });
        });
      };

      fileReader.onerror = function (event) {
        switch (event.target.error.code) {
          case event.target.error.NOT_FOUND_ERR:
            alert('File not found!');
            break;
          case event.target.error.NOT_READABLE_ERR:
            alert('File is not readable');
            break;
          case event.target.error.ABORT_ERR:
            break; // noop
          default:
            alert('An error occurred reading this file.');
        }
      };

      fileReader.onabort = function (e) {
        alert('File read cancelled');
      };

      fileReader.readAsText(file);
    }
  }]);

  return FileOpenHandlerController;
}();

angular.module('AVDStudio').directive('fileOpenHandler', function () {
  return {
    restrict: 'A',
    controller: FileOpenHandlerController,
    require: '^fileOpenHandler',
    link: function link($element, $scope, $attrs, ctrl) {
      ctrl.onLink($element);
    }
  };
});

},{}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var TimelineConsts = exports.TimelineConsts = {
  TIMELINE_ANIMATION_PADDING: 20 // 20px
};

},{}],6:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _model = require('model');

var _ModelUtil = require('ModelUtil');

var _MathUtil = require('MathUtil');

var _UiUtil = require('UiUtil');

var _DragHelper = require('DragHelper');

var _SvgLoader = require('SvgLoader');

var _VectorDrawableLoader = require('VectorDrawableLoader');

var _consts = require('./consts');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LAYER_INDENT = 20; // pixels

var SNAP_PIXELS = 10; // distance in pixels from a snap point before snapping to the point

var MIN_BLOCK_DURATION = 10; // 10ms

var MAX_ZOOM = 10;
var MIN_ZOOM = 0.01;

var MouseActions = {
  MOVING: 0,
  SCALING_UNIFORM_START: 1,
  SCALING_UNIFORM_END: 2,
  SCALING_TOGETHER_START: 3,
  SCALING_TOGETHER_END: 4
};

var LayerTimelineController = function () {
  function LayerTimelineController($scope, $element, $timeout, StudioStateService) {
    var _this = this;

    _classCallCheck(this, LayerTimelineController);

    this.scope_ = $scope;
    this.element_ = $element;
    this.timeout_ = $timeout;
    this.studioState_ = StudioStateService;
    this.studioState_.onChange(function (event, changes) {
      if (changes.artwork || changes.animations) {
        _this.rebuildModel_();
        _this.rebuildSnapTimes_();
      }
      if (changes.isReset) {
        _this.autoZoomToAnimation();
      }
    }, $scope);

    this.horizZoom = 2; // 1ms = 2px

    this.setupMouseWheelZoom_();

    this.rebuildModel_();
    this.rebuildSnapTimes_();
    this.autoZoomToAnimation();
  }

  _createClass(LayerTimelineController, [{
    key: 'setupMouseWheelZoom_',


    /**
     * Handles alt+mousewheel for zooming into and out of the timeline.
     */
    value: function setupMouseWheelZoom_() {
      var _this2 = this;

      var $timeline = this.element_.find('.slt-timeline');
      var $zoomStartActiveAnimation = void 0;
      var targetHorizZoom = void 0;
      var performZoomRAF = null;
      var endZoomTimeout = null;
      var zoomStartTimeCursorPos = void 0;

      $timeline.on('wheel', function (event) {
        if (event.altKey || event.ctrlKey) {
          // chrome+mac trackpad pinch-zoom = ctrlKey
          if (!targetHorizZoom) {
            // multiple changes can happen to targetHorizZoom before the
            // actual zoom level is updated (see performZoom_)
            targetHorizZoom = _this2.horizZoom;
          }

          event.preventDefault();
          targetHorizZoom *= Math.pow(1.01, -event.originalEvent.deltaY);
          targetHorizZoom = _MathUtil.MathUtil.constrain(targetHorizZoom, MIN_ZOOM, MAX_ZOOM);
          if (targetHorizZoom != _this2.horizZoom) {
            // zoom has changed
            if (performZoomRAF) {
              window.cancelAnimationFrame(performZoomRAF);
            }
            performZoomRAF = window.requestAnimationFrame(function () {
              return performZoom_();
            });

            if (endZoomTimeout) {
              window.clearTimeout(endZoomTimeout);
            } else {
              startZoom_();
            }

            endZoomTimeout = window.setTimeout(function () {
              return endZoom_();
            }, 100);
          }
          return false;
        }
      });

      var startZoom_ = function startZoom_() {
        $zoomStartActiveAnimation = $('.slt-timeline-animation.is-active');
        zoomStartTimeCursorPos = $zoomStartActiveAnimation.position().left + _this2.activeTime * _this2.horizZoom + _consts.TimelineConsts.TIMELINE_ANIMATION_PADDING;
      };

      var performZoom_ = function performZoom_() {
        _this2.horizZoom = targetHorizZoom;
        _this2.scope_.$apply();

        // set the scroll offset such that the time cursor remains at
        // zoomStartTimeCursorPos
        if ($zoomStartActiveAnimation) {
          var newScrollLeft = $zoomStartActiveAnimation.position().left + $timeline.scrollLeft() + _this2.activeTime * _this2.horizZoom + _consts.TimelineConsts.TIMELINE_ANIMATION_PADDING - zoomStartTimeCursorPos;
          $timeline.scrollLeft(newScrollLeft);
        }
      };

      var endZoom_ = function endZoom_() {
        zoomStartTimeCursorPos = 0;
        $zoomStartActiveAnimation = null;
        endZoomTimeout = null;
        targetHorizZoom = 0;
      };
    }

    /**
     * Rebuilds internal layer/timeline related data structures (_slt) about the current
     * artwork and animations.
     */

  }, {
    key: 'rebuildModel_',
    value: function rebuildModel_() {
      var _this3 = this;

      if (!this.artwork || !this.animations) {
        return;
      }

      var isEmptyObj_ = function isEmptyObj_(obj) {
        for (var k in obj) {
          return false;
        }
        return true;
      };

      this.artwork.walk(function (layer) {
        var _slt = {};
        _slt.layerType = layer instanceof _model.LayerGroup ? 'group' : layer instanceof _model.MaskLayer ? 'mask' : 'layer';
        _slt.blocksByProperty = {};
        _slt.availableProperties = layer.animatableProperties;
        _slt.hasAvailableProperties = !isEmptyObj_(_slt.availableProperties);
        layer._slt = _slt;
      });

      this.animations.forEach(function (animation) {
        var blocksByLayerId = _ModelUtil.ModelUtil.getOrderedAnimationBlocksByLayerIdAndProperty(animation);
        Object.keys(blocksByLayerId).forEach(function (layerId) {
          var layer = _this3.artwork.findLayerById(layerId);
          if (!layer) {
            return;
          }

          Object.keys(blocksByLayerId[layerId]).forEach(function (propertyName) {
            layer._slt.blocksByProperty[propertyName] = layer._slt.blocksByProperty[propertyName] || {};
            layer._slt.blocksByProperty[propertyName][animation.id] = blocksByLayerId[layerId][propertyName];
            delete layer._slt.availableProperties[propertyName];
            layer._slt.hasAvailableProperties = !isEmptyObj_(layer._slt.availableProperties);
          });
        });
      });
    }

    /**
     * Zooms the timeline to fit the first animation.
     */

  }, {
    key: 'autoZoomToAnimation',
    value: function autoZoomToAnimation() {
      var _this4 = this;

      if (this.animations.length) {
        _UiUtil.UiUtil.waitForElementWidth_(this.element_.find('.slt-timeline')).then(function (width) {
          width -= 100; // shave off a hundred pixels for safety
          var zoom = width / _this4.animations[0].duration;
          _this4.horizZoom = zoom;
        });
      }
    }

    /**
     * Handles scrubbing (dragging) over the timeline header area, which should
     * change the time cursor.
     */

  }, {
    key: 'onTimelineHeaderScrub',
    value: function onTimelineHeaderScrub(animation, time, options) {
      options = options || {};
      if (!options.disableSnap) {
        time = this.snapTime_(animation, time, false);
      }

      this.studioState_.deselectItem(this.studioState_.activeAnimation);
      this.studioState_.activeAnimation = animation;
      this.studioState_.activeTime = time;
      this.studioState_.playing = false;
    }

    /**
     * Builds a cache of snap times for all available animations.
     */

  }, {
    key: 'rebuildSnapTimes_',
    value: function rebuildSnapTimes_() {
      var _this5 = this;

      if (this.suppressRebuildSnapTimes_) {
        return;
      }

      this.snapTimes_ = {};
      if (this.animations) {
        this.animations.forEach(function (animation) {
          var snapTimes = new Set([]);
          snapTimes.add(0);
          snapTimes.add(animation.duration);
          animation.blocks.forEach(function (block) {
            snapTimes.add(block.startTime);
            snapTimes.add(block.endTime);
          });
          _this5.snapTimes_[animation.id] = Array.from(snapTimes);
        });
      }
    }

    /**
     * Returns a new time, possibly snapped to animation boundaries
     */

  }, {
    key: 'snapTime_',
    value: function snapTime_(animation, time) {
      var includeActiveTime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      var snapTimes = this.snapTimes_[animation.id];
      var snapDelta = SNAP_PIXELS / this.horizZoom;
      var reducer_ = function reducer_(bestSnapTime, snapTime) {
        var dist = Math.abs(time - snapTime);
        return dist < snapDelta && dist < Math.abs(time - bestSnapTime) ? snapTime : bestSnapTime;
      };
      var bestSnapTime = snapTimes.reduce(reducer_, Infinity);
      if (includeActiveTime) {
        bestSnapTime = reducer_(bestSnapTime, this.activeTime);
      }
      return isFinite(bestSnapTime) ? bestSnapTime : time;
    }

    /**
     * Called when adding a new timeline block to a property that's already animated
     */

  }, {
    key: 'onAddTimelineBlock',
    value: function onAddTimelineBlock($event, layer, propertyName) {
      var _this6 = this;

      var animation = this.studioState_.activeAnimation;

      var newBlockDuration = 100; // min duration of 100ms

      // find the right start time for the block, which should be a gap between
      // neighboring blocks closest to the time cursor (activeTime), of a minimum size
      var blocksByLayerId = _ModelUtil.ModelUtil.getOrderedAnimationBlocksByLayerIdAndProperty(animation);
      var blockNeighbors = (blocksByLayerId[layer.id] || {})[propertyName] || [];
      var gaps = [];
      for (var i = 0; i < blockNeighbors.length; i++) {
        gaps.push({
          start: i == 0 ? 0 : blockNeighbors[i - 1].endTime,
          end: blockNeighbors[i].startTime
        });
      }
      gaps.push({
        start: blockNeighbors.length ? blockNeighbors[blockNeighbors.length - 1].endTime : 0,
        end: animation.duration
      });
      gaps = gaps.filter(function (gap) {
        return gap.end - gap.start > newBlockDuration;
      }).map(function (gap) {
        return Object.assign(gap, {
          dist: Math.min(Math.abs(gap.end - _this6.studioState_.activeTime), Math.abs(gap.start - _this6.studioState_.activeTime))
        });
      }).sort(function (a, b) {
        return a.dist - b.dist;
      });

      if (!gaps.length) {
        // no available gaps, cancel
        return;
      }

      var startTime = Math.max(this.studioState_.activeTime, gaps[0].start);
      var endTime = Math.min(startTime + newBlockDuration, gaps[0].end);
      if (endTime - startTime < newBlockDuration) {
        startTime = endTime - newBlockDuration;
      }

      // generate the new block, cloning the current rendered property value
      var propertyObj = layer.animatableProperties[propertyName];
      var valueAtCurrentTime = this.studioState_.animationRenderer.getLayerPropertyValue(layer.id, propertyName);
      var newBlock = new _model.AnimationBlock({
        layerId: layer.id,
        propertyName: propertyName,
        startTime: startTime,
        endTime: endTime,
        fromValue: propertyObj.cloneValue(valueAtCurrentTime),
        toValue: propertyObj.cloneValue(valueAtCurrentTime)
      });

      // add the block
      newBlock.parent = animation;
      animation.blocks.push(newBlock);
      this.studioState_.selection = [newBlock];
      this.studioState_.animChanged();
    }

    /**
     * Handles clicks on an animation in the list of current animations.
     */

  }, {
    key: 'onAnimationMouseDown',
    value: function onAnimationMouseDown($event, animation) {
      if (this.studioState_.activeAnimation !== animation) {
        this.studioState_.deselectItem(this.studioState_.activeAnimation);
      }
      this.studioState_.activeAnimation = animation;
    }

    /**
     * Called in response to adding a layer of a given type to the artwork.
     */

  }, {
    key: 'onAddLayer',
    value: function onAddLayer($event, type) {
      var cls = type == 'group' ? _model.LayerGroup : type == 'mask' ? _model.MaskLayer : _model.PathLayer;
      var newLayer = new cls();
      newLayer.id = this.studioState_.getUniqueLayerId(null, newLayer);

      // TODO: add just below the selected layer
      newLayer.parent = this.studioState_.artwork; // TODO: this should be automatic
      this.studioState_.artwork.layers.push(newLayer);
      this.studioState_.artworkChanged();
    }

    /**
     * Handles clicks on a layer, either selecting or deselecting it.
     */

  }, {
    key: 'onLayerClick',
    value: function onLayerClick($event, layer) {
      if (this.suppressClick_) {
        return;
      }

      if ($event.metaKey || $event.shiftKey) {
        this.studioState_.toggleSelected(layer);
      } else {
        this.studioState_.selection = [layer];
      }
    }

    /**
     * Handle toggling expanded/collapsed visual state for a layer.
     */

  }, {
    key: 'onLayerToggleExpanded',
    value: function onLayerToggleExpanded($event, layer) {
      if (!(layer instanceof _model.LayerGroup)) {
        return;
      }

      var expand = !layer.expanded;
      if ($event.altKey) {
        // recursive expand/collapse
        layer.walk(function (layer) {
          if (layer instanceof _model.LayerGroup) {
            layer.expanded = expand;
          }
        });
      } else {
        // expand/collapse just this layer
        layer.expanded = expand;
      }

      $event.stopPropagation();
    }

    /**
     * Handle toggling of visible/invisible state.
     */

  }, {
    key: 'onLayerToggleVisibility',
    value: function onLayerToggleVisibility($event, layer) {
      layer.visible = !layer.visible;
      this.studioState_.artworkChanged();
      $event.stopPropagation();
    }

    /**
     * Converts the given path layer to a clip path.
     */

  }, {
    key: 'onConvertLayerToClipPath',
    value: function onConvertLayerToClipPath($event, layer) {
      var clipPathLayer = new _model.MaskLayer(layer);
      this.studioState_.swapLayer(layer, clipPathLayer);
    }

    /**
     * Converts the given layer (clip path) to a path layer.
     */

  }, {
    key: 'onConvertLayerToPath',
    value: function onConvertLayerToPath($event, layer) {
      var newLayer = new _model.PathLayer(layer);
      this.studioState_.swapLayer(layer, newLayer);
    }

    /**
     * Creates a new empty animation to the list of animations.
     */

  }, {
    key: 'onAddNewAnimation',
    value: function onAddNewAnimation($event) {
      var newAnim = new _model.Animation({
        id: this.studioState_.getUniqueAnimationId(),
        blocks: [],
        duration: 300
      });
      this.studioState_.deselectItem(this.studioState_.activeAnimation);
      this.studioState_.animations.push(newAnim);
      this.studioState_.activeAnimation = newAnim;
      this.studioState_.animChanged();
    }

    /**
     * Selects the given animation, for inspection w/ the property inspector.
     */

  }, {
    key: 'onAnimationHeaderClick',
    value: function onAnimationHeaderClick($event, anim) {
      this.studioState_.selection = [anim];
    }

    /**
     * Handles clicks on a timeline block (either selecting or deselecting it).
     */

  }, {
    key: 'onTimelineBlockClick',
    value: function onTimelineBlockClick($event, block, layer) {
      if (this.suppressClick_) {
        return;
      }

      if ($event.metaKey || $event.shiftKey) {
        this.studioState_.toggleSelected(block);
      } else {
        this.studioState_.selection = [block];
      }
    }
  }, {
    key: 'dirtyCheck_',
    value: function dirtyCheck_() {
      if (this.studioState_.dirty && !window.confirm('You\'ve made changes but haven\'t saved. Are you sure you want to continue?')) {
        return true;
      }

      return false;
    }

    /**
     * Handles creating a new file
     */

  }, {
    key: 'onNewFile',
    value: function onNewFile() {
      if (this.dirtyCheck_()) {
        return;
      }

      ga('send', 'event', 'file', 'newFile');
      this.studioState_.new();
    }

    /**
     * Handles opening a file using a file open dialog
     */

  }, {
    key: 'onOpenFile',
    value: function onOpenFile(fileInfo) {
      if (this.dirtyCheck_()) {
        return;
      }

      ga('send', 'event', 'file', 'openFile');
      var jsonObj = JSON.parse(fileInfo.textContent);
      this.studioState_.load({
        artwork: new _model.Artwork(jsonObj.artwork),
        animations: jsonObj.animations.map(function (anim) {
          return new _model.Animation(anim);
        })
      });
    }

    /**
     * Handles export to JSON format.
     */

  }, {
    key: 'onSaveFile',
    value: function onSaveFile() {
      ga('send', 'event', 'file', 'saveFile');
      this.studioState_.saveToFile();
    }

    /**
     * Handles importing an SVG as layers.
     */

  }, {
    key: 'onAddLayersFromSVG',
    value: function onAddLayersFromSVG(fileInfo) {
      ga('send', 'event', 'file', 'importSVG.addLayers');
      var artwork = _SvgLoader.SvgLoader.loadArtworkFromSvgString(fileInfo.textContent);
      this.studioState_.addLayers(artwork.layers);
    }

    /**
     * Handles importing an SVG as layers.
     */

  }, {
    key: 'onNewFromSVG',
    value: function onNewFromSVG(fileInfo) {
      if (this.dirtyCheck_()) {
        return;
      }

      ga('send', 'event', 'file', 'importSVG.new');
      var artwork = _SvgLoader.SvgLoader.loadArtworkFromSvgString(fileInfo.textContent);
      this.studioState_.load({ artwork: artwork });
    }

    /**
     * Handles importing a vector drawable from XML.
     */

  }, {
    key: 'onNewFromVD',
    value: function onNewFromVD(fileInfo) {
      if (this.dirtyCheck_()) {
        return;
      }

      ga('send', 'event', 'file', 'importVD.new');
      var artwork = _VectorDrawableLoader.VectorDrawableLoader.loadArtworkFromXmlString(fileInfo.textContent);
      this.studioState_.load({ artwork: artwork });
    }

    /**
     * Handles export to animated vector drawable format.
     */

  }, {
    key: 'onExportAVDs',
    value: function onExportAVDs() {
      ga('send', 'event', 'export', 'exportVectorAnimated');
      this.studioState_.exportAVDs();
    }

    /**
     * Handles export to vector drawable format.
     */

  }, {
    key: 'onExportVectorDrawable',
    value: function onExportVectorDrawable() {
      ga('send', 'event', 'export', 'exportVectorStatic');
      this.studioState_.exportVectorDrawable();
    }

    /**
     * Handles a variety of drag behaviors for timeline blocks, including movement
     * and scaling.
     */

  }, {
    key: 'onTimelineBlockMouseDown',
    value: function onTimelineBlockMouseDown(event, dragBlock, animation, layer) {
      var _this7 = this;

      event.preventDefault(); // prevent html5 dragging
      var $target = $(event.target);

      // some geometry and hit-testing basics
      var animRect = $(event.target).parents('.slt-property').get(0).getBoundingClientRect();
      var xToTime_ = function xToTime_(x) {
        return (x - animRect.left) / animRect.width * animation.duration;
      };
      var downTime = xToTime_(event.clientX);

      // determine the action based on where the user clicked and the modifier keys
      var action = MouseActions.MOVING;
      if ($target.hasClass('slt-timeline-block-edge-end')) {
        action = event.altKey ? MouseActions.SCALING_TOGETHER_END : MouseActions.SCALING_UNIFORM_END;
      } else if ($target.hasClass('slt-timeline-block-edge-start')) {
        action = event.altKey ? MouseActions.SCALING_TOGETHER_START : MouseActions.SCALING_UNIFORM_START;
      }

      // start up a cache of info for each selected block, calculating the left- and right-
      // bounds for each selected block, based on adjacent non-dragging blocks
      var activeAnimBlocksByLayerId = _ModelUtil.ModelUtil.getOrderedAnimationBlocksByLayerIdAndProperty(this.studioState_.activeAnimation);
      var draggingBlocks = dragBlock.selected_ ? this.studioState_.selectedAnimationBlocks : [dragBlock]; // either drag all selected blocks or just the mousedown'd block
      var blockInfos = draggingBlocks.filter(function (block) {
        return block.parent == _this7.studioState_.activeAnimation;
      }).map(function (block) {
        // by default the block is only bound by the animation duration
        var startBound = 0;
        var endBound = block.parent.duration;

        var blockNeighbors = activeAnimBlocksByLayerId[block.layerId][block.propertyName];
        var indexIntoNeighbors = blockNeighbors.indexOf(block);

        // find start time bound
        if (indexIntoNeighbors > 0) {
          for (var i = indexIntoNeighbors - 1; i >= 0; i--) {
            var neighbor = blockNeighbors[i];
            if (!draggingBlocks.includes(neighbor) || action == MouseActions.SCALING_UNIFORM_START) {
              startBound = neighbor.endTime; // only be bound by neighbors not being dragged
              // except when uniformly changing just start time
              break;
            }
          }
        }

        // find end time bound
        if (indexIntoNeighbors < blockNeighbors.length - 1) {
          for (var _i = indexIntoNeighbors + 1; _i < blockNeighbors.length; _i++) {
            var _neighbor = blockNeighbors[_i];
            if (!draggingBlocks.includes(_neighbor) || action == MouseActions.SCALING_UNIFORM_END) {
              endBound = _neighbor.startTime; // only be bound by neighbors not being dragged
              // except when uniformly changing just end time
              break;
            }
          }
        }

        return { block: block, startBound: startBound, endBound: endBound,
          downStartTime: block.startTime,
          downEndTime: block.endTime };
      });

      var dragBlockDownStartTime = dragBlock.startTime;
      var dragBlockDownEndTime = dragBlock.endTime;

      var minStartTime = void 0,
          maxEndTime = void 0;
      if (action == MouseActions.SCALING_TOGETHER_END || action == MouseActions.SCALING_TOGETHER_START) {
        minStartTime = blockInfos.reduce(function (t, info) {
          return Math.min(t, info.block.startTime);
        }, Infinity);
        maxEndTime = blockInfos.reduce(function (t, info) {
          return Math.max(t, info.block.endTime);
        }, 0);
        maxEndTime = Math.max(maxEndTime, minStartTime + 10); // avoid divide by zero
      }

      // set up drag handlers
      var dragHelper = new _DragHelper.DragHelper({
        downEvent: event,
        direction: 'horizontal',
        draggingCursor: action == MouseActions.MOVING ? 'grabbing' : 'ew-resize',

        onBeginDrag: function onBeginDrag(event) {
          return _this7.scope_.$apply(function () {
            _this7.suppressClick_ = true;
            _this7.suppressRebuildSnapTimes_ = true;
          });
        },
        onDrop: function onDrop(event) {
          return _this7.timeout_(function () {
            _this7.suppressClick_ = false;
            _this7.suppressRebuildSnapTimes_ = false;
            _this7.rebuildSnapTimes_();
          }, 0);
        },

        onDrag: function onDrag(event) {
          return _this7.scope_.$apply(function () {
            var timeDelta = Math.round(xToTime_(event.clientX) - downTime);
            var allowSnap = !event.altKey;

            switch (action) {
              case MouseActions.MOVING:
                {
                  blockInfos.forEach(function (info) {
                    // snap timedelta
                    if (allowSnap && info.block == dragBlock) {
                      var newStartTime = info.downStartTime + timeDelta;
                      var newStartTimeSnapDelta = _this7.snapTime_(animation, newStartTime) - newStartTime;
                      var newEndTime = info.downEndTime + timeDelta;
                      var newEndTimeSnapDelta = _this7.snapTime_(animation, newEndTime) - newEndTime;
                      if (newStartTimeSnapDelta) {
                        if (newEndTimeSnapDelta) {
                          timeDelta += Math.min(newStartTimeSnapDelta, newEndTimeSnapDelta);
                        } else {
                          timeDelta += newStartTimeSnapDelta;
                        }
                      } else if (newEndTimeSnapDelta) {
                        timeDelta += newEndTimeSnapDelta;
                      }
                    }
                    // constrain timeDelta
                    timeDelta = Math.min(timeDelta, info.endBound - info.downEndTime);
                    timeDelta = Math.max(timeDelta, info.startBound - info.downStartTime);
                  });
                  blockInfos.forEach(function (info) {
                    var blockDuration = info.block.endTime - info.block.startTime;
                    info.block.startTime = info.downStartTime + timeDelta;
                    info.block.endTime = info.block.startTime + blockDuration;
                  });
                  break;
                }

              case MouseActions.SCALING_UNIFORM_START:
                {
                  blockInfos.forEach(function (info) {
                    // snap timedelta
                    if (allowSnap && info.block == dragBlock) {
                      var newStartTime = info.downStartTime + timeDelta;
                      var newStartTimeSnapDelta = _this7.snapTime_(animation, newStartTime) - newStartTime;
                      if (newStartTimeSnapDelta) {
                        timeDelta += newStartTimeSnapDelta;
                      }
                    }
                    // constrain timeDelta
                    timeDelta = Math.min(timeDelta, info.block.endTime - MIN_BLOCK_DURATION - info.downStartTime);
                    timeDelta = Math.max(timeDelta, info.startBound - info.downStartTime);
                  });
                  blockInfos.forEach(function (info) {
                    return info.block.startTime = info.downStartTime + timeDelta;
                  });
                  break;
                }

              case MouseActions.SCALING_UNIFORM_END:
                {
                  blockInfos.forEach(function (info) {
                    // snap timedelta
                    if (allowSnap && info.block == dragBlock) {
                      var newEndTime = info.downEndTime + timeDelta;
                      var newEndTimeSnapDelta = _this7.snapTime_(animation, newEndTime) - newEndTime;
                      if (newEndTimeSnapDelta) {
                        timeDelta += newEndTimeSnapDelta;
                      }
                    }
                    // constrain timeDelta
                    timeDelta = Math.min(timeDelta, info.endBound - info.downEndTime);
                    timeDelta = Math.max(timeDelta, info.block.startTime + MIN_BLOCK_DURATION - info.downEndTime);
                  });
                  blockInfos.forEach(function (info) {
                    return info.block.endTime = info.downEndTime + timeDelta;
                  });
                  break;
                }

              case MouseActions.SCALING_TOGETHER_START:
                {
                  var scale = (dragBlockDownStartTime + timeDelta - maxEndTime) / (dragBlockDownStartTime - maxEndTime);
                  scale = Math.min(scale, maxEndTime / (maxEndTime - minStartTime));
                  var cancel = false;
                  blockInfos.forEach(function (info) {
                    info.newStartTime = maxEndTime - (maxEndTime - info.downStartTime) * scale;
                    info.newEndTime = Math.max(maxEndTime - (maxEndTime - info.downEndTime) * scale, info.newStartTime + MIN_BLOCK_DURATION);
                    if (info.newStartTime < info.startBound || info.newEndTime > info.endBound) {
                      cancel = true;
                    }
                  });
                  if (!cancel) {
                    blockInfos.forEach(function (info) {
                      info.block.startTime = info.newStartTime;
                      info.block.endTime = info.newEndTime;
                    });
                  }
                  break;
                }

              case MouseActions.SCALING_TOGETHER_END:
                {
                  var _scale = (dragBlockDownEndTime + timeDelta - minStartTime) / (dragBlockDownEndTime - minStartTime);
                  _scale = Math.min(_scale, (animation.duration - minStartTime) / (maxEndTime - minStartTime));
                  var _cancel = false;
                  blockInfos.forEach(function (info) {
                    info.newStartTime = minStartTime + (info.downStartTime - minStartTime) * _scale;
                    info.newEndTime = Math.max(minStartTime + (info.downEndTime - minStartTime) * _scale, info.newStartTime + MIN_BLOCK_DURATION);
                    if (info.newStartTime < info.startBound || info.newEndTime > info.endBound) {
                      _cancel = true;
                    }
                  });
                  if (!_cancel) {
                    blockInfos.forEach(function (info) {
                      info.block.startTime = info.newStartTime;
                      info.block.endTime = info.newEndTime;
                    });
                  }
                  break;
                }
            }

            _this7.studioState_.animChanged();
          });
        }
      });
    }

    /**
     * Handles drag and drop for layers, allowing re-ordering and re-parenting layers in
     * the artwork.
     */

  }, {
    key: 'onLayerMouseDown',
    value: function onLayerMouseDown(event, dragLayer) {
      var _this8 = this;

      var $layersList = $(event.target).parents('.slt-layers-list');
      var $scroller = $(event.target).parents('.slt-layers-list-scroller');

      var orderedLayerInfos = [];
      var $dragIndicator = void 0;
      var scrollerRect = void 0;

      var targetLayerInfo = null;
      var targetEdge = void 0;

      var EDGES = { top: true, bottom: true };

      var dragHelper = new _DragHelper.DragHelper({
        downEvent: event,
        direction: 'both',

        onBeginDrag: function onBeginDrag() {
          _this8.suppressClick_ = true;

          // build up a list of all layers ordered by Y position
          orderedLayerInfos = [];
          scrollerRect = $scroller.get(0).getBoundingClientRect();
          var scrollTop = $scroller.scrollTop();
          $layersList.find('.slt-layer-container').each(function (i, element) {
            if (!$(element).data('layer-id')) {
              // the artwork root layer doesn't have an ID set
              return;
            }

            var rect = element.getBoundingClientRect();
            rect = {
              left: rect.left,
              top: rect.top + scrollTop - scrollerRect.top,
              bottom: rect.bottom + scrollTop - scrollerRect.top
            };

            var layer = _this8.studioState_.artwork.findLayerById($(element).data('layer-id'));
            orderedLayerInfos.push({
              layer: layer,
              element: element,
              localRect: rect
            });

            // add a fake target for empty groups
            if (layer instanceof _model.LayerGroup && !layer.layers.length) {
              rect = Object.assign({}, rect, { left: rect.left + LAYER_INDENT, top: rect.bottom });
              orderedLayerInfos.push({
                layer: layer,
                element: element,
                localRect: rect,
                moveIntoEmptyLayerGroup: true
              });
            }
          });

          orderedLayerInfos.sort(function (a, b) {
            return a.localRect.top - b.localRect.top;
          });

          $dragIndicator = $('<div>').addClass('slt-layers-list-drag-indicator').appendTo($scroller);
        },

        onDrag: function onDrag(event) {
          var localEventY = event.clientY - scrollerRect.top + $scroller.scrollTop();

          // find the target layer and edge (top or bottom)
          targetLayerInfo = null;
          var minDistance = Infinity;
          var minDistanceIndent = Infinity; // tie break to most indented layer
          for (var i = 0; i < orderedLayerInfos.length; i++) {
            var layerInfo = orderedLayerInfos[i];

            // skip if mouse to the left of this layer
            if (event.clientX < layerInfo.localRect.left) {
              continue;
            }

            for (var edge in EDGES) {
              // test distance to top edge
              var distance = Math.abs(localEventY - layerInfo.localRect[edge]);
              var indent = layerInfo.localRect.left;
              if (distance <= minDistance) {
                if (distance != minDistance || indent > minDistanceIndent) {
                  minDistance = distance;
                  minDistanceIndent = indent;
                  targetLayerInfo = layerInfo;
                  targetEdge = edge;
                }
              }
            }
          }

          // disallow dragging a layer into itself or its children
          if (targetLayerInfo) {
            var layer = targetLayerInfo.layer;
            while (layer) {
              if (layer == dragLayer) {
                targetLayerInfo = null;
                break;
              }

              layer = layer.parent;
            }
          }

          if (targetLayerInfo && targetEdge == 'bottom' && targetLayerInfo.layer.nextSibling == dragLayer) {
            targetLayerInfo = null;
          }

          if (targetLayerInfo) {
            $dragIndicator.css('left', targetLayerInfo.localRect.left);
            $dragIndicator.css('top', targetLayerInfo.localRect[targetEdge]);
          }

          $dragIndicator.toggle(!!targetLayerInfo);
        },

        onDrop: function onDrop(event) {
          if ($dragIndicator) {
            $dragIndicator.remove();
          }

          if (targetLayerInfo) {
            _this8.scope_.$apply(function () {
              if (targetLayerInfo.moveIntoEmptyLayerGroup) {
                // moving into an empty layer group
                var newParent = targetLayerInfo.layer;
                dragLayer.remove();
                newParent.layers.push(dragLayer);
                dragLayer.parent = newParent;
              } else {
                // moving next to another layer
                var _newParent = targetLayerInfo.layer.parent;
                if (_newParent) {
                  dragLayer.remove();
                  var index = _newParent.layers.indexOf(targetLayerInfo.layer);
                  if (index >= 0) {
                    index += targetEdge == 'top' ? 0 : 1;
                    _newParent.layers.splice(index, 0, dragLayer);
                    dragLayer.parent = _newParent;
                  }
                }
              }

              _this8.studioState_.artworkChanged();
            });
          }

          _this8.timeout_(function () {
            return _this8.suppressClick_ = false;
          }, 0);
        }
      });
    }
  }, {
    key: 'horizZoom',
    get: function get() {
      return this.horizZoom_;
    },
    set: function set(val) {
      this.horizZoom_ = _MathUtil.MathUtil.constrain(val, MIN_ZOOM, MAX_ZOOM);
    }
  }, {
    key: 'artwork',
    get: function get() {
      return this.studioState_.artwork;
    }
  }, {
    key: 'activeTime',
    get: function get() {
      return this.studioState_.activeTime;
    }
  }, {
    key: 'animations',
    get: function get() {
      return this.studioState_.animations;
    }
  }, {
    key: 'activeAnimation',
    get: function get() {
      return this.studioState_.activeAnimation;
    }
  }]);

  return LayerTimelineController;
}();

angular.module('AVDStudio').directive('studioLayerTimeline', function () {
  return {
    restrict: 'E',
    scope: {},
    templateUrl: 'components/layertimeline/layertimeline.html',
    replace: true,
    bindToController: true,
    controller: LayerTimelineController,
    controllerAs: 'ctrl'
  };
});

// timeline grid

},{"./consts":5,"DragHelper":16,"MathUtil":18,"ModelUtil":19,"SvgLoader":21,"UiUtil":23,"VectorDrawableLoader":24,"model":35}],7:[function(require,module,exports){
'use strict';

var _MathUtil = require('MathUtil');

var _DragHelper = require('DragHelper');

var _consts = require('./consts');

var GRID_INTERVALS_MS = [10, 25, 50, 100, 250, 500, 1000, 2500, 5000, 10000, 30000, 60000]; /*
                                                                                             * Copyright 2016 Google Inc.
                                                                                             *
                                                                                             * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                             * you may not use this file except in compliance with the License.
                                                                                             * You may obtain a copy of the License at
                                                                                             *
                                                                                             *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                             *
                                                                                             * Unless required by applicable law or agreed to in writing, software
                                                                                             * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                             * See the License for the specific language governing permissions and
                                                                                             * limitations under the License.
                                                                                             */

angular.module('AVDStudio').directive('studioTimelineGrid', function () {
  return {
    restrict: 'E',
    scope: {
      isActive: '=',
      activeTime: '=',
      animation: '=',
      onScrub: '&'
    },
    template: '<canvas></canvas>',
    replace: true,
    require: '^studioLayerTimeline',
    link: function link(scope, element, attrs, layerTimelineCtrl) {
      var $canvas = element;
      var canvas = $canvas.get(0);

      var isHeader = 'isHeader' in attrs;

      scope.$watch(function () {
        return scope.redraw_();
      });

      if ('onScrub' in attrs) {
        var handleScrubEvent_ = function handleScrubEvent_(event) {
          var x = event.clientX;
          x -= $canvas.offset().left;
          var time = (x - _consts.TimelineConsts.TIMELINE_ANIMATION_PADDING) / ($canvas.width() - _consts.TimelineConsts.TIMELINE_ANIMATION_PADDING * 2) * scope.animation.duration;
          time = _MathUtil.MathUtil.constrain(time, 0, scope.animation.duration);
          scope.onScrub({
            animation: scope.animation,
            time: time,
            options: { disableSnap: !!event.altKey }
          });
        };

        $canvas.on('mousedown', function (event) {
          return scope.$apply(function () {
            handleScrubEvent_(event);
            new _DragHelper.DragHelper({
              downEvent: event,
              direction: 'horizontal',
              skipSlopCheck: true,
              onDrag: function onDrag(event) {
                return scope.$apply(function () {
                  return handleScrubEvent_(event);
                });
              }
            });
            event.preventDefault();
            return false;
          });
        });
      }

      scope.redraw_ = function () {
        if (!$canvas.is(':visible')) {
          return;
        }

        var width = $canvas.width();
        var height = $canvas.height();
        var horizZoom = layerTimelineCtrl.horizZoom;
        $canvas.attr('width', width * window.devicePixelRatio);
        $canvas.attr('height', isHeader ? height * window.devicePixelRatio : 1);

        var ctx = canvas.getContext('2d');
        ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        ctx.translate(_consts.TimelineConsts.TIMELINE_ANIMATION_PADDING, 0);

        // compute grid spacing (40 = minimum grid spacing in pixels)
        var interval = 0;
        var spacingMs = GRID_INTERVALS_MS[interval];
        while (spacingMs * horizZoom < 40 || interval >= GRID_INTERVALS_MS.length) {
          ++interval;
          spacingMs = GRID_INTERVALS_MS[interval];
        }

        var spacingPx = spacingMs * horizZoom;

        if (isHeader) {
          // text labels
          ctx.fillStyle = 'rgba(0,0,0,0.4)';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.font = '10px Roboto';
          for (var x = 0, t = 0; x <= width; x += spacingPx, t += spacingMs) {
            //ctx.fillRect(x - 0.5, 0, 1, height);
            ctx.fillText(t / 1000 + 's', x, height / 2);
          }

          if (scope.isActive) {
            ctx.fillStyle = 'rgba(244, 67, 54, .7)';
            ctx.beginPath();
            ctx.arc(scope.activeTime * horizZoom, height / 2, 4, 0, 2 * Math.PI, false);
            ctx.fill();
            ctx.closePath();
            ctx.fillRect(scope.activeTime * horizZoom - 1, height / 2 + 4, 2, height);
          }
        } else {
          // grid lines
          ctx.fillStyle = 'rgba(0,0,0,0.1)';
          for (var _x = spacingPx; _x < width - _consts.TimelineConsts.TIMELINE_ANIMATION_PADDING * 2; _x += spacingPx) {
            ctx.fillRect(_x - 0.5, 0, 1, 1);
          }

          if (scope.isActive) {
            ctx.fillStyle = 'rgba(244, 67, 54, .7)';
            ctx.fillRect(scope.activeTime * horizZoom - 1, 0, 2, 1);
          }
        }
      };

      scope.redraw_();
    }
  };
});

},{"./consts":5,"DragHelper":16,"MathUtil":18}],8:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _model = require('model');

var _properties = require('model/properties');

var _ColorUtil = require('ColorUtil');

var _ModelUtil = require('ModelUtil');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PropertyInspectorController = function () {
  function PropertyInspectorController($scope, $element, StudioStateService) {
    var _this = this;

    _classCallCheck(this, PropertyInspectorController);

    this.scope_ = $scope;
    this.element_ = $element;

    this.studioState_ = StudioStateService;
    this.studioState_.onChange(function (event, changes) {
      if (changes.selection) {
        _this.rebuildSelection_();
      }
    }, $scope);

    this.rebuildSelection_();
  }

  _createClass(PropertyInspectorController, [{
    key: 'rebuildSelection_',
    value: function rebuildSelection_() {
      this.selectionInfo = null;
      if (this.studioState_.selectedLayers.length) {
        this.rebuildLayersSelection_();
      } else if (this.studioState_.selectedAnimationBlocks.length) {
        this.rebuildAnimationBlocksSelection_();
      } else if (this.studioState_.firstSelectedItem instanceof _model.Animation) {
        this.rebuildAnimationsSelection_();
      }
    }
  }, {
    key: 'androidToCssColor',
    value: function androidToCssColor(val) {
      return _ColorUtil.ColorUtil.androidToCssColor(val);
    }
  }, {
    key: 'computeSharedPropertyNames_',
    value: function computeSharedPropertyNames_(items) {
      if (!items || !items.length) {
        return [];
      }

      var shared = void 0;
      items.forEach(function (item) {
        var names = Object.keys(item.inspectableProperties);
        if (!shared) {
          shared = names;
        } else {
          var namesSet = new Set(names);
          shared = shared.filter(function (n) {
            return namesSet.has(n);
          });
        }
      });

      return shared;
    }
  }, {
    key: 'rebuildLayersSelection_',
    value: function rebuildLayersSelection_() {
      var _this2 = this;

      this.selectionInfo = {
        type: 'layers',
        inspectedProperties: []
      };

      if (this.studioState_.selection.length > 1) {
        // batch layer editing
        var count = this.studioState_.selection.length;
        this.selectionInfo.multiple = true;
        this.selectionInfo.icon = 'collection';
        this.selectionInfo.description = count + ' layers';

        var layers = this.studioState_.selection;
        var sharedPropertyNames = this.computeSharedPropertyNames_(layers);
        sharedPropertyNames.forEach(function (propertyName) {
          var property = layers[0].inspectableProperties[propertyName];
          if (property instanceof _properties.IdProperty) {
            return;
          }

          _this2.selectionInfo.inspectedProperties.push(new InspectedProperty({
            get value() {
              return layers.reduce(function (v, layer) {
                return v == layer[propertyName] ? v : null;
              }, layers[0][propertyName]);
            },
            set value(val) {
              layers.forEach(function (layer) {
                return layer[propertyName] = val;
              });
            },
            propertyName: propertyName,
            property: property,
            onChange: function onChange() {
              _this2.studioState_.animChanged();
              _this2.studioState_.artworkChanged();
            }
          }));
        });
      } else {
        // edit a single layer
        var layer = this.studioState_.firstSelectedItem;
        this.selectionInfo.icon = layer.typeIcon;
        Object.defineProperty(this.selectionInfo, 'description', {
          get: function get() {
            return layer.id;
          }
        });
        Object.keys(layer.inspectableProperties).forEach(function (propertyName) {
          var self = _this2;
          var property = layer.inspectableProperties[propertyName];
          _this2.selectionInfo.inspectedProperties.push(new InspectedProperty({
            object: layer,
            propertyName: propertyName,
            property: property,
            get value() {
              if (!self.studioState_.animationRenderer || layer === self.studioState_.artwork) {
                return layer[propertyName];
              }

              var renderedLayer = self.studioState_.animationRenderer.renderedArtwork.findLayerById(layer.id);
              return renderedLayer ? renderedLayer[propertyName] : null;
            },
            set value(value) {
              if (property instanceof _properties.IdProperty) {
                self.studioState_.updateLayerId(layer, value);
              } else {
                layer[propertyName] = value;
                self.studioState_.artworkChanged();
              }
            },
            transformEditedValue: property instanceof _properties.IdProperty ? function (enteredValue) {
              return _this2.studioState_.getUniqueLayerId(_properties.IdProperty.sanitize(enteredValue), layer);
            } : null,
            get editable() {
              return self.studioState_.animationRenderer ? !self.studioState_.animationRenderer.getLayerPropertyState(layer.id, propertyName).activeBlock : true;
            }
          }));
        });
      }
    }
  }, {
    key: 'rebuildAnimationBlocksSelection_',
    value: function rebuildAnimationBlocksSelection_() {
      var _this3 = this;

      this.selectionInfo = {
        type: 'animationBlocks',
        inspectedProperties: []
      };

      if (this.studioState_.selection.length > 1) {
        // batch animation block editing
        var count = this.studioState_.selection.length;
        this.selectionInfo.multiple = true;
        this.selectionInfo.icon = 'collection';
        this.selectionInfo.description = count + ' property animations';

        var blocks = this.studioState_.selection;
        var sharedPropertyNames = this.computeSharedPropertyNames_(blocks);
        sharedPropertyNames.forEach(function (propertyName) {
          var property = blocks[0].inspectableProperties[propertyName];
          if (property instanceof _properties.StubProperty) {
            // fromValue and toValue only work when they're animating compatible property types
            var properties = blocks.map(function (block) {
              return _this3.studioState_.artwork.findLayerById(block.layerId).inspectableProperties[block.propertyName];
            });
            var propertiesCompatible = properties.reduce(function (c, prop) {
              return c && prop.constructor === properties[0].constructor;
            }, true);
            if (!propertiesCompatible) {
              return;
            }
            property = properties[0];
          }
          _this3.selectionInfo.inspectedProperties.push(new InspectedProperty({
            get value() {
              return blocks.reduce(function (v, block) {
                return v == block[propertyName] ? v : null;
              }, blocks[0][propertyName]);
            },
            set value(val) {
              blocks.forEach(function (block) {
                return block[propertyName] = val;
              });
            },
            propertyName: propertyName,
            property: property,
            onChange: function onChange() {
              return _this3.studioState_.animChanged();
            }
          }));
        });
      } else {
        // edit a single animation block
        var block = this.studioState_.firstSelectedItem;
        this.selectionInfo.icon = 'animation_block';
        this.selectionInfo.description = '' + block.propertyName;
        this.selectionInfo.subDescription = 'for \'' + block.layerId + '\'';
        Object.keys(block.inspectableProperties).forEach(function (propertyName) {
          var property = block.inspectableProperties[propertyName];
          if (property instanceof _properties.StubProperty) {
            property = _this3.studioState_.artwork.findLayerById(block.layerId).inspectableProperties[block.propertyName];
          }
          _this3.selectionInfo.inspectedProperties.push(new InspectedProperty({
            object: block,
            propertyName: propertyName,
            property: property,
            onChange: function onChange() {
              return _this3.studioState_.animChanged();
            }
          }));
        });
      }
    }
  }, {
    key: 'rebuildAnimationsSelection_',
    value: function rebuildAnimationsSelection_() {
      var _this4 = this;

      this.selectionInfo = {
        type: 'animations',
        inspectedProperties: []
      };

      if (this.studioState_.selection.length > 1) {
        // batch animation editing
        var count = this.studioState_.selection.length;
        this.selectionInfo.multiple = true;
        this.selectionInfo.icon = 'collection';
        this.selectionInfo.description = count + ' animations';
        // TODO
      } else {
        // edit a single animation
        var animation = this.studioState_.firstSelectedItem;
        this.selectionInfo.icon = 'animation';
        Object.defineProperty(this.selectionInfo, 'description', {
          get: function get() {
            return animation.id;
          }
        });
        Object.keys(animation.inspectableProperties).forEach(function (propertyName) {
          var property = animation.inspectableProperties[propertyName];
          _this4.selectionInfo.inspectedProperties.push(new InspectedProperty({
            object: animation,
            propertyName: propertyName,
            transformEditedValue: property instanceof _properties.IdProperty ? function (enteredValue) {
              return _this4.studioState_.getUniqueAnimationId(_properties.IdProperty.sanitize(enteredValue), animation);
            } : null,
            property: property,
            onChange: function onChange() {
              return _this4.studioState_.animChanged();
            }
          }));
        });
      }
    }
  }, {
    key: 'onValueEditorKeyDown',
    value: function onValueEditorKeyDown(event, inspectedProperty) {
      switch (event.keyCode) {
        // up/down buttons
        case 38:
        case 40:
          inspectedProperty.resolveEnteredValue();
          var $target = $(event.target);
          var numberValue = Number($target.val());
          if (!isNaN(numberValue)) {
            var delta = event.keyCode == 38 ? 1 : -1;

            if (inspectedProperty.property instanceof _properties.FractionProperty) {
              delta *= .1;
            }

            if (event.shiftKey) {
              delta *= 10;
            } else if (event.altKey) {
              delta /= 10;
            }

            numberValue += delta;
            inspectedProperty.property.trySetEditedValue(inspectedProperty, 'value', Number(numberValue.toFixed(6)));
            setTimeout(function () {
              return $target.get(0).select();
            }, 0);
            return true;
          }
          break;
      }
    }
  }, {
    key: 'selectionDescription',
    get: function get() {
      return this.selectionInfo && this.selectionInfo.description;
    }
  }]);

  return PropertyInspectorController;
}();

var InspectedProperty = function () {
  function InspectedProperty(delegate) {
    _classCallCheck(this, InspectedProperty);

    this.delegate = delegate;
    this.object = delegate.object;
    this.propertyName = delegate.propertyName;
    this.property = delegate.property;
    this.enteredValue_ = null;
  }

  _createClass(InspectedProperty, [{
    key: 'resolveEnteredValue',
    value: function resolveEnteredValue() {
      this.enteredValue_ = null;
    }
  }, {
    key: 'value',
    get: function get() {
      return 'value' in this.delegate ? this.delegate.value : this.object[this.propertyName];
    },
    set: function set(value) {
      'value' in this.delegate ? this.delegate.value = value : this.object[this.propertyName] = value;
      if (this.delegate.onChange) {
        this.delegate.onChange();
      }
    }
  }, {
    key: 'typeName',
    get: function get() {
      return this.property.constructor.name;
    }
  }, {
    key: 'editable',
    get: function get() {
      return 'editable' in this.delegate ? this.delegate.editable : true;
    }
  }, {
    key: 'displayValue',
    get: function get() {
      return this.property.displayValueForValue(this.value);
    }
  }, {
    key: 'editableValue',
    get: function get() {
      return this.enteredValue_ !== null ? this.enteredValue_ : this.property.getEditableValue(this, 'value');
    },
    set: function set(enteredValue) {
      this.enteredValue_ = enteredValue;
      if (this.delegate.transformEditedValue) {
        enteredValue = this.delegate.transformEditedValue(enteredValue);
      }
      this.property.trySetEditedValue(this, 'value', enteredValue);
    }
  }]);

  return InspectedProperty;
}();

angular.module('AVDStudio').directive('studioPropertyInspector', function () {
  return {
    restrict: 'E',
    scope: {},
    templateUrl: 'components/propertyinspector/propertyinspector.html',
    replace: true,
    bindToController: true,
    controller: PropertyInspectorController,
    controllerAs: 'ctrl'
  };
});

// timeline grid

},{"ColorUtil":15,"ModelUtil":19,"model":35,"model/properties":44}],9:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var groups = {};

var ScrollGroupController = function ScrollGroupController($scope, $element, $attrs) {
  _classCallCheck(this, ScrollGroupController);

  var scrollGroup = $attrs.scrollGroup || '';
  groups[scrollGroup] = groups[scrollGroup] || [];
  groups[scrollGroup].push($element);

  $element.on('scroll', function () {
    var scrollTop = $element.scrollTop();
    groups[scrollGroup].forEach(function (el) {
      return el !== $element ? el.scrollTop(scrollTop) : null;
    });
  });

  $scope.$on('$destroy', function () {
    groups[scrollGroup].splice(groups[scrollGroup].indexOf($element), 1);
  });
};

angular.module('AVDStudio').directive('scrollGroup', function () {
  return {
    restrict: 'A',
    controller: ScrollGroupController
  };
});

},{}],10:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _DragHelper = require('DragHelper');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SplitterController = function () {
  function SplitterController($scope, $element, $attrs) {
    var _this = this;

    _classCallCheck(this, SplitterController);

    this.edge_ = $attrs.edge;
    this.min_ = Number($attrs.min) || 100;
    this.persistKey_ = $attrs.persistId ? '$$splitter::' + $attrs.persistId : null;
    this.orientation_ = this.edge_ == 'left' || this.edge_ == 'right' ? 'vertical' : 'horizontal';
    this.element_ = $element;
    this.parent_ = $element.parent();
    this.dragging_ = false;

    if (this.orientation_ == 'vertical') {
      this.sizeGetter_ = function () {
        return _this.parent_.width();
      };
      this.sizeSetter_ = function (size) {
        return _this.parent_.width(size);
      };
      this.clientXY_ = 'clientX';
    } else {
      this.sizeGetter_ = function () {
        return _this.parent_.height();
      };
      this.sizeSetter_ = function (size) {
        return _this.parent_.height(size);
      };
      this.clientXY_ = 'clientY';
    }

    this.addClasses_();
    this.setupEventListeners_();
    this.deserializeState_();
  }

  _createClass(SplitterController, [{
    key: 'deserializeState_',
    value: function deserializeState_() {
      if (this.persistKey_ in localStorage) {
        this.setSize_(Number(localStorage[this.persistKey_]));
      }
    }
  }, {
    key: 'addClasses_',
    value: function addClasses_() {
      this.element_.addClass('splt-' + this.orientation_).addClass('splt-edge-' + this.edge_);
    }
  }, {
    key: 'setupEventListeners_',
    value: function setupEventListeners_() {
      var _this2 = this;

      this.element_.on('mousedown', function (event) {
        _this2.downXY_ = event[_this2.clientXY_];
        _this2.downSize_ = _this2.sizeGetter_();
        event.preventDefault();

        new _DragHelper.DragHelper({
          downEvent: event,
          direction: _this2.orientation_ == 'vertical' ? 'horizontal' : 'vertical',
          draggingCursor: _this2.orientation_ == 'vertical' ? 'col-resize' : 'row-resize',

          onBeginDrag: function onBeginDrag(event) {
            return _this2.element_.addClass('is-dragging');
          },
          onDrop: function onDrop(event) {
            return _this2.element_.removeClass('is-dragging');
          },
          onDrag: function onDrag(event, delta) {
            var sign = _this2.edge_ == 'left' || _this2.edge_ == 'top' ? -1 : 1;
            _this2.setSize_(Math.max(_this2.min_, _this2.downSize_ + sign * delta[_this2.orientation_ == 'vertical' ? 'x' : 'y']));
          }
        });
      });
    }
  }, {
    key: 'setSize_',
    value: function setSize_(size) {
      if (this.persistKey_) {
        localStorage[this.persistKey_] = size;
      }
      this.sizeSetter_(size);
    }
  }]);

  return SplitterController;
}();

angular.module('AVDStudio').directive('studioSplitter', function () {
  return {
    restrict: 'E',
    scope: {},
    template: '<div class="studio-splitter"></div>',
    replace: true,
    bindToController: true,
    controller: SplitterController,
    controllerAs: 'ctrl'
  };
});

},{"DragHelper":16}],11:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _model = require('model');

var _MathUtil = require('MathUtil');

var _ColorUtil = require('ColorUtil');

var _SvgLoader = require('SvgLoader');

var _VectorDrawableLoader = require('VectorDrawableLoader');

var _AvdSerializer = require('AvdSerializer');

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//import TEST_DATA from '../../../_sandbox/debug.iconanim.json';


var PLAYBACK_SPEEDS = [.1, .25, .5, 1, 2, 3, 4, 8, 10];

var DEBUG = !!window.location.search.match(/debug/);

var StudioCtrl = function () {
  function StudioCtrl($scope, $http, $mdToast, $mdDialog, $timeout, StudioStateService) {
    _classCallCheck(this, StudioCtrl);

    this.versionInfo = window.APP_VERSION_INFO;

    this.scope_ = $scope;
    this.http_ = $http;
    this.mdToast_ = $mdToast;
    this.mdDialog_ = $mdDialog;
    this.timeout_ = $timeout;
    this.studioState_ = StudioStateService;

    this.previewMode = false;
    this.isLoaded = false;

    this.setupKeyboardAndUnloadEvents_();
    this.setupClipboardEvents_();

    this.loadInitialArtwork_();
  }

  _createClass(StudioCtrl, [{
    key: 'showError_',
    value: function showError_(message, error) {
      this.mdToast_.show(this.mdToast_.simple().textContent(message).hideDelay(3000));
      console.error(error);
    }
  }, {
    key: 'loadInitialArtwork_',
    value: function loadInitialArtwork_() {
      var _this = this;

      var exampleMatch = window.location.search.match(/(?:example|fileUrl)=(.+)/);
      if (exampleMatch) {
        // Load example
        this.http_({
          url: decodeURIComponent(exampleMatch[1])
        }).then(function (response) {
          try {
            _this.studioState_.load({
              artwork: new _model.Artwork(response.data.artwork),
              animations: response.data.animations.map(function (anim) {
                return new _model.Animation(anim);
              })
            });
          } catch (e) {
            _this.showError_('Error parsing example artwork', e);
            _this.studioState_.new();
          }
          _this.isLoaded = true;
        }, function (error) {
          _this.showError_('Error loading example artwork', error);
          _this.studioState_.new();
          _this.isLoaded = true;
        });
      } else {
        // load empty artwork
        this.studioState_.new();
        this.isLoaded = true;
      }
    }
  }, {
    key: 'setupClipboardEvents_',
    value: function setupClipboardEvents_() {
      var _this2 = this;

      var cutCopyHandler_ = function cutCopyHandler_(event, shouldCut) {
        if (document.activeElement.matches('input')) {
          return true;
        }

        var selectedLayers = _this2.studioState_.selectedLayers;
        if (!selectedLayers) {
          return false;
        }

        var clipboardData = event.originalEvent.clipboardData;
        clipboardData.setData('text/plain', JSON.stringify({
          clipboardType: 'layers',
          layers: selectedLayers.filter(function (l) {
            return !(l instanceof _model.Artwork);
          }).map(function (l) {
            return l.toJSON();
          })
        }, null, 2));

        if (shouldCut) {
          _this2.deleteSelectedLayers_();
        }

        return false;
      };

      var cutHandler_ = function cutHandler_(event) {
        return cutCopyHandler_(event, true);
      };
      var copyHandler_ = function copyHandler_(event) {
        return cutCopyHandler_(event, false);
      };

      var pasteHandler_ = function pasteHandler_(event) {
        if (document.activeElement.matches('input')) {
          return true;
        }

        var targetParent = _this2.studioState_.artwork;
        var firstSelectedItem = _this2.studioState_.firstSelectedItem;
        if (firstSelectedItem && firstSelectedItem instanceof _model.LayerGroup) {
          targetParent = firstSelectedItem;
        }

        var clipboardData = event.originalEvent.clipboardData;
        var str = clipboardData.getData('text');

        var pasteLayers = null;

        if (str.match(/<\/svg>\s*$/)) {
          // paste SVG
          ga('send', 'event', 'paste', 'svg');
          var artwork = _SvgLoader.SvgLoader.loadArtworkFromSvgString(str);
          pasteLayers = artwork.layers;
        } else if (str.match(/<\/vector>\s*$/)) {
          // paste VD
          ga('send', 'event', 'paste', 'vd');
          var _artwork = _VectorDrawableLoader.VectorDrawableLoader.loadArtworkFromXmlString(str);
          pasteLayers = _artwork.layers;
        } else if (str.match(/\}\s*$/)) {
          // paste JSON
          var parsed = void 0;
          try {
            parsed = JSON.parse(str);
          } catch (e) {
            console.error('Couldn\'t parse JSON: ' + str);
            return false;
          }

          if (parsed.clipboardType == 'layers') {
            ga('send', 'event', 'paste', 'json.layers');
            pasteLayers = parsed.layers.map(function (l) {
              return _model.BaseLayer.load(l);
            });
          } else {
            ga('send', 'event', 'paste', 'json.unknown');
          }
        }

        if (pasteLayers && pasteLayers.length) {
          var newSelection = [];
          pasteLayers.forEach(function (layer) {
            layer.parent = targetParent;
            layer.walk(function (layer) {
              layer.id = _this2.studioState_.getUniqueLayerId(layer.id, layer);
            });
            targetParent.layers.push(layer);
            newSelection.push(layer);
          });

          _this2.studioState_.selection = newSelection;
          _this2.studioState_.artworkChanged();
          return false;
        }
      };

      var digestedCutHandler_ = function digestedCutHandler_(event) {
        return _this2.scope_.$apply(function () {
          return cutHandler_(event);
        });
      };
      var digestedCopyHandler_ = function digestedCopyHandler_(event) {
        return _this2.scope_.$apply(function () {
          return copyHandler_(event);
        });
      };
      var digestedPasteHandler_ = function digestedPasteHandler_(event) {
        return _this2.scope_.$apply(function () {
          return pasteHandler_(event);
        });
      };

      $(window).on('cut', digestedCutHandler_).on('copy', digestedCopyHandler_).on('paste', digestedPasteHandler_);

      this.scope_.$on('$destroy', function () {
        $(window).off('cut', digestedCutHandler_).off('copy', digestedCopyHandler_).off('paste', digestedPasteHandler_);
      });
    }
  }, {
    key: 'setupKeyboardAndUnloadEvents_',
    value: function setupKeyboardAndUnloadEvents_() {
      var _this3 = this;

      var keydownHandler_ = function keydownHandler_(event) {
        // delete/backspace
        if (document.activeElement.matches('input')) {
          return true;
        }

        if (event.keyCode == 32) {
          // spacebar
          _this3.allowPlayAnimate = true;
          _this3.studioState_.playing = !_this3.studioState_.playing;
          return false;
        } else if (event.keyCode == 8) {
          // delete key
          event.preventDefault(); // in case there's a JS error, never navigate away
          _this3.deleteSelectedLayers_();
          _this3.deleteSelectedAnimationBlocks_();
          _this3.deleteSelectedAnimations_();
          return false;
        } else if (event.keyCode == 27) {
          // escape key
          if (_this3.previewMode) {
            _this3.previewMode = false;
          }
          return false;
        } else if (event.keyCode == "P".charCodeAt(0)) {
          // preview mode (P key)
          _this3.previewMode = !_this3.previewMode;
          return false;
        } else if (event.keyCode == "R".charCodeAt(0)) {
          // rewind (R key)
          _this3.rewind();
          return false;
        } else if (event.metaKey && event.keyCode == "Z".charCodeAt(0)) {
          // undo/redo (Z key)
          event.shiftKey ? _this3.studioState_.tryRedo() : _this3.studioState_.tryUndo();
          return false;
        } else if (event.metaKey && event.keyCode == "G".charCodeAt(0)) {
          // group/ungroup (G key)
          event.shiftKey ? _this3.ungroupSelectedLayers_() : _this3.groupSelectedLayers_();
          return false;
        } else if (event.keyCode == 187 || event.keyCode == 189 || event.keyCode == "0".charCodeAt(0)) {
          // -/+/0 keys to change playback speed
          if (_this3.studioState_.playing) {
            _this3.studioState_.playing = false;
            if (event.keyCode == "0".charCodeAt(0)) {
              _this3.studioState_.playbackSpeed = 1;
            } else {
              var speedUp = !!(event.keyCode == 187);
              var currentIndex = PLAYBACK_SPEEDS.indexOf(_this3.studioState_.playbackSpeed);
              if (currentIndex < 0) {
                _this3.studioState_.playbackSpeed = 1;
              } else {
                _this3.studioState_.playbackSpeed = PLAYBACK_SPEEDS[_MathUtil.MathUtil.constrain(currentIndex + (speedUp ? 1 : -1), 0, PLAYBACK_SPEEDS.length - 1)];
              }
            }
            _this3.studioState_.playing = true;
          }
          return false;
        }
      };

      var digestedKeydownHandler_ = function digestedKeydownHandler_(event) {
        return _this3.scope_.$apply(function () {
          return keydownHandler_(event);
        });
      };

      var beforeUnloadHandler_ = function beforeUnloadHandler_(event) {
        if (_this3.studioState_.dirty && !DEBUG) {
          return 'You\'ve made changes but haven\'t saved. ' + 'Are you sure you want to navigate away?';
        }
      };

      $(window).on('keydown', digestedKeydownHandler_).on('beforeunload', beforeUnloadHandler_);

      this.scope_.$on('$destroy', function () {
        $(window).off('keydown', digestedKeydownHandler_).off('beforeunload', beforeUnloadHandler_);
      });
    }
  }, {
    key: 'isPlaying',
    value: function isPlaying() {
      return this.studioState_.playing;
    }
  }, {
    key: 'togglePlaying',
    value: function togglePlaying() {
      this.allowPlayAnimate = true;
      this.studioState_.playing = !this.studioState_.playing;
    }
  }, {
    key: 'rewind',
    value: function rewind() {
      var _this4 = this;

      this.studioState_.playing = false;
      this.timeout_(function () {
        return _this4.studioState_.activeTime = 0;
      }, 0);
    }
  }, {
    key: 'restartPlayback',
    value: function restartPlayback() {
      this.studioState_.activeTime = 0;
      this.studioState_.playing = true;
    }
  }, {
    key: 'onDropFile',
    value: function onDropFile(fileInfo) {
      var _this5 = this;

      var confirm_ = function confirm_() {
        if (_this5.studioState_.dirty && !DEBUG) {
          if (!window.confirm('You\'ve made changes but haven\'t saved. ' + 'Really load the dropped file?')) {
            return false;
          }
        }

        return true;
      };

      if (fileInfo.type == 'application/json' || fileInfo.name.match(/\.iconanim$/)) {
        ga('send', 'event', 'file', 'openFile.dragDrop');
        if (!confirm_()) {
          return;
        }

        var jsonObj = JSON.parse(fileInfo.textContent);
        this.studioState_.load({
          artwork: new _model.Artwork(jsonObj.artwork),
          animations: jsonObj.animations.map(function (anim) {
            return new _model.Animation(anim);
          })
        });
      } else if (fileInfo.type == 'image/svg+xml') {
        var artwork = _SvgLoader.SvgLoader.loadArtworkFromSvgString(fileInfo.textContent);

        var startFromScratch_ = function startFromScratch_() {
          if (!confirm_()) {
            return;
          }

          ga('send', 'event', 'file', 'importSVG.startFromScratch.dragDrop');
          _this5.studioState_.load({ artwork: artwork });
        };

        if (!this.studioState_.artwork.layers.length) {
          startFromScratch_();
          return;
        }

        this.mdDialog_.show({
          title: 'Attention',
          templateUrl: 'pages/studio/dialog-svg-drop.html',
          clickOutsideToClose: true,
          controller: function controller($scope, $mdDialog) {
            $scope.closeDialog = function () {
              return $mdDialog.hide();
            };

            $scope.startFromScratch = function () {
              startFromScratch_();
              $mdDialog.hide();
            };

            $scope.addLayers = function () {
              ga('send', 'event', 'file', 'importSVG.addLayers.dragDrop');
              _this5.studioState_.addLayers(artwork.layers);
              $mdDialog.hide();
            };
          }
        });
      } else if (fileInfo.type === 'application/xml' || fileInfo.type === 'text/xml') {
        ga('send', 'event', 'file', 'importVD.dragDrop');
        if (!confirm_()) {
          return;
        }
        var _artwork2 = _VectorDrawableLoader.VectorDrawableLoader.loadArtworkFromXmlString(fileInfo.textContent);
        this.studioState_.load({ artwork: _artwork2 });
      }
    }
  }, {
    key: 'deleteSelectedLayers_',
    value: function deleteSelectedLayers_() {
      if (this.studioState_.firstSelectedItem instanceof _model.BaseLayer) {
        // delete layers
        this.studioState_.deleteLayers(this.studioState_.selectedLayers);
        this.studioState_.selection = null;
        this.studioState_.artworkChanged();
        this.studioState_.animChanged();
      }
    }
  }, {
    key: 'deleteSelectedAnimationBlocks_',
    value: function deleteSelectedAnimationBlocks_() {
      if (this.studioState_.firstSelectedItem instanceof _model.AnimationBlock) {
        // delete animations
        var selectedAnimationBlocks = this.studioState_.selectedAnimationBlocks;
        this.studioState_.animations.forEach(function (animation) {
          for (var i = animation.blocks.length - 1; i >= 0; --i) {
            var block = animation.blocks[i];
            if (selectedAnimationBlocks.indexOf(block) >= 0) {
              animation.blocks.splice(i, 1);
            }
          }
        });

        this.studioState_.selection = null;
        this.studioState_.animChanged();
        return false;
      }
    }
  }, {
    key: 'deleteSelectedAnimations_',
    value: function deleteSelectedAnimations_() {
      var _this6 = this;

      if (this.studioState_.firstSelectedItem instanceof _model.Animation) {
        // delete animations
        this.studioState_.activeAnimation = null;
        this.studioState_.animations = this.studioState_.animations.filter(function (animation) {
          return animation !== _this6.studioState_.firstSelectedItem;
        });
        this.studioState_.selection = null;
        this.studioState_.animChanged();
        return false;
      }
    }
  }, {
    key: 'groupOrUngroupSelectedLayers_',
    value: function groupOrUngroupSelectedLayers_(shouldGroup) {
      var _this7 = this;

      if (this.studioState_.selectedLayers.length) {
        // sort selected layers by order they appear in tree
        var tempSelLayers = this.studioState_.selectedLayers.slice();
        var selLayerOrders = {};
        var n = 0;
        this.studioState_.artwork.walk(function (layer) {
          if (tempSelLayers.indexOf(layer) >= 0) {
            selLayerOrders[layer.id] = n;
            ++n;
          }
        });
        tempSelLayers.sort(function (a, b) {
          return selLayerOrders[a.id] - selLayerOrders[b.id];
        });

        // either group or ungroup selection
        if (shouldGroup) {
          // group selected layers

          // remove any layers that are descendants of other selected layers,
          // and remove the artwork itself if selected
          tempSelLayers = tempSelLayers.filter(function (layer) {
            if (layer instanceof _model.Artwork) {
              return false;
            }

            var p = layer.parent;
            while (p) {
              if (tempSelLayers.indexOf(p) >= 0) {
                return false;
              }
              p = p.parent;
            }
            return true;
          });

          if (!tempSelLayers.length) {
            return;
          }

          // find destination parent and insertion point
          var firstSelectedLayerParent = tempSelLayers[0].parent;
          var firstSelectedLayerIndexInParent = firstSelectedLayerParent.layers.indexOf(tempSelLayers[0]);

          // remove all selected items from their parents and
          // move them into a new parent
          var newGroup = new _model.LayerGroup({
            id: this.studioState_.getUniqueLayerId('group'),
            layers: tempSelLayers
          });
          tempSelLayers.forEach(function (layer) {
            return layer.parent.layers.splice(layer.parent.layers.indexOf(layer), 1);
          });
          newGroup.parent = firstSelectedLayerParent;
          firstSelectedLayerParent.layers.splice(firstSelectedLayerIndexInParent, 0, newGroup);

          this.studioState_.artworkChanged();
          this.studioState_.animChanged();
          this.studioState_.selection = [newGroup];
        } else {
          // ungroup selected layer groups
          var newSelectedLayers = [];
          tempSelLayers.filter(function (layer) {
            return layer instanceof _model.LayerGroup && !(layer instanceof _model.Artwork);
          }).forEach(function (layerGroup) {
            var _parent$layers;

            // move children into parent
            var parent = layerGroup.parent;
            var indexInParent = Math.max(0, parent.layers.indexOf(layerGroup));
            (_parent$layers = parent.layers).splice.apply(_parent$layers, [indexInParent, 0].concat(_toConsumableArray(layerGroup.layers)));
            newSelectedLayers.splice.apply(newSelectedLayers, [0, 0].concat(_toConsumableArray(layerGroup.layers)));
            layerGroup.layers.forEach(function (layer) {
              return layer.parent = parent;
            });
            layerGroup.layers = [];

            // delete the parent
            _this7.studioState_.deleteLayers(layerGroup);

            _this7.studioState_.artworkChanged();
            _this7.studioState_.animChanged();
          });
          this.studioState_.selection = newSelectedLayers;
        }
      }
    }
  }, {
    key: 'groupSelectedLayers_',
    value: function groupSelectedLayers_() {
      this.groupOrUngroupSelectedLayers_(true);
    }
  }, {
    key: 'ungroupSelectedLayers_',
    value: function ungroupSelectedLayers_() {
      this.groupOrUngroupSelectedLayers_(false);
    }
  }, {
    key: 'previewCanvasCloseButtonTheme',
    get: function get() {
      return _ColorUtil.ColorUtil.isAndroidColorDark(this.studioState_.artwork.canvasColor) ? 'dark' : 'default';
    }
  }, {
    key: 'previewCanvasColor',
    get: function get() {
      return _ColorUtil.ColorUtil.androidToCssColor(this.studioState_.artwork.canvasColor);
    }
  }]);

  return StudioCtrl;
}();

angular.module('AVDStudio').controller('StudioCtrl', StudioCtrl);

},{"AvdSerializer":14,"ColorUtil":15,"MathUtil":18,"SvgLoader":21,"VectorDrawableLoader":24,"model":35}],12:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _zipjsBrowserify = require('zipjs-browserify');

var _zipjsBrowserify2 = _interopRequireDefault(_zipjsBrowserify);

var _model = require('model');

var _AnimationRenderer = require('AnimationRenderer');

var _AvdSerializer = require('AvdSerializer');

var _ModelUtil = require('ModelUtil');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CHANGES_TAG = '$$studioState::CHANGES';

var MAX_UNDO_SLOTS = 10;
var UNDO_DEBOUNCE_MS = 1000;

var BLANK_ARTWORK = {
  id: new _model.Artwork().typeIdPrefix,
  width: 24,
  height: 24,
  layers: []
};

var BLANK_ANIMATION = {
  id: new _model.Animation().typeIdPrefix,
  duration: 300
};

var StudioStateService = function () {
  function StudioStateService($rootScope, $timeout) {
    _classCallCheck(this, StudioStateService);

    this.rootScope_ = $rootScope;
    this.timeout_ = $timeout;
    this.rebuildRenderer_();
  }

  _createClass(StudioStateService, [{
    key: 'load',
    value: function load(obj) {
      this.artwork_ = obj.artwork;
      this.animations_ = obj.animations || [new _model.Animation(BLANK_ANIMATION)];

      this.undoStates_ = [];
      this.currentUndoState_ = -1;
      this.debouncedSaveUndoPromise_ = null;

      this.activeTime_ = 0;
      this.playing_ = false;
      this.selection_ = null;

      this.activeAnimation_ = this.animations_.length ? this.animations_[0] : null;

      this.rebuildRenderer_();

      this.broadcastChanges_({
        artwork: true,
        animations: true,
        selection: true,
        activeTime: true,
        playing: true,
        isReset: true
      });

      this.dirty_ = false;
      this.saveUndoState_();
    }
  }, {
    key: 'animChanged',
    value: function animChanged() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.dirty_ = true;
      this.rebuildRenderer_();
      this.broadcastChanges_({ animations: true });
      if (!options.noUndo) {
        this.saveUndoState_({ debounce: true });
      }
    }
  }, {
    key: 'artworkChanged',
    value: function artworkChanged() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.dirty_ = true;
      this.rebuildRenderer_();
      this.broadcastChanges_({ artwork: true });
      if (!options.noUndo) {
        this.saveUndoState_({ debounce: true });
      }
    }
  }, {
    key: 'saveUndoState_',
    value: function saveUndoState_() {
      var _this = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      // if there's a pending debounce, defer it
      if (this.debouncedSaveUndoPromise_) {
        this.timeout_.cancel(this.debouncedSaveUndoPromise_);
        this.undoStates_.shift();
      }

      // step 1: stage a new slot for the undo state
      if (this.currentUndoState_ > 0) {
        // currently in an undo state, blow away all undo states after this one
        this.undoStates_.splice(0, this.currentUndoState_);
      }

      this.undoStates_.unshift(null);
      this.currentUndoState_ = 0;

      // cap the max number of undo states
      this.undoStates_.splice(MAX_UNDO_SLOTS, this.undoStates_.length - MAX_UNDO_SLOTS);

      // step 2: either commit the current state right away, or debounce
      // (commit the current state after N millisec of inactivity)
      if (options.debounce) {
        this.debouncedSaveUndoPromise_ = this.timeout_(function () {
          return _this.commitUndoStateToTopSlot_();
        }, UNDO_DEBOUNCE_MS);
      } else {
        this.commitUndoStateToTopSlot_();
      }
    }
  }, {
    key: 'commitUndoStateToTopSlot_',
    value: function commitUndoStateToTopSlot_() {
      this.undoStates_[0] = {
        artwork: new _model.Artwork(this.artwork_),
        animations: (this.animations_ || []).map(function (anim) {
          return new _model.Animation(anim);
        }),
        activeAnimationIndex: (this.animations_ || []).indexOf(this.activeAnimation_)
      };
      this.debouncedSaveUndoPromise_ = null;
    }
  }, {
    key: 'realizeUndoState_',
    value: function realizeUndoState_() {
      var state = this.undoStates_[this.currentUndoState_];
      this.artwork_ = new _model.Artwork(state.artwork);
      this.animations_ = state.animations.map(function (anim) {
        return new _model.Animation(anim);
      });
      this.activeAnimation_ = this.animations_.length > 0 && state.activeAnimationIndex >= 0 ? this.animations_[state.activeAnimationIndex] : null;
      this.selection = [];
      this.artworkChanged({ noUndo: true });
      this.animChanged({ noUndo: true });
    }
  }, {
    key: 'tryUndo',
    value: function tryUndo() {
      // if there's a debounced commit of undo state, commit it now
      if (this.debouncedSaveUndoPromise_) {
        this.timeout_.cancel(this.debouncedSaveUndoPromise_);
        this.commitUndoStateToTopSlot_();
      }

      if (this.currentUndoState_ < this.undoStates_.length - 1) {
        ++this.currentUndoState_;
        this.realizeUndoState_();
      }
    }
  }, {
    key: 'tryRedo',
    value: function tryRedo() {
      if (this.currentUndoState_ > 0) {
        --this.currentUndoState_;
        this.realizeUndoState_();
      }
    }
  }, {
    key: 'rebuildRenderer_',
    value: function rebuildRenderer_() {
      this.animationRenderer_ = null;
      if (this.activeAnimation) {
        this.animationRenderer_ = new _AnimationRenderer.AnimationRenderer(this.artwork, this.activeAnimation);
        this.animationRenderer_.setAnimationTime(this.activeTime_);
      }
    }
  }, {
    key: 'getSelectionByType_',
    value: function getSelectionByType_(type) {
      return this.selection_ && this.selection_.length && this.selection_[0] instanceof type ? this.selection_ : [];
    }
  }, {
    key: 'areItemsMultiselectCompatible_',
    value: function areItemsMultiselectCompatible_(item1, item2) {
      return !!(!item1 || !item2 || item1.constructor === item2.constructor || item1 instanceof _model.BaseLayer && item2 instanceof _model.BaseLayer);
    }
  }, {
    key: 'selectItem',
    value: function selectItem(item) {
      this.toggleSelected(item, true);
    }
  }, {
    key: 'deselectItem',
    value: function deselectItem(item) {
      this.toggleSelected(item, false);
    }
  }, {
    key: 'toggleSelected',
    value: function toggleSelected(item, select) {
      if (!item) {
        return;
      }

      if (select === undefined) {
        select = !item.selected_;
      }

      if (!!item.selected_ == select) {
        return;
      }

      this.selection_ = this.selection_ || [];

      if (select) {
        // ensure only one type of thing is selected
        if (this.areItemsMultiselectCompatible_(this.firstSelectedItem, item)) {
          // add this item to the existing selection
          this.selection_.push(item);
          item.selected_ = true;
        } else {
          // reset the selection
          this.selection = [item];
        }
      } else {
        // simply toggle this item being selected
        var index = this.selection_.indexOf(item);
        if (index >= 0) {
          this.selection_.splice(index, 1);
          delete item.selected_;
        }
      }

      this.broadcastChanges_({ selection: true });
    }
  }, {
    key: 'deleteLayers',
    value: function deleteLayers(layersToDelete) {
      var _this2 = this;

      if (!Array.isArray(layersToDelete)) {
        layersToDelete = [layersToDelete];
      }

      var deleteAnimationsForLayer_ = function deleteAnimationsForLayer_(layer) {
        layer.walk(function (layer) {
          _this2.animations.forEach(function (animation) {
            animation.blocks = animation.blocks.filter(function (block) {
              return block.layerId != layer.id;
            });
          });
        });
      };

      var visit_ = function visit_(layerGroup) {
        for (var i = layerGroup.layers.length - 1; i >= 0; --i) {
          var layer = layerGroup.layers[i];
          if (layersToDelete.indexOf(layer) >= 0) {
            deleteAnimationsForLayer_(layer);
            layerGroup.layers.splice(i, 1);
          } else if (layer.layers) {
            visit_(layer);
          }
        }
      };

      visit_(this.artwork);
      this.artworkChanged();
      this.animChanged();
    }
  }, {
    key: 'updateLayerId',
    value: function updateLayerId(layer, newId) {
      var oldId = layer.id;
      if (oldId == newId) {
        return;
      }

      this.animations.forEach(function (animation) {
        return animation.blocks.forEach(function (block) {
          if (block.layerId == oldId) {
            block.layerId = newId;
          }
        });
      });
      layer.id = newId;

      this.artworkChanged();
      this.animChanged();
    }
  }, {
    key: 'getUniqueAnimationId',
    value: function getUniqueAnimationId(prefix) {
      var _this3 = this;

      var targetAnimation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      return _ModelUtil.ModelUtil.getUniqueId({
        prefix: prefix || 'anim',
        objectById: function objectById(id) {
          return _this3.animations.reduce(function (a, b) {
            return a || b.id == id;
          }, false);
        },
        skipObject: targetAnimation
      });
    }
  }, {
    key: 'getUniqueLayerId',
    value: function getUniqueLayerId(prefix) {
      var _this4 = this;

      var targetLayer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      return _ModelUtil.ModelUtil.getUniqueId({
        prefix: prefix || (targetLayer ? targetLayer.typeIdPrefix : 'layer'),
        objectById: function objectById(id) {
          return _this4.artwork.findLayerById(id);
        },
        skipObject: targetLayer
      });
    }
  }, {
    key: 'broadcastChanges_',
    value: function broadcastChanges_(changes) {
      // todo: debounce
      this.rootScope_.$emit(CHANGES_TAG, changes);
    }
  }, {
    key: 'onChange',
    value: function onChange(fn, $scope) {
      var watcher = this.rootScope_.$on(CHANGES_TAG, function () {
        // window.setTimeout(() => $scope.$apply(() => fn.apply(this, arguments)), 0);
        fn.apply(this, arguments);
      });
      $scope.$on('$destroy', function () {
        return watcher();
      });
      return watcher;
    }
  }, {
    key: 'downloadFile_',
    value: function downloadFile_(content, filename) {
      var anchor = $('<a>').hide().appendTo(document.body);
      var blob = content;
      if (!(content instanceof Blob)) {
        blob = new Blob([content], { type: 'octet/stream' });
      }
      var url = window.URL.createObjectURL(blob);
      anchor.attr({
        href: url,
        download: filename
      });
      anchor.get(0).click();
      window.URL.revokeObjectURL(url);
    }
  }, {
    key: 'addLayers',
    value: function addLayers(layers) {
      var _this5 = this;

      (layers || []).forEach(function (layer) {
        layer.parent = _this5.artwork;
        layer.walk(function (layer) {
          layer.id = _this5.getUniqueLayerId(layer.id, layer);
        });
        _this5.artwork.layers.push(layer);
      });
      this.artworkChanged();
    }
  }, {
    key: 'swapLayer',
    value: function swapLayer(layer, withLayer) {
      var parent = layer.parent;
      var indexInParent = parent.layers.indexOf(layer);
      withLayer.parent = layer.parent;
      parent.layers.splice(indexInParent, 1, withLayer);
      var indexInSelection = this.selection.indexOf(layer);
      if (indexInSelection >= 0) {
        this.selection.splice(indexInSelection, 1, withLayer);
      }
      // TODO: preserve still-valid animations
      this.animations.forEach(function (animation) {
        animation.blocks = animation.blocks.filter(function (block) {
          return block.layerId != layer.id;
        });
      });
      this.artworkChanged();
    }
  }, {
    key: 'new',
    value: function _new() {
      this.load({
        artwork: new _model.Artwork(BLANK_ARTWORK),
        animations: [new _model.Animation(BLANK_ANIMATION)]
      });
    }
  }, {
    key: 'saveToFile',
    value: function saveToFile() {
      var jsonStr = JSON.stringify({
        artwork: this.artwork.toJSON(),
        animations: this.animations.map(function (anim) {
          return anim.toJSON();
        })
      }, null, 2);
      this.downloadFile_(jsonStr, this.artwork.id + '.iconanim');
      this.dirty_ = false;
    }
  }, {
    key: 'exportVectorDrawable',
    value: function exportVectorDrawable() {
      var xmlStr = _AvdSerializer.AvdSerializer.artworkToVectorDrawableXmlString(this.artwork);
      this.downloadFile_(xmlStr, this.artwork.id + '.xml');
    }
  }, {
    key: 'exportAVDs',
    value: function exportAVDs() {
      var _this6 = this;

      if (this.animations.length) {
        var exportedAnimations = this.animations.map(function (animation) {
          return {
            animation: animation,
            filename: 'avd_' + _this6.artwork.id + '_' + animation.id + '.xml',
            xmlStr: _AvdSerializer.AvdSerializer.artworkAnimationToAvdXmlString(_this6.artwork, animation)
          };
        });

        if (exportedAnimations.length == 1) {
          // download a single XML
          this.downloadFile_(exportedAnimations[0].xmlStr, exportedAnimations[0].filename);
        } else {
          // download a ZIP
          _zipjsBrowserify2.default.createWriter(new _zipjsBrowserify2.default.BlobWriter(), function (writer) {
            var i = -1;
            var next_ = function next_() {
              ++i;
              if (i >= exportedAnimations.length) {
                // close
                writer.close(function (blob) {
                  return _this6.downloadFile_(blob, 'avd_' + _this6.artwork.id + '.zip');
                });
              } else {
                // add next file
                var exportedAnimation = exportedAnimations[i];
                writer.add(exportedAnimation.filename, new _zipjsBrowserify2.default.TextReader(exportedAnimation.xmlStr), next_);
              }
            };
            next_();
          }, function (error) {
            return console.error(error);
          });
        }
      }
    }
  }, {
    key: 'playbackSpeed',
    get: function get() {
      return this.playbackSpeed_ || 1;
    },
    set: function set(speed) {
      this.playbackSpeed_ = speed;
    }
  }, {
    key: 'playing',
    get: function get() {
      return this.playing_;
    },
    set: function set(playing) {
      this.playing_ = playing;
      this.broadcastChanges_({ playing: true });
    }
  }, {
    key: 'artwork',
    get: function get() {
      // if (this.currentUndoState_ >= 0) {
      //   return this.undoStates_[this.currentUndoState_].artwork;
      // }

      return this.artwork_;
    },
    set: function set(artwork) {
      this.artwork_ = artwork;
      this.artworkChanged({ noUndo: true });
    }
  }, {
    key: 'animations',
    get: function get() {
      // if (this.currentUndoState_ >= 0) {
      //   return this.undoStates_[this.currentUndoState_].animations;
      // }

      return this.animations_ = this.animations_ || [];
    },
    set: function set(animations) {
      this.animations_ = animations;
      if (animations.indexOf(this.activeAnimation) < 0) {
        this.activeAnimation = animations[0];
      }
      this.animChanged();
    }
  }, {
    key: 'dirty',
    get: function get() {
      return !!this.dirty_;
    },
    set: function set(dirty) {
      this.dirty_ = dirty;
    }
  }, {
    key: 'animationRenderer',
    get: function get() {
      return this.animationRenderer_;
    }
  }, {
    key: 'activeAnimation',
    get: function get() {
      // if (this.currentUndoState_ >= 0) {
      //   let currentUndoState = this.undoStates_[this.currentUndoState_];
      //   return currentUndoState.animations[currentUndoState.activeAnimationIndex];
      // }

      return this.activeAnimation_ || this.animations.length && this.animations[0];
    },
    set: function set(activeAnimation) {
      if (this.activeAnimation_ === activeAnimation) {
        return;
      }

      this.activeAnimation_ = activeAnimation;
      this.rebuildRenderer_();
      this.broadcastChanges_({ activeAnimation: true });
    }
  }, {
    key: 'activeTime',
    get: function get() {
      return this.activeTime_ || 0;
    },
    set: function set(activeTime) {
      this.activeTime_ = activeTime;
      if (this.animationRenderer_) {
        this.animationRenderer_.setAnimationTime(activeTime);
      }
      this.broadcastChanges_({ activeTime: true });
    }
  }, {
    key: 'selectedLayers',
    get: function get() {
      return this.getSelectionByType_(_model.BaseLayer);
    }
  }, {
    key: 'selectedAnimationBlocks',
    get: function get() {
      return this.getSelectionByType_(_model.AnimationBlock);
    }
  }, {
    key: 'selectedAnimations',
    get: function get() {
      return this.getSelectionByType_(_model.Animation);
    }
  }, {
    key: 'firstSelectedItem',
    get: function get() {
      return (this.selection_ || []).length > 0 ? this.selection_[0] : null;
    }
  }, {
    key: 'isMultipleSelection',
    get: function get() {
      return this.selection_ ? !!(this.selection_.length > 1) : false;
    }
  }, {
    key: 'selection',
    get: function get() {
      return this.selection_ || [];
    },
    set: function set(selection) {
      this.selection_ = this.selection_ || [];
      this.selection_.forEach(function (item) {
        return delete item.selected_;
      });
      this.selection_ = selection ? selection.slice() : [];
      this.selection_.forEach(function (item) {
        return item.selected_ = true;
      });
      this.broadcastChanges_({ selection: true });
    }
  }]);

  return StudioStateService;
}();

angular.module('AVDStudio').service('StudioStateService', StudioStateService);

},{"AnimationRenderer":13,"AvdSerializer":14,"ModelUtil":19,"model":35,"zipjs-browserify":53}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnimationRenderer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _model = require('model');

var _ModelUtil = require('ModelUtil');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DEFAULT_LAYER_PROPERTY_STATE = {
  activeBlock: null,
  interpolatedValue: false
};

var AnimationRenderer = exports.AnimationRenderer = function () {
  function AnimationRenderer(artwork, animation) {
    var _this = this;

    _classCallCheck(this, AnimationRenderer);

    this.originalArtwork = artwork;
    this.animation = animation;
    this.renderedArtwork = new _model.Artwork(artwork, { linkSelectedState: true });
    this.animDataByLayer = _ModelUtil.ModelUtil.getOrderedAnimationBlocksByLayerIdAndProperty(animation);

    Object.keys(this.animDataByLayer).forEach(function (layerId) {
      _this.animDataByLayer[layerId] = {
        originalLayer: _this.originalArtwork.findLayerById(layerId),
        renderedLayer: _this.renderedArtwork.findLayerById(layerId),
        orderedBlocks: _this.animDataByLayer[layerId]
      };
    });

    this.setAnimationTime(0);
  }

  _createClass(AnimationRenderer, [{
    key: 'setAnimationTime',
    value: function setAnimationTime(time) {
      for (var layerId in this.animDataByLayer) {
        var animData = this.animDataByLayer[layerId];
        animData.renderedLayer._ar = animData.renderedLayer._ar || {};

        for (var propertyName in animData.orderedBlocks) {
          var blocks = animData.orderedBlocks[propertyName];
          var _ar = Object.assign({}, DEFAULT_LAYER_PROPERTY_STATE);

          // compute rendered value at given time
          var property = animData.originalLayer.animatableProperties[propertyName];
          var value = animData.originalLayer[propertyName];
          for (var i = 0; i < blocks.length; ++i) {
            var block = blocks[i];
            if (time < block.startTime) {
              break;
            } else if (time < block.endTime) {
              var fromValue = 'fromValue' in block ? block.fromValue : value;
              var f = (time - block.startTime) / (block.endTime - block.startTime);
              f = block.interpolator.interpolate(f);
              value = property.interpolateValue(fromValue, block.toValue, f);
              _ar.activeBlock = block;
              _ar.interpolatedValue = true;
              break;
            }

            value = block.toValue;
            _ar.activeBlock = block;
          }

          animData.renderedLayer[propertyName] = value;

          // cached data
          animData.renderedLayer._ar[propertyName] = animData.renderedLayer._ar[propertyName] || {};
          animData.renderedLayer._ar[propertyName] = _ar;
        }
      }

      this.animTime = time;
    }
  }, {
    key: 'getLayerPropertyValue',
    value: function getLayerPropertyValue(layerId, propertyName) {
      return this.renderedArtwork.findLayerById(layerId)[propertyName];
    }
  }, {
    key: 'getLayerPropertyState',
    value: function getLayerPropertyState(layerId, propertyName) {
      var layerAnimData = this.animDataByLayer[layerId];
      return layerAnimData ? layerAnimData.renderedLayer._ar[propertyName] || {} : Object.assign({}, DEFAULT_LAYER_PROPERTY_STATE);
    }
  }]);

  return AnimationRenderer;
}();

},{"ModelUtil":19,"model":35}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AvdSerializer = undefined;

var _xmlserializer = require('xmlserializer');

var _xmlserializer2 = _interopRequireDefault(_xmlserializer);

var _model = require('./model');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var XMLNS_NS = 'http://www.w3.org/2000/xmlns/';
var ANDROID_NS = 'http://schemas.android.com/apk/res/android';
var AAPT_NS = 'http://schemas.android.com/aapt';

var conditionalAttr_ = function conditionalAttr_(node, attr, value, skipValue) {
  if (value !== undefined && value !== null && (skipValue === undefined || value !== skipValue)) {
    node.setAttributeNS(ANDROID_NS, attr, value);
  }
};

var serializeXmlNode_ = function serializeXmlNode_(xmlNode) {
  var xmlStr = _xmlserializer2.default.serializeToString(xmlNode, { indent: 4, multiAttributeIndent: 4 });
  return xmlStr; //new XMLSerializer().serializeToString(xmlNode);
  // return vkbeautify.xml(xmlStr, 4);
};

var AvdSerializer = exports.AvdSerializer = {

  /**
   * Serializes an Artwork to a vector drawable XML file.
   */
  artworkToVectorDrawableXmlString: function artworkToVectorDrawableXmlString(artwork) {
    var xmlDoc = document.implementation.createDocument(null, 'vector');
    var rootNode = xmlDoc.documentElement;
    AvdSerializer.artworkToXmlNode_(artwork, rootNode, xmlDoc);
    return serializeXmlNode_(rootNode);
  },


  /**
   * Serializes a given Artwork and Animation to an animatedvector drawable XML file.
   */
  artworkAnimationToAvdXmlString: function artworkAnimationToAvdXmlString(artwork, animation) {
    var xmlDoc = document.implementation.createDocument(null, 'animated-vector');
    var rootNode = xmlDoc.documentElement;
    rootNode.setAttributeNS(XMLNS_NS, 'xmlns:android', ANDROID_NS);
    rootNode.setAttributeNS(XMLNS_NS, 'xmlns:aapt', AAPT_NS);

    // create drawable node containing the artwork
    var artworkContainerNode = xmlDoc.createElementNS(AAPT_NS, 'aapt:attr');
    artworkContainerNode.setAttribute('name', 'android:drawable');
    rootNode.appendChild(artworkContainerNode);

    var artworkNode = xmlDoc.createElement('vector');
    AvdSerializer.artworkToXmlNode_(artwork, artworkNode, xmlDoc);
    artworkContainerNode.appendChild(artworkNode);

    // create animation nodes (one per layer)
    var animBlocksByLayer = {};
    animation.blocks.forEach(function (block) {
      animBlocksByLayer[block.layerId] = animBlocksByLayer[block.layerId] || [];
      animBlocksByLayer[block.layerId].push(block);
    });

    var _loop = function _loop(layerId) {
      var targetNode = xmlDoc.createElement('target');
      targetNode.setAttributeNS(ANDROID_NS, 'android:name', layerId);
      rootNode.appendChild(targetNode);

      var animationNode = xmlDoc.createElementNS(AAPT_NS, 'aapt:attr');
      animationNode.setAttribute('name', 'android:animation');
      targetNode.appendChild(animationNode);

      var blocksForLayer = animBlocksByLayer[layerId];
      var blockContainerNode = animationNode;
      var multiBlock = false;
      if (blocksForLayer.length > 1) {
        multiBlock = true;

        // <set> for multiple property animations on a single layer
        blockContainerNode = xmlDoc.createElement('set');
        blockContainerNode.setAttributeNS(XMLNS_NS, 'xmlns:android', ANDROID_NS);
        animationNode.appendChild(blockContainerNode);
      }

      var layer = artwork.findLayerById(layerId);
      var animatableProperties = layer.animatableProperties;

      blocksForLayer.forEach(function (block) {
        var blockNode = xmlDoc.createElement('objectAnimator');
        if (!multiBlock) {
          blockNode.setAttributeNS(XMLNS_NS, 'xmlns:android', ANDROID_NS);
        }
        blockNode.setAttributeNS(ANDROID_NS, 'android:propertyName', block.propertyName);
        conditionalAttr_(blockNode, 'android:startOffset', block.startTime, 0);
        conditionalAttr_(blockNode, 'android:duration', block.endTime - block.startTime);
        conditionalAttr_(blockNode, 'android:valueFrom', block.fromValue);
        conditionalAttr_(blockNode, 'android:valueTo', block.toValue);
        conditionalAttr_(blockNode, 'android:valueType', animatableProperties[block.propertyName].animatorValueType);
        conditionalAttr_(blockNode, 'android:interpolator', block.interpolator.androidRef);
        blockContainerNode.appendChild(blockNode);
      });
    };

    for (var layerId in animBlocksByLayer) {
      _loop(layerId);
    }

    return serializeXmlNode_(rootNode);
  },


  /**
   * Helper method that serializes an Artwork to a destinationNode in an xmlDoc.
   * The destinationNode should be a <vector> node.
   */
  artworkToXmlNode_: function artworkToXmlNode_(artwork, destinationNode, xmlDoc) {
    destinationNode.setAttributeNS(XMLNS_NS, 'xmlns:android', ANDROID_NS);
    destinationNode.setAttributeNS(ANDROID_NS, 'android:width', artwork.width + 'dp');
    destinationNode.setAttributeNS(ANDROID_NS, 'android:height', artwork.height + 'dp');
    destinationNode.setAttributeNS(ANDROID_NS, 'android:viewportWidth', '' + artwork.width);
    destinationNode.setAttributeNS(ANDROID_NS, 'android:viewportHeight', '' + artwork.height);
    conditionalAttr_(destinationNode, 'android:alpha', artwork.alpha, 1);

    artwork.walk(function (layer, parentNode) {
      if (layer instanceof _model.Artwork) {
        return parentNode;
      } else if (layer instanceof _model.PathLayer) {
        var node = xmlDoc.createElement('path');
        conditionalAttr_(node, 'android:name', layer.id);
        conditionalAttr_(node, 'android:pathData', layer.pathData.pathString);
        conditionalAttr_(node, 'android:fillColor', layer.fillColor, '');
        conditionalAttr_(node, 'android:fillAlpha', layer.fillAlpha, 1);
        conditionalAttr_(node, 'android:strokeColor', layer.strokeColor, '');
        conditionalAttr_(node, 'android:strokeAlpha', layer.strokeAlpha, 1);
        conditionalAttr_(node, 'android:strokeWidth', layer.strokeWidth, 0);
        conditionalAttr_(node, 'android:trimPathStart', layer.trimPathStart, 0);
        conditionalAttr_(node, 'android:trimPathEnd', layer.trimPathEnd, 1);
        conditionalAttr_(node, 'android:trimPathOffset', layer.trimPathOffset, 0);
        conditionalAttr_(node, 'android:strokeLineCap', layer.strokeLinecap, _model.DefaultValues.LINECAP);
        conditionalAttr_(node, 'android:strokeLineJoin', layer.strokeLinejoin, _model.DefaultValues.LINEJOIN);
        conditionalAttr_(node, 'android:strokeMiterLimit', layer.strokeMiterLimit, _model.DefaultValues.MITER_LIMIT);
        parentNode.appendChild(node);
        return parentNode;
      } else if (layer instanceof _model.MaskLayer) {
        var _node = xmlDoc.createElement('clip-path');
        conditionalAttr_(_node, 'android:name', layer.id);
        conditionalAttr_(_node, 'android:pathData', layer.pathData.pathString);
        parentNode.appendChild(_node);
        return parentNode;
      } else if (layer instanceof _model.LayerGroup) {
        var _node2 = xmlDoc.createElement('group');
        conditionalAttr_(_node2, 'android:name', layer.id);
        conditionalAttr_(_node2, 'android:pivotX', layer.pivotX, 0);
        conditionalAttr_(_node2, 'android:pivotY', layer.pivotY, 0);
        conditionalAttr_(_node2, 'android:translateX', layer.translateX, 0);
        conditionalAttr_(_node2, 'android:translateY', layer.translateY, 0);
        conditionalAttr_(_node2, 'android:scaleX', layer.scaleX, 1);
        conditionalAttr_(_node2, 'android:scaleY', layer.scaleY, 1);
        conditionalAttr_(_node2, 'android:rotation', layer.rotation, 0);
        parentNode.appendChild(_node2);
        return _node2;
      }
    }, destinationNode);
  }
};

},{"./model":35,"xmlserializer":46}],15:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ColorUtil = undefined;

var _tinycolor = require('tinycolor2');

var _tinycolor2 = _interopRequireDefault(_tinycolor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BRIGHTNESS_THRESHOLD = 130; // for isColorDark


/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var ColorUtil = exports.ColorUtil = {
  parseAndroidColor: function parseAndroidColor(val) {
    val = (val || '').replace(/^\s*#?|\s*$/g, '');
    var dict = { a: 255 };

    if (val.length == 3) {
      dict.r = parseInt(val.substring(0, 1), 16) * 17;
      dict.g = parseInt(val.substring(1, 2), 16) * 17;
      dict.b = parseInt(val.substring(2, 3), 16) * 17;
    } else if (val.length == 4) {
      dict.a = parseInt(val.substring(0, 1), 16) * 17;
      dict.r = parseInt(val.substring(1, 2), 16) * 17;
      dict.g = parseInt(val.substring(2, 3), 16) * 17;
      dict.b = parseInt(val.substring(3, 4), 16) * 17;
    } else if (val.length == 6) {
      dict.r = parseInt(val.substring(0, 2), 16);
      dict.g = parseInt(val.substring(2, 4), 16);
      dict.b = parseInt(val.substring(4, 6), 16);
    } else if (val.length == 8) {
      dict.a = parseInt(val.substring(0, 2), 16);
      dict.r = parseInt(val.substring(2, 4), 16);
      dict.g = parseInt(val.substring(4, 6), 16);
      dict.b = parseInt(val.substring(6, 8), 16);
    } else {
      return null;
    }

    return isNaN(dict.r) || isNaN(dict.g) || isNaN(dict.b) || isNaN(dict.a) ? null : dict;
  },
  toAndroidString: function toAndroidString(dict) {
    var str = '#';
    if (dict.a != 255) {
      str += (dict.a < 16 ? '0' : '') + dict.a.toString(16);
    }

    str += (dict.r < 16 ? '0' : '') + dict.r.toString(16) + (dict.g < 16 ? '0' : '') + dict.g.toString(16) + (dict.b < 16 ? '0' : '') + dict.b.toString(16);
    return str;
  },
  svgToAndroidColor: function svgToAndroidColor(color) {
    if (color == 'none') {
      return null;
    }
    color = (0, _tinycolor2.default)(color);
    var colorHex = color.toHex();
    var alphaHex = color.toHex8().substr(6);
    return '#' + (alphaHex != 'ff' ? alphaHex : '') + colorHex;
  },
  androidToCssColor: function androidToCssColor(androidColor, multAlpha) {
    multAlpha = multAlpha === undefined ? 1 : multAlpha;
    if (!androidColor) {
      return 'transparent';
    }

    var d = ColorUtil.parseAndroidColor(androidColor);
    return 'rgba(' + d.r + ',' + d.g + ',' + d.b + ',' + (d.a * multAlpha / 255).toFixed(2) + ')';
  },
  isAndroidColorDark: function isAndroidColorDark(androidColor) {
    if (!androidColor) {
      return false;
    }

    var d = ColorUtil.parseAndroidColor(androidColor);
    return (30 * d.r + 59 * d.g + 11 * d.b) / 100 <= BRIGHTNESS_THRESHOLD;
  }
};

},{"tinycolor2":52}],16:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var DRAG_SLOP = 4; // pixels


var DragHelper = exports.DragHelper = function () {
  function DragHelper(opts) {
    var _this = this;

    _classCallCheck(this, DragHelper);

    opts = opts || {};

    this.direction_ = opts.direction || 'both';
    this.downX_ = opts.downEvent.clientX;
    this.downY_ = opts.downEvent.clientY;
    this.skipSlopCheck_ = !!opts.skipSlopCheck;

    this.onBeginDrag_ = opts.onBeginDrag || function () {};
    this.onDrag_ = opts.onDrag || function () {};
    this.onDrop_ = opts.onDrop || function () {};

    this.dragging_ = false;
    this.draggingScrim_ = null;

    this.draggingCursor = opts.draggingCursor || 'grabbing';

    var mouseMoveHandler_ = function mouseMoveHandler_(event) {
      if (!_this.dragging_ && _this.shouldBeginDragging_(event)) {
        _this.dragging_ = true;
        _this.draggingScrim_ = _this.buildDraggingScrim_().appendTo(document.body);
        _this.draggingCursor = _this.draggingCursor_;
        _this.onBeginDrag_(event);
      }

      if (_this.dragging_) {
        _this.onDrag_(event, {
          x: event.clientX - _this.downX_,
          y: event.clientY - _this.downY_
        });
      }
    };

    var mouseUpHandler_ = function mouseUpHandler_(event) {
      $(window).off('mousemove', mouseMoveHandler_).off('mouseup', mouseUpHandler_);
      if (_this.dragging_) {
        _this.onDrag_(event, {
          x: event.clientX - _this.downX_,
          y: event.clientY - _this.downY_
        });

        _this.onDrop_();

        _this.draggingScrim_.remove();
        _this.draggingScrim_ = null;
        _this.dragging_ = false;

        event.stopPropagation();
        event.preventDefault();
        return false;
      }
    };

    $(window).on('mousemove', mouseMoveHandler_).on('mouseup', mouseUpHandler_);
  }

  _createClass(DragHelper, [{
    key: 'shouldBeginDragging_',
    value: function shouldBeginDragging_(mouseMoveEvent) {
      if (this.skipSlopCheck_) {
        return true;
      }

      var begin = false;
      if (this.direction_ == 'both' || this.direction_ == 'horizontal') {
        begin = begin || Math.abs(mouseMoveEvent.clientX - this.downX_) > DRAG_SLOP;
      }
      if (this.direction_ == 'both' || this.direction_ == 'vertical') {
        begin = begin || Math.abs(mouseMoveEvent.clientY - this.downY_) > DRAG_SLOP;
      }
      return begin;
    }
  }, {
    key: 'buildDraggingScrim_',
    value: function buildDraggingScrim_() {
      return $('<div>').css({
        position: 'fixed',
        left: 0,
        top: 0,
        right: 0,
        bottom: 0,
        zIndex: 9999
      });
    }
  }, {
    key: 'draggingCursor',
    set: function set(cursor) {
      if (cursor == 'grabbing') {
        cursor = '-webkit-' + cursor;
      }

      this.draggingCursor_ = cursor;
      if (this.draggingScrim_) {
        this.draggingScrim_.css({ cursor: cursor });
      }
    }
  }]);

  return DragHelper;
}();

},{}],17:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Based on http://www.backalleycoder.com/2013/03/18/cross-browser-event-based-element-resize-detection/

var ElementResizeWatcher = exports.ElementResizeWatcher = function () {
  function ElementResizeWatcher(element, listener) {
    var _this = this;

    _classCallCheck(this, ElementResizeWatcher);

    this.element_ = $(element);

    // create resize listener
    var rafHandle = void 0;

    this.onResize_ = function (event) {
      var el = event.target || event.srcElement;
      if (rafHandle) {
        el.cancelAnimationFrame(rafHandle);
      }

      rafHandle = el.requestAnimationFrame(function () {
        return listener();
      });
    };

    // add listener
    if (getComputedStyle(this.element_.get(0)).position == 'static') {
      this.element_.css({ position: 'relative' });
    }

    this.proxyElement_ = $('<object>').css({
      display: 'block',
      position: 'absolute',
      left: 0,
      top: 0,
      width: '100%',
      height: '100%',
      overflow: 'hidden',
      pointerEvents: 'none',
      zIndex: -1
    }).attr('type', 'text/html').attr('data', 'about:blank').on('load', function () {
      _this.proxyDefaultView_ = _this.proxyElement_.get(0).contentDocument.defaultView;
      _this.proxyDefaultView_.addEventListener('resize', _this.onResize_);
    }).appendTo(this.element_);
  }

  _createClass(ElementResizeWatcher, [{
    key: 'destroy',
    value: function destroy() {
      if (this.proxyDefaultView_) {
        this.proxyDefaultView_.removeEventListener('resize', this.onResize_);
      }

      this.proxyElement_.remove();
    }
  }]);

  return ElementResizeWatcher;
}();

},{}],18:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var MathUtil = exports.MathUtil = {
  progress: function progress(val, min, max) {
    return MathUtil.constrain((val - min) / (max - min), 0, 1);
  },
  constrain: function constrain(val, min, max) {
    if (val < min) {
      return min;
    } else if (val > max) {
      return max;
    } else {
      return val;
    }
  },
  interpolate: function interpolate(start, end, f) {
    return start + (end - start) * f;
  },
  dist: function dist(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(y2 - y1, 2) + Math.pow(x2 - x1, 2));
  }
};

},{}],19:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var ModelUtil = exports.ModelUtil = {
  getOrderedAnimationBlocksByLayerIdAndProperty: function getOrderedAnimationBlocksByLayerIdAndProperty(animation) {
    var animationBlocksByLayerId = {};

    animation.blocks.forEach(function (block) {
      var blocksByProperty = animationBlocksByLayerId[block.layerId];
      if (!blocksByProperty) {
        blocksByProperty = {};
        animationBlocksByLayerId[block.layerId] = blocksByProperty;
      }

      blocksByProperty[block.propertyName] = blocksByProperty[block.propertyName] || [];
      blocksByProperty[block.propertyName].push(block);
    });

    for (var layerId in animationBlocksByLayerId) {
      var blocksByProperty = animationBlocksByLayerId[layerId];
      for (var propertyName in blocksByProperty) {
        blocksByProperty[propertyName].sort(function (a, b) {
          return a.startTime - b.startTime;
        });
      }
    }

    return animationBlocksByLayerId;
  },
  getUniqueId: function getUniqueId(opts) {
    opts = opts || {};
    opts.prefix = opts.prefix || '';
    opts.objectById = opts.objectById || function () {
      return null;
    };
    opts.targetObject = opts.targetObject || null;

    var n = 0;
    var id_ = function id_() {
      return opts.prefix + (n ? '_' + n : '');
    };
    while (true) {
      var o = opts.objectById(id_());
      if (!o || o == opts.targetObject) {
        break;
      }

      ++n;
    }

    return id_();
  }
};

},{}],20:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var IDENTITY_TRANSFORM_MATRIX = [1, 0, 0, 1, 0, 0];

var RenderUtil = exports.RenderUtil = {
  transformMatrixForLayer: function transformMatrixForLayer(layer) {
    var cosR = Math.cos(layer.rotation * Math.PI / 180);
    var sinR = Math.sin(layer.rotation * Math.PI / 180);

    // first negative pivot, then scale, rotate, translate, and pivot
    // notes:
    // translate: [1, 0, 0, 1, x, y]
    // scale: [sx, 0, 0, sy, 0, 0]
    // rotate: [cos, sin, -sin, cos, 0, 0]

    return [cosR * layer.scaleX, sinR * layer.scaleX, -sinR * layer.scaleY, cosR * layer.scaleY, layer.pivotX + layer.translateX - cosR * layer.scaleX * layer.pivotX + sinR * layer.scaleY * layer.pivotY, layer.pivotY + layer.translateY - cosR * layer.scaleY * layer.pivotY - sinR * layer.scaleX * layer.pivotX];
  },
  flattenTransforms: function flattenTransforms(transforms) {
    return (transforms || []).reduce(function (m, transform) {
      return transformMatrix_(transform, m);
    }, IDENTITY_TRANSFORM_MATRIX);
  },
  transformPoint: function transformPoint(matrices, p) {
    if (!matrices || !matrices.length) {
      return Object.assign({}, p);
    }

    return matrices.reduce(function (p, m) {
      return {
        // [a c e]   [p.x]
        // [b d f] * [p.y]
        // [0 0 1]   [ 1 ]
        x: m[0] * p.x + m[2] * p.y + m[4],
        y: m[1] * p.x + m[3] * p.y + m[5]
      };
    }, p);
  },
  computeStrokeWidthMultiplier: function computeStrokeWidthMultiplier(transformMatrix) {
    // from getMatrixScale in
    // https://android.googlesource.com/platform/frameworks/base/+/master/libs/hwui/VectorDrawable.cpp

    // Given unit vectors A = (0, 1) and B = (1, 0).
    // After matrix mapping, we got A' and B'. Let theta = the angel b/t A' and B'.
    // Therefore, the final scale we want is min(|A'| * sin(theta), |B'| * sin(theta)),
    // which is (|A'| * |B'| * sin(theta)) / max (|A'|, |B'|);
    // If  max (|A'|, |B'|) = 0, that means either x or y has a scale of 0.
    //
    // For non-skew case, which is most of the cases, matrix scale is computing exactly the
    // scale on x and y axis, and take the minimal of these two.
    // For skew case, an unit square will mapped to a parallelogram. And this function will
    // return the minimal height of the 2 bases.

    // first remove translate elements from matrix
    transformMatrix[4] = transformMatrix[5] = 0;

    var vecA = RenderUtil.transformPoint([transformMatrix], { x: 0, y: 1 });
    var vecB = RenderUtil.transformPoint([transformMatrix], { x: 1, y: 0 });
    var scaleX = Math.hypot(vecA.x, vecA.y);
    var scaleY = Math.hypot(vecB.x, vecB.y);
    var crossProduct = vecA.y * vecB.x - vecA.x * vecB.y; // vector cross product
    var maxScale = Math.max(scaleX, scaleY);
    var matrixScale = 0;
    if (maxScale > 0) {
      matrixScale = Math.abs(crossProduct) / maxScale;
    }
    return matrixScale;
  }
};

// formula generated w/ wolfram alpha
// returns the product of 2D transformation matrices s and t

function transformMatrix_(s, t) {
  return [t[0] * s[0] + t[1] * s[2], t[0] * s[1] + t[1] * s[3], s[0] * t[2] + s[2] * t[3], s[1] * t[2] + t[3] * s[3], s[0] * t[4] + s[4] + s[2] * t[5], s[1] * t[4] + s[3] * t[5] + s[5]];
}

},{}],21:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SvgLoader = undefined;

var _model = require('./model');

var _properties = require('./model/properties');

var _ColorUtil = require('./ColorUtil');

var _SvgPathData = require('./SvgPathData');

var _ModelUtil = require('./ModelUtil');

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /*
                                                                                                                                                                                                     * Copyright 2016 Google Inc.
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                     * you may not use this file except in compliance with the License.
                                                                                                                                                                                                     * You may obtain a copy of the License at
                                                                                                                                                                                                     *
                                                                                                                                                                                                     *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                     * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                     * See the License for the specific language governing permissions and
                                                                                                                                                                                                     * limitations under the License.
                                                                                                                                                                                                     */

var SvgLoader = exports.SvgLoader = {
  loadArtworkFromSvgString: function loadArtworkFromSvgString(svgString) {
    var parser = new DOMParser();
    var doc = parser.parseFromString(svgString, 'image/svg+xml');

    var usedIds = {};

    var nodeToLayerData_ = function nodeToLayerData_(node, context) {
      if (!node) {
        return null;
      }

      if (node.nodeType == Node.TEXT_NODE || node.nodeType == Node.COMMENT_NODE) {
        return null;
      }

      var makeFinalNodeId_ = function makeFinalNodeId_(typeIdPrefix) {
        var finalId = _ModelUtil.ModelUtil.getUniqueId({
          prefix: _properties.IdProperty.sanitize(node.id || typeIdPrefix),
          objectById: function objectById(id) {
            return usedIds[id];
          }
        });
        usedIds[finalId] = true;
        return finalId;
      };

      var layerData = {};

      var simpleAttr_ = function simpleAttr_(nodeAttr, contextAttr) {
        if (node.attributes[nodeAttr]) {
          context[contextAttr] = node.attributes[nodeAttr].value;
        }
      };

      // set attributes
      simpleAttr_('stroke', 'strokeColor');
      simpleAttr_('stroke-width', 'strokeWidth');
      simpleAttr_('stroke-linecap', 'strokeLinecap');
      simpleAttr_('stroke-linejoin', 'strokeLinejoin');
      simpleAttr_('stroke-miterlimit', 'strokeMiterLimit');
      simpleAttr_('stroke-opacity', 'strokeAlpha');
      simpleAttr_('fill', 'fillColor');
      simpleAttr_('fill-opacity', 'fillAlpha');

      // add transforms

      if (node.transform) {
        var _context$transforms;

        var transforms = Array.from(node.transform.baseVal);
        transforms.reverse();
        context.transforms = context.transforms ? context.transforms.slice() : [];
        (_context$transforms = context.transforms).splice.apply(_context$transforms, [0, 0].concat(_toConsumableArray(transforms)));
      }

      // see if this is a path
      var path = void 0;
      if (node instanceof SVGPathElement) {
        path = node.attributes.d.value;
      } else if (node instanceof SVGRectElement) {
        var l = lengthPx_(node.x),
            t = lengthPx_(node.y),
            r = l + lengthPx_(node.width),
            b = t + lengthPx_(node.height);
        // TODO: handle corner radii
        path = 'M ' + l + ',' + t + ' ' + r + ',' + t + ' ' + r + ',' + b + ' ' + l + ',' + b + ' Z';
      } else if (node instanceof SVGLineElement) {
        var x1 = lengthPx_(node.x1),
            y1 = lengthPx_(node.y1),
            x2 = lengthPx_(node.x2),
            y2 = lengthPx_(node.y2);
        path = 'M ' + x1 + ',' + y1 + ' ' + x2 + ',' + y2 + ' Z';
      } else if (node instanceof SVGPolygonElement || node instanceof SVGPolylineElement) {
        path = 'M ' + Array.from(node.points).map(function (pt) {
          return pt.x + ',' + pt.y;
        }).join(' ');
        if (node instanceof SVGPolygonElement) {
          path += ' Z';
        }
      } else if (node instanceof SVGCircleElement) {
        var cx = lengthPx_(node.cx),
            cy = lengthPx_(node.cy),
            _r = lengthPx_(node.r);
        path = 'M ' + cx + ',' + (cy - _r) + ' A ' + _r + ' ' + _r + ' 0 1 0 ' + cx + ',' + (cy + _r) + ' A ' + _r + ' ' + _r + ' 0 1 0 ' + cx + ',' + (cy - _r) + ' Z';
      } else if (node instanceof SVGEllipseElement) {
        var _cx = lengthPx_(node.cx),
            _cy = lengthPx_(node.cy),
            rx = lengthPx_(node.rx),
            ry = lengthPx_(node.ry);
        path = 'M ' + _cx + ',' + (_cy - ry) + ' A ' + rx + ' ' + ry + ' 0 1 0 ' + _cx + ',' + (_cy + ry) + ' ' + ('A ' + rx + ' ' + ry + ' 0 1 0 ' + _cx + ',' + (_cy - ry) + ' Z');
      }

      if (path) {
        // transform all points
        if (context.transforms && context.transforms.length) {
          var pathData = new _SvgPathData.SvgPathData(path);
          pathData.transform(context.transforms);
          path = pathData.pathString;
        }

        // create a path layer
        return Object.assign(layerData, {
          id: makeFinalNodeId_('path'),
          pathData: path,
          fillColor: 'fillColor' in context ? _ColorUtil.ColorUtil.svgToAndroidColor(context.fillColor) : "#ff000000",
          fillAlpha: 'fillAlpha' in context ? context.fillAlpha : 1,
          strokeColor: 'strokeColor' in context ? _ColorUtil.ColorUtil.svgToAndroidColor(context.strokeColor) : null,
          strokeAlpha: 'strokeAlpha' in context ? context.strokeAlpha : 1,
          strokeWidth: 'strokeWidth' in context ? context.strokeWidth : 1,
          strokeLinecap: context.strokeLinecap || _model.DefaultValues.LINECAP,
          strokeLinejoin: context.strokeLinejoin || _model.DefaultValues.LINEJOIN,
          strokeMiterLimit: 'strokeMiterLimit' in context ? context.strokeMiterLimit : _model.DefaultValues.MITER_LIMIT
        });
      }

      if (node.childNodes.length) {
        var layers = Array.from(node.childNodes).map(function (child) {
          return nodeToLayerData_(child, Object.assign({}, context));
        }).filter(function (layer) {
          return !!layer;
        });
        if (layers && layers.length) {
          // create a group (there are valid children)
          return Object.assign(layerData, {
            id: makeFinalNodeId_('group'),
            type: 'group',
            layers: layers
          });
        } else {
          return null;
        }
      }
    };

    var docElContext = {};
    var width = lengthPx_(doc.documentElement.width);
    var height = lengthPx_(doc.documentElement.height);

    if (doc.documentElement.viewBox) {
      width = doc.documentElement.viewBox.baseVal.width;
      height = doc.documentElement.viewBox.baseVal.height;

      // fake a translate transform for the viewbox
      docElContext.transforms = [{
        matrix: {
          a: 1,
          b: 0,
          c: 0,
          d: 1,
          e: -doc.documentElement.viewBox.baseVal.x,
          f: -doc.documentElement.viewBox.baseVal.y
        }
      }];
    }

    var rootLayer = nodeToLayerData_(doc.documentElement, docElContext);

    var artwork = {
      width: width,
      height: height,
      layers: (rootLayer ? rootLayer.layers : null) || [],
      alpha: doc.documentElement.getAttribute('opacity') || 1
    };

    return new _model.Artwork(artwork);
  }
};

function lengthPx_(svgLength) {
  if (svgLength.baseVal) {
    svgLength = svgLength.baseVal;
  }
  svgLength.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX);
  return svgLength.valueInSpecifiedUnits;
}

},{"./ColorUtil":15,"./ModelUtil":19,"./SvgPathData":22,"./model":35,"./model/properties":44}],22:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SvgPathData = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _bezierJs = require('bezier-js');

var _bezierJs2 = _interopRequireDefault(_bezierJs);

var _MathUtil = require('./MathUtil');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SvgPathData = exports.SvgPathData = function () {
  function SvgPathData(obj) {
    _classCallCheck(this, SvgPathData);

    this.length = 0;
    this.bounds = null;
    this.subPaths = [];

    if (obj) {
      if (typeof obj == 'string') {
        this.pathString = obj;
      } else if (Array.isArray(obj)) {
        this.commands = obj;
      } else if (obj instanceof SvgPathData) {
        this.pathString = obj.pathString;
      }
    }
  }

  _createClass(SvgPathData, [{
    key: 'toString',
    value: function toString() {
      return this.pathString;
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      return this.pathString;
    }
  }, {
    key: 'execute',
    value: function execute(ctx) {
      ctx.beginPath();
      this.commands_.forEach(function (_ref) {
        var command = _ref.command,
            args = _ref.args;

        if (command == '__arc__') {
          executeArc_(ctx, args);
        } else {
          ctx[command].apply(ctx, _toConsumableArray(args));
        }
      });
    }

    // executes the path, possibly trimming it
    // (if actually trimming, draws only using beziers)

  }, {
    key: 'executeTrimmed',
    value: function executeTrimmed(ctx) {
      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var beginPath = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;

      if (start === end) {
        return;
      }

      if (start === 0 && end === 1 && offset === 0) {
        this.execute(ctx);
        return;
      }

      start += offset;
      if (start > 1) {
        start = (start % 1 + 1) % 1; // double modulo to stay positive
      }
      end += offset;
      if (end > 1) {
        end = (end % 1 + 1) % 1;
      }

      if (beginPath) {
        ctx.beginPath();
      }

      if (start > end) {
        // wrap around
        this.executeTrimmed(ctx, 0, end, 0, false);
        this.executeTrimmed(ctx, start, 1, 0, false);
        return;
      }

      // start guaranteed to be before end

      if (!this.subPaths.length) {
        return;
      }

      // NOTE: don't support trimming multiple subpaths to match android behavior
      // https://code.google.com/p/android/issues/detail?id=172547
      var firstSubPath = this.subPaths[0];
      var length = firstSubPath.reduce(function (l, subPath) {
        return l + subPath.length;
      }, 0);
      if (!length) {
        return;
      }

      // compute the string of beziers (possibly split) that make up the
      // path from start to end
      var beziers = [];
      var lengthCovered = 0;
      var started = false;
      var ended = false;
      firstSubPath.forEach(function (segment) {
        var segStart = lengthCovered / length;
        var segEnd = (segment.length + lengthCovered) / length;
        if (!started) {
          if (start < segEnd) {
            started = true;
            var splitStart = _MathUtil.MathUtil.progress(start, segStart, segEnd);
            if (end < segEnd) {
              ended = true;
              var splitEnd = _MathUtil.MathUtil.progress(end, segStart, segEnd);
              beziers.push(segment.bezier.split(tForBezierDistance_(segment, splitStart), tForBezierDistance_(segment, splitEnd)));
            } else {
              beziers.push(segment.bezier.split(tForBezierDistance_(segment, splitStart)).right);
            }
          }
        } else if (!ended) {
          if (end < segEnd) {
            ended = true;
            var _splitEnd = _MathUtil.MathUtil.progress(end, segStart, segEnd);
            beziers.push(segment.bezier.split(tForBezierDistance_(segment, _splitEnd)).left);
          } else {
            beziers.push(segment.bezier);
          }
        }
        lengthCovered += segment.length;
      });

      // draw the beziers just computed
      if (beziers.length) {
        ctx.moveTo(beziers[0].points[0].x, beziers[0].points[0].y);
        beziers.forEach(function (bez) {
          if (bez.points.length == 4) {
            ctx.bezierCurveTo(bez.points[1].x, bez.points[1].y, bez.points[2].x, bez.points[2].y, bez.points[3].x, bez.points[3].y);
          } else if (bez.points.length == 3) {
            ctx.quadraticCurveTo(bez.points[1].x, bez.points[1].y, bez.points[2].x, bez.points[2].y);
          }
        });
      }
    }
  }, {
    key: 'hitTestStroke',
    value: function hitTestStroke(point, pointTransformerFn, strokeWidth) {
      // If the shortest distance from the point to the path is less than half
      // the stroke width, then select the path.
      return this.subPaths.reduce(function (all, subPath) {
        return all.concat(subPath);
      }, []).map(function (segment) {
        return segment.bezier;
      }).map(function (bez) {
        return new _bezierJs2.default(bez.points.map(function (p) {
          return pointTransformerFn(p);
        }));
      }).map(function (bez) {
        return bez.project(point);
      }).reduce(function (proj, min) {
        return proj.d < min.d ? proj : min;
      }).d <= strokeWidth / 2;
    }
  }, {
    key: 'hitTestFill',
    value: function hitTestFill(point, pointTransformerFn) {
      // We use the 'even-odd rule' to determine if the filled path is selected.
      // We create a line from the mouse point to a point we know that is not
      // inside the path (in this case, we use a coordinate outside the path's
      // bounded box). The path should be selected if and only if the number of =
      // intersections between the line and the path is odd.
      var line = {
        p1: point,
        p2: {
          x: this.bounds.r + 1,
          y: this.bounds.b + 1
        }
      };
      return this.subPaths.reduce(function (all, subPath) {
        return all.concat(subPath);
      }, []).map(function (segment) {
        return segment.bezier;
      }).map(function (bez) {
        return new _bezierJs2.default(bez.points.map(function (p) {
          return pointTransformerFn(p);
        }));
      }).map(function (bez) {
        return bez.intersects(line).length;
      }).reduce(function (l, sum) {
        return sum + l;
      }) % 2 != 0;
    }
  }, {
    key: 'transform',
    value: function transform(transforms) {
      this.commands_.forEach(function (_ref2) {
        var command = _ref2.command,
            args = _ref2.args;

        if (command == '__arc__') {
          var start = transformPoint_({ x: args[0], y: args[1] }, transforms);
          args[0] = start.x;
          args[1] = start.y;
          var arc = transformArc_({
            rx: args[2],
            ry: args[3],
            xAxisRotation: args[4],
            largeArcFlag: args[5],
            sweepFlag: args[6],
            endX: args[7],
            endY: args[8]
          }, transforms);
          args[2] = arc.rx;
          args[3] = arc.ry;
          args[4] = arc.xAxisRotation;
          args[5] = arc.largeArcFlag;
          args[6] = arc.sweepFlag;
          args[7] = arc.endX;
          args[8] = arc.endY;
          return;
        }

        for (var i = 0; i < args.length; i += 2) {
          var transformed = transformPoint_({ x: args[i], y: args[i + 1] }, transforms);
          args[i] = transformed.x;
          args[i + 1] = transformed.y;
        }
      });

      this.string_ = commandsToString_(this.commands_);

      var _makePathComputations = makePathComputations_(this.commands_),
          length = _makePathComputations.length,
          bounds = _makePathComputations.bounds,
          subPaths = _makePathComputations.subPaths;

      this.length = length;
      this.bounds = bounds;
      this.subPaths = subPaths;
    }
  }, {
    key: 'pathString',
    get: function get() {
      return this.string_ || '';
    },
    set: function set(value) {
      this.string_ = value;
      var commands = parseCommands_(value);
      this.commands_ = commands;

      var _makePathComputations2 = makePathComputations_(this.commands_),
          length = _makePathComputations2.length,
          bounds = _makePathComputations2.bounds,
          subPaths = _makePathComputations2.subPaths;

      this.length = length;
      this.bounds = bounds;
      this.subPaths = subPaths;
    }
  }, {
    key: 'commands',
    get: function get() {
      return this.commands_;
    },
    set: function set(value) {
      this.commands_ = value ? value.slice() : [];
      this.string_ = commandsToString_(this.commands_);

      var _makePathComputations3 = makePathComputations_(this.commands_),
          length = _makePathComputations3.length,
          bounds = _makePathComputations3.bounds,
          subPaths = _makePathComputations3.subPaths;

      this.length = length;
      this.bounds = bounds;
      this.subPaths = subPaths;
    }
  }], [{
    key: 'interpolate',
    value: function interpolate(start, end, f) {
      if (!end || !start || !end.commands || !start.commands || end.commands.length != start.commands.length) {
        // TODO: show a warning
        return [];
      }

      var interpolatedCommands = [];

      var i = void 0,
          j = void 0;
      for (i = 0; i < start.commands.length; i++) {
        var si = start.commands[i],
            ei = end.commands[i];
        if (!ei.args || !si.args || ei.args.length != si.args.length) {
          console.warn('Incompatible path interpolation');
          return [];
        }

        var interpolatedArgs = [];
        for (j = 0; j < si.args.length; j++) {
          interpolatedArgs.push(simpleInterpolate_(si.args[j], ei.args[j], f));
        }

        interpolatedCommands.push({
          command: si.command,
          args: interpolatedArgs
        });
      }

      return new SvgPathData(interpolatedCommands);
    }
  }]);

  return SvgPathData;
}();

var simpleInterpolate_ = function simpleInterpolate_(start, end, f) {
  return start + (end - start) * f;
};

var TOKEN_ABSOLUTE_COMMAND = 1;
var TOKEN_RELATIVE_COMMAND = 2;
var TOKEN_VALUE = 3;
var TOKEN_EOF = 4;

function parseCommands_(pathString) {
  var commands = [];
  var pushCommandComplex_ = function pushCommandComplex_(command) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return commands.push({ command: command, args: args });
  };
  var pushCommandPoints_ = function pushCommandPoints_(command) {
    for (var _len2 = arguments.length, points = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      points[_key2 - 1] = arguments[_key2];
    }

    return commands.push({
      command: command, args: points.reduce(function (arr, point) {
        return arr.concat(point.x, point.y);
      }, []) });
  };

  var currentPoint = { x: NaN, y: NaN };
  var currentControlPoint = null; // used for S and T commands
  var index = 0;
  var length = pathString.length;

  var tempPoint1 = { x: 0, y: 0 };
  var tempPoint2 = { x: 0, y: 0 };
  var tempPoint3 = { x: 0, y: 0 };

  var firstMove = true;
  var currentToken = void 0;

  var advanceToNextToken_ = function advanceToNextToken_() {
    while (index < length) {
      var c = pathString.charAt(index);
      if ('a' <= c && c <= 'z') {
        return currentToken = TOKEN_RELATIVE_COMMAND;
      } else if ('A' <= c && c <= 'Z') {
        return currentToken = TOKEN_ABSOLUTE_COMMAND;
      } else if ('0' <= c && c <= '9' || c == '.' || c == '-') {
        return currentToken = TOKEN_VALUE;
      }

      // skip unrecognized character
      ++index;
    }

    return currentToken = TOKEN_EOF;
  };

  var consumeCommand_ = function consumeCommand_() {
    advanceToNextToken_();
    if (currentToken !== TOKEN_RELATIVE_COMMAND && currentToken !== TOKEN_ABSOLUTE_COMMAND) {
      throw new Error('Expected command');
    }

    return pathString.charAt(index++);
  };

  var consumePoint_ = function consumePoint_(out, relative) {
    out.x = consumeValue_();
    out.y = consumeValue_();
    if (relative) {
      out.x += currentPoint.x;
      out.y += currentPoint.y;
    }
  };

  var consumeValue_ = function consumeValue_() {
    advanceToNextToken_();
    if (currentToken !== TOKEN_VALUE) {
      throw new Error('Expected value');
    }

    var start = true;
    var seenDot = false;
    var tempIndex = index;
    while (tempIndex < length) {
      var c = pathString.charAt(tempIndex);

      if (!('0' <= c && c <= '9') && (c != '.' || seenDot) && (c != '-' || !start) && c != 'e') {
        // end of value
        break;
      }

      if (c == '.') {
        seenDot = true;
      }

      start = false;
      if (c == 'e') {
        start = true;
      }
      ++tempIndex;
    }

    if (tempIndex == index) {
      throw new Error('Expected value');
    }

    var str = pathString.substring(index, tempIndex);
    index = tempIndex;
    return parseFloat(str);
  };

  while (index < length) {
    var command = consumeCommand_();
    var relative = currentToken === TOKEN_RELATIVE_COMMAND;

    switch (command) {
      case 'M':
      case 'm':
        {
          // move command
          var firstPoint = true;
          while (advanceToNextToken_() === TOKEN_VALUE) {
            consumePoint_(tempPoint1, relative && !isNaN(currentPoint.x));
            if (firstPoint) {
              pushCommandPoints_('moveTo', tempPoint1);
              firstPoint = false;
              if (firstMove) {
                currentPoint = Object.assign({}, tempPoint1);
                firstMove = false;
              }
            } else {
              pushCommandPoints_('lineTo', tempPoint1);
            }
          }

          currentControlPoint = null;
          currentPoint = Object.assign({}, tempPoint1);
          break;
        }

      case 'C':
      case 'c':
        {
          // cubic curve command
          if (isNaN(currentPoint.x)) {
            throw new Error('Relative commands require current point');
          }

          while (advanceToNextToken_() === TOKEN_VALUE) {
            consumePoint_(tempPoint1, relative);
            consumePoint_(tempPoint2, relative);
            consumePoint_(tempPoint3, relative);
            pushCommandPoints_('bezierCurveTo', tempPoint1, tempPoint2, tempPoint3);

            currentControlPoint = Object.assign({}, tempPoint2);
            currentPoint = Object.assign({}, tempPoint3);
          }

          break;
        }

      case 'S':
      case 's':
        {
          // cubic curve command (string of curves)
          if (isNaN(currentPoint.x)) {
            throw new Error('Relative commands require current point');
          }

          while (advanceToNextToken_() === TOKEN_VALUE) {
            consumePoint_(tempPoint1, relative);
            consumePoint_(tempPoint2, relative);
            if (currentControlPoint) {
              tempPoint3.x = currentPoint.x + (currentPoint.x - currentControlPoint.x);
              tempPoint3.y = currentPoint.y + (currentPoint.y - currentControlPoint.y);
            } else {
              Object.assign(tempPoint3, tempPoint1);
            }
            pushCommandPoints_('bezierCurveTo', tempPoint3, tempPoint1, tempPoint2);

            currentControlPoint = Object.assign({}, tempPoint1);
            currentPoint = Object.assign({}, tempPoint2);
          }

          break;
        }

      case 'Q':
      case 'q':
        {
          // quadratic curve command
          if (isNaN(currentPoint.x)) {
            throw new Error('Relative commands require current point');
          }

          while (advanceToNextToken_() === TOKEN_VALUE) {
            consumePoint_(tempPoint1, relative);
            consumePoint_(tempPoint2, relative);
            pushCommandPoints_('quadraticCurveTo', tempPoint1, tempPoint2);

            currentControlPoint = Object.assign({}, tempPoint1);
            currentPoint = Object.assign({}, tempPoint2);
          }

          break;
        }

      case 'T':
      case 't':
        {
          // quadratic curve command (string of curves)
          if (isNaN(currentPoint.x)) {
            throw new Error('Relative commands require current point');
          }

          while (advanceToNextToken_() === TOKEN_VALUE) {
            consumePoint_(tempPoint1, relative);
            if (currentControlPoint) {
              tempPoint2.x = currentPoint.x + (currentPoint.x - currentControlPoint.x);
              tempPoint2.y = currentPoint.y + (currentPoint.y - currentControlPoint.y);
            } else {
              Object.assign(tempPoint2, tempPoint1);
            }
            pushCommandPoints_('quadraticCurveTo', tempPoint2, tempPoint1);

            currentControlPoint = Object.assign({}, tempPoint2);
            currentPoint = Object.assign({}, tempPoint1);
          }

          break;
        }

      case 'L':
      case 'l':
        {
          // line command
          if (isNaN(currentPoint.x)) {
            throw new Error('Relative commands require current point');
          }

          while (advanceToNextToken_() === TOKEN_VALUE) {
            consumePoint_(tempPoint1, relative);
            pushCommandPoints_('lineTo', tempPoint1);

            currentControlPoint = null;
            currentPoint = Object.assign({}, tempPoint1);
          }

          break;
        }

      case 'H':
      case 'h':
        {
          // horizontal line command
          if (isNaN(currentPoint.x)) {
            throw new Error('Relative commands require current point');
          }

          while (advanceToNextToken_() === TOKEN_VALUE) {
            tempPoint1.x = consumeValue_();
            tempPoint1.y = currentPoint.y;
            if (relative) {
              tempPoint1.x += currentPoint.x;
            }

            pushCommandPoints_('lineTo', tempPoint1);

            currentControlPoint = null;
            currentPoint = Object.assign({}, tempPoint1);
          }
          break;
        }

      case 'A':
      case 'a':
        {
          // arc command
          if (isNaN(currentPoint.x)) {
            throw new Error('Relative commands require current point');
          }

          while (advanceToNextToken_() === TOKEN_VALUE) {
            var rx = consumeValue_();
            var ry = consumeValue_();
            var xAxisRotation = consumeValue_();
            var largeArcFlag = consumeValue_();
            var sweepFlag = consumeValue_();
            consumePoint_(tempPoint1, relative);

            pushCommandComplex_('__arc__', currentPoint.x, currentPoint.y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, tempPoint1.x, tempPoint1.y);

            // pp.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);
            // pp.addMarkerAngle(tempPoint1, ah - dir * Math.PI);

            currentControlPoint = null;
            currentPoint = Object.assign({}, tempPoint1);
          }
          break;
        }

      case 'V':
      case 'v':
        {
          // vertical line command
          if (isNaN(currentPoint.x)) {
            throw new Error('Relative commands require current point');
          }

          while (advanceToNextToken_() === TOKEN_VALUE) {
            tempPoint1.y = consumeValue_();
            tempPoint1.x = currentPoint.x;
            if (relative) {
              tempPoint1.y += currentPoint.y;
            }
            pushCommandPoints_('lineTo', tempPoint1);

            currentControlPoint = null;
            currentPoint = Object.assign({}, tempPoint1);
          }
          break;
        }

      case 'Z':
      case 'z':
        {
          // close command
          pushCommandPoints_('closePath');
          break;
        }
    }
  }

  return commands;
}

function commandsToString_(commands) {
  var tokens = [];
  commands.forEach(function (_ref3) {
    var command = _ref3.command,
        args = _ref3.args;

    if (command == '__arc__') {
      tokens.push('A');
      tokens.splice(tokens.length, 0, args.slice(2)); // skip first two arc args
      return;
    }

    switch (command) {
      case 'moveTo':
        tokens.push('M');break;
      case 'lineTo':
        tokens.push('L');break;
      case 'bezierCurveTo':
        tokens.push('C');break;
      case 'quadraticCurveTo':
        tokens.push('Q');break;
      case 'closePath':
        tokens.push('Z');break;
    }

    tokens.splice.apply(tokens, [tokens.length, 0].concat(_toConsumableArray(args.map(function (arg) {
      return Number(arg.toFixed(3)).toString();
    }))));
  });

  return tokens.join(' ');
}

function executeArc_(ctx, arcArgs) {
  var _arcArgs = _slicedToArray(arcArgs, 9),
      currentPointX = _arcArgs[0],
      currentPointY = _arcArgs[1],
      rx = _arcArgs[2],
      ry = _arcArgs[3],
      xAxisRotation = _arcArgs[4],
      largeArcFlag = _arcArgs[5],
      sweepFlag = _arcArgs[6],
      tempPoint1X = _arcArgs[7],
      tempPoint1Y = _arcArgs[8];

  if (currentPointX == tempPoint1X && currentPointY == tempPoint1Y) {
    // degenerate to point
    return;
  }

  if (rx == 0 || ry == 0) {
    // degenerate to line
    ctx.lineTo(tempPoint1X, tempPoint1Y);
    return;
  }

  var bezierCoords = arcToBeziers_(currentPointX, currentPointY, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, tempPoint1X, tempPoint1Y);

  for (var i = 0; i < bezierCoords.length; i += 8) {
    ctx.bezierCurveTo(bezierCoords[i + 2], bezierCoords[i + 3], bezierCoords[i + 4], bezierCoords[i + 5], bezierCoords[i + 6], bezierCoords[i + 7]);
  }
}

// maps a distance along the curve to the bezier parameter space (t)
function tForBezierDistance_(_ref4, f) {
  var lut = _ref4.lut,
      length = _ref4.length;

  var targetDist = f * length;
  for (var i = 0; i < lut.length - 1; i++) {
    var p1 = lut[i];
    var p2 = lut[i + 1];
    var dist = _MathUtil.MathUtil.dist(p1.x, p1.y, p2.x, p2.y);
    if (!dist) {
      continue;
    }

    if (targetDist <= dist) {
      f = targetDist / dist;
      return (i + f) / (lut.length - 1);
    }

    targetDist -= dist;
  }

  return 1;
}

function makePathComputations_(commands) {
  var length = 0;
  var bounds = { l: Infinity, t: Infinity, r: -Infinity, b: -Infinity };
  var currentSubPath = null;
  var subPaths = [];

  var pushBezier_ = function pushBezier_(bezier) {
    currentSubPath.push({
      bezier: bezier,
      lut: bezier.getLUT(100),
      length: bezier.length()
    });
  };

  var expandBounds_ = function expandBounds_(x, y) {
    bounds.l = Math.min(x, bounds.l);
    bounds.t = Math.min(y, bounds.t);
    bounds.r = Math.max(x, bounds.r);
    bounds.b = Math.max(y, bounds.b);
  };

  var expandBoundsToBezier_ = function expandBoundsToBezier_(bez) {
    var bbox = bez.bbox();
    expandBounds_(bbox.x.min, bbox.y.min);
    expandBounds_(bbox.x.max, bbox.y.min);
    expandBounds_(bbox.x.min, bbox.y.max);
    expandBounds_(bbox.x.max, bbox.y.max);
  };

  var lastMovePoint = null;
  var currentPoint = { x: 0, y: 0 };

  commands.forEach(function (_ref5) {
    var command = _ref5.command,
        args = _ref5.args;

    switch (command) {
      case 'moveTo':
        {
          // start new sub-path
          currentSubPath = [];
          subPaths.push(currentSubPath);
          lastMovePoint = { x: args[0], y: args[1] };
          currentPoint.x = args[0];
          currentPoint.y = args[1];
          expandBounds_(args[0], args[1]);
          break;
        }

      case 'lineTo':
        {
          length += _MathUtil.MathUtil.dist(args[0], args[1], currentPoint.x, currentPoint.y);
          pushBezier_(new _bezierJs2.default(currentPoint.x, currentPoint.y, args[0], args[1], args[0], args[1]));
          currentPoint.x = args[0];
          currentPoint.y = args[1];
          expandBounds_(args[0], args[1]);
          break;
        }

      case 'closePath':
        {
          if (lastMovePoint) {
            length += _MathUtil.MathUtil.dist(lastMovePoint.x, lastMovePoint.y, currentPoint.x, currentPoint.y);
            pushBezier_(new _bezierJs2.default(currentPoint.x, currentPoint.y, lastMovePoint.x, lastMovePoint.y, lastMovePoint.x, lastMovePoint.y));
            currentPoint.x = lastMovePoint.x;
            currentPoint.y = lastMovePoint.y;
          }
          break;
        }

      case 'bezierCurveTo':
        {
          var bez = new _bezierJs2.default(currentPoint.x, currentPoint.y, args[0], args[1], args[2], args[3], args[4], args[5]);
          length += bez.length();
          currentPoint.x = args[4];
          currentPoint.y = args[5];
          pushBezier_(bez);
          expandBoundsToBezier_(bez);
          break;
        }

      case 'quadraticCurveTo':
        {
          var _bez = new _bezierJs2.default(currentPoint.x, currentPoint.y, args[0], args[1], args[2], args[3]);
          length += _bez.length();
          currentPoint.x = args[2];
          currentPoint.y = args[3];
          pushBezier_(_bez);
          expandBoundsToBezier_(_bez);
          break;
        }

      case '__arc__':
        {
          var _args = _slicedToArray(args, 9),
              currentPointX = _args[0],
              currentPointY = _args[1],
              rx = _args[2],
              ry = _args[3],
              xAxisRotation = _args[4],
              largeArcFlag = _args[5],
              sweepFlag = _args[6],
              tempPoint1X = _args[7],
              tempPoint1Y = _args[8];

          if (currentPointX == tempPoint1X && currentPointY == tempPoint1Y) {
            // degenerate to point (0 length)
            break;
          }

          if (rx == 0 || ry == 0) {
            // degenerate to line
            length += _MathUtil.MathUtil.dist(currentPointX, currentPointY, tempPoint1X, tempPoint1Y);
            expandBounds_(tempPoint1X, tempPoint1Y);
            currentPoint.x = tempPoint1X;
            currentPoint.y = tempPoint1Y;
            return;
          }

          var bezierCoords = arcToBeziers_(currentPointX, currentPointY, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, tempPoint1X, tempPoint1Y);

          for (var i = 0; i < bezierCoords.length; i += 8) {
            var _bez2 = new _bezierJs2.default(currentPoint.x, currentPoint.y, bezierCoords[i + 2], bezierCoords[i + 3], bezierCoords[i + 4], bezierCoords[i + 5], bezierCoords[i + 6], bezierCoords[i + 7]);
            length += _bez2.length();
            currentPoint.x = bezierCoords[i + 6];
            currentPoint.y = bezierCoords[i + 7];
            expandBoundsToBezier_(_bez2);
            pushBezier_(_bez2);
          }
          currentPoint.x = tempPoint1X;
          currentPoint.y = tempPoint1Y;
          break;
        }
    }
  });

  return { length: length, bounds: bounds, subPaths: subPaths };
}

// Based on code from https://code.google.com/archive/p/androidsvg
function arcToBeziers_(xf, yf, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, xt, yt) {
  // Sign of the radii is ignored (behaviour specified by the spec)
  rx = Math.abs(rx);
  ry = Math.abs(ry);

  var rotate = xAxisRotation * Math.PI / 180;
  var cosAngle = Math.cos(rotate);
  var sinAngle = Math.sin(rotate);

  // We simplify the calculations by transforming the arc so that the origin is at the
  // midpoint calculated above followed by a rotation to line up the coordinate axes
  // with the axes of the ellipse.

  // Compute the midpoint of the line between the current and the end point
  var dx2 = (xf - xt) / 2;
  var dy2 = (yf - yt) / 2;

  // Step 1 : Compute (x1', y1') - the transformed start point
  var x1 = cosAngle * dx2 + sinAngle * dy2;
  var y1 = -sinAngle * dx2 + cosAngle * dy2;

  var rx_sq = rx * rx;
  var ry_sq = ry * ry;
  var x1_sq = x1 * x1;
  var y1_sq = y1 * y1;

  // Check that radii are large enough.
  // If they are not, the spec says to scale them up so they are.
  // This is to compensate for potential rounding errors/differences between SVG implementations.
  var radiiCheck = x1_sq / rx_sq + y1_sq / ry_sq;
  if (radiiCheck > 1) {
    rx = Math.sqrt(radiiCheck) * rx;
    ry = Math.sqrt(radiiCheck) * ry;
    rx_sq = rx * rx;
    ry_sq = ry * ry;
  }

  // Step 2 : Compute (cx1, cy1) - the transformed centre point
  var sign = largeArcFlag == sweepFlag ? -1 : 1;
  var sq = (rx_sq * ry_sq - rx_sq * y1_sq - ry_sq * x1_sq) / (rx_sq * y1_sq + ry_sq * x1_sq);
  sq = sq < 0 ? 0 : sq;
  var coef = sign * Math.sqrt(sq);
  var cx1 = coef * (rx * y1 / ry);
  var cy1 = coef * -(ry * x1 / rx);

  // Step 3 : Compute (cx, cy) from (cx1, cy1)
  var sx2 = (xf + xt) / 2;
  var sy2 = (yf + yt) / 2;
  var cx = sx2 + (cosAngle * cx1 - sinAngle * cy1);
  var cy = sy2 + (sinAngle * cx1 + cosAngle * cy1);

  // Step 4 : Compute the angleStart (angle1) and the angleExtent (dangle)
  var ux = (x1 - cx1) / rx;
  var uy = (y1 - cy1) / ry;
  var vx = (-x1 - cx1) / rx;
  var vy = (-y1 - cy1) / ry;
  var p = void 0,
      n = void 0;

  // Compute the angle start
  n = Math.sqrt(ux * ux + uy * uy);
  p = ux; // (1 * ux) + (0 * uy)
  sign = uy < 0 ? -1 : 1;
  var angleStart = sign * Math.acos(p / n) * 180 / Math.PI;

  // Compute the angle extent
  n = Math.sqrt((ux * ux + uy * uy) * (vx * vx + vy * vy));
  p = ux * vx + uy * vy;
  sign = ux * vy - uy * vx < 0 ? -1 : 1;
  var angleExtent = sign * Math.acos(p / n) * 180 / Math.PI;
  if (!sweepFlag && angleExtent > 0) {
    angleExtent -= 360;
  } else if (sweepFlag && angleExtent < 0) {
    angleExtent += 360;
  }

  angleExtent %= 360;
  angleStart %= 360;

  // Many elliptical arc implementations including the Java2D and Android ones, only
  // support arcs that are axis aligned.  Therefore we need to substitute the arc
  // with bezier curves.  The following method call will generate the beziers for
  // a unit circle that covers the arc angles we want.
  var bezierCoords = unitCircleArcToBeziers_(angleStart, angleExtent);

  // Calculate a transformation matrix that will move and scale these bezier points to the correct location.
  // translate(cx, cy) --> rotate(rotate) --> scale(rx, ry)
  for (var i = 0; i < bezierCoords.length; i += 2) {
    // dot product
    var x = bezierCoords[i];
    var y = bezierCoords[i + 1];
    bezierCoords[i] = cosAngle * rx * x + -sinAngle * ry * y + cx;

    bezierCoords[i + 1] = sinAngle * rx * x + cosAngle * ry * y + cy;
  }

  // The last point in the bezier set should match exactly the last coord pair in the arc (ie: x,y). But
  // considering all the mathematical manipulation we have been doing, it is bound to be off by a tiny
  // fraction. Experiments show that it can be up to around 0.00002.  So why don't we just set it to
  // exactly what it ought to be.
  bezierCoords[bezierCoords.length - 2] = xt;
  bezierCoords[bezierCoords.length - 1] = yt;
  return bezierCoords;
}

/*
* Generate the control points and endpoints for a set of bezier curves that match
* a circular arc starting from angle 'angleStart' and sweep the angle 'angleExtent'.
* The circle the arc follows will be centred on (0,0) and have a radius of 1.0.
*
* Each bezier can cover no more than 90 degrees, so the arc will be divided evenly
* into a maximum of four curves.
*
* The resulting control points will later be scaled and rotated to match the final
* arc required.
*
* The returned array has the format [x0,y0, x1,y1,...].
*/
function unitCircleArcToBeziers_(angleStart, angleExtent) {
  var numSegments = Math.ceil(Math.abs(angleExtent) / 90);

  angleStart = angleStart * Math.PI / 180;
  angleExtent = angleExtent * Math.PI / 180;

  var angleIncrement = angleExtent / numSegments;

  // The length of each control point vector is given by the following formula.
  var controlLength = 4 / 3 * Math.sin(angleIncrement / 2) / (1 + Math.cos(angleIncrement / 2));

  var coords = new Array(numSegments * 8);
  var pos = 0;

  for (var i = 0; i < numSegments; i++) {
    var angle = angleStart + i * angleIncrement;

    // Calculate the control vector at this angle
    var dx = Math.cos(angle);
    var dy = Math.sin(angle);

    // First point
    coords[pos++] = dx;
    coords[pos++] = dy;

    // First control point
    coords[pos++] = dx - controlLength * dy;
    coords[pos++] = dy + controlLength * dx;

    // Second control point
    angle += angleIncrement;
    dx = Math.cos(angle);
    dy = Math.sin(angle);

    coords[pos++] = dx + controlLength * dy;
    coords[pos++] = dy - controlLength * dx;

    // Endpoint of bezier
    coords[pos++] = dx;
    coords[pos++] = dy;
  }

  return coords;
}

// TODO: refactor into a MatrixUtil
function transformPoint_(p, transformMatricies) {
  return transformMatricies.reduce(function (p, transform) {
    var m = transform.matrix;
    return {
      // dot product
      x: m.a * p.x + m.c * p.y + m.e * 1,
      y: m.b * p.x + m.d * p.y + m.f * 1
    };
  }, p);
}

// Code adapted from here:
// https://gist.github.com/alexjlockwood/c037140879806fb4d9820b7e70195494#file-flatten-js-L441-L547
function transformArc_(initialArc, transformMatricies) {
  var isNearZero = function isNearZero(n) {
    return Math.abs(n) < 0.0000000000000001;
  };
  return transformMatricies.reduce(function (arc, transform) {
    var rx = arc.rx,
        ry = arc.ry,
        xAxisRotation = arc.xAxisRotation,
        largeArcFlag = arc.largeArcFlag,
        sweepFlag = arc.sweepFlag,
        endX = arc.endX,
        endY = arc.endY;


    xAxisRotation = xAxisRotation * Math.PI / 180;

    var s = parseFloat(Math.sin(xAxisRotation));
    var c = parseFloat(Math.cos(xAxisRotation));

    // Matrix representation of transformed ellipse.
    var m = [];

    // Build ellipse representation matrix (unit circle transformation).
    // The 2x2 matrix multiplication with the upper 2x2 of a_mat is inlined.
    var matrix = transform.matrix;
    m[0] = matrix.a * +rx * c + matrix.c * rx * s;
    m[1] = matrix.b * +rx * c + matrix.d * rx * s;
    m[2] = matrix.a * -ry * s + matrix.c * ry * c;
    m[3] = matrix.b * -ry * s + matrix.d * ry * c;

    // To implict equation (centered).
    var A = m[0] * m[0] + m[2] * m[2];
    var C = m[1] * m[1] + m[3] * m[3];
    var B = (m[0] * m[1] + m[2] * m[3]) * 2.0;

    // Precalculate distance A to C.
    var ac = A - C;

    // Convert implicit equation to angle and halfaxis.
    var A2 = void 0,
        C2 = void 0;
    if (isNearZero(B)) {
      xAxisRotation = 0;
      A2 = A;
      C2 = C;
    } else {
      if (isNearZero(ac)) {
        A2 = A + B * 0.5;
        C2 = A - B * 0.5;
        xAxisRotation = Math.PI / 4.0;
      } else {
        // Precalculate radical.
        var K = 1 + B * B / (ac * ac);

        // Clamp (precision issues might need this... not likely, but better safe than sorry).
        K = K < 0 ? 0 : Math.sqrt(K);

        A2 = 0.5 * (A + C + K * ac);
        C2 = 0.5 * (A + C - K * ac);
        xAxisRotation = 0.5 * Math.atan2(B, ac);
      }
    }

    // This can get slightly below zero due to rounding issues.
    // It's safe to clamp to zero in this case (this yields a zero length halfaxis).
    A2 = A2 < 0 ? 0 : Math.sqrt(A2);
    C2 = C2 < 0 ? 0 : Math.sqrt(C2);

    // Now A2 and C2 are half-axis.
    if (ac <= 0) {
      ry = A2;
      rx = C2;
    } else {
      ry = C2;
      rx = A2;
    }

    // If the transformation matrix contain a mirror-component
    // winding order of the ellise needs to be changed.
    if (matrix.a * matrix.d - matrix.b * matrix.c < 0) {
      sweepFlag = sweepFlag ? 0 : 1;
    }

    // Finally, transform arc endpoint. This takes care about the
    // translational part which we ignored at the whole math-showdown above.
    var end = transformPoint_({ x: endX, y: endY }, [transform]);

    xAxisRotation = xAxisRotation * 180 / Math.PI;

    return {
      rx: rx,
      ry: ry,
      xAxisRotation: xAxisRotation,
      largeArcFlag: largeArcFlag,
      sweepFlag: sweepFlag,
      endX: end.x,
      endY: end.y
    };
  }, initialArc);
}

},{"./MathUtil":18,"bezier-js":48}],23:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var UiUtil = exports.UiUtil = {
  waitForElementWidth_: function waitForElementWidth_(el) {
    var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;

    var start = Number(new Date());
    var $el = $(el);
    return new Promise(function (resolve, reject) {
      var tryResolve_ = function tryResolve_() {
        if (Number(new Date()) - start > timeout) {
          reject();
          return;
        }

        var width = $el.width();
        if (width) {
          resolve(width);
        } else {
          setTimeout(function () {
            return tryResolve_();
          }, 0);
        }
      };

      tryResolve_();
    });
  }
};

},{}],24:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VectorDrawableLoader = undefined;

var _model = require('./model');

var _properties = require('./model/properties');

var _ModelUtil = require('./ModelUtil');

var VectorDrawableLoader = exports.VectorDrawableLoader = {
  loadArtworkFromXmlString: function loadArtworkFromXmlString(xmlString) {
    var parser = new DOMParser();
    var doc = parser.parseFromString(xmlString, 'application/xml');

    var usedIds = {};

    var nodeToLayerData_ = function nodeToLayerData_(node) {
      if (!node) {
        return null;
      }
      if (node.nodeType == Node.TEXT_NODE || node.nodeType == Node.COMMENT_NODE) {
        return null;
      }

      var makeFinalNodeId_ = function makeFinalNodeId_(node, typeIdPrefix) {
        var name = node.getAttribute('android:name');
        var finalId = _ModelUtil.ModelUtil.getUniqueId({
          prefix: _properties.IdProperty.sanitize(name || typeIdPrefix),
          objectById: function objectById(id) {
            return usedIds[id];
          }
        });
        usedIds[finalId] = true;
        return finalId;
      };

      var layerData = {};

      if (node.tagName === 'path') {
        return Object.assign(layerData, {
          id: makeFinalNodeId_(node, 'path'),
          pathData: node.getAttribute('android:pathData') || null,
          fillColor: node.getAttribute('android:fillColor') || null,
          fillAlpha: node.getAttribute('android:fillAlpha') || 1,
          strokeColor: node.getAttribute('android:strokeColor') || null,
          strokeAlpha: node.getAttribute('android:strokeAlpha') || 1,
          strokeWidth: node.getAttribute('android:strokeWidth') || 0,
          strokeLinecap: node.getAttribute('android:strokeLineCap') || _model.DefaultValues.LINECAP,
          strokeLinejoin: node.getAttribute('android:strokeLineJoin') || _model.DefaultValues.LINEJOIN,
          strokeMiterLimit: node.getAttribute('android:strokeMiterLimit') || _model.DefaultValues.MITER_LIMIT,
          trimPathStart: node.getAttribute('android:trimPathStart') || 0,
          trimPathEnd: node.getAttribute('android:trimPathEnd') || 1,
          trimPathOffset: node.getAttribute('android:trimPathOffset') || 0
        });
      }

      if (node.childNodes.length) {
        var layers = Array.from(node.childNodes).map(function (child) {
          return nodeToLayerData_(child);
        }).filter(function (layer) {
          return !!layer;
        });
        if (layers && layers.length) {
          // create a group (there are valid children)
          return Object.assign(layerData, {
            id: makeFinalNodeId_(node, 'group'),
            type: 'group',
            rotation: node.getAttribute('android:rotation') || 0,
            scaleX: node.getAttribute('android:scaleX') || 1,
            scaleY: node.getAttribute('android:scaleY') || 1,
            pivotX: node.getAttribute('android:pivotX') || 0,
            pivotY: node.getAttribute('android:pivotY') || 0,
            translateX: node.getAttribute('android:translateX') || 0,
            translateY: node.getAttribute('android:translateY') || 0,
            layers: layers
          });
        } else {
          return null;
        }
      }
    };

    var rootLayer = nodeToLayerData_(doc.documentElement);
    var id = _properties.IdProperty.sanitize(doc.documentElement.getAttribute('android:name') || 'vector');
    usedIds[id] = true;
    var width = doc.documentElement.getAttribute('android:viewportWidth');
    var height = doc.documentElement.getAttribute('android:viewportHeight');
    var alpha = doc.documentElement.getAttribute('android:alpha') || 1;
    var artwork = {
      id: id,
      width: width,
      height: height,
      layers: (rootLayer ? rootLayer.layers : null) || [],
      alpha: alpha
    };
    return new _model.Artwork(artwork);
  }
}; /*
    * Copyright 2016 Google Inc.
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    *     http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    */

},{"./ModelUtil":19,"./model":35,"./model/properties":44}],25:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

angular.module('AVDStudio', ['ngMaterial', 'ngRoute']).config(require('./materialtheme')).config(require('./icons')).config(require('./routes').routeConfig);

// core app
angular.module('AVDStudio').controller('AppCtrl', function AppCtrl($scope) {
  _classCallCheck(this, AppCtrl);
});

// all components
require('../components/canvas/canvas-ruler.js');require('../components/canvas/canvas.js');require('../components/filehandlers/filedroptarget.js');require('../components/filehandlers/fileopenhandler.js');require('../components/layertimeline/consts.js');require('../components/layertimeline/layertimeline.js');require('../components/layertimeline/timelinegrid.js');require('../components/propertyinspector/propertyinspector.js');require('../components/scrollgroup/scrollgroup.js');require('../components/splitter/splitter.js');

// all pages
require('../pages/studio/studio.js');require('../pages/studio/studiostate.js');

},{"../components/canvas/canvas-ruler.js":1,"../components/canvas/canvas.js":2,"../components/filehandlers/filedroptarget.js":3,"../components/filehandlers/fileopenhandler.js":4,"../components/layertimeline/consts.js":5,"../components/layertimeline/layertimeline.js":6,"../components/layertimeline/timelinegrid.js":7,"../components/propertyinspector/propertyinspector.js":8,"../components/scrollgroup/scrollgroup.js":9,"../components/splitter/splitter.js":10,"../pages/studio/studio.js":11,"../pages/studio/studiostate.js":12,"./icons":26,"./materialtheme":27,"./routes":45}],26:[function(require,module,exports){
'use strict';

/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module.exports = function ($mdIconProvider) {
  $mdIconProvider.iconSet('avdstudio', 'images/icons.svg');
};

},{}],27:[function(require,module,exports){
'use strict';

/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module.exports = function ($mdThemingProvider) {
    $mdThemingProvider.theme('default').primaryPalette('blue').accentPalette('blue');
    $mdThemingProvider.theme('dark').primaryPalette('blue').accentPalette('blue').dark();
    $mdThemingProvider.setDefaultTheme('default');
};

},{}],28:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Animation = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dec, _class; /*
                   * Copyright 2016 Google Inc.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *     http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

var _properties = require('./properties');

var _AnimationBlock = require('./AnimationBlock');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * An animation represents a collection of layer property tweens for a given artwork.
 */
var Animation = exports.Animation = (_dec = _properties.Property.register([new _properties.IdProperty('id'), new _properties.NumberProperty('duration', { min: 100, max: 60000 })]), _dec(_class = function () {
  function Animation() {
    var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Animation);

    this.id = obj.id || null;
    this.blocks = (obj.blocks || []).map(function (obj) {
      return new _AnimationBlock.AnimationBlock(obj);
    });
    this.duration = obj.duration || 100;
  }

  _createClass(Animation, [{
    key: 'toJSON',
    value: function toJSON() {
      return {
        id: this.id,
        duration: this.duration,
        blocks: this.blocks.map(function (block) {
          return block.toJSON();
        })
      };
    }
  }, {
    key: 'blocks',
    get: function get() {
      return this.blocks_ || [];
    },
    set: function set(blocks) {
      var _this = this;

      this.blocks_ = blocks;
      this.blocks_.forEach(function (block) {
        return block.parent = _this;
      });
    }
  }, {
    key: 'typeString',
    get: function get() {
      return 'animation';
    }
  }, {
    key: 'typeIdPrefix',
    get: function get() {
      return 'anim';
    }
  }, {
    key: 'typeIcon',
    get: function get() {
      return 'animation';
    }
  }]);

  return Animation;
}()) || _class);

},{"./AnimationBlock":29,"./properties":44}],29:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnimationBlock = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dec, _class; /*
                   * Copyright 2016 Google Inc.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *     http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

var _bezierEasing = require('bezier-easing');

var _bezierEasing2 = _interopRequireDefault(_bezierEasing);

var _SvgPathData = require('../SvgPathData');

var _properties = require('./properties');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FAST_OUT_SLOW_IN_EASING = (0, _bezierEasing2.default)(.4, 0, .2, 1);
var FAST_OUT_LINEAR_IN_EASING = (0, _bezierEasing2.default)(.4, 0, 1, 1);
var LINEAR_OUT_SLOW_IN_EASING = (0, _bezierEasing2.default)(0, 0, .2, 1);

var ENUM_INTERPOLATOR_OPTIONS = [{
  value: 'ACCELERATE_DECELERATE',
  label: 'Accelerate/decelerate',
  androidRef: '@android:anim/accelerate_decelerate_interpolator',
  interpolate: function interpolate(f) {
    return Math.cos((f + 1) * Math.PI) / 2.0 + 0.5;
  }
}, {
  value: 'ACCELERATE',
  label: 'Accelerate',
  androidRef: '@android:anim/accelerate_interpolator',
  interpolate: function interpolate(f) {
    return f * f;
  }
}, {
  value: 'DECELERATE',
  label: 'Decelerate',
  androidRef: '@android:anim/decelerate_interpolator',
  interpolate: function interpolate(f) {
    return 1 - (1 - f) * (1 - f);
  }
}, {
  value: 'ANTICIPATE',
  label: 'Anticipate',
  androidRef: '@android:anim/anticipate_interpolator',
  interpolate: function interpolate(f) {
    return f * f * ((2 + 1) * f - 2);
  }
}, {
  value: 'LINEAR',
  label: 'Linear',
  androidRef: '@android:anim/linear_interpolator',
  interpolate: function interpolate(f) {
    return f;
  }
}, {
  value: 'OVERSHOOT',
  label: 'Overshoot',
  androidRef: '@android:anim/overshoot_interpolator',
  interpolate: function interpolate(f) {
    return (f - 1) * (f - 1) * ((2 + 1) * (f - 1) + 2) + 1;
  }
}, {
  value: 'FAST_OUT_SLOW_IN',
  label: 'Fast out, slow in',
  androidRef: '@android:interpolator/fast_out_slow_in',
  interpolate: function interpolate(f) {
    return FAST_OUT_SLOW_IN_EASING(f);
  }
}, {
  value: 'FAST_OUT_LINEAR_IN',
  label: 'Fast out, linear in',
  androidRef: '@android:interpolator/fast_out_linear_in',
  interpolate: function interpolate(f) {
    return FAST_OUT_LINEAR_IN_EASING(f);
  }
}, {
  value: 'LINEAR_OUT_SLOW_IN',
  label: 'Linear out, slow in',
  androidRef: '@android:interpolator/linear_out_slow_in',
  interpolate: function interpolate(f) {
    return LINEAR_OUT_SLOW_IN_EASING(f);
  }
}];

/**
 * An animation block is an individual layer property tween (property animation).
 */
var AnimationBlock = exports.AnimationBlock = (_dec = _properties.Property.register([new _properties.StubProperty('fromValue'), new _properties.StubProperty('toValue'), new _properties.NumberProperty('startTime', { min: 0, integer: true }), new _properties.NumberProperty('endTime', { min: 0, integer: true }), new _properties.EnumProperty('interpolator', ENUM_INTERPOLATOR_OPTIONS, { storeEntireOption: true })]), _dec(_class = function () {
  function AnimationBlock() {
    var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, AnimationBlock);

    this.layerId = obj.layerId || null;
    this.propertyName = obj.propertyName || null;
    var isPathData = this.propertyName == 'pathData';
    if ('fromValue' in obj) {
      this.fromValue = isPathData ? new _SvgPathData.SvgPathData(obj.fromValue) : obj.fromValue;
    }
    this.toValue = isPathData ? new _SvgPathData.SvgPathData(obj.toValue) : obj.toValue;
    this.startTime = obj.startTime || 0;
    this.endTime = obj.endTime || 0;
    if (this.startTime > this.endTime) {
      var tmp = this.endTime;
      this.endTime = this.startTime;
      this.startTime = tmp;
    }
    this.interpolator = obj.interpolator || 'ACCELERATE_DECELERATE';
  }

  _createClass(AnimationBlock, [{
    key: 'toJSON',
    value: function toJSON() {
      return {
        layerId: this.layerId,
        propertyName: this.propertyName,
        fromValue: valueToJson_(this.fromValue),
        toValue: valueToJson_(this.toValue),
        startTime: this.startTime,
        endTime: this.endTime,
        interpolator: this.interpolator.value
      };
    }
  }, {
    key: 'typeString',
    get: function get() {
      return 'block';
    }
  }, {
    key: 'typeIdPrefix',
    get: function get() {
      return 'block';
    }
  }, {
    key: 'typeIcon',
    get: function get() {
      return 'animation_block';
    }
  }]);

  return AnimationBlock;
}()) || _class);


function valueToJson_(val) {
  if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) == 'object' && 'toJSON' in val) {
    return val.toJSON();
  }

  return val;
}

},{"../SvgPathData":22,"./properties":44,"bezier-easing":47}],30:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Artwork = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _dec, _class; /*
                   * Copyright 2016 Google Inc.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *     http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

var _properties = require('./properties');

var _BaseLayer = require('./BaseLayer');

var _LayerGroup2 = require('./LayerGroup');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * An artwork is the root layer group for a vector, defined mostly by
 * a width, height, and its children.
 */
var Artwork = exports.Artwork = (_dec = _properties.Property.register([new _properties.IdProperty('id'), new _properties.ColorProperty('canvasColor'), new _properties.NumberProperty('width', { min: 4, max: 1024, integer: true }), new _properties.NumberProperty('height', { min: 4, max: 1024, integer: true }), new _properties.FractionProperty('alpha', { animatable: true })], { reset: true }), _dec(_class = function (_LayerGroup) {
  _inherits(Artwork, _LayerGroup);

  function Artwork() {
    var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Artwork);

    var _this = _possibleConstructorReturn(this, (Artwork.__proto__ || Object.getPrototypeOf(Artwork)).call(this, obj, opts));

    _this.id = _this.id || _this.typeIdPrefix;
    _this.canvasColor = obj.fillColor || null;
    _this.width = obj.width || 100;
    _this.height = obj.height || 100;
    _this.alpha = obj.alpha || 1;
    return _this;
  }

  _createClass(Artwork, [{
    key: 'computeBounds',
    value: function computeBounds() {
      return { l: 0, t: 0, r: this.width, b: this.height };
    }
  }, {
    key: 'findLayerById',
    value: function findLayerById(id) {
      if (this.id === id) {
        return this;
      }
      return _get(Artwork.prototype.__proto__ || Object.getPrototypeOf(Artwork.prototype), 'findLayerById', this).call(this, id);
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      return {
        id: this.id,
        canvasColor: this.canvasColor,
        width: this.width,
        height: this.height,
        alpha: this.alpha,
        layers: this.layers.map(function (layer) {
          return layer.toJSON();
        })
      };
    }
  }, {
    key: 'typeString',
    get: function get() {
      return 'artwork';
    }
  }, {
    key: 'typeIdPrefix',
    get: function get() {
      return 'vector';
    }
  }, {
    key: 'typeIcon',
    get: function get() {
      return 'artwork';
    }
  }]);

  return Artwork;
}(_LayerGroup2.LayerGroup)) || _class);


_BaseLayer.BaseLayer.LAYER_CLASSES_BY_TYPE['artwork'] = Artwork;

},{"./BaseLayer":31,"./LayerGroup":32,"./properties":44}],31:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BaseLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dec, _class; /*
                   * Copyright 2016 Google Inc.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *     http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

var _properties = require('./properties');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Base class for any node in the tree, including path layers, layer groups, and artworks.
 */
var BaseLayer = exports.BaseLayer = (_dec = _properties.Property.register([new _properties.IdProperty('id')]), _dec(_class = function () {
  function BaseLayer() {
    var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, BaseLayer);

    this.parent = null;
    this.id = obj.id || null;
    if (opts && opts.linkSelectedState) {
      this.selectedStateLinkedObj_ = obj;
    }

    // meta
    this.visible = 'visible' in obj ? obj.visible : true;
    this.expanded = true;
  }

  _createClass(BaseLayer, [{
    key: 'computeBounds',
    value: function computeBounds() {
      return null;
    }
  }, {
    key: 'getSibling_',
    value: function getSibling_(offs) {
      if (!this.parent || !this.parent.layers) {
        return null;
      }

      var index = this.parent.layers.indexOf(this);
      if (index < 0) {
        return null;
      }

      index += offs;
      if (index < 0 || index >= this.parent.layers.length) {
        return null;
      }

      return this.parent.layers[index];
    }
  }, {
    key: 'remove',
    value: function remove() {
      if (!this.parent || !this.parent.layers) {
        return;
      }

      var index = this.parent.layers.indexOf(this);
      if (index >= 0) {
        this.parent.layers.splice(index, 1);
      }

      this.parent = null;
    }
  }, {
    key: 'walk',
    value: function walk(fn, context) {
      var visit_ = function visit_(layer, context) {
        var childContext = fn(layer, context);
        if (layer.layers) {
          walkLayerGroup_(layer, childContext);
        }
      };

      var walkLayerGroup_ = function walkLayerGroup_(layerGroup, context) {
        layerGroup.layers.forEach(function (layer) {
          return visit_(layer, context);
        });
      };

      visit_(this, context);
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      return {
        id: this.id,
        type: this.typeString,
        visible: this.visible
      };
    }
  }, {
    key: 'selected',
    get: function get() {
      return this.selectedStateLinkedObj_ ? this.selectedStateLinkedObj_.selected_ : this.selected_;
    }
  }, {
    key: 'previousSibling',
    get: function get() {
      return this.getSibling_(-1);
    }
  }, {
    key: 'nextSibling',
    get: function get() {
      return this.getSibling_(1);
    }
  }], [{
    key: 'load',
    value: function load() {
      var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var opts = arguments[1];

      if (obj instanceof BaseLayer) {
        return new obj.constructor(obj, opts);
      }

      return new BaseLayer.LAYER_CLASSES_BY_TYPE[obj.type || 'path'](obj, opts);
    }
  }]);

  return BaseLayer;
}()) || _class);

// filled in by derived classes

BaseLayer.LAYER_CLASSES_BY_TYPE = {};

},{"./properties":44}],32:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LayerGroup = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _dec, _class; /*
                   * Copyright 2016 Google Inc.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *     http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

var _properties = require('./properties');

var _BaseLayer2 = require('./BaseLayer');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A group ('folder') containing other layers.
 */
var LayerGroup = exports.LayerGroup = (_dec = _properties.Property.register([new _properties.NumberProperty('rotation', { animatable: true }), new _properties.NumberProperty('scaleX', { animatable: true }), new _properties.NumberProperty('scaleY', { animatable: true }), new _properties.NumberProperty('pivotX', { animatable: true }), new _properties.NumberProperty('pivotY', { animatable: true }), new _properties.NumberProperty('translateX', { animatable: true }), new _properties.NumberProperty('translateY', { animatable: true })]), _dec(_class = function (_BaseLayer) {
  _inherits(LayerGroup, _BaseLayer);

  function LayerGroup() {
    var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, LayerGroup);

    var _this = _possibleConstructorReturn(this, (LayerGroup.__proto__ || Object.getPrototypeOf(LayerGroup)).call(this, obj, opts));

    _this.layers = (obj.layers || []).map(function (obj) {
      return _BaseLayer2.BaseLayer.load(obj, opts);
    });
    _this.rotation = obj.rotation || 0;
    _this.scaleX = 'scaleX' in obj ? obj.scaleX : 1;
    _this.scaleY = 'scaleY' in obj ? obj.scaleY : 1;
    _this.pivotX = obj.pivotX || 0;
    _this.pivotY = obj.pivotY || 0;
    _this.translateX = obj.translateX || 0;
    _this.translateY = obj.translateY || 0;

    // meta
    _this.expanded = 'expanded' in obj ? obj.expanded : true;
    return _this;
  }

  _createClass(LayerGroup, [{
    key: 'computeBounds',
    value: function computeBounds() {
      var bounds = null;
      this.layers.forEach(function (child) {
        var childBounds = child.computeBounds();
        if (!childBounds) {
          return;
        }

        if (!bounds) {
          bounds = Object.assign({}, childBounds);
        } else {
          bounds.l = Math.min(childBounds.l, bounds.l);
          bounds.t = Math.min(childBounds.t, bounds.t);
          bounds.r = Math.max(childBounds.r, bounds.r);
          bounds.b = Math.max(childBounds.b, bounds.b);
        }
      });
      return bounds;
    }
  }, {
    key: 'findLayerById',
    value: function findLayerById(id) {
      for (var i = 0; i < this.layers.length; i++) {
        var layer = this.layers[i];
        if (layer.id === id) {
          return layer;
        } else if (layer.findLayerById) {
          layer = layer.findLayerById(id);
          if (layer) {
            return layer;
          }
        }
      }

      return null;
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      return Object.assign(_get(LayerGroup.prototype.__proto__ || Object.getPrototypeOf(LayerGroup.prototype), 'toJSON', this).call(this), {
        rotation: this.rotation,
        scaleX: this.scaleX,
        scaleY: this.scaleY,
        pivotX: this.pivotX,
        pivotY: this.pivotY,
        translateX: this.translateX,
        translateY: this.translateY,
        layers: this.layers.map(function (layer) {
          return layer.toJSON();
        }),
        expanded: this.expanded
      });
    }
  }, {
    key: 'layers',
    get: function get() {
      return this.layers_ || [];
    },
    set: function set(layers) {
      var _this2 = this;

      this.layers_ = layers;
      this.layers_.forEach(function (layer) {
        return layer.parent = _this2;
      });
    }
  }, {
    key: 'typeString',
    get: function get() {
      return 'group';
    }
  }, {
    key: 'typeIdPrefix',
    get: function get() {
      return 'group';
    }
  }, {
    key: 'typeIcon',
    get: function get() {
      return 'layer_group';
    }
  }]);

  return LayerGroup;
}(_BaseLayer2.BaseLayer)) || _class);


_BaseLayer2.BaseLayer.LAYER_CLASSES_BY_TYPE['group'] = LayerGroup;

},{"./BaseLayer":31,"./properties":44}],33:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MaskLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _dec, _class; /*
                   * Copyright 2016 Google Inc.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *     http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

var _properties = require('./properties');

var _BaseLayer2 = require('./BaseLayer');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A mask layer (mask defined by a path) that clips/masks layers that follow it
 * within its layer group.
 */
var MaskLayer = exports.MaskLayer = (_dec = _properties.Property.register([new _properties.PathDataProperty('pathData', { animatable: true })]), _dec(_class = function (_BaseLayer) {
  _inherits(MaskLayer, _BaseLayer);

  function MaskLayer() {
    var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, MaskLayer);

    var _this = _possibleConstructorReturn(this, (MaskLayer.__proto__ || Object.getPrototypeOf(MaskLayer)).call(this, obj, opts));

    _this.pathData = obj.pathData || '';
    return _this;
  }

  _createClass(MaskLayer, [{
    key: 'computeBounds',
    value: function computeBounds() {
      return Object.assign({}, this.pathData && this.pathData.bounds ? this.pathData.bounds : null);
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      return Object.assign(_get(MaskLayer.prototype.__proto__ || Object.getPrototypeOf(MaskLayer.prototype), 'toJSON', this).call(this), {
        pathData: this.pathData.pathString
      });
    }
  }, {
    key: 'typeString',
    get: function get() {
      return 'mask';
    }
  }, {
    key: 'typeIdPrefix',
    get: function get() {
      return 'mask';
    }
  }, {
    key: 'typeIcon',
    get: function get() {
      return 'mask_layer';
    }
  }]);

  return MaskLayer;
}(_BaseLayer2.BaseLayer)) || _class);


_BaseLayer2.BaseLayer.LAYER_CLASSES_BY_TYPE['mask'] = MaskLayer;

},{"./BaseLayer":31,"./properties":44}],34:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PathLayer = exports.DefaultValues = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _dec, _class; /*
                   * Copyright 2016 Google Inc.
                   *
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   *     http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */

var _properties = require('./properties');

var _BaseLayer2 = require('./BaseLayer');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DefaultValues = exports.DefaultValues = {
  LINECAP: 'butt',
  LINEJOIN: 'miter',
  MITER_LIMIT: 4
};

var ENUM_LINECAP_OPTIONS = [{ value: 'butt', label: 'Butt' }, { value: 'square', label: 'Square' }, { value: 'round', label: 'Round' }];

var ENUM_LINEJOIN_OPTIONS = [{ value: 'miter', label: 'Miter' }, { value: 'round', label: 'Round' }, { value: 'bevel', label: 'Bevel' }];

/**
 * A path layer, which is the main building block for visible content in a vector
 * artwork.
 */
var PathLayer = exports.PathLayer = (_dec = _properties.Property.register([new _properties.PathDataProperty('pathData', { animatable: true }), new _properties.ColorProperty('fillColor', { animatable: true }), new _properties.FractionProperty('fillAlpha', { animatable: true }), new _properties.ColorProperty('strokeColor', { animatable: true }), new _properties.FractionProperty('strokeAlpha', { animatable: true }), new _properties.NumberProperty('strokeWidth', { min: 0, animatable: true }), new _properties.EnumProperty('strokeLinecap', ENUM_LINECAP_OPTIONS), new _properties.EnumProperty('strokeLinejoin', ENUM_LINEJOIN_OPTIONS), new _properties.NumberProperty('strokeMiterLimit', { min: 1 }), new _properties.FractionProperty('trimPathStart', { animatable: true }), new _properties.FractionProperty('trimPathEnd', { animatable: true }), new _properties.FractionProperty('trimPathOffset', { animatable: true })]), _dec(_class = function (_BaseLayer) {
  _inherits(PathLayer, _BaseLayer);

  function PathLayer() {
    var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, PathLayer);

    var _this = _possibleConstructorReturn(this, (PathLayer.__proto__ || Object.getPrototypeOf(PathLayer)).call(this, obj, opts));

    _this.pathData = obj.pathData || '';
    _this.fillColor = obj.fillColor || null;
    _this.fillAlpha = 'fillAlpha' in obj ? obj.fillAlpha : 1;
    _this.strokeColor = obj.strokeColor || '';
    _this.strokeAlpha = 'strokeAlpha' in obj ? obj.strokeAlpha : 1;
    _this.strokeWidth = obj.strokeWidth || 0;
    _this.strokeLinecap = obj.strokeLinecap || DefaultValues.LINECAP;
    _this.strokeLinejoin = obj.strokeLinejoin || DefaultValues.LINEJOIN;
    _this.strokeMiterLimit = obj.strokeMiterLimit || DefaultValues.MITER_LIMIT;
    _this.trimPathStart = obj.trimPathStart || 0;
    _this.trimPathEnd = 'trimPathEnd' in obj && typeof obj.trimPathEnd == 'number' ? obj.trimPathEnd : 1;
    _this.trimPathOffset = obj.trimPathOffset || 0;
    return _this;
  }

  _createClass(PathLayer, [{
    key: 'computeBounds',
    value: function computeBounds() {
      return Object.assign({}, this.pathData && this.pathData.bounds ? this.pathData.bounds : null);
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      return Object.assign(_get(PathLayer.prototype.__proto__ || Object.getPrototypeOf(PathLayer.prototype), 'toJSON', this).call(this), {
        pathData: this.pathData.pathString,
        fillColor: this.fillColor,
        fillAlpha: this.fillAlpha,
        strokeColor: this.strokeColor,
        strokeAlpha: this.strokeAlpha,
        strokeWidth: this.strokeWidth,
        strokeLinecap: this.strokeLinecap,
        strokeLinejoin: this.strokeLinejoin,
        strokeMiterLimit: this.strokeMiterLimit,
        trimPathStart: this.trimPathStart,
        trimPathEnd: this.trimPathEnd,
        trimPathOffset: this.trimPathOffset
      });
    }
  }, {
    key: 'typeString',
    get: function get() {
      return 'path';
    }
  }, {
    key: 'typeIdPrefix',
    get: function get() {
      return 'path';
    }
  }, {
    key: 'typeIcon',
    get: function get() {
      return 'path_layer';
    }
  }]);

  return PathLayer;
}(_BaseLayer2.BaseLayer)) || _class);


_BaseLayer2.BaseLayer.LAYER_CLASSES_BY_TYPE['path'] = PathLayer;

},{"./BaseLayer":31,"./properties":44}],35:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Animation = require('./Animation');

Object.defineProperty(exports, 'Animation', {
  enumerable: true,
  get: function get() {
    return _Animation.Animation;
  }
});

var _AnimationBlock = require('./AnimationBlock');

Object.defineProperty(exports, 'AnimationBlock', {
  enumerable: true,
  get: function get() {
    return _AnimationBlock.AnimationBlock;
  }
});

var _Artwork = require('./Artwork');

Object.defineProperty(exports, 'Artwork', {
  enumerable: true,
  get: function get() {
    return _Artwork.Artwork;
  }
});

var _BaseLayer = require('./BaseLayer');

Object.defineProperty(exports, 'BaseLayer', {
  enumerable: true,
  get: function get() {
    return _BaseLayer.BaseLayer;
  }
});

var _LayerGroup = require('./LayerGroup');

Object.defineProperty(exports, 'LayerGroup', {
  enumerable: true,
  get: function get() {
    return _LayerGroup.LayerGroup;
  }
});

var _MaskLayer = require('./MaskLayer');

Object.defineProperty(exports, 'MaskLayer', {
  enumerable: true,
  get: function get() {
    return _MaskLayer.MaskLayer;
  }
});

var _PathLayer = require('./PathLayer');

Object.defineProperty(exports, 'PathLayer', {
  enumerable: true,
  get: function get() {
    return _PathLayer.PathLayer;
  }
});
Object.defineProperty(exports, 'DefaultValues', {
  enumerable: true,
  get: function get() {
    return _PathLayer.DefaultValues;
  }
});

},{"./Animation":28,"./AnimationBlock":29,"./Artwork":30,"./BaseLayer":31,"./LayerGroup":32,"./MaskLayer":33,"./PathLayer":34}],36:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ColorProperty = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ColorUtil = require('ColorUtil');

var _MathUtil = require('MathUtil');

var _Property2 = require('./Property');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var ColorProperty = exports.ColorProperty = function (_Property) {
  _inherits(ColorProperty, _Property);

  function ColorProperty() {
    _classCallCheck(this, ColorProperty);

    return _possibleConstructorReturn(this, (ColorProperty.__proto__ || Object.getPrototypeOf(ColorProperty)).apply(this, arguments));
  }

  _createClass(ColorProperty, [{
    key: 'interpolateValue',
    value: function interpolateValue(start, end, f) {
      start = _ColorUtil.ColorUtil.parseAndroidColor(start);
      end = _ColorUtil.ColorUtil.parseAndroidColor(end);
      return _ColorUtil.ColorUtil.toAndroidString({
        r: _MathUtil.MathUtil.constrain(Math.round(_Property2.Property.simpleInterpolate(start.r, end.r, f)), 0, 255),
        g: _MathUtil.MathUtil.constrain(Math.round(_Property2.Property.simpleInterpolate(start.g, end.g, f)), 0, 255),
        b: _MathUtil.MathUtil.constrain(Math.round(_Property2.Property.simpleInterpolate(start.b, end.b, f)), 0, 255),
        a: _MathUtil.MathUtil.constrain(Math.round(_Property2.Property.simpleInterpolate(start.a, end.a, f)), 0, 255)
      });
    }
  }, {
    key: 'trySetEditedValue',
    value: function trySetEditedValue(obj, propertyName, value) {
      if (!value) {
        obj[propertyName] = null;
        return;
      }

      var processedValue = _ColorUtil.ColorUtil.parseAndroidColor(value);
      if (!processedValue) {
        processedValue = _ColorUtil.ColorUtil.parseAndroidColor(_ColorUtil.ColorUtil.svgToAndroidColor(value));
      }

      obj[propertyName] = _ColorUtil.ColorUtil.toAndroidString(processedValue);
    }
  }, {
    key: 'animatorValueType',
    get: function get() {
      return 'colorType';
    }
  }]);

  return ColorProperty;
}(_Property2.Property);

},{"./Property":42,"ColorUtil":15,"MathUtil":18}],37:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EnumProperty = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Property2 = require('./Property');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var EnumProperty = exports.EnumProperty = function (_Property) {
  _inherits(EnumProperty, _Property);

  function EnumProperty(name, options) {
    var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, EnumProperty);

    var _this = _possibleConstructorReturn(this, (EnumProperty.__proto__ || Object.getPrototypeOf(EnumProperty)).call(this, name, config));

    _this.optionsByValue_ = {};
    _this.options_ = (options || []).map(function (option) {
      var newOption = {};
      if (typeof option === 'string') {
        newOption = {
          value: option,
          label: option
        };
        option = newOption;
      }

      if (!('label' in option)) {
        option.label = option.value;
      }

      _this.optionsByValue_[option.value] = option;
      return option;
    });

    config = config || {};
    if (config.storeEntireOption) {
      _this.storeEntireOption = config.storeEntireOption;
    }
    return _this;
  }

  _createClass(EnumProperty, [{
    key: 'getter_',
    value: function getter_(obj, propertyName, value) {
      var backingPropertyName = propertyName + '_';
      return obj[backingPropertyName];
    }
  }, {
    key: 'setter_',
    value: function setter_(obj, propertyName, value) {
      var backingPropertyName = propertyName + '_';

      obj[backingPropertyName] = this.storeEntireOption ? this.getOptionForValue_(value) : this.getOptionForValue_(value).value;
    }
  }, {
    key: 'getOptionForValue_',
    value: function getOptionForValue_(value) {
      if (!value) {
        return null;
      }

      if (typeof value === 'string') {
        return this.optionsByValue_[value];
      } else if ('value' in value) {
        return value;
      }

      return null;
    }
  }, {
    key: 'displayValueForValue',
    value: function displayValueForValue(value) {
      if (!value) {
        return '';
      }

      return this.getOptionForValue_(value).label;
    }
  }, {
    key: 'options',
    get: function get() {
      return this.options_;
    }
  }]);

  return EnumProperty;
}(_Property2.Property);

},{"./Property":42}],38:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FractionProperty = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NumberProperty2 = require('./NumberProperty');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var FractionProperty = exports.FractionProperty = function (_NumberProperty) {
  _inherits(FractionProperty, _NumberProperty);

  function FractionProperty(name) {
    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, FractionProperty);

    config.min = 0;
    config.max = 1;
    return _possibleConstructorReturn(this, (FractionProperty.__proto__ || Object.getPrototypeOf(FractionProperty)).call(this, name, config));
  }

  _createClass(FractionProperty, [{
    key: 'animatorValueType',
    get: function get() {
      return 'floatType';
    }
  }]);

  return FractionProperty;
}(_NumberProperty2.NumberProperty);

},{"./NumberProperty":40}],39:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IdProperty = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Property2 = require('./Property');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var IdProperty = exports.IdProperty = function (_Property) {
  _inherits(IdProperty, _Property);

  function IdProperty() {
    _classCallCheck(this, IdProperty);

    return _possibleConstructorReturn(this, (IdProperty.__proto__ || Object.getPrototypeOf(IdProperty)).apply(this, arguments));
  }

  _createClass(IdProperty, [{
    key: 'trySetEditedValue',
    value: function trySetEditedValue(obj, propertyName, value) {
      obj[propertyName] = IdProperty.sanitize(value);
    }
  }], [{
    key: 'sanitize',
    value: function sanitize(value) {
      value = (value || '').toLowerCase().replace(/^\s+|\s+$/g, '').replace(/[\s-]+/g, '_').replace(/[^\w_]+/g, '');
      return value;
    }
  }]);

  return IdProperty;
}(_Property2.Property);

},{"./Property":42}],40:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NumberProperty = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Property2 = require('./Property');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var NumberProperty = exports.NumberProperty = function (_Property) {
  _inherits(NumberProperty, _Property);

  function NumberProperty(name) {
    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, NumberProperty);

    var _this = _possibleConstructorReturn(this, (NumberProperty.__proto__ || Object.getPrototypeOf(NumberProperty)).call(this, name, config));

    _this.config = config;
    return _this;
  }

  _createClass(NumberProperty, [{
    key: 'trySetEditedValue',
    value: function trySetEditedValue(obj, propertyName, value) {
      value = parseFloat(value);
      if (!isNaN(value)) {
        if ('min' in this.config) {
          value = Math.max(this.config.min, value);
        }
        if ('max' in this.config) {
          value = Math.min(this.config.max, value);
        }
        if (this.config.integer) {
          value = Math.floor(value);
        }
        obj[propertyName] = value;
      }
    }
  }, {
    key: 'displayValueForValue',
    value: function displayValueForValue(value) {
      if (typeof value === 'number') {
        return (Number.isInteger(value) ? value.toString() : Number(value.toFixed(3)).toString()).replace(/-/g, '\u2212');
      }
      return value;
    }
  }, {
    key: 'setter_',
    value: function setter_(obj, propertyName, value) {
      if (typeof value === 'string') {
        value = Number(value);
      }

      if (typeof value === 'number') {
        if (!isNaN(value)) {
          if ('min' in this.config) {
            value = Math.max(this.config.min, value);
          }
          if ('max' in this.config) {
            value = Math.min(this.config.max, value);
          }
          if (this.config.integer) {
            value = Math.floor(value);
          }
        }
      }

      var backingPropertyName = propertyName + '_';
      obj[backingPropertyName] = value;
    }
  }, {
    key: 'interpolateValue',
    value: function interpolateValue(start, end, f) {
      return _Property2.Property.simpleInterpolate(start, end, f);
    }
  }, {
    key: 'animatorValueType',
    get: function get() {
      return 'floatType';
    }
  }]);

  return NumberProperty;
}(_Property2.Property);

},{"./Property":42}],41:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PathDataProperty = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SvgPathData = require('SvgPathData');

var _Property2 = require('./Property');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var PathDataProperty = exports.PathDataProperty = function (_Property) {
  _inherits(PathDataProperty, _Property);

  function PathDataProperty() {
    _classCallCheck(this, PathDataProperty);

    return _possibleConstructorReturn(this, (PathDataProperty.__proto__ || Object.getPrototypeOf(PathDataProperty)).apply(this, arguments));
  }

  _createClass(PathDataProperty, [{
    key: 'interpolateValue',
    value: function interpolateValue(start, end, f) {
      return _SvgPathData.SvgPathData.interpolate(start, end, f);
    }
  }, {
    key: 'displayValueForValue',
    value: function displayValueForValue(val) {
      return val.pathString;
    }
  }, {
    key: 'getEditableValue',
    value: function getEditableValue(obj, propertyName) {
      return obj[propertyName] ? obj[propertyName].pathString : '';
    }
  }, {
    key: 'trySetEditedValue',
    value: function trySetEditedValue(obj, propertyName, stringValue) {
      obj[propertyName] = new _SvgPathData.SvgPathData(stringValue);
    }
  }, {
    key: 'getter_',
    value: function getter_(obj, propertyName) {
      var backingPropertyName = propertyName + '_';
      return obj[backingPropertyName];
    }
  }, {
    key: 'setter_',
    value: function setter_(obj, propertyName, value) {
      var backingPropertyName = propertyName + '_';
      var pathData = void 0;
      if (!value || value instanceof _SvgPathData.SvgPathData) {
        pathData = value;
      } else {
        pathData = new _SvgPathData.SvgPathData(value);
      }

      obj[backingPropertyName] = pathData;
    }
  }, {
    key: 'cloneValue',
    value: function cloneValue(val) {
      return JSON.parse(JSON.stringify(val));
    }
  }, {
    key: 'animatorValueType',
    get: function get() {
      return 'pathType';
    }
  }]);

  return PathDataProperty;
}(_Property2.Property);

},{"./Property":42,"SvgPathData":22}],42:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Property = exports.Property = function () {
  function Property(name) {
    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Property);

    this.name = name;
    this.config = config;
    this.animatable = config.animatable;
    this.inspectable = config.inspectable;
  }

  _createClass(Property, [{
    key: 'interpolateValue',
    value: function interpolateValue(start, end, f) {
      return start;
    }
  }, {
    key: 'getEditableValue',
    value: function getEditableValue(obj, propertyName) {
      return obj[propertyName];
    }
  }, {
    key: 'trySetEditedValue',
    value: function trySetEditedValue(obj, propertyName, value) {
      obj[propertyName] = value;
    }
  }, {
    key: 'getter_',
    value: function getter_(obj, propertyName, value) {
      var backingPropertyName = propertyName + '_';
      return obj[backingPropertyName];
    }
  }, {
    key: 'setter_',
    value: function setter_(obj, propertyName, value) {
      var backingPropertyName = propertyName + '_';
      obj[backingPropertyName] = value;
    }
  }, {
    key: 'displayValueForValue',
    value: function displayValueForValue(val) {
      return val;
    }
  }, {
    key: 'cloneValue',
    value: function cloneValue(val) {
      return val;
    }
  }], [{
    key: 'simpleInterpolate',
    value: function simpleInterpolate(start, end, f) {
      return start + (end - start) * f;
    }
  }, {
    key: 'register',
    value: function register(props) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref$reset = _ref.reset,
          reset = _ref$reset === undefined ? false : _ref$reset;

      return function (cls) {
        props.forEach(function (prop) {
          if (!(prop instanceof StubProperty)) {
            Object.defineProperty(cls.prototype, prop.name, {
              get: function get() {
                return prop.getter_(this, prop.name);
              },
              set: function set(value) {
                prop.setter_(this, prop.name, value);
              }
            });
          }
        });

        var animatableProperties = {};
        var inspectableProperties = {};

        if (!reset) {
          Object.assign(animatableProperties, cls.prototype.animatableProperties);
          Object.assign(inspectableProperties, cls.prototype.inspectableProperties);
        }

        props.forEach(function (prop) {
          if (prop.animatable) {
            animatableProperties[prop.name] = prop;
          }

          if (!prop.inspectable) {
            inspectableProperties[prop.name] = prop;
          }
        });

        Object.defineProperty(cls.prototype, 'animatableProperties', {
          get: function get() {
            return Object.assign({}, animatableProperties);
          }
        });

        Object.defineProperty(cls.prototype, 'inspectableProperties', {
          get: function get() {
            return Object.assign({}, inspectableProperties);
          }
        });
      };
    }
  }]);

  return Property;
}();

var StubProperty = exports.StubProperty = function (_Property) {
  _inherits(StubProperty, _Property);

  function StubProperty() {
    _classCallCheck(this, StubProperty);

    return _possibleConstructorReturn(this, (StubProperty.__proto__ || Object.getPrototypeOf(StubProperty)).apply(this, arguments));
  }

  return StubProperty;
}(Property);

},{}],43:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StringProperty = undefined;

var _Property2 = require('./Property');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var StringProperty = exports.StringProperty = function (_Property) {
  _inherits(StringProperty, _Property);

  function StringProperty() {
    _classCallCheck(this, StringProperty);

    return _possibleConstructorReturn(this, (StringProperty.__proto__ || Object.getPrototypeOf(StringProperty)).apply(this, arguments));
  }

  return StringProperty;
}(_Property2.Property);

},{"./Property":42}],44:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ColorProperty = require('./ColorProperty');

Object.defineProperty(exports, 'ColorProperty', {
  enumerable: true,
  get: function get() {
    return _ColorProperty.ColorProperty;
  }
});

var _EnumProperty = require('./EnumProperty');

Object.defineProperty(exports, 'EnumProperty', {
  enumerable: true,
  get: function get() {
    return _EnumProperty.EnumProperty;
  }
});

var _FractionProperty = require('./FractionProperty');

Object.defineProperty(exports, 'FractionProperty', {
  enumerable: true,
  get: function get() {
    return _FractionProperty.FractionProperty;
  }
});

var _IdProperty = require('./IdProperty');

Object.defineProperty(exports, 'IdProperty', {
  enumerable: true,
  get: function get() {
    return _IdProperty.IdProperty;
  }
});

var _NumberProperty = require('./NumberProperty');

Object.defineProperty(exports, 'NumberProperty', {
  enumerable: true,
  get: function get() {
    return _NumberProperty.NumberProperty;
  }
});

var _PathDataProperty = require('./PathDataProperty');

Object.defineProperty(exports, 'PathDataProperty', {
  enumerable: true,
  get: function get() {
    return _PathDataProperty.PathDataProperty;
  }
});

var _Property = require('./Property');

Object.defineProperty(exports, 'Property', {
  enumerable: true,
  get: function get() {
    return _Property.Property;
  }
});
Object.defineProperty(exports, 'StubProperty', {
  enumerable: true,
  get: function get() {
    return _Property.StubProperty;
  }
});

var _StringProperty = require('./StringProperty');

Object.defineProperty(exports, 'StringProperty', {
  enumerable: true,
  get: function get() {
    return _StringProperty.StringProperty;
  }
});

},{"./ColorProperty":36,"./EnumProperty":37,"./FractionProperty":38,"./IdProperty":39,"./NumberProperty":40,"./PathDataProperty":41,"./Property":42,"./StringProperty":43}],45:[function(require,module,exports){
'use strict';

/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module.exports.routeConfig = function ($locationProvider, $routeProvider) {
  $locationProvider.html5Mode(true);

  $routeProvider.otherwise({
    templateUrl: 'pages/studio/studio.html'
  });
};

Object.assign(module.exports, {
  studio: function studio() {
    return '/';
  }
});

},{}],46:[function(require,module,exports){
'use strict';

/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Based on https://github.com/cburgmer/xmlserializer/blob/master/lib/serializer.js
// Other options for pretty-printing:
// - https://github.com/travisleithead/xmlserialization-polyfill
// - https://github.com/prettydiff/prettydiff/blob/master/lib/markuppretty.js
// - https://github.com/vkiryukhin/vkBeautify

var removeInvalidCharacters = function removeInvalidCharacters(content) {
    // See http://www.w3.org/TR/xml/#NT-Char for valid XML 1.0 characters
    return content.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F]/g, '');
};

var serializeAttributeValue = function serializeAttributeValue(value) {
    return value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;');
};

var serializeTextContent = function serializeTextContent(content) {
    return content.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
};

var serializeAttribute = function serializeAttribute(attr) {
    var value = attr.value;

    return attr.name + '="' + serializeAttributeValue(value) + '"';
};

var getTagName = function getTagName(node) {
    var tagName = node.tagName;

    // Aid in serializing of original HTML documents
    if (node.namespaceURI === 'http://www.w3.org/1999/xhtml') {
        tagName = tagName.toLowerCase();
    }
    return tagName;
};

var serializeNamespace = function serializeNamespace(node, options) {
    var nodeHasXmlnsAttr = Array.prototype.map.call(node.attributes || node.attrs, function (attr) {
        return attr.name;
    }).indexOf('xmlns') >= 0;
    // Serialize the namespace as an xmlns attribute whenever the element
    // doesn't already have one and the inherited namespace does not match
    // the element's namespace.
    if (!nodeHasXmlnsAttr && node.namespaceURI && options.isRootNode /* ||
                                                                     node.namespaceURI !== node.parentNode.namespaceURI*/) {
        return ' xmlns="' + node.namespaceURI + '"';
    } else {
        return '';
    }
};

var serializeChildren = function serializeChildren(node, options) {
    return Array.prototype.map.call(node.childNodes, function (childNode) {
        return nodeTreeToXHTML(childNode, options);
    }).join('');
};

var serializeTag = function serializeTag(node, options) {
    var output = '';
    if (options.indent && options._indentLevel) {
        output += Array(options._indentLevel * options.indent + 1).join(' ');
    }
    output += '<' + getTagName(node);
    output += serializeNamespace(node, options.isRootNode);

    var attributes = node.attributes || node.attrs;
    Array.prototype.forEach.call(attributes, function (attr) {
        if (options.multiAttributeIndent && attributes.length > 1) {
            output += '\n';
            output += Array((options._indentLevel || 0) * options.indent + options.multiAttributeIndent + 1).join(' ');
        } else {
            output += ' ';
        }
        output += serializeAttribute(attr);
    });

    if (node.childNodes.length > 0) {
        output += '>';
        if (options.indent) {
            output += '\n';
        }
        options.isRootNode = false;
        options._indentLevel = (options._indentLevel || 0) + 1;
        output += serializeChildren(node, options);
        --options._indentLevel;
        if (options.indent && options._indentLevel) {
            output += Array(options._indentLevel * options.indent + 1).join(' ');
        }
        output += '</' + getTagName(node) + '>';
    } else {
        output += '/>';
    }
    if (options.indent) {
        output += '\n';
    }
    return output;
};

var serializeText = function serializeText(node) {
    var text = node.nodeValue || node.value || '';
    return serializeTextContent(text);
};

var serializeComment = function serializeComment(node) {
    return '<!--' + node.data.replace(/-/g, '&#45;') + '-->';
};

var serializeCDATA = function serializeCDATA(node) {
    return '<![CDATA[' + node.nodeValue + ']]>';
};

var nodeTreeToXHTML = function nodeTreeToXHTML(node, options) {
    if (node.nodeName === '#document' || node.nodeName === '#document-fragment') {
        return serializeChildren(node, options);
    } else {
        if (node.tagName) {
            return serializeTag(node, options);
        } else if (node.nodeName === '#text') {
            return serializeText(node);
        } else if (node.nodeName === '#comment') {
            return serializeComment(node);
        } else if (node.nodeName === '#cdata-section') {
            return serializeCDATA(node);
        }
    }
};

exports.serializeToString = function (node, options) {
    options = options || {};
    options.rootNode = true;
    return removeInvalidCharacters(nodeTreeToXHTML(node, options));
};

},{}],47:[function(require,module,exports){
/**
 * https://github.com/gre/bezier-easing
 * BezierEasing - use bezier curve for transition easing function
 * by Gatan Renaudeau 2014 - 2015  MIT License
 */

// These values are established by empiricism with tests (tradeoff: performance VS precision)
var NEWTON_ITERATIONS = 4;
var NEWTON_MIN_SLOPE = 0.001;
var SUBDIVISION_PRECISION = 0.0000001;
var SUBDIVISION_MAX_ITERATIONS = 10;

var kSplineTableSize = 11;
var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

var float32ArraySupported = typeof Float32Array === 'function';

function A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }
function B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }
function C (aA1)      { return 3.0 * aA1; }

// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
function calcBezier (aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT; }

// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
function getSlope (aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1); }

function binarySubdivide (aX, aA, aB, mX1, mX2) {
  var currentX, currentT, i = 0;
  do {
    currentT = aA + (aB - aA) / 2.0;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0.0) {
      aB = currentT;
    } else {
      aA = currentT;
    }
  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
  return currentT;
}

function newtonRaphsonIterate (aX, aGuessT, mX1, mX2) {
 for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
   var currentSlope = getSlope(aGuessT, mX1, mX2);
   if (currentSlope === 0.0) {
     return aGuessT;
   }
   var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
   aGuessT -= currentX / currentSlope;
 }
 return aGuessT;
}

module.exports = function bezier (mX1, mY1, mX2, mY2) {
  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
    throw new Error('bezier x values must be in [0, 1] range');
  }

  // Precompute samples table
  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
  if (mX1 !== mY1 || mX2 !== mY2) {
    for (var i = 0; i < kSplineTableSize; ++i) {
      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
    }
  }

  function getTForX (aX) {
    var intervalStart = 0.0;
    var currentSample = 1;
    var lastSample = kSplineTableSize - 1;

    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }
    --currentSample;

    // Interpolate to provide an initial guess for t
    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
    var guessForT = intervalStart + dist * kSampleStepSize;

    var initialSlope = getSlope(guessForT, mX1, mX2);
    if (initialSlope >= NEWTON_MIN_SLOPE) {
      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    } else if (initialSlope === 0.0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    }
  }

  return function BezierEasing (x) {
    if (mX1 === mY1 && mX2 === mY2) {
      return x; // linear
    }
    // Because JavaScript number are imprecise, we should guarantee the extremes are right.
    if (x === 0) {
      return 0;
    }
    if (x === 1) {
      return 1;
    }
    return calcBezier(getTForX(x), mY1, mY2);
  };
};

},{}],48:[function(require,module,exports){
module.exports = require('./lib/bezier');

},{"./lib/bezier":49}],49:[function(require,module,exports){
/**
  A javascript Bezier curve library by Pomax.

  Based on http://pomax.github.io/bezierinfo

  This code is MIT licensed.
**/
(function() {
  "use strict";

  // math-inlining.
  var abs = Math.abs,
      min = Math.min,
      max = Math.max,
      acos = Math.acos,
      sqrt = Math.sqrt,
      pi = Math.PI,
      // a zero coordinate, which is surprisingly useful
      ZERO = {x:0,y:0,z:0};

  // quite needed
  var utils = require('./utils.js');

  // not quite needed, but eventually this'll be useful...
  var PolyBezier = require('./poly-bezier.js');

  /**
   * Bezier curve constructor. The constructor argument can be one of three things:
   *
   * 1. array/4 of {x:..., y:..., z:...}, z optional
   * 2. numerical array/8 ordered x1,y1,x2,y2,x3,y3,x4,y4
   * 3. numerical array/12 ordered x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4
   *
   */
  var Bezier = function(coords) {
    var args = (coords && coords.forEach) ? coords : [].slice.call(arguments);
    var coordlen = false;
    if(typeof args[0] === "object") {
      coordlen = args.length;
      var newargs = [];
      args.forEach(function(point) {
        ['x','y','z'].forEach(function(d) {
          if(typeof point[d] !== "undefined") {
            newargs.push(point[d]);
          }
        });
      });
      args = newargs;
    }
    var higher = false;
    var len = args.length;
    if (coordlen) {
      if(coordlen>4) {
        if (arguments.length !== 1) {
          throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");
        }
        higher = true;
      }
    } else {
      if(len!==6 && len!==8 && len!==9 && len!==12) {
        if (arguments.length !== 1) {
          throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");
        }
      }
    }
    var _3d = (!higher && (len === 9 || len === 12)) || (coords && coords[0] && typeof coords[0].z !== "undefined");
    this._3d = _3d;
    var points = [];
    for(var idx=0, step=(_3d ? 3 : 2); idx<len; idx+=step) {
      var point = {
        x: args[idx],
        y: args[idx+1]
      };
      if(_3d) { point.z = args[idx+2] };
      points.push(point);
    }
    this.order = points.length - 1;
    this.points = points;
    var dims = ['x','y'];
    if(_3d) dims.push('z');
    this.dims = dims;
    this.dimlen = dims.length;

    (function(curve) {
      var order = curve.order;
      var points = curve.points;
      var a = utils.align(points, {p1:points[0], p2:points[order]});
      for(var i=0; i<a.length; i++) {
        if(abs(a[i].y) > 0.0001) {
          curve._linear = false;
          return;
        }
      }
      curve._linear = true;
    }(this));

    this._t1 = 0;
    this._t2 = 1;
    this.update();
  };

  Bezier.fromSVG = function(svgString) {
    var list = svgString.match(/[-+]?\d*\.?\d+(?:[eE][-+]?\d+)?/g).map(parseFloat);
    var relative = /[cq]/.test(svgString);
    if(!relative) return new Bezier(list);
    list = list.map(function(v,i) {
      return i < 2 ? v : v + list[i % 2];
    });
    return new Bezier(list);
  };

  function getABC(n,S,B,E,t) {
    if(typeof t === "undefined") { t = 0.5; }
    var u = utils.projectionratio(t,n),
        um = 1-u,
        C = {
          x: u*S.x + um*E.x,
          y: u*S.y + um*E.y
        },
        s = utils.abcratio(t,n),
        A = {
          x: B.x + (B.x-C.x)/s,
          y: B.y + (B.y-C.y)/s
        };
    return { A:A, B:B, C:C };
  }

  Bezier.quadraticFromPoints = function(p1,p2,p3, t) {
    if(typeof t === "undefined") { t = 0.5; }
    // shortcuts, although they're really dumb
    if(t===0) { return new Bezier(p2,p2,p3); }
    if(t===1) { return new Bezier(p1,p2,p2); }
    // real fitting.
    var abc = getABC(2,p1,p2,p3,t);
    return new Bezier(p1, abc.A, p3);
  };

  Bezier.cubicFromPoints = function(S,B,E, t,d1) {
    if(typeof t === "undefined") { t = 0.5; }
    var abc = getABC(3,S,B,E,t);
    if(typeof d1 === "undefined") { d1 = utils.dist(B,abc.C); }
    var d2 = d1 * (1-t)/t;

    var selen = utils.dist(S,E),
        lx = (E.x-S.x)/selen,
        ly = (E.y-S.y)/selen,
        bx1 = d1 * lx,
        by1 = d1 * ly,
        bx2 = d2 * lx,
        by2 = d2 * ly;
    // derivation of new hull coordinates
    var e1  = { x: B.x - bx1, y: B.y - by1 },
        e2  = { x: B.x + bx2, y: B.y + by2 },
        A = abc.A,
        v1  = { x: A.x + (e1.x-A.x)/(1-t), y: A.y + (e1.y-A.y)/(1-t) },
        v2  = { x: A.x + (e2.x-A.x)/(t), y: A.y + (e2.y-A.y)/(t) },
        nc1 = { x: S.x + (v1.x-S.x)/(t), y: S.y + (v1.y-S.y)/(t) },
        nc2 = { x: E.x + (v2.x-E.x)/(1-t), y: E.y + (v2.y-E.y)/(1-t) };
    // ...done
    return new Bezier(S,nc1,nc2,E);
  };

  var getUtils = function() {
    return utils;
  };

  Bezier.getUtils = getUtils;

  Bezier.prototype = {
    getUtils: getUtils,
    valueOf: function() {
      return this.toString();
    },
    toString: function() {
      return utils.pointsToString(this.points);
    },
    toSVG: function(relative) {
      if(this._3d) return false;
      var p = this.points,
          x = p[0].x,
          y = p[0].y,
          s = ["M", x, y, (this.order===2 ? "Q":"C")];
      for(var i=1, last=p.length; i<last; i++) {
        s.push(p[i].x);
        s.push(p[i].y);
      }
      return s.join(" ");
    },
    update: function() {
      // one-time compute derivative coordinates
      this.dpoints = [];
      for(var p=this.points, d=p.length, c=d-1; d>1; d--, c--) {
        var list = [];
        for(var j=0, dpt; j<c; j++) {
          dpt = {
            x: c * (p[j+1].x - p[j].x),
            y: c * (p[j+1].y - p[j].y)
          };
          if(this._3d) {
            dpt.z = c * (p[j+1].z - p[j].z);
          }
          list.push(dpt);
        }
        this.dpoints.push(list);
        p = list;
      };
      this.computedirection();
    },
    computedirection: function() {
      var points = this.points;
      var angle = utils.angle(points[0], points[this.order], points[1]);
      this.clockwise = angle > 0;
    },
    length: function() {
      return utils.length(this.derivative.bind(this));
    },
    _lut: [],
    getLUT: function(steps) {
      steps = steps || 100;
      if (this._lut.length === steps) { return this._lut; }
      this._lut = [];
      for(var t=0; t<=steps; t++) {
        this._lut.push(this.compute(t/steps));
      }
      return this._lut;
    },
    on: function(point, error) {
      error = error || 5;
      var lut = this.getLUT(), hits = [], c, t=0;
      for(var i=0; i<lut.length; i++) {
        c = lut[i];
        if (utils.dist(c,point) < error) {
          hits.push(c)
          t += i / lut.length;
        }
      }
      if(!hits.length) return false;
      return t /= hits.length;
    },
    project: function(point) {
      // step 1: coarse check
      var LUT = this.getLUT(), l = LUT.length-1,
          closest = utils.closest(LUT, point),
          mdist = closest.mdist,
          mpos = closest.mpos;
      if (mpos===0 || mpos===l) {
        var t = mpos/l, pt = this.compute(t);
        pt.t = t;
        pt.d = mdist;
        return pt;
      }

      // step 2: fine check
      var ft, t, p, d,
          t1 = (mpos-1)/l,
          t2 = (mpos+1)/l,
          step = 0.1/l;
      mdist += 1;
      for(t=t1,ft=t; t<t2+step; t+=step) {
        p = this.compute(t);
        d = utils.dist(point, p);
        if (d<mdist) {
          mdist = d;
          ft = t;
        }
      }
      p = this.compute(ft);
      p.t = ft;
      p.d = mdist;
      return p;
    },
    get: function(t) {
      return this.compute(t);
    },
    point: function(idx) {
      return this.points[idx];
    },
    compute: function(t) {
      // shortcuts
      if(t===0) { return this.points[0]; }
      if(t===1) { return this.points[this.order]; }

      var p = this.points;
      var mt = 1-t;

      // linear?
      if(this.order===1) {
        ret = {
          x: mt*p[0].x + t*p[1].x,
          y: mt*p[0].y + t*p[1].y
        };
        if (this._3d) { ret.z = mt*p[0].z + t*p[1].z; }
        return ret;
      }

      // quadratic/cubic curve?
      if(this.order<4) {
        var mt2 = mt*mt,
            t2 = t*t,
            a,b,c,d = 0;
        if(this.order===2) {
          p = [p[0], p[1], p[2], ZERO];
          a = mt2;
          b = mt*t*2;
          c = t2;
        }
        else if(this.order===3) {
          a = mt2*mt;
          b = mt2*t*3;
          c = mt*t2*3;
          d = t*t2;
        }
        var ret = {
          x: a*p[0].x + b*p[1].x + c*p[2].x + d*p[3].x,
          y: a*p[0].y + b*p[1].y + c*p[2].y + d*p[3].y
        };
        if(this._3d) {
          ret.z = a*p[0].z + b*p[1].z + c*p[2].z + d*p[3].z;
        }
        return ret;
      }

      // higher order curves: use de Casteljau's computation
      var dCpts = JSON.parse(JSON.stringify(this.points));
      while(dCpts.length > 1) {
        for (var i=0; i<dCpts.length-1; i++) {
          dCpts[i] = {
            x: dCpts[i].x + (dCpts[i+1].x - dCpts[i].x) * t,
            y: dCpts[i].y + (dCpts[i+1].y - dCpts[i].y) * t
          };
          if (typeof dCpts[i].z !== "undefined") {
            dCpts[i] = dCpts[i].z + (dCpts[i+1].z - dCpts[i].z) * t
          }
        }
        dCpts.splice(dCpts.length-1, 1);
      }
      return dCpts[0];
    },
    raise: function() {
      var p = this.points, np = [p[0]], i, k=p.length, pi, pim;
      for (var i=1; i<k; i++) {
        pi = p[i];
        pim = p[i-1];
        np[i] = {
          x: (k-i)/k * pi.x + i/k * pim.x,
          y: (k-i)/k * pi.y + i/k * pim.y
        };
      }
      np[k] = p[k-1];
      return new Bezier(np);
    },
    derivative: function(t) {
      var mt = 1-t,
          a,b,c=0,
          p = this.dpoints[0];
      if(this.order===2) { p = [p[0], p[1], ZERO]; a = mt; b = t; }
      if(this.order===3) { a = mt*mt; b = mt*t*2; c = t*t; }
      var ret = {
        x: a*p[0].x + b*p[1].x + c*p[2].x,
        y: a*p[0].y + b*p[1].y + c*p[2].y
      };
      if(this._3d) {
        ret.z = a*p[0].z + b*p[1].z + c*p[2].z;
      }
      return ret;
    },
    inflections: function() {
      return utils.inflections(this.points);
    },
    normal: function(t) {
      return this._3d ? this.__normal3(t) : this.__normal2(t);
    },
    __normal2: function(t) {
      var d = this.derivative(t);
      var q = sqrt(d.x*d.x + d.y*d.y)
      return { x: -d.y/q, y: d.x/q };
    },
    __normal3: function(t) {
      // see http://stackoverflow.com/questions/25453159
      var r1 = this.derivative(t),
          r2 = this.derivative(t+0.01),
          q1 = sqrt(r1.x*r1.x + r1.y*r1.y + r1.z*r1.z),
          q2 = sqrt(r2.x*r2.x + r2.y*r2.y + r2.z*r2.z);
      r1.x /= q1; r1.y /= q1; r1.z /= q1;
      r2.x /= q2; r2.y /= q2; r2.z /= q2;
      // cross product
      var c = {
        x: r2.y*r1.z - r2.z*r1.y,
        y: r2.z*r1.x - r2.x*r1.z,
        z: r2.x*r1.y - r2.y*r1.x
      };
      var m = sqrt(c.x*c.x + c.y*c.y + c.z*c.z);
      c.x /= m; c.y /= m; c.z /= m;
      // rotation matrix
      var R = [   c.x*c.x,   c.x*c.y-c.z, c.x*c.z+c.y,
                c.x*c.y+c.z,   c.y*c.y,   c.y*c.z-c.x,
                c.x*c.z-c.y, c.y*c.z+c.x,   c.z*c.z    ];
      // normal vector:
      var n = {
        x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,
        y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,
        z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z
      };
      return n;
    },
    hull: function(t) {
      var p = this.points,
          _p = [],
          pt,
          q = [],
          idx = 0,
          i=0,
          l=0;
      q[idx++] = p[0];
      q[idx++] = p[1];
      q[idx++] = p[2];
      if(this.order === 3) { q[idx++] = p[3]; }
      // we lerp between all points at each iteration, until we have 1 point left.
      while(p.length>1) {
        _p = [];
        for(i=0, l=p.length-1; i<l; i++) {
          pt = utils.lerp(t,p[i],p[i+1]);
          q[idx++] = pt;
          _p.push(pt);
        }
        p = _p;
      }
      return q;
    },
    split: function(t1, t2) {
      // shortcuts
      if(t1===0 && !!t2) { return this.split(t2).left; }
      if(t2===1) { return this.split(t1).right; }

      // no shortcut: use "de Casteljau" iteration.
      var q = this.hull(t1);
      var result = {
        left: this.order === 2 ? new Bezier([q[0],q[3],q[5]]) : new Bezier([q[0],q[4],q[7],q[9]]),
        right: this.order === 2 ? new Bezier([q[5],q[4],q[2]]) : new Bezier([q[9],q[8],q[6],q[3]]),
        span: q
      };

      // make sure we bind _t1/_t2 information!
      result.left._t1  = utils.map(0,  0,1, this._t1,this._t2);
      result.left._t2  = utils.map(t1, 0,1, this._t1,this._t2);
      result.right._t1 = utils.map(t1, 0,1, this._t1,this._t2);
      result.right._t2 = utils.map(1,  0,1, this._t1,this._t2);

      // if we have no t2, we're done
      if(!t2) { return result; }

      // if we have a t2, split again:
      t2 = utils.map(t2,t1,1,0,1);
      var subsplit = result.right.split(t2);
      return subsplit.left;
    },
    extrema: function() {
      var dims = this.dims,
          result={},
          roots=[],
          p, mfn;
      dims.forEach(function(dim) {
        mfn = function(v) { return v[dim]; };
        p = this.dpoints[0].map(mfn);
        result[dim] = utils.droots(p);
        if(this.order === 3) {
          p = this.dpoints[1].map(mfn);
          result[dim] = result[dim].concat(utils.droots(p));
        }
        result[dim] = result[dim].filter(function(t) { return (t>=0 && t<=1); });
        roots = roots.concat(result[dim].sort());
      }.bind(this));
      roots = roots.sort().filter(function(v,idx) { return (roots.indexOf(v) === idx); });
      result.values = roots;
      return result;
    },
    bbox: function() {
      var extrema = this.extrema(), result = {};
      this.dims.forEach(function(d) {
        result[d] = utils.getminmax(this, d, extrema[d]);
      }.bind(this));
      return result;
    },
    overlaps: function(curve) {
      var lbbox = this.bbox(),
          tbbox = curve.bbox();
      return utils.bboxoverlap(lbbox,tbbox);
    },
    offset: function(t, d) {
      if(typeof d !== "undefined") {
        var c = this.get(t);
        var n = this.normal(t);
        var ret = {
          c: c,
          n: n,
          x: c.x + n.x * d,
          y: c.y + n.y * d
        };
        if(this._3d) {
          ret.z = c.z + n.z * d;
        };
        return ret;
      }
      if(this._linear) {
        var nv = this.normal(0);
        var coords = this.points.map(function(p) {
          var ret = {
            x: p.x + t * nv.x,
            y: p.y + t * nv.y
          };
          if(p.z && n.z) { ret.z = p.z + t * nv.z; }
          return ret;
        });
        return [new Bezier(coords)];
      }
      var reduced = this.reduce();
      return reduced.map(function(s) {
        return s.scale(t);
      });
    },
    simple: function() {
      if(this.order===3) {
        var a1 = utils.angle(this.points[0], this.points[3], this.points[1]);
        var a2 = utils.angle(this.points[0], this.points[3], this.points[2]);
        if(a1>0 && a2<0 || a1<0 && a2>0) return false;
      }
      var n1 = this.normal(0);
      var n2 = this.normal(1);
      var s = n1.x*n2.x + n1.y*n2.y;
      if(this._3d) { s += n1.z*n2.z; }
      var angle = abs(acos(s));
      return angle < pi/3;
    },
    reduce: function() {
      var i, t1=0, t2=0, step=0.01, segment, pass1=[], pass2=[];
      // first pass: split on extrema
      var extrema = this.extrema().values;
      if(extrema.indexOf(0)===-1) { extrema = [0].concat(extrema); }
      if(extrema.indexOf(1)===-1) { extrema.push(1); }

      for(t1=extrema[0], i=1; i<extrema.length; i++) {
        t2 = extrema[i];
        segment = this.split(t1,t2);
        segment._t1 = t1;
        segment._t2 = t2;
        pass1.push(segment);
        t1 = t2;
      }

      // second pass: further reduce these segments to simple segments
      pass1.forEach(function(p1) {
        t1=0;
        t2=0;
        while(t2 <= 1) {
          for(t2=t1+step; t2<=1+step; t2+=step) {
            segment = p1.split(t1,t2);
            if(!segment.simple()) {
              t2 -= step;
              if(abs(t1-t2)<step) {
                // we can never form a reduction
                return [];
              }
              segment = p1.split(t1,t2);
              segment._t1 = utils.map(t1,0,1,p1._t1,p1._t2);
              segment._t2 = utils.map(t2,0,1,p1._t1,p1._t2);
              pass2.push(segment);
              t1 = t2;
              break;
            }
          }
        }
        if(t1<1) {
          segment = p1.split(t1,1);
          segment._t1 = utils.map(t1,0,1,p1._t1,p1._t2);
          segment._t2 = p1._t2;
          pass2.push(segment);
        }
      });
      return pass2;
    },
    scale: function(d) {
      var order = this.order;
      var distanceFn = false
      if(typeof d === "function") { distanceFn = d; }
      if(distanceFn && order === 2) { return this.raise().scale(distanceFn); }

      // TODO: add special handling for degenerate (=linear) curves.
      var clockwise = this.clockwise;
      var r1 = distanceFn ? distanceFn(0) : d;
      var r2 = distanceFn ? distanceFn(1) : d;
      var v = [ this.offset(0,10), this.offset(1,10) ];
      var o = utils.lli4(v[0], v[0].c, v[1], v[1].c);
      if(!o) { throw new Error("cannot scale this curve. Try reducing it first."); }
      // move all points by distance 'd' wrt the origin 'o'
      var points=this.points, np=[];

      // move end points by fixed distance along normal.
      [0,1].forEach(function(t) {
        var p = np[t*order] = utils.copy(points[t*order]);
        p.x += (t?r2:r1) * v[t].n.x;
        p.y += (t?r2:r1) * v[t].n.y;
      }.bind(this));

      if (!distanceFn) {
        // move control points to lie on the intersection of the offset
        // derivative vector, and the origin-through-control vector
        [0,1].forEach(function(t) {
          if(this.order===2 && !!t) return;
          var p = np[t*order];
          var d = this.derivative(t);
          var p2 = { x: p.x + d.x, y: p.y + d.y };
          np[t+1] = utils.lli4(p, p2, o, points[t+1]);
        }.bind(this));
        return new Bezier(np);
      }

      // move control points by "however much necessary to
      // ensure the correct tangent to endpoint".
      [0,1].forEach(function(t) {
        if(this.order===2 && !!t) return;
        var p = points[t+1];
        var ov = {
          x: p.x - o.x,
          y: p.y - o.y
        };
        var rc = distanceFn ? distanceFn((t+1)/order) : d;
        if(distanceFn && !clockwise) rc = -rc;
        var m = sqrt(ov.x*ov.x + ov.y*ov.y);
        ov.x /= m;
        ov.y /= m;
        np[t+1] = {
          x: p.x + rc*ov.x,
          y: p.y + rc*ov.y
        }
      }.bind(this));
      return new Bezier(np);
    },
    outline: function(d1, d2, d3, d4) {
      d2 = (typeof d2 === "undefined") ? d1 : d2;
      var reduced = this.reduce(),
          len = reduced.length,
          fcurves = [],
          bcurves = [],
          p,
          alen = 0,
          tlen = this.length();

      var graduated = (typeof d3 !== "undefined" && typeof d4 !== "undefined");

      function linearDistanceFunction(s,e, tlen,alen,slen) {
        return function (v) {
          var f1 = alen/tlen, f2 = (alen+slen)/tlen, d = e-s;
          return utils.map(v, 0,1, s+f1*d, s+f2*d);
        };
      };

      // form curve oulines
      reduced.forEach(function(segment) {
        slen = segment.length();
        if (graduated) {
          fcurves.push(segment.scale(  linearDistanceFunction( d1, d3, tlen,alen,slen)  ));
          bcurves.push(segment.scale(  linearDistanceFunction(-d2,-d4, tlen,alen,slen)  ));
        } else {
          fcurves.push(segment.scale( d1));
          bcurves.push(segment.scale(-d2));
        }
        alen += slen;
      });

      // reverse the "return" outline
      bcurves = bcurves.map(function(s) {
        p = s.points;
        if(p[3]) { s.points = [p[3],p[2],p[1],p[0]]; }
        else { s.points = [p[2],p[1],p[0]]; }
        return s;
      }).reverse();

      // form the endcaps as lines
      var fs = fcurves[0].points[0],
          fe = fcurves[len-1].points[fcurves[len-1].points.length-1],
          bs = bcurves[len-1].points[bcurves[len-1].points.length-1],
          be = bcurves[0].points[0],
          ls = utils.makeline(bs,fs),
          le = utils.makeline(fe,be),
          segments = [ls].concat(fcurves).concat([le]).concat(bcurves),
          slen = segments.length;

      return new PolyBezier(segments);
    },
    outlineshapes: function(d1, d2, curveIntersectionThreshold) {
      d2 = d2 || d1;
      var outline = this.outline(d1,d2).curves;
      var shapes = [];
      for(var i=1, len=outline.length; i < len/2; i++) {
        var shape = utils.makeshape(outline[i], outline[len-i], curveIntersectionThreshold);
        shape.startcap.virtual = (i > 1);
        shape.endcap.virtual = (i < len/2-1);
        shapes.push(shape);
      }
      return shapes;
    },
    intersects: function(curve, curveIntersectionThreshold) {
      if(!curve) return this.selfintersects(curveIntersectionThreshold);
      if(curve.p1 && curve.p2) {
        return this.lineIntersects(curve);
      }
      if(curve instanceof Bezier) { curve = curve.reduce(); }
      return this.curveintersects(this.reduce(), curve, curveIntersectionThreshold);
    },
    lineIntersects: function(line) {
      var mx = min(line.p1.x, line.p2.x),
          my = min(line.p1.y, line.p2.y),
          MX = max(line.p1.x, line.p2.x),
          MY = max(line.p1.y, line.p2.y),
          self=this;
      return utils.roots(this.points, line).filter(function(t) {
        var p = self.get(t);
        return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);
      });
    },
    selfintersects: function(curveIntersectionThreshold) {
      var reduced = this.reduce();
      // "simple" curves cannot intersect with their direct
      // neighbour, so for each segment X we check whether
      // it intersects [0:x-2][x+2:last].
      var i,len=reduced.length-2,results=[],result,left,right;
      for(i=0; i<len; i++) {
        left = reduced.slice(i,i+1);
        right = reduced.slice(i+2);
        result = this.curveintersects(left, right, curveIntersectionThreshold);
        results = results.concat( result );
      }
      return results;
    },
    curveintersects: function(c1, c2, curveIntersectionThreshold) {
      var pairs = [];
      // step 1: pair off any overlapping segments
      c1.forEach(function(l) {
        c2.forEach(function(r) {
          if(l.overlaps(r)) {
            pairs.push({ left: l, right: r });
          }
        });
      });
      // step 2: for each pairing, run through the convergence algorithm.
      var intersections = [];
      pairs.forEach(function(pair) {
        var result = utils.pairiteration(pair.left, pair.right, curveIntersectionThreshold);
        if(result.length > 0) {
          intersections = intersections.concat(result);
        }
      });
      return intersections;
    },
    arcs: function(errorThreshold) {
      errorThreshold = errorThreshold || 0.5;
      var circles = [];
      return this._iterate(errorThreshold, circles);
    },
    _error: function(pc, np1, s, e) {
      var q = (e - s) / 4,
          c1 = this.get(s + q),
          c2 = this.get(e - q),
          ref = utils.dist(pc, np1),
          d1  = utils.dist(pc, c1),
          d2  = utils.dist(pc, c2);
      return abs(d1-ref) + abs(d2-ref);
    },
    _iterate: function(errorThreshold, circles) {
      var s = 0, e = 1, safety;
      // we do a binary search to find the "good `t` closest to no-longer-good"
      do {
        safety=0;

        // step 1: start with the maximum possible arc
        e = 1;

        // points:
        var np1 = this.get(s), np2, np3, arc, prev_arc;

        // booleans:
        var curr_good = false, prev_good = false, done;

        // numbers:
        var m = e, prev_e = 1, step = 0;

        // step 2: find the best possible arc
        do {
          prev_good = curr_good;
          prev_arc = arc;
          m = (s + e)/2;
          step++;

          np2 = this.get(m);
          np3 = this.get(e);

          arc = utils.getccenter(np1, np2, np3);

          //also save the t values
          arc.interval = {
            start: s,
            end: e
          };

          var error = this._error(arc, np1, s, e);
          curr_good = (error <= errorThreshold);

          done = prev_good && !curr_good;
          if(!done) prev_e = e;

          // this arc is fine: we can move 'e' up to see if we can find a wider arc
          if(curr_good) {

            // if e is already at max, then we're done for this arc.
            if (e >= 1) {
              arc.interval.end = prev_e = 1;
              prev_arc = arc;
              break;
            }
            // if not, move it up by half the iteration distance
            e = e + (e-s)/2;
          }

          // this is a bad arc: we need to move 'e' down to find a good arc
          else {
            e = m;
          }
        }
        while(!done && safety++<100);

        if(safety>=100) {
          break;
        }

        // console.log("L835: [F] arc found", s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);

        prev_arc = (prev_arc ? prev_arc : arc);
        circles.push(prev_arc);
        s = prev_e;
      }
      while(e < 1);
      return circles;
    }
  };

  module.exports = Bezier;

}());

},{"./poly-bezier.js":50,"./utils.js":51}],50:[function(require,module,exports){
(function() {
  "use strict";

  var utils = require('./utils.js');

  /**
   * Poly Bezier
   * @param {[type]} curves [description]
   */
  var PolyBezier = function(curves) {
    this.curves = [];
    this._3d = false;
    if(!!curves) {
      this.curves = curves;
      this._3d = this.curves[0]._3d;
    }
  }

  PolyBezier.prototype = {
    valueOf: function() {
      return this.toString();
    },
    toString: function() {
      return "[" + this.curves.map(function(curve) {
        return utils.pointsToString(curve.points);
      }).join(", ") + "]";
    },
    addCurve: function(curve) {
      this.curves.push(curve);
      this._3d = this._3d || curve._3d;
    },
    length: function() {
      return this.curves.map(function(v) { return v.length(); }).reduce(function(a,b) { return a+b; });
    },
    curve: function(idx) {
      return this.curves[idx];
    },
    bbox: function() {
      var c = this.curves;
      var bbox = c[0].bbox();
      for(var i=1; i<c.length; i++) {
        utils.expandbox(bbox, c[i].bbox());
      }
      return bbox;
    },
    offset: function(d) {
      var offset = [];
      this.curves.forEach(function(v) {
        offset = offset.concat(v.offset(d));
      });
      return new PolyBezier(offset);
    }
  };

  module.exports = PolyBezier;
}());

},{"./utils.js":51}],51:[function(require,module,exports){
(function() {
  "use strict";

  // math-inlining.
  var abs = Math.abs,
      cos = Math.cos,
      sin = Math.sin,
      acos = Math.acos,
      atan2 = Math.atan2,
      sqrt = Math.sqrt,
      pow = Math.pow,
      // cube root function yielding real roots
      crt = function(v) { return (v<0) ? -pow(-v,1/3) : pow(v,1/3); },
      // trig constants
      pi = Math.PI,
      tau = 2*pi,
      quart = pi/2,
      // float precision significant decimal
      epsilon = 0.000001,
      // extremas used in bbox calculation and similar algorithms
      nMax = Number.MAX_SAFE_INTEGER,
      nMin = Number.MIN_SAFE_INTEGER;

  // Bezier utility functions
  var utils = {
    // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
    Tvalues: [
      -0.0640568928626056260850430826247450385909,
       0.0640568928626056260850430826247450385909,
      -0.1911188674736163091586398207570696318404,
       0.1911188674736163091586398207570696318404,
      -0.3150426796961633743867932913198102407864,
       0.3150426796961633743867932913198102407864,
      -0.4337935076260451384870842319133497124524,
       0.4337935076260451384870842319133497124524,
      -0.5454214713888395356583756172183723700107,
       0.5454214713888395356583756172183723700107,
      -0.6480936519369755692524957869107476266696,
       0.6480936519369755692524957869107476266696,
      -0.7401241915785543642438281030999784255232,
       0.7401241915785543642438281030999784255232,
      -0.8200019859739029219539498726697452080761,
       0.8200019859739029219539498726697452080761,
      -0.8864155270044010342131543419821967550873,
       0.8864155270044010342131543419821967550873,
      -0.9382745520027327585236490017087214496548,
       0.9382745520027327585236490017087214496548,
      -0.9747285559713094981983919930081690617411,
       0.9747285559713094981983919930081690617411,
      -0.9951872199970213601799974097007368118745,
       0.9951872199970213601799974097007368118745
    ],

    // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
    Cvalues: [
      0.1279381953467521569740561652246953718517,
      0.1279381953467521569740561652246953718517,
      0.1258374563468282961213753825111836887264,
      0.1258374563468282961213753825111836887264,
      0.1216704729278033912044631534762624256070,
      0.1216704729278033912044631534762624256070,
      0.1155056680537256013533444839067835598622,
      0.1155056680537256013533444839067835598622,
      0.1074442701159656347825773424466062227946,
      0.1074442701159656347825773424466062227946,
      0.0976186521041138882698806644642471544279,
      0.0976186521041138882698806644642471544279,
      0.0861901615319532759171852029837426671850,
      0.0861901615319532759171852029837426671850,
      0.0733464814110803057340336152531165181193,
      0.0733464814110803057340336152531165181193,
      0.0592985849154367807463677585001085845412,
      0.0592985849154367807463677585001085845412,
      0.0442774388174198061686027482113382288593,
      0.0442774388174198061686027482113382288593,
      0.0285313886289336631813078159518782864491,
      0.0285313886289336631813078159518782864491,
      0.0123412297999871995468056670700372915759,
      0.0123412297999871995468056670700372915759
    ],

    arcfn: function(t, derivativeFn) {
      var d = derivativeFn(t);
      var l = d.x*d.x + d.y*d.y;
      if(typeof d.z !== "undefined") {
        l += d.z*d.z;
      }
      return sqrt(l);
    },

    between: function(v, m, M) {
      return (m <= v && v <= M) || utils.approximately(v, m) || utils.approximately(v, M);
    },

    approximately: function(a,b,precision) {
      return abs(a-b) <= (precision || epsilon);
    },

    length: function(derivativeFn) {
      var z=0.5,sum=0,len=utils.Tvalues.length,i,t;
      for(i=0; i<len; i++) {
        t = z * utils.Tvalues[i] + z;
        sum += utils.Cvalues[i] * utils.arcfn(t,derivativeFn);
      }
      return z * sum;
    },

    map: function(v, ds,de, ts,te) {
      var d1 = de-ds, d2 = te-ts, v2 =  v-ds, r = v2/d1;
      return ts + d2*r;
    },

    lerp: function(r, v1, v2) {
      var ret = {
        x: v1.x + r*(v2.x-v1.x),
        y: v1.y + r*(v2.y-v1.y)
      };
      if(!!v1.z && !!v2.z) {
        ret.z =  v1.z + r*(v2.z-v1.z);
      }
      return ret;
    },

    pointToString: function(p) {
      var s = p.x+"/"+p.y;
      if(typeof p.z !== "undefined") {
        s += "/"+p.z;
      }
      return s;
    },

    pointsToString: function(points) {
      return "[" + points.map(utils.pointToString).join(", ") + "]";
    },

    copy: function(obj) {
      return JSON.parse(JSON.stringify(obj));
    },

    angle: function(o,v1,v2) {
      var dx1 = v1.x - o.x,
          dy1 = v1.y - o.y,
          dx2 = v2.x - o.x,
          dy2 = v2.y - o.y,
          cross = dx1*dy2 - dy1*dx2,
          dot = dx1*dx2 + dy1*dy2;
      return atan2(cross, dot);
    },

    // round as string, to avoid rounding errors
    round: function(v, d) {
      var s = '' + v;
      var pos = s.indexOf(".");
      return parseFloat(s.substring(0,pos+1+d));
    },

    dist: function(p1, p2) {
      var dx = p1.x - p2.x,
          dy = p1.y - p2.y;
      return sqrt(dx*dx+dy*dy);
    },

    closest: function(LUT, point) {
      var mdist = pow(2,63), mpos, d;
      LUT.forEach(function(p, idx) {
        d = utils.dist(point, p);
        if (d<mdist) {
          mdist = d;
          mpos = idx;
        }
      });
      return { mdist:mdist, mpos:mpos };
    },

    abcratio: function(t, n) {
      // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc
      if (n!==2 && n!==3) {
        return false;
      }
      if (typeof t === "undefined") {
        t = 0.5;
      } else if (t===0 || t===1) {
        return t;
      }
      var bottom = pow(t,n) + pow(1-t,n), top = bottom - 1;
      return abs(top/bottom);
    },

    projectionratio: function(t, n) {
      // see u(t) note on http://pomax.github.io/bezierinfo/#abc
      if (n!==2 && n!==3) {
        return false;
      }
      if (typeof t === "undefined") {
        t = 0.5;
      } else if (t===0 || t===1) {
        return t;
      }
      var top = pow(1-t, n), bottom = pow(t,n) + top;
      return top/bottom;
    },

    lli8: function(x1,y1,x2,y2,x3,y3,x4,y4) {
      var nx=(x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4),
          ny=(x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4),
          d=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);
      if(d==0) { return false; }
      return { x: nx/d, y: ny/d };
    },

    lli4: function(p1,p2,p3,p4) {
      var x1 = p1.x, y1 = p1.y,
          x2 = p2.x, y2 = p2.y,
          x3 = p3.x, y3 = p3.y,
          x4 = p4.x, y4 = p4.y;
      return utils.lli8(x1,y1,x2,y2,x3,y3,x4,y4);
    },

    lli: function(v1, v2) {
      return utils.lli4(v1,v1.c,v2,v2.c);
    },

    makeline: function(p1,p2) {
      var Bezier = require('./bezier');
      var x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y, dx = (x2-x1)/3, dy = (y2-y1)/3;
      return new Bezier(x1, y1, x1+dx, y1+dy, x1+2*dx, y1+2*dy, x2, y2);
    },

    findbbox: function(sections) {
      var mx=nMax,my=nMax,MX=nMin,MY=nMin;
      sections.forEach(function(s) {
        var bbox = s.bbox();
        if(mx > bbox.x.min) mx = bbox.x.min;
        if(my > bbox.y.min) my = bbox.y.min;
        if(MX < bbox.x.max) MX = bbox.x.max;
        if(MY < bbox.y.max) MY = bbox.y.max;
      });
      return {
        x: { min: mx, mid:(mx+MX)/2, max: MX, size:MX-mx },
        y: { min: my, mid:(my+MY)/2, max: MY, size:MY-my }
      }
    },

    shapeintersections: function(s1, bbox1, s2, bbox2, curveIntersectionThreshold) {
      if(!utils.bboxoverlap(bbox1, bbox2)) return [];
      var intersections = [];
      var a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];
      var a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];
      a1.forEach(function(l1) {
        if(l1.virtual) return;
        a2.forEach(function(l2) {
          if(l2.virtual) return;
          var iss = l1.intersects(l2, curveIntersectionThreshold);
          if(iss.length>0) {
            iss.c1 = l1;
            iss.c2 = l2;
            iss.s1 = s1;
            iss.s2 = s2;
            intersections.push(iss);
          }
        });
      });
      return intersections;
    },

    makeshape: function(forward, back, curveIntersectionThreshold) {
      var bpl = back.points.length;
      var fpl = forward.points.length;
      var start  = utils.makeline(back.points[bpl-1], forward.points[0]);
      var end    = utils.makeline(forward.points[fpl-1], back.points[0]);
      var shape  = {
        startcap: start,
        forward: forward,
        back: back,
        endcap: end,
        bbox: utils.findbbox([start, forward, back, end])
      };
      var self = utils;
      shape.intersections = function(s2) {
        return self.shapeintersections(shape,shape.bbox,s2,s2.bbox, curveIntersectionThreshold);
      };
      return shape;
    },

    getminmax: function(curve, d, list) {
      if(!list) return { min:0, max:0 };
      var min=nMax, max=nMin,t,c;
      if(list.indexOf(0)===-1) { list = [0].concat(list); }
      if(list.indexOf(1)===-1) { list.push(1); }
      for(var i=0,len=list.length; i<len; i++) {
        t = list[i];
        c = curve.get(t);
        if(c[d] < min) { min = c[d]; }
        if(c[d] > max) { max = c[d]; }
      }
      return { min:min, mid:(min+max)/2, max:max, size:max-min };
    },

    align: function(points, line) {
      var tx = line.p1.x,
          ty = line.p1.y,
          a = -atan2(line.p2.y-ty, line.p2.x-tx),
          d = function(v) {
            return {
              x: (v.x-tx)*cos(a) - (v.y-ty)*sin(a),
              y: (v.x-tx)*sin(a) + (v.y-ty)*cos(a)
            };
          };
      return points.map(d);
    },

    roots: function(points, line) {
      line = line || {p1:{x:0,y:0},p2:{x:1,y:0}};
      var order = points.length - 1;
      var p = utils.align(points, line);
      var reduce = function(t) { return 0<=t && t <=1; };

      if (order === 2) {
        var a = p[0].y,
            b = p[1].y,
            c = p[2].y,
            d = a - 2*b + c;
        if(d!==0) {
          var m1 = -sqrt(b*b-a*c),
              m2 = -a+b,
              v1 = -( m1+m2)/d,
              v2 = -(-m1+m2)/d;
          return [v1, v2].filter(reduce);
        }
        else if(b!==c && d===0) {
          return [ (2*b-c)/2*(b-c) ].filter(reduce);
        }
        return [];
      }

      // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm
      var pa = p[0].y,
          pb = p[1].y,
          pc = p[2].y,
          pd = p[3].y,
          d = (-pa + 3*pb - 3*pc + pd),
          a = (3*pa - 6*pb + 3*pc) / d,
          b = (-3*pa + 3*pb) / d,
          c = pa / d,
          p = (3*b - a*a)/3,
          p3 = p/3,
          q = (2*a*a*a - 9*a*b + 27*c)/27,
          q2 = q/2,
          discriminant = q2*q2 + p3*p3*p3,
          u1,v1,x1,x2,x3;
       if (discriminant < 0) {
        var mp3 = -p/3,
            mp33 = mp3*mp3*mp3,
            r = sqrt( mp33 ),
            t = -q/(2*r),
            cosphi = t<-1 ? -1 : t>1 ? 1 : t,
            phi = acos(cosphi),
            crtr = crt(r),
            t1 = 2*crtr;
        x1 = t1 * cos(phi/3) - a/3;
        x2 = t1 * cos((phi+tau)/3) - a/3;
        x3 = t1 * cos((phi+2*tau)/3) - a/3;
        return [x1, x2, x3].filter(reduce);
      } else if(discriminant === 0) {
        u1 = q2 < 0 ? crt(-q2) : -crt(q2);
        x1 = 2*u1-a/3;
        x2 = -u1 - a/3;
        return [x1,x2].filter(reduce);
      } else {
        var sd = sqrt(discriminant);
        u1 = crt(-q2+sd);
        v1 = crt(q2+sd);
        return [u1-v1-a/3].filter(reduce);;
      }
    },

    droots: function(p) {
      // quadratic roots are easy
      if(p.length === 3) {
        var a = p[0],
            b = p[1],
            c = p[2],
            d = a - 2*b + c;
        if(d!==0) {
          var m1 = -sqrt(b*b-a*c),
              m2 = -a+b,
              v1 = -( m1+m2)/d,
              v2 = -(-m1+m2)/d;
          return [v1, v2];
        }
        else if(b!==c && d===0) {
          return [(2*b-c)/(2*(b-c))];
        }
        return [];
      }

      // linear roots are even easier
      if(p.length === 2) {
        var a = p[0], b = p[1];
        if(a!==b) {
          return [a/(a-b)];
        }
        return [];
      }
    },

    inflections: function(points) {
      if (points.length<4) return [];

      // FIXME: TODO: add in inflection abstraction for quartic+ curves?

      var p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }),
          a = p[2].x * p[1].y,
          b = p[3].x * p[1].y,
          c = p[1].x * p[2].y,
          d = p[3].x * p[2].y,
          v1 = 18 * (-3*a + 2*b + 3*c - d),
          v2 = 18 * (3*a - b - 3*c),
          v3 = 18 * (c - a);

      if (utils.approximately(v1,0)){
        if(!utils.approximately(v2,0)){
          var t = -v3/v2;
          if (0 <= t && t <= 1)
             return [t];
        }
        return [];
      }

      var trm = v2*v2 - 4*v1*v3,
          sq = Math.sqrt(trm),
          d = 2 * v1;

      if (utils.approximately(d,0)) return [];

      return [(sq-v2)/d, -(v2+sq)/d].filter(function(r) {
        return (0 <= r && r <= 1);
      });
    },

    bboxoverlap: function(b1,b2) {
      var dims=['x','y'],len=dims.length,i,dim,l,t,d
      for(i=0; i<len; i++) {
        dim = dims[i];
        l = b1[dim].mid;
        t = b2[dim].mid;
        d = (b1[dim].size + b2[dim].size)/2;
        if(abs(l-t) >= d) return false;
      }
      return true;
    },

    expandbox: function(bbox, _bbox) {
      if(_bbox.x.min < bbox.x.min) { bbox.x.min = _bbox.x.min; }
      if(_bbox.y.min < bbox.y.min) { bbox.y.min = _bbox.y.min; }
      if(_bbox.z && _bbox.z.min < bbox.z.min) { bbox.z.min = _bbox.z.min; }
      if(_bbox.x.max > bbox.x.max) { bbox.x.max = _bbox.x.max; }
      if(_bbox.y.max > bbox.y.max) { bbox.y.max = _bbox.y.max; }
      if(_bbox.z && _bbox.z.max > bbox.z.max) { bbox.z.max = _bbox.z.max; }
      bbox.x.mid = (bbox.x.min + bbox.x.max)/2;
      bbox.y.mid = (bbox.y.min + bbox.y.max)/2;
      if(bbox.z) { bbox.z.mid = (bbox.z.min + bbox.z.max)/2; }
      bbox.x.size = bbox.x.max - bbox.x.min;
      bbox.y.size = bbox.y.max - bbox.y.min;
      if(bbox.z) { bbox.z.size = bbox.z.max - bbox.z.min; }
    },

    pairiteration: function(c1, c2, curveIntersectionThreshold) {
      var c1b = c1.bbox(),
          c2b = c2.bbox(),
          r = 100000,
          threshold = curveIntersectionThreshold || 0.5;
      if(c1b.x.size + c1b.y.size < threshold && c2b.x.size + c2b.y.size < threshold) {
        return [ ((r * (c1._t1+c1._t2)/2)|0)/r + "/" + ((r * (c2._t1+c2._t2)/2)|0)/r ];
      }
      var cc1 = c1.split(0.5),
          cc2 = c2.split(0.5),
          pairs = [
            {left: cc1.left, right: cc2.left },
            {left: cc1.left, right: cc2.right },
            {left: cc1.right, right: cc2.right },
            {left: cc1.right, right: cc2.left }];
      pairs = pairs.filter(function(pair) {
        return utils.bboxoverlap(pair.left.bbox(),pair.right.bbox());
      });
      var results = [];
      if(pairs.length === 0) return results;
      pairs.forEach(function(pair) {
        results = results.concat(
          utils.pairiteration(pair.left, pair.right, threshold)
        );
      })
      results = results.filter(function(v,i) {
        return results.indexOf(v) === i;
      });
      return results;
    },

    getccenter: function(p1,p2,p3) {
      var dx1 = (p2.x - p1.x),
          dy1 = (p2.y - p1.y),
          dx2 = (p3.x - p2.x),
          dy2 = (p3.y - p2.y);
      var dx1p = dx1 * cos(quart) - dy1 * sin(quart),
          dy1p = dx1 * sin(quart) + dy1 * cos(quart),
          dx2p = dx2 * cos(quart) - dy2 * sin(quart),
          dy2p = dx2 * sin(quart) + dy2 * cos(quart);
      // chord midpoints
      var mx1 = (p1.x + p2.x)/2,
          my1 = (p1.y + p2.y)/2,
          mx2 = (p2.x + p3.x)/2,
          my2 = (p2.y + p3.y)/2;
      // midpoint offsets
      var mx1n = mx1 + dx1p,
          my1n = my1 + dy1p,
          mx2n = mx2 + dx2p,
          my2n = my2 + dy2p;
      // intersection of these lines:
      var arc = utils.lli8(mx1,my1,mx1n,my1n, mx2,my2,mx2n,my2n),
          r = utils.dist(arc,p1),
          // arc start/end values, over mid point:
          s = atan2(p1.y - arc.y, p1.x - arc.x),
          m = atan2(p2.y - arc.y, p2.x - arc.x),
          e = atan2(p3.y - arc.y, p3.x - arc.x),
          _;
      // determine arc direction (cw/ccw correction)
      if (s<e) {
        // if s<m<e, arc(s, e)
        // if m<s<e, arc(e, s + tau)
        // if s<e<m, arc(e, s + tau)
        if (s>m || m>e) { s += tau; }
        if (s>e) { _=e; e=s; s=_; }
      } else {
        // if e<m<s, arc(e, s)
        // if m<e<s, arc(s, e + tau)
        // if e<s<m, arc(s, e + tau)
        if (e<m && m<s) { _=e; e=s; s=_; } else { e += tau; }
      }
      // assign and done.
      arc.s = s;
      arc.e = e;
      arc.r = r;
      return arc;
    }
  };

  module.exports = utils;
}());

},{"./bezier":49}],52:[function(require,module,exports){
// TinyColor v1.4.1
// https://github.com/bgrins/TinyColor
// Brian Grinstead, MIT License

(function(Math) {

var trimLeft = /^\s+/,
    trimRight = /\s+$/,
    tinyCounter = 0,
    mathRound = Math.round,
    mathMin = Math.min,
    mathMax = Math.max,
    mathRandom = Math.random;

function tinycolor (color, opts) {

    color = (color) ? color : '';
    opts = opts || { };

    // If input is already a tinycolor, return itself
    if (color instanceof tinycolor) {
       return color;
    }
    // If we are called as a function, call using new instead
    if (!(this instanceof tinycolor)) {
        return new tinycolor(color, opts);
    }

    var rgb = inputToRGB(color);
    this._originalInput = color,
    this._r = rgb.r,
    this._g = rgb.g,
    this._b = rgb.b,
    this._a = rgb.a,
    this._roundA = mathRound(100*this._a) / 100,
    this._format = opts.format || rgb.format;
    this._gradientType = opts.gradientType;

    // Don't let the range of [0,255] come back in [0,1].
    // Potentially lose a little bit of precision here, but will fix issues where
    // .5 gets interpreted as half of the total, instead of half of 1
    // If it was supposed to be 128, this was already taken care of by `inputToRgb`
    if (this._r < 1) { this._r = mathRound(this._r); }
    if (this._g < 1) { this._g = mathRound(this._g); }
    if (this._b < 1) { this._b = mathRound(this._b); }

    this._ok = rgb.ok;
    this._tc_id = tinyCounter++;
}

tinycolor.prototype = {
    isDark: function() {
        return this.getBrightness() < 128;
    },
    isLight: function() {
        return !this.isDark();
    },
    isValid: function() {
        return this._ok;
    },
    getOriginalInput: function() {
      return this._originalInput;
    },
    getFormat: function() {
        return this._format;
    },
    getAlpha: function() {
        return this._a;
    },
    getBrightness: function() {
        //http://www.w3.org/TR/AERT#color-contrast
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
    },
    getLuminance: function() {
        //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
        var rgb = this.toRgb();
        var RsRGB, GsRGB, BsRGB, R, G, B;
        RsRGB = rgb.r/255;
        GsRGB = rgb.g/255;
        BsRGB = rgb.b/255;

        if (RsRGB <= 0.03928) {R = RsRGB / 12.92;} else {R = Math.pow(((RsRGB + 0.055) / 1.055), 2.4);}
        if (GsRGB <= 0.03928) {G = GsRGB / 12.92;} else {G = Math.pow(((GsRGB + 0.055) / 1.055), 2.4);}
        if (BsRGB <= 0.03928) {B = BsRGB / 12.92;} else {B = Math.pow(((BsRGB + 0.055) / 1.055), 2.4);}
        return (0.2126 * R) + (0.7152 * G) + (0.0722 * B);
    },
    setAlpha: function(value) {
        this._a = boundAlpha(value);
        this._roundA = mathRound(100*this._a) / 100;
        return this;
    },
    toHsv: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
    },
    toHsvString: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
        return (this._a == 1) ?
          "hsv("  + h + ", " + s + "%, " + v + "%)" :
          "hsva(" + h + ", " + s + "%, " + v + "%, "+ this._roundA + ")";
    },
    toHsl: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
    },
    toHslString: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
        return (this._a == 1) ?
          "hsl("  + h + ", " + s + "%, " + l + "%)" :
          "hsla(" + h + ", " + s + "%, " + l + "%, "+ this._roundA + ")";
    },
    toHex: function(allow3Char) {
        return rgbToHex(this._r, this._g, this._b, allow3Char);
    },
    toHexString: function(allow3Char) {
        return '#' + this.toHex(allow3Char);
    },
    toHex8: function(allow4Char) {
        return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
    },
    toHex8String: function(allow4Char) {
        return '#' + this.toHex8(allow4Char);
    },
    toRgb: function() {
        return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
    },
    toRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" :
          "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
    },
    toPercentageRgb: function() {
        return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
    },
    toPercentageRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" :
          "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
    },
    toName: function() {
        if (this._a === 0) {
            return "transparent";
        }

        if (this._a < 1) {
            return false;
        }

        return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
    },
    toFilter: function(secondColor) {
        var hex8String = '#' + rgbaToArgbHex(this._r, this._g, this._b, this._a);
        var secondHex8String = hex8String;
        var gradientType = this._gradientType ? "GradientType = 1, " : "";

        if (secondColor) {
            var s = tinycolor(secondColor);
            secondHex8String = '#' + rgbaToArgbHex(s._r, s._g, s._b, s._a);
        }

        return "progid:DXImageTransform.Microsoft.gradient("+gradientType+"startColorstr="+hex8String+",endColorstr="+secondHex8String+")";
    },
    toString: function(format) {
        var formatSet = !!format;
        format = format || this._format;

        var formattedString = false;
        var hasAlpha = this._a < 1 && this._a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");

        if (needsAlphaFormat) {
            // Special case for "transparent", all other non-alpha formats
            // will return rgba when there is transparency.
            if (format === "name" && this._a === 0) {
                return this.toName();
            }
            return this.toRgbString();
        }
        if (format === "rgb") {
            formattedString = this.toRgbString();
        }
        if (format === "prgb") {
            formattedString = this.toPercentageRgbString();
        }
        if (format === "hex" || format === "hex6") {
            formattedString = this.toHexString();
        }
        if (format === "hex3") {
            formattedString = this.toHexString(true);
        }
        if (format === "hex4") {
            formattedString = this.toHex8String(true);
        }
        if (format === "hex8") {
            formattedString = this.toHex8String();
        }
        if (format === "name") {
            formattedString = this.toName();
        }
        if (format === "hsl") {
            formattedString = this.toHslString();
        }
        if (format === "hsv") {
            formattedString = this.toHsvString();
        }

        return formattedString || this.toHexString();
    },
    clone: function() {
        return tinycolor(this.toString());
    },

    _applyModification: function(fn, args) {
        var color = fn.apply(null, [this].concat([].slice.call(args)));
        this._r = color._r;
        this._g = color._g;
        this._b = color._b;
        this.setAlpha(color._a);
        return this;
    },
    lighten: function() {
        return this._applyModification(lighten, arguments);
    },
    brighten: function() {
        return this._applyModification(brighten, arguments);
    },
    darken: function() {
        return this._applyModification(darken, arguments);
    },
    desaturate: function() {
        return this._applyModification(desaturate, arguments);
    },
    saturate: function() {
        return this._applyModification(saturate, arguments);
    },
    greyscale: function() {
        return this._applyModification(greyscale, arguments);
    },
    spin: function() {
        return this._applyModification(spin, arguments);
    },

    _applyCombination: function(fn, args) {
        return fn.apply(null, [this].concat([].slice.call(args)));
    },
    analogous: function() {
        return this._applyCombination(analogous, arguments);
    },
    complement: function() {
        return this._applyCombination(complement, arguments);
    },
    monochromatic: function() {
        return this._applyCombination(monochromatic, arguments);
    },
    splitcomplement: function() {
        return this._applyCombination(splitcomplement, arguments);
    },
    triad: function() {
        return this._applyCombination(triad, arguments);
    },
    tetrad: function() {
        return this._applyCombination(tetrad, arguments);
    }
};

// If input is an object, force 1 into "1.0" to handle ratios properly
// String input requires "1.0" as input, so 1 will be treated as 1
tinycolor.fromRatio = function(color, opts) {
    if (typeof color == "object") {
        var newColor = {};
        for (var i in color) {
            if (color.hasOwnProperty(i)) {
                if (i === "a") {
                    newColor[i] = color[i];
                }
                else {
                    newColor[i] = convertToPercentage(color[i]);
                }
            }
        }
        color = newColor;
    }

    return tinycolor(color, opts);
};

// Given a string or object, convert that input to RGB
// Possible string inputs:
//
//     "red"
//     "#f00" or "f00"
//     "#ff0000" or "ff0000"
//     "#ff000000" or "ff000000"
//     "rgb 255 0 0" or "rgb (255, 0, 0)"
//     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
//     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
//     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
//     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
//     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
//     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
//
function inputToRGB(color) {

    var rgb = { r: 0, g: 0, b: 0 };
    var a = 1;
    var s = null;
    var v = null;
    var l = null;
    var ok = false;
    var format = false;

    if (typeof color == "string") {
        color = stringInputToObject(color);
    }

    if (typeof color == "object") {
        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
            rgb = rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        }
        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
            s = convertToPercentage(color.s);
            v = convertToPercentage(color.v);
            rgb = hsvToRgb(color.h, s, v);
            ok = true;
            format = "hsv";
        }
        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
            s = convertToPercentage(color.s);
            l = convertToPercentage(color.l);
            rgb = hslToRgb(color.h, s, l);
            ok = true;
            format = "hsl";
        }

        if (color.hasOwnProperty("a")) {
            a = color.a;
        }
    }

    a = boundAlpha(a);

    return {
        ok: ok,
        format: color.format || format,
        r: mathMin(255, mathMax(rgb.r, 0)),
        g: mathMin(255, mathMax(rgb.g, 0)),
        b: mathMin(255, mathMax(rgb.b, 0)),
        a: a
    };
}


// Conversion Functions
// --------------------

// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

// `rgbToRgb`
// Handle bounds / percentage checking to conform to CSS color spec
// <http://www.w3.org/TR/css3-color/>
// *Assumes:* r, g, b in [0, 255] or [0, 1]
// *Returns:* { r, g, b } in [0, 255]
function rgbToRgb(r, g, b){
    return {
        r: bound01(r, 255) * 255,
        g: bound01(g, 255) * 255,
        b: bound01(b, 255) * 255
    };
}

// `rgbToHsl`
// Converts an RGB color value to HSL.
// *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
// *Returns:* { h, s, l } in [0,1]
function rgbToHsl(r, g, b) {

    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);

    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, l = (max + min) / 2;

    if(max == min) {
        h = s = 0; // achromatic
    }
    else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }

        h /= 6;
    }

    return { h: h, s: s, l: l };
}

// `hslToRgb`
// Converts an HSL color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
function hslToRgb(h, s, l) {
    var r, g, b;

    h = bound01(h, 360);
    s = bound01(s, 100);
    l = bound01(l, 100);

    function hue2rgb(p, q, t) {
        if(t < 0) t += 1;
        if(t > 1) t -= 1;
        if(t < 1/6) return p + (q - p) * 6 * t;
        if(t < 1/2) return q;
        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
    }

    if(s === 0) {
        r = g = b = l; // achromatic
    }
    else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
    }

    return { r: r * 255, g: g * 255, b: b * 255 };
}

// `rgbToHsv`
// Converts an RGB color value to HSV
// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
// *Returns:* { h, s, v } in [0,1]
function rgbToHsv(r, g, b) {

    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);

    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, v = max;

    var d = max - min;
    s = max === 0 ? 0 : d / max;

    if(max == min) {
        h = 0; // achromatic
    }
    else {
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return { h: h, s: s, v: v };
}

// `hsvToRgb`
// Converts an HSV color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
 function hsvToRgb(h, s, v) {

    h = bound01(h, 360) * 6;
    s = bound01(s, 100);
    v = bound01(v, 100);

    var i = Math.floor(h),
        f = h - i,
        p = v * (1 - s),
        q = v * (1 - f * s),
        t = v * (1 - (1 - f) * s),
        mod = i % 6,
        r = [v, q, p, p, t, v][mod],
        g = [t, v, v, q, p, p][mod],
        b = [p, p, t, v, v, q][mod];

    return { r: r * 255, g: g * 255, b: b * 255 };
}

// `rgbToHex`
// Converts an RGB color to hex
// Assumes r, g, and b are contained in the set [0, 255]
// Returns a 3 or 6 character hex
function rgbToHex(r, g, b, allow3Char) {

    var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ];

    // Return a 3 character hex if possible
    if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
    }

    return hex.join("");
}

// `rgbaToHex`
// Converts an RGBA color plus alpha transparency to hex
// Assumes r, g, b are contained in the set [0, 255] and
// a in [0, 1]. Returns a 4 or 8 character rgba hex
function rgbaToHex(r, g, b, a, allow4Char) {

    var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16)),
        pad2(convertDecimalToHex(a))
    ];

    // Return a 4 character hex if possible
    if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
    }

    return hex.join("");
}

// `rgbaToArgbHex`
// Converts an RGBA color to an ARGB Hex8 string
// Rarely used, but required for "toFilter()"
function rgbaToArgbHex(r, g, b, a) {

    var hex = [
        pad2(convertDecimalToHex(a)),
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ];

    return hex.join("");
}

// `equals`
// Can be called with any tinycolor input
tinycolor.equals = function (color1, color2) {
    if (!color1 || !color2) { return false; }
    return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};

tinycolor.random = function() {
    return tinycolor.fromRatio({
        r: mathRandom(),
        g: mathRandom(),
        b: mathRandom()
    });
};


// Modification Functions
// ----------------------
// Thanks to less.js for some of the basics here
// <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

function desaturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s -= amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}

function saturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s += amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}

function greyscale(color) {
    return tinycolor(color).desaturate(100);
}

function lighten (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l += amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}

function brighten(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var rgb = tinycolor(color).toRgb();
    rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * - (amount / 100))));
    rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * - (amount / 100))));
    rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * - (amount / 100))));
    return tinycolor(rgb);
}

function darken (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l -= amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}

// Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
// Values outside of this range will be wrapped into this range.
function spin(color, amount) {
    var hsl = tinycolor(color).toHsl();
    var hue = (hsl.h + amount) % 360;
    hsl.h = hue < 0 ? 360 + hue : hue;
    return tinycolor(hsl);
}

// Combination Functions
// ---------------------
// Thanks to jQuery xColor for some of the ideas behind these
// <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

function complement(color) {
    var hsl = tinycolor(color).toHsl();
    hsl.h = (hsl.h + 180) % 360;
    return tinycolor(hsl);
}

function triad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
    ];
}

function tetrad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
    ];
}

function splitcomplement(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l}),
        tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l})
    ];
}

function analogous(color, results, slices) {
    results = results || 6;
    slices = slices || 30;

    var hsl = tinycolor(color).toHsl();
    var part = 360 / slices;
    var ret = [tinycolor(color)];

    for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(tinycolor(hsl));
    }
    return ret;
}

function monochromatic(color, results) {
    results = results || 6;
    var hsv = tinycolor(color).toHsv();
    var h = hsv.h, s = hsv.s, v = hsv.v;
    var ret = [];
    var modification = 1 / results;

    while (results--) {
        ret.push(tinycolor({ h: h, s: s, v: v}));
        v = (v + modification) % 1;
    }

    return ret;
}

// Utility Functions
// ---------------------

tinycolor.mix = function(color1, color2, amount) {
    amount = (amount === 0) ? 0 : (amount || 50);

    var rgb1 = tinycolor(color1).toRgb();
    var rgb2 = tinycolor(color2).toRgb();

    var p = amount / 100;

    var rgba = {
        r: ((rgb2.r - rgb1.r) * p) + rgb1.r,
        g: ((rgb2.g - rgb1.g) * p) + rgb1.g,
        b: ((rgb2.b - rgb1.b) * p) + rgb1.b,
        a: ((rgb2.a - rgb1.a) * p) + rgb1.a
    };

    return tinycolor(rgba);
};


// Readability Functions
// ---------------------
// <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)

// `contrast`
// Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)
tinycolor.readability = function(color1, color2) {
    var c1 = tinycolor(color1);
    var c2 = tinycolor(color2);
    return (Math.max(c1.getLuminance(),c2.getLuminance())+0.05) / (Math.min(c1.getLuminance(),c2.getLuminance())+0.05);
};

// `isReadable`
// Ensure that foreground and background color combinations meet WCAG2 guidelines.
// The third argument is an optional Object.
//      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';
//      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.
// If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.

// *Example*
//    tinycolor.isReadable("#000", "#111") => false
//    tinycolor.isReadable("#000", "#111",{level:"AA",size:"large"}) => false
tinycolor.isReadable = function(color1, color2, wcag2) {
    var readability = tinycolor.readability(color1, color2);
    var wcag2Parms, out;

    out = false;

    wcag2Parms = validateWCAG2Parms(wcag2);
    switch (wcag2Parms.level + wcag2Parms.size) {
        case "AAsmall":
        case "AAAlarge":
            out = readability >= 4.5;
            break;
        case "AAlarge":
            out = readability >= 3;
            break;
        case "AAAsmall":
            out = readability >= 7;
            break;
    }
    return out;

};

// `mostReadable`
// Given a base color and a list of possible foreground or background
// colors for that base, returns the most readable color.
// Optionally returns Black or White if the most readable color is unreadable.
// *Example*
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:false}).toHexString(); // "#112255"
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:true}).toHexString();  // "#ffffff"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"large"}).toHexString(); // "#faf3f3"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"small"}).toHexString(); // "#ffffff"
tinycolor.mostReadable = function(baseColor, colorList, args) {
    var bestColor = null;
    var bestScore = 0;
    var readability;
    var includeFallbackColors, level, size ;
    args = args || {};
    includeFallbackColors = args.includeFallbackColors ;
    level = args.level;
    size = args.size;

    for (var i= 0; i < colorList.length ; i++) {
        readability = tinycolor.readability(baseColor, colorList[i]);
        if (readability > bestScore) {
            bestScore = readability;
            bestColor = tinycolor(colorList[i]);
        }
    }

    if (tinycolor.isReadable(baseColor, bestColor, {"level":level,"size":size}) || !includeFallbackColors) {
        return bestColor;
    }
    else {
        args.includeFallbackColors=false;
        return tinycolor.mostReadable(baseColor,["#fff", "#000"],args);
    }
};


// Big List of Colors
// ------------------
// <http://www.w3.org/TR/css3-color/#svg-color>
var names = tinycolor.names = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "0ff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000",
    blanchedalmond: "ffebcd",
    blue: "00f",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    burntsienna: "ea7e5d",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "0ff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkgrey: "a9a9a9",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkslategrey: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dimgrey: "696969",
    dodgerblue: "1e90ff",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "f0f",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    grey: "808080",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgray: "d3d3d3",
    lightgreen: "90ee90",
    lightgrey: "d3d3d3",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslategray: "789",
    lightslategrey: "789",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "0f0",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "f0f",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370db",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "db7093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "663399",
    red: "f00",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    slategrey: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    wheat: "f5deb3",
    white: "fff",
    whitesmoke: "f5f5f5",
    yellow: "ff0",
    yellowgreen: "9acd32"
};

// Make it easy to access colors via `hexNames[hex]`
var hexNames = tinycolor.hexNames = flip(names);


// Utilities
// ---------

// `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
function flip(o) {
    var flipped = { };
    for (var i in o) {
        if (o.hasOwnProperty(i)) {
            flipped[o[i]] = i;
        }
    }
    return flipped;
}

// Return a valid alpha value [0,1] with all invalid values being set to 1
function boundAlpha(a) {
    a = parseFloat(a);

    if (isNaN(a) || a < 0 || a > 1) {
        a = 1;
    }

    return a;
}

// Take input from [0, n] and return it as [0, 1]
function bound01(n, max) {
    if (isOnePointZero(n)) { n = "100%"; }

    var processPercent = isPercentage(n);
    n = mathMin(max, mathMax(0, parseFloat(n)));

    // Automatically convert percentage into number
    if (processPercent) {
        n = parseInt(n * max, 10) / 100;
    }

    // Handle floating point rounding errors
    if ((Math.abs(n - max) < 0.000001)) {
        return 1;
    }

    // Convert into [0, 1] range if it isn't already
    return (n % max) / parseFloat(max);
}

// Force a number between 0 and 1
function clamp01(val) {
    return mathMin(1, mathMax(0, val));
}

// Parse a base-16 hex value into a base-10 integer
function parseIntFromHex(val) {
    return parseInt(val, 16);
}

// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
function isOnePointZero(n) {
    return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
}

// Check to see if string passed in is a percentage
function isPercentage(n) {
    return typeof n === "string" && n.indexOf('%') != -1;
}

// Force a hex value to have 2 characters
function pad2(c) {
    return c.length == 1 ? '0' + c : '' + c;
}

// Replace a decimal with it's percentage value
function convertToPercentage(n) {
    if (n <= 1) {
        n = (n * 100) + "%";
    }

    return n;
}

// Converts a decimal to a hex value
function convertDecimalToHex(d) {
    return Math.round(parseFloat(d) * 255).toString(16);
}
// Converts a hex value to a decimal
function convertHexToDecimal(h) {
    return (parseIntFromHex(h) / 255);
}

var matchers = (function() {

    // <http://www.w3.org/TR/css3-values/#integers>
    var CSS_INTEGER = "[-\\+]?\\d+%?";

    // <http://www.w3.org/TR/css3-values/#number-value>
    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

    // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
    var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

    // Actual matching.
    // Parentheses and commas are optional, but not required.
    // Whitespace can take the place of commas or opening paren
    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";

    return {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
})();

// `isValidCSSUnit`
// Take in a single string / number and check to see if it looks like a CSS unit
// (see `matchers` above for definition).
function isValidCSSUnit(color) {
    return !!matchers.CSS_UNIT.exec(color);
}

// `stringInputToObject`
// Permissive string parsing.  Take in a number of formats, and output an object
// based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
function stringInputToObject(color) {

    color = color.replace(trimLeft,'').replace(trimRight, '').toLowerCase();
    var named = false;
    if (names[color]) {
        color = names[color];
        named = true;
    }
    else if (color == 'transparent') {
        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
    }

    // Try to match string input using regular expressions.
    // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
    // Just return an object and let the conversion functions handle that.
    // This way the result will be the same whether the tinycolor is initialized with string or object.
    var match;
    if ((match = matchers.rgb.exec(color))) {
        return { r: match[1], g: match[2], b: match[3] };
    }
    if ((match = matchers.rgba.exec(color))) {
        return { r: match[1], g: match[2], b: match[3], a: match[4] };
    }
    if ((match = matchers.hsl.exec(color))) {
        return { h: match[1], s: match[2], l: match[3] };
    }
    if ((match = matchers.hsla.exec(color))) {
        return { h: match[1], s: match[2], l: match[3], a: match[4] };
    }
    if ((match = matchers.hsv.exec(color))) {
        return { h: match[1], s: match[2], v: match[3] };
    }
    if ((match = matchers.hsva.exec(color))) {
        return { h: match[1], s: match[2], v: match[3], a: match[4] };
    }
    if ((match = matchers.hex8.exec(color))) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            a: convertHexToDecimal(match[4]),
            format: named ? "name" : "hex8"
        };
    }
    if ((match = matchers.hex6.exec(color))) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named ? "name" : "hex"
        };
    }
    if ((match = matchers.hex4.exec(color))) {
        return {
            r: parseIntFromHex(match[1] + '' + match[1]),
            g: parseIntFromHex(match[2] + '' + match[2]),
            b: parseIntFromHex(match[3] + '' + match[3]),
            a: convertHexToDecimal(match[4] + '' + match[4]),
            format: named ? "name" : "hex8"
        };
    }
    if ((match = matchers.hex3.exec(color))) {
        return {
            r: parseIntFromHex(match[1] + '' + match[1]),
            g: parseIntFromHex(match[2] + '' + match[2]),
            b: parseIntFromHex(match[3] + '' + match[3]),
            format: named ? "name" : "hex"
        };
    }

    return false;
}

function validateWCAG2Parms(parms) {
    // return valid WCAG2 parms for isReadable.
    // If input parms are invalid, return {"level":"AA", "size":"small"}
    var level, size;
    parms = parms || {"level":"AA", "size":"small"};
    level = (parms.level || "AA").toUpperCase();
    size = (parms.size || "small").toLowerCase();
    if (level !== "AA" && level !== "AAA") {
        level = "AA";
    }
    if (size !== "small" && size !== "large") {
        size = "small";
    }
    return {"level":level, "size":size};
}

// Node: Export function
if (typeof module !== "undefined" && module.exports) {
    module.exports = tinycolor;
}
// AMD/requirejs: Define the module
else if (typeof define === 'function' && define.amd) {
    define(function () {return tinycolor;});
}
// Browser: Expose to window
else {
    window.tinycolor = tinycolor;
}

})(Math);

},{}],53:[function(require,module,exports){

var zip = require('zip');

function createUrl(src){
  var blob = new Blob([src], { type: 'application/javascript' });
  return URL.createObjectURL(blob);
}

var zWorker = createUrl("/* jshint worker:true */\n(function main(global) {\n\t\"use strict\";\n\n\tif (global.zWorkerInitialized)\n\t\tthrow new Error('z-worker.js should be run only once');\n\tglobal.zWorkerInitialized = true;\n\n\taddEventListener(\"message\", function(event) {\n\t\tvar message = event.data, type = message.type, sn = message.sn;\n\t\tvar handler = handlers[type];\n\t\tif (handler) {\n\t\t\ttry {\n\t\t\t\thandler(message);\n\t\t\t} catch (e) {\n\t\t\t\tonError(type, sn, e);\n\t\t\t}\n\t\t}\n\t\t//for debug\n\t\t//postMessage({type: 'echo', originalType: type, sn: sn});\n\t});\n\n\tvar handlers = {\n\t\timportScripts: doImportScripts,\n\t\tnewTask: newTask,\n\t\tappend: processData,\n\t\tflush: processData,\n\t};\n\n\t// deflater/inflater tasks indexed by serial numbers\n\tvar tasks = {};\n\n\tfunction doImportScripts(msg) {\n\t\tif (msg.scripts && msg.scripts.length > 0)\n\t\t\timportScripts.apply(undefined, msg.scripts);\n\t\tpostMessage({type: 'importScripts'});\n\t}\n\n\tfunction newTask(msg) {\n\t\tvar CodecClass = global[msg.codecClass];\n\t\tvar sn = msg.sn;\n\t\tif (tasks[sn])\n\t\t\tthrow Error('duplicated sn');\n\t\ttasks[sn] =  {\n\t\t\tcodec: new CodecClass(msg.options),\n\t\t\tcrcInput: msg.crcType === 'input',\n\t\t\tcrcOutput: msg.crcType === 'output',\n\t\t\tcrc: new Crc32(),\n\t\t};\n\t\tpostMessage({type: 'newTask', sn: sn});\n\t}\n\n\t// performance may not be supported\n\tvar now = global.performance ? global.performance.now.bind(global.performance) : Date.now;\n\n\tfunction processData(msg) {\n\t\tvar sn = msg.sn, type = msg.type, input = msg.data;\n\t\tvar task = tasks[sn];\n\t\t// allow creating codec on first append\n\t\tif (!task && msg.codecClass) {\n\t\t\tnewTask(msg);\n\t\t\ttask = tasks[sn];\n\t\t}\n\t\tvar isAppend = type === 'append';\n\t\tvar start = now();\n\t\tvar output;\n\t\tif (isAppend) {\n\t\t\ttry {\n\t\t\t\toutput = task.codec.append(input, function onprogress(loaded) {\n\t\t\t\t\tpostMessage({type: 'progress', sn: sn, loaded: loaded});\n\t\t\t\t});\n\t\t\t} catch (e) {\n\t\t\t\tdelete tasks[sn];\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t} else {\n\t\t\tdelete tasks[sn];\n\t\t\toutput = task.codec.flush();\n\t\t}\n\t\tvar codecTime = now() - start;\n\n\t\tstart = now();\n\t\tif (input && task.crcInput)\n\t\t\ttask.crc.append(input);\n\t\tif (output && task.crcOutput)\n\t\t\ttask.crc.append(output);\n\t\tvar crcTime = now() - start;\n\n\t\tvar rmsg = {type: type, sn: sn, codecTime: codecTime, crcTime: crcTime};\n\t\tvar transferables = [];\n\t\tif (output) {\n\t\t\trmsg.data = output;\n\t\t\ttransferables.push(output.buffer);\n\t\t}\n\t\tif (!isAppend && (task.crcInput || task.crcOutput))\n\t\t\trmsg.crc = task.crc.get();\n\t\t\n\t\t// posting a message with transferables will fail on IE10\n\t\ttry {\n\t\t\tpostMessage(rmsg, transferables);\n\t\t} catch(ex) {\n\t\t\tpostMessage(rmsg); // retry without transferables\n\t\t}\n\t}\n\n\tfunction onError(type, sn, e) {\n\t\tvar msg = {\n\t\t\ttype: type,\n\t\t\tsn: sn,\n\t\t\terror: formatError(e)\n\t\t};\n\t\tpostMessage(msg);\n\t}\n\n\tfunction formatError(e) {\n\t\treturn { message: e.message, stack: e.stack };\n\t}\n\n\t// Crc32 code copied from file zip.js\n\tfunction Crc32() {\n\t\tthis.crc = -1;\n\t}\n\tCrc32.prototype.append = function append(data) {\n\t\tvar crc = this.crc | 0, table = this.table;\n\t\tfor (var offset = 0, len = data.length | 0; offset < len; offset++)\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ data[offset]) & 0xFF];\n\t\tthis.crc = crc;\n\t};\n\tCrc32.prototype.get = function get() {\n\t\treturn ~this.crc;\n\t};\n\tCrc32.prototype.table = (function() {\n\t\tvar i, j, t, table = []; // Uint32Array is actually slower than []\n\t\tfor (i = 0; i < 256; i++) {\n\t\t\tt = i;\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t\tif (t & 1)\n\t\t\t\t\tt = (t >>> 1) ^ 0xEDB88320;\n\t\t\t\telse\n\t\t\t\t\tt = t >>> 1;\n\t\t\ttable[i] = t;\n\t\t}\n\t\treturn table;\n\t})();\n\n\t// \"no-op\" codec\n\tfunction NOOP() {}\n\tglobal.NOOP = NOOP;\n\tNOOP.prototype.append = function append(bytes, onprogress) {\n\t\treturn bytes;\n\t};\n\tNOOP.prototype.flush = function flush() {};\n})(this);\n");
zip.workerScripts = {
  deflater: [zWorker, createUrl("/*\n Copyright (c) 2013 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright \n notice, this list of conditions and the following disclaimer in \n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * This program is based on JZlib 1.0.2 ymnk, JCraft,Inc.\n * JZlib is based on zlib-1.1.3, so all credit should go authors\n * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)\n * and contributors of zlib.\n */\n\n(function(global) {\n\t\"use strict\";\n\n\t// Global\n\n\tvar MAX_BITS = 15;\n\tvar D_CODES = 30;\n\tvar BL_CODES = 19;\n\n\tvar LENGTH_CODES = 29;\n\tvar LITERALS = 256;\n\tvar L_CODES = (LITERALS + 1 + LENGTH_CODES);\n\tvar HEAP_SIZE = (2 * L_CODES + 1);\n\n\tvar END_BLOCK = 256;\n\n\t// Bit length codes must not exceed MAX_BL_BITS bits\n\tvar MAX_BL_BITS = 7;\n\n\t// repeat previous bit length 3-6 times (2 bits of repeat count)\n\tvar REP_3_6 = 16;\n\n\t// repeat a zero length 3-10 times (3 bits of repeat count)\n\tvar REPZ_3_10 = 17;\n\n\t// repeat a zero length 11-138 times (7 bits of repeat count)\n\tvar REPZ_11_138 = 18;\n\n\t// The lengths of the bit length codes are sent in order of decreasing\n\t// probability, to avoid transmitting the lengths for unused bit\n\t// length codes.\n\n\tvar Buf_size = 8 * 2;\n\n\t// JZlib version : \"1.0.2\"\n\tvar Z_DEFAULT_COMPRESSION = -1;\n\n\t// compression strategy\n\tvar Z_FILTERED = 1;\n\tvar Z_HUFFMAN_ONLY = 2;\n\tvar Z_DEFAULT_STRATEGY = 0;\n\n\tvar Z_NO_FLUSH = 0;\n\tvar Z_PARTIAL_FLUSH = 1;\n\tvar Z_FULL_FLUSH = 3;\n\tvar Z_FINISH = 4;\n\n\tvar Z_OK = 0;\n\tvar Z_STREAM_END = 1;\n\tvar Z_NEED_DICT = 2;\n\tvar Z_STREAM_ERROR = -2;\n\tvar Z_DATA_ERROR = -3;\n\tvar Z_BUF_ERROR = -5;\n\n\t// Tree\n\n\t// see definition of array dist_code below\n\tvar _dist_code = [ 0, 1, 2, 3, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n\t\t\t10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n\t\t\t12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n\t\t\t13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n\t\t\t14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n\t\t\t14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n\t\t\t15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 16, 17, 18, 18, 19, 19,\n\t\t\t20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n\t\t\t24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n\t\t\t26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n\t\t\t27, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n\t\t\t28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29,\n\t\t\t29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,\n\t\t\t29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29 ];\n\n\tfunction Tree() {\n\t\tvar that = this;\n\n\t\t// dyn_tree; // the dynamic tree\n\t\t// max_code; // largest code with non zero frequency\n\t\t// stat_desc; // the corresponding static tree\n\n\t\t// Compute the optimal bit lengths for a tree and update the total bit\n\t\t// length\n\t\t// for the current block.\n\t\t// IN assertion: the fields freq and dad are set, heap[heap_max] and\n\t\t// above are the tree nodes sorted by increasing frequency.\n\t\t// OUT assertions: the field len is set to the optimal bit length, the\n\t\t// array bl_count contains the frequencies for each bit length.\n\t\t// The length opt_len is updated; static_len is also updated if stree is\n\t\t// not null.\n\t\tfunction gen_bitlen(s) {\n\t\t\tvar tree = that.dyn_tree;\n\t\t\tvar stree = that.stat_desc.static_tree;\n\t\t\tvar extra = that.stat_desc.extra_bits;\n\t\t\tvar base = that.stat_desc.extra_base;\n\t\t\tvar max_length = that.stat_desc.max_length;\n\t\t\tvar h; // heap index\n\t\t\tvar n, m; // iterate over the tree elements\n\t\t\tvar bits; // bit length\n\t\t\tvar xbits; // extra bits\n\t\t\tvar f; // frequency\n\t\t\tvar overflow = 0; // number of elements with bit length too large\n\n\t\t\tfor (bits = 0; bits <= MAX_BITS; bits++)\n\t\t\t\ts.bl_count[bits] = 0;\n\n\t\t\t// In a first pass, compute the optimal bit lengths (which may\n\t\t\t// overflow in the case of the bit length tree).\n\t\t\ttree[s.heap[s.heap_max] * 2 + 1] = 0; // root of the heap\n\n\t\t\tfor (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n\t\t\t\tn = s.heap[h];\n\t\t\t\tbits = tree[tree[n * 2 + 1] * 2 + 1] + 1;\n\t\t\t\tif (bits > max_length) {\n\t\t\t\t\tbits = max_length;\n\t\t\t\t\toverflow++;\n\t\t\t\t}\n\t\t\t\ttree[n * 2 + 1] = bits;\n\t\t\t\t// We overwrite tree[n*2+1] which is no longer needed\n\n\t\t\t\tif (n > that.max_code)\n\t\t\t\t\tcontinue; // not a leaf node\n\n\t\t\t\ts.bl_count[bits]++;\n\t\t\t\txbits = 0;\n\t\t\t\tif (n >= base)\n\t\t\t\t\txbits = extra[n - base];\n\t\t\t\tf = tree[n * 2];\n\t\t\t\ts.opt_len += f * (bits + xbits);\n\t\t\t\tif (stree)\n\t\t\t\t\ts.static_len += f * (stree[n * 2 + 1] + xbits);\n\t\t\t}\n\t\t\tif (overflow === 0)\n\t\t\t\treturn;\n\n\t\t\t// This happens for example on obj2 and pic of the Calgary corpus\n\t\t\t// Find the first bit length which could increase:\n\t\t\tdo {\n\t\t\t\tbits = max_length - 1;\n\t\t\t\twhile (s.bl_count[bits] === 0)\n\t\t\t\t\tbits--;\n\t\t\t\ts.bl_count[bits]--; // move one leaf down the tree\n\t\t\t\ts.bl_count[bits + 1] += 2; // move one overflow item as its brother\n\t\t\t\ts.bl_count[max_length]--;\n\t\t\t\t// The brother of the overflow item also moves one step up,\n\t\t\t\t// but this does not affect bl_count[max_length]\n\t\t\t\toverflow -= 2;\n\t\t\t} while (overflow > 0);\n\n\t\t\tfor (bits = max_length; bits !== 0; bits--) {\n\t\t\t\tn = s.bl_count[bits];\n\t\t\t\twhile (n !== 0) {\n\t\t\t\t\tm = s.heap[--h];\n\t\t\t\t\tif (m > that.max_code)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (tree[m * 2 + 1] != bits) {\n\t\t\t\t\t\ts.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];\n\t\t\t\t\t\ttree[m * 2 + 1] = bits;\n\t\t\t\t\t}\n\t\t\t\t\tn--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Reverse the first len bits of a code, using straightforward code (a\n\t\t// faster\n\t\t// method would use a table)\n\t\t// IN assertion: 1 <= len <= 15\n\t\tfunction bi_reverse(code, // the value to invert\n\t\tlen // its bit length\n\t\t) {\n\t\t\tvar res = 0;\n\t\t\tdo {\n\t\t\t\tres |= code & 1;\n\t\t\t\tcode >>>= 1;\n\t\t\t\tres <<= 1;\n\t\t\t} while (--len > 0);\n\t\t\treturn res >>> 1;\n\t\t}\n\n\t\t// Generate the codes for a given tree and bit counts (which need not be\n\t\t// optimal).\n\t\t// IN assertion: the array bl_count contains the bit length statistics for\n\t\t// the given tree and the field len is set for all tree elements.\n\t\t// OUT assertion: the field code is set for all tree elements of non\n\t\t// zero code length.\n\t\tfunction gen_codes(tree, // the tree to decorate\n\t\tmax_code, // largest code with non zero frequency\n\t\tbl_count // number of codes at each bit length\n\t\t) {\n\t\t\tvar next_code = []; // next code value for each\n\t\t\t// bit length\n\t\t\tvar code = 0; // running code value\n\t\t\tvar bits; // bit index\n\t\t\tvar n; // code index\n\t\t\tvar len;\n\n\t\t\t// The distribution counts are first used to generate the code values\n\t\t\t// without bit reversal.\n\t\t\tfor (bits = 1; bits <= MAX_BITS; bits++) {\n\t\t\t\tnext_code[bits] = code = ((code + bl_count[bits - 1]) << 1);\n\t\t\t}\n\n\t\t\t// Check that the bit counts in bl_count are consistent. The last code\n\t\t\t// must be all ones.\n\t\t\t// Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n\t\t\t// \"inconsistent bit counts\");\n\t\t\t// Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n\t\t\tfor (n = 0; n <= max_code; n++) {\n\t\t\t\tlen = tree[n * 2 + 1];\n\t\t\t\tif (len === 0)\n\t\t\t\t\tcontinue;\n\t\t\t\t// Now reverse the bits\n\t\t\t\ttree[n * 2] = bi_reverse(next_code[len]++, len);\n\t\t\t}\n\t\t}\n\n\t\t// Construct one Huffman tree and assigns the code bit strings and lengths.\n\t\t// Update the total bit length for the current block.\n\t\t// IN assertion: the field freq is set for all tree elements.\n\t\t// OUT assertions: the fields len and code are set to the optimal bit length\n\t\t// and corresponding code. The length opt_len is updated; static_len is\n\t\t// also updated if stree is not null. The field max_code is set.\n\t\tthat.build_tree = function(s) {\n\t\t\tvar tree = that.dyn_tree;\n\t\t\tvar stree = that.stat_desc.static_tree;\n\t\t\tvar elems = that.stat_desc.elems;\n\t\t\tvar n, m; // iterate over heap elements\n\t\t\tvar max_code = -1; // largest code with non zero frequency\n\t\t\tvar node; // new node being created\n\n\t\t\t// Construct the initial heap, with least frequent element in\n\t\t\t// heap[1]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n\t\t\t// heap[0] is not used.\n\t\t\ts.heap_len = 0;\n\t\t\ts.heap_max = HEAP_SIZE;\n\n\t\t\tfor (n = 0; n < elems; n++) {\n\t\t\t\tif (tree[n * 2] !== 0) {\n\t\t\t\t\ts.heap[++s.heap_len] = max_code = n;\n\t\t\t\t\ts.depth[n] = 0;\n\t\t\t\t} else {\n\t\t\t\t\ttree[n * 2 + 1] = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// The pkzip format requires that at least one distance code exists,\n\t\t\t// and that at least one bit should be sent even if there is only one\n\t\t\t// possible code. So to avoid special checks later on we force at least\n\t\t\t// two codes of non zero frequency.\n\t\t\twhile (s.heap_len < 2) {\n\t\t\t\tnode = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;\n\t\t\t\ttree[node * 2] = 1;\n\t\t\t\ts.depth[node] = 0;\n\t\t\t\ts.opt_len--;\n\t\t\t\tif (stree)\n\t\t\t\t\ts.static_len -= stree[node * 2 + 1];\n\t\t\t\t// node is 0 or 1 so it does not have extra bits\n\t\t\t}\n\t\t\tthat.max_code = max_code;\n\n\t\t\t// The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n\t\t\t// establish sub-heaps of increasing lengths:\n\n\t\t\tfor (n = Math.floor(s.heap_len / 2); n >= 1; n--)\n\t\t\t\ts.pqdownheap(tree, n);\n\n\t\t\t// Construct the Huffman tree by repeatedly combining the least two\n\t\t\t// frequent nodes.\n\n\t\t\tnode = elems; // next internal node of the tree\n\t\t\tdo {\n\t\t\t\t// n = node of least frequency\n\t\t\t\tn = s.heap[1];\n\t\t\t\ts.heap[1] = s.heap[s.heap_len--];\n\t\t\t\ts.pqdownheap(tree, 1);\n\t\t\t\tm = s.heap[1]; // m = node of next least frequency\n\n\t\t\t\ts.heap[--s.heap_max] = n; // keep the nodes sorted by frequency\n\t\t\t\ts.heap[--s.heap_max] = m;\n\n\t\t\t\t// Create a new node father of n and m\n\t\t\t\ttree[node * 2] = (tree[n * 2] + tree[m * 2]);\n\t\t\t\ts.depth[node] = Math.max(s.depth[n], s.depth[m]) + 1;\n\t\t\t\ttree[n * 2 + 1] = tree[m * 2 + 1] = node;\n\n\t\t\t\t// and insert the new node in the heap\n\t\t\t\ts.heap[1] = node++;\n\t\t\t\ts.pqdownheap(tree, 1);\n\t\t\t} while (s.heap_len >= 2);\n\n\t\t\ts.heap[--s.heap_max] = s.heap[1];\n\n\t\t\t// At this point, the fields freq and dad are set. We can now\n\t\t\t// generate the bit lengths.\n\n\t\t\tgen_bitlen(s);\n\n\t\t\t// The field len is now set, we can generate the bit codes\n\t\t\tgen_codes(tree, that.max_code, s.bl_count);\n\t\t};\n\n\t}\n\n\tTree._length_code = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16,\n\t\t\t16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n\t\t\t20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n\t\t\t22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n\t\t\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n\t\t\t25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n\t\t\t26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28 ];\n\n\tTree.base_length = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 0 ];\n\n\tTree.base_dist = [ 0, 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384,\n\t\t\t24576 ];\n\n\t// Mapping from a distance to a distance code. dist is the distance - 1 and\n\t// must not have side effects. _dist_code[256] and _dist_code[257] are never\n\t// used.\n\tTree.d_code = function(dist) {\n\t\treturn ((dist) < 256 ? _dist_code[dist] : _dist_code[256 + ((dist) >>> 7)]);\n\t};\n\n\t// extra bits for each length code\n\tTree.extra_lbits = [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0 ];\n\n\t// extra bits for each distance code\n\tTree.extra_dbits = [ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ];\n\n\t// extra bits for each bit length code\n\tTree.extra_blbits = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7 ];\n\n\tTree.bl_order = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];\n\n\t// StaticTree\n\n\tfunction StaticTree(static_tree, extra_bits, extra_base, elems, max_length) {\n\t\tvar that = this;\n\t\tthat.static_tree = static_tree;\n\t\tthat.extra_bits = extra_bits;\n\t\tthat.extra_base = extra_base;\n\t\tthat.elems = elems;\n\t\tthat.max_length = max_length;\n\t}\n\n\tStaticTree.static_ltree = [ 12, 8, 140, 8, 76, 8, 204, 8, 44, 8, 172, 8, 108, 8, 236, 8, 28, 8, 156, 8, 92, 8, 220, 8, 60, 8, 188, 8, 124, 8, 252, 8, 2, 8,\n\t\t\t130, 8, 66, 8, 194, 8, 34, 8, 162, 8, 98, 8, 226, 8, 18, 8, 146, 8, 82, 8, 210, 8, 50, 8, 178, 8, 114, 8, 242, 8, 10, 8, 138, 8, 74, 8, 202, 8, 42,\n\t\t\t8, 170, 8, 106, 8, 234, 8, 26, 8, 154, 8, 90, 8, 218, 8, 58, 8, 186, 8, 122, 8, 250, 8, 6, 8, 134, 8, 70, 8, 198, 8, 38, 8, 166, 8, 102, 8, 230, 8,\n\t\t\t22, 8, 150, 8, 86, 8, 214, 8, 54, 8, 182, 8, 118, 8, 246, 8, 14, 8, 142, 8, 78, 8, 206, 8, 46, 8, 174, 8, 110, 8, 238, 8, 30, 8, 158, 8, 94, 8,\n\t\t\t222, 8, 62, 8, 190, 8, 126, 8, 254, 8, 1, 8, 129, 8, 65, 8, 193, 8, 33, 8, 161, 8, 97, 8, 225, 8, 17, 8, 145, 8, 81, 8, 209, 8, 49, 8, 177, 8, 113,\n\t\t\t8, 241, 8, 9, 8, 137, 8, 73, 8, 201, 8, 41, 8, 169, 8, 105, 8, 233, 8, 25, 8, 153, 8, 89, 8, 217, 8, 57, 8, 185, 8, 121, 8, 249, 8, 5, 8, 133, 8,\n\t\t\t69, 8, 197, 8, 37, 8, 165, 8, 101, 8, 229, 8, 21, 8, 149, 8, 85, 8, 213, 8, 53, 8, 181, 8, 117, 8, 245, 8, 13, 8, 141, 8, 77, 8, 205, 8, 45, 8,\n\t\t\t173, 8, 109, 8, 237, 8, 29, 8, 157, 8, 93, 8, 221, 8, 61, 8, 189, 8, 125, 8, 253, 8, 19, 9, 275, 9, 147, 9, 403, 9, 83, 9, 339, 9, 211, 9, 467, 9,\n\t\t\t51, 9, 307, 9, 179, 9, 435, 9, 115, 9, 371, 9, 243, 9, 499, 9, 11, 9, 267, 9, 139, 9, 395, 9, 75, 9, 331, 9, 203, 9, 459, 9, 43, 9, 299, 9, 171, 9,\n\t\t\t427, 9, 107, 9, 363, 9, 235, 9, 491, 9, 27, 9, 283, 9, 155, 9, 411, 9, 91, 9, 347, 9, 219, 9, 475, 9, 59, 9, 315, 9, 187, 9, 443, 9, 123, 9, 379,\n\t\t\t9, 251, 9, 507, 9, 7, 9, 263, 9, 135, 9, 391, 9, 71, 9, 327, 9, 199, 9, 455, 9, 39, 9, 295, 9, 167, 9, 423, 9, 103, 9, 359, 9, 231, 9, 487, 9, 23,\n\t\t\t9, 279, 9, 151, 9, 407, 9, 87, 9, 343, 9, 215, 9, 471, 9, 55, 9, 311, 9, 183, 9, 439, 9, 119, 9, 375, 9, 247, 9, 503, 9, 15, 9, 271, 9, 143, 9,\n\t\t\t399, 9, 79, 9, 335, 9, 207, 9, 463, 9, 47, 9, 303, 9, 175, 9, 431, 9, 111, 9, 367, 9, 239, 9, 495, 9, 31, 9, 287, 9, 159, 9, 415, 9, 95, 9, 351, 9,\n\t\t\t223, 9, 479, 9, 63, 9, 319, 9, 191, 9, 447, 9, 127, 9, 383, 9, 255, 9, 511, 9, 0, 7, 64, 7, 32, 7, 96, 7, 16, 7, 80, 7, 48, 7, 112, 7, 8, 7, 72, 7,\n\t\t\t40, 7, 104, 7, 24, 7, 88, 7, 56, 7, 120, 7, 4, 7, 68, 7, 36, 7, 100, 7, 20, 7, 84, 7, 52, 7, 116, 7, 3, 8, 131, 8, 67, 8, 195, 8, 35, 8, 163, 8,\n\t\t\t99, 8, 227, 8 ];\n\n\tStaticTree.static_dtree = [ 0, 5, 16, 5, 8, 5, 24, 5, 4, 5, 20, 5, 12, 5, 28, 5, 2, 5, 18, 5, 10, 5, 26, 5, 6, 5, 22, 5, 14, 5, 30, 5, 1, 5, 17, 5, 9, 5,\n\t\t\t25, 5, 5, 5, 21, 5, 13, 5, 29, 5, 3, 5, 19, 5, 11, 5, 27, 5, 7, 5, 23, 5 ];\n\n\tStaticTree.static_l_desc = new StaticTree(StaticTree.static_ltree, Tree.extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n\n\tStaticTree.static_d_desc = new StaticTree(StaticTree.static_dtree, Tree.extra_dbits, 0, D_CODES, MAX_BITS);\n\n\tStaticTree.static_bl_desc = new StaticTree(null, Tree.extra_blbits, 0, BL_CODES, MAX_BL_BITS);\n\n\t// Deflate\n\n\tvar MAX_MEM_LEVEL = 9;\n\tvar DEF_MEM_LEVEL = 8;\n\n\tfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n\t\tvar that = this;\n\t\tthat.good_length = good_length;\n\t\tthat.max_lazy = max_lazy;\n\t\tthat.nice_length = nice_length;\n\t\tthat.max_chain = max_chain;\n\t\tthat.func = func;\n\t}\n\n\tvar STORED = 0;\n\tvar FAST = 1;\n\tvar SLOW = 2;\n\tvar config_table = [ new Config(0, 0, 0, 0, STORED), new Config(4, 4, 8, 4, FAST), new Config(4, 5, 16, 8, FAST), new Config(4, 6, 32, 32, FAST),\n\t\t\tnew Config(4, 4, 16, 16, SLOW), new Config(8, 16, 32, 32, SLOW), new Config(8, 16, 128, 128, SLOW), new Config(8, 32, 128, 256, SLOW),\n\t\t\tnew Config(32, 128, 258, 1024, SLOW), new Config(32, 258, 258, 4096, SLOW) ];\n\n\tvar z_errmsg = [ \"need dictionary\", // Z_NEED_DICT\n\t// 2\n\t\"stream end\", // Z_STREAM_END 1\n\t\"\", // Z_OK 0\n\t\"\", // Z_ERRNO (-1)\n\t\"stream error\", // Z_STREAM_ERROR (-2)\n\t\"data error\", // Z_DATA_ERROR (-3)\n\t\"\", // Z_MEM_ERROR (-4)\n\t\"buffer error\", // Z_BUF_ERROR (-5)\n\t\"\",// Z_VERSION_ERROR (-6)\n\t\"\" ];\n\n\t// block not completed, need more input or more output\n\tvar NeedMore = 0;\n\n\t// block flush performed\n\tvar BlockDone = 1;\n\n\t// finish started, need only more output at next deflate\n\tvar FinishStarted = 2;\n\n\t// finish done, accept no more input or output\n\tvar FinishDone = 3;\n\n\t// preset dictionary flag in zlib header\n\tvar PRESET_DICT = 0x20;\n\n\tvar INIT_STATE = 42;\n\tvar BUSY_STATE = 113;\n\tvar FINISH_STATE = 666;\n\n\t// The deflate compression method\n\tvar Z_DEFLATED = 8;\n\n\tvar STORED_BLOCK = 0;\n\tvar STATIC_TREES = 1;\n\tvar DYN_TREES = 2;\n\n\tvar MIN_MATCH = 3;\n\tvar MAX_MATCH = 258;\n\tvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\n\tfunction smaller(tree, n, m, depth) {\n\t\tvar tn2 = tree[n * 2];\n\t\tvar tm2 = tree[m * 2];\n\t\treturn (tn2 < tm2 || (tn2 == tm2 && depth[n] <= depth[m]));\n\t}\n\n\tfunction Deflate() {\n\n\t\tvar that = this;\n\t\tvar strm; // pointer back to this zlib stream\n\t\tvar status; // as the name implies\n\t\t// pending_buf; // output still pending\n\t\tvar pending_buf_size; // size of pending_buf\n\t\t// pending_out; // next pending byte to output to the stream\n\t\t// pending; // nb of bytes in the pending buffer\n\t\tvar method; // STORED (for zip only) or DEFLATED\n\t\tvar last_flush; // value of flush param for previous deflate call\n\n\t\tvar w_size; // LZ77 window size (32K by default)\n\t\tvar w_bits; // log2(w_size) (8..16)\n\t\tvar w_mask; // w_size - 1\n\n\t\tvar window;\n\t\t// Sliding window. Input bytes are read into the second half of the window,\n\t\t// and move to the first half later to keep a dictionary of at least wSize\n\t\t// bytes. With this organization, matches are limited to a distance of\n\t\t// wSize-MAX_MATCH bytes, but this ensures that IO is always\n\t\t// performed with a length multiple of the block size. Also, it limits\n\t\t// the window size to 64K, which is quite useful on MSDOS.\n\t\t// To do: use the user input buffer as sliding window.\n\n\t\tvar window_size;\n\t\t// Actual size of window: 2*wSize, except when the user input buffer\n\t\t// is directly used as sliding window.\n\n\t\tvar prev;\n\t\t// Link to older string with same hash index. To limit the size of this\n\t\t// array to 64K, this link is maintained only for the last 32K strings.\n\t\t// An index in this array is thus a window index modulo 32K.\n\n\t\tvar head; // Heads of the hash chains or NIL.\n\n\t\tvar ins_h; // hash index of string to be inserted\n\t\tvar hash_size; // number of elements in hash table\n\t\tvar hash_bits; // log2(hash_size)\n\t\tvar hash_mask; // hash_size-1\n\n\t\t// Number of bits by which ins_h must be shifted at each input\n\t\t// step. It must be such that after MIN_MATCH steps, the oldest\n\t\t// byte no longer takes part in the hash key, that is:\n\t\t// hash_shift * MIN_MATCH >= hash_bits\n\t\tvar hash_shift;\n\n\t\t// Window position at the beginning of the current output block. Gets\n\t\t// negative when the window is moved backwards.\n\n\t\tvar block_start;\n\n\t\tvar match_length; // length of best match\n\t\tvar prev_match; // previous match\n\t\tvar match_available; // set if previous match exists\n\t\tvar strstart; // start of string to insert\n\t\tvar match_start; // start of matching string\n\t\tvar lookahead; // number of valid bytes ahead in window\n\n\t\t// Length of the best match at previous step. Matches not greater than this\n\t\t// are discarded. This is used in the lazy match evaluation.\n\t\tvar prev_length;\n\n\t\t// To speed up deflation, hash chains are never searched beyond this\n\t\t// length. A higher limit improves compression ratio but degrades the speed.\n\t\tvar max_chain_length;\n\n\t\t// Attempt to find a better match only when the current match is strictly\n\t\t// smaller than this value. This mechanism is used only for compression\n\t\t// levels >= 4.\n\t\tvar max_lazy_match;\n\n\t\t// Insert new strings in the hash table only if the match length is not\n\t\t// greater than this length. This saves time but degrades compression.\n\t\t// max_insert_length is used only for compression levels <= 3.\n\n\t\tvar level; // compression level (1..9)\n\t\tvar strategy; // favor or force Huffman coding\n\n\t\t// Use a faster search when the previous match is longer than this\n\t\tvar good_match;\n\n\t\t// Stop searching when current match exceeds this\n\t\tvar nice_match;\n\n\t\tvar dyn_ltree; // literal and length tree\n\t\tvar dyn_dtree; // distance tree\n\t\tvar bl_tree; // Huffman tree for bit lengths\n\n\t\tvar l_desc = new Tree(); // desc for literal tree\n\t\tvar d_desc = new Tree(); // desc for distance tree\n\t\tvar bl_desc = new Tree(); // desc for bit length tree\n\n\t\t// that.heap_len; // number of elements in the heap\n\t\t// that.heap_max; // element of largest frequency\n\t\t// The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n\t\t// The same heap array is used to build all trees.\n\n\t\t// Depth of each subtree used as tie breaker for trees of equal frequency\n\t\tthat.depth = [];\n\n\t\tvar l_buf; // index for literals or lengths */\n\n\t\t// Size of match buffer for literals/lengths. There are 4 reasons for\n\t\t// limiting lit_bufsize to 64K:\n\t\t// - frequencies can be kept in 16 bit counters\n\t\t// - if compression is not successful for the first block, all input\n\t\t// data is still in the window so we can still emit a stored block even\n\t\t// when input comes from standard input. (This can also be done for\n\t\t// all blocks if lit_bufsize is not greater than 32K.)\n\t\t// - if compression is not successful for a file smaller than 64K, we can\n\t\t// even emit a stored file instead of a stored block (saving 5 bytes).\n\t\t// This is applicable only for zip (not gzip or zlib).\n\t\t// - creating new Huffman trees less frequently may not provide fast\n\t\t// adaptation to changes in the input data statistics. (Take for\n\t\t// example a binary file with poorly compressible code followed by\n\t\t// a highly compressible string table.) Smaller buffer sizes give\n\t\t// fast adaptation but have of course the overhead of transmitting\n\t\t// trees more frequently.\n\t\t// - I can't count above 4\n\t\tvar lit_bufsize;\n\n\t\tvar last_lit; // running index in l_buf\n\n\t\t// Buffer for distances. To simplify the code, d_buf and l_buf have\n\t\t// the same number of elements. To use different lengths, an extra flag\n\t\t// array would be necessary.\n\n\t\tvar d_buf; // index of pendig_buf\n\n\t\t// that.opt_len; // bit length of current block with optimal trees\n\t\t// that.static_len; // bit length of current block with static trees\n\t\tvar matches; // number of string matches in current block\n\t\tvar last_eob_len; // bit length of EOB code for last block\n\n\t\t// Output buffer. bits are inserted starting at the bottom (least\n\t\t// significant bits).\n\t\tvar bi_buf;\n\n\t\t// Number of valid bits in bi_buf. All bits above the last valid bit\n\t\t// are always zero.\n\t\tvar bi_valid;\n\n\t\t// number of codes at each bit length for an optimal tree\n\t\tthat.bl_count = [];\n\n\t\t// heap used to build the Huffman trees\n\t\tthat.heap = [];\n\n\t\tdyn_ltree = [];\n\t\tdyn_dtree = [];\n\t\tbl_tree = [];\n\n\t\tfunction lm_init() {\n\t\t\tvar i;\n\t\t\twindow_size = 2 * w_size;\n\n\t\t\thead[hash_size - 1] = 0;\n\t\t\tfor (i = 0; i < hash_size - 1; i++) {\n\t\t\t\thead[i] = 0;\n\t\t\t}\n\n\t\t\t// Set the default configuration parameters:\n\t\t\tmax_lazy_match = config_table[level].max_lazy;\n\t\t\tgood_match = config_table[level].good_length;\n\t\t\tnice_match = config_table[level].nice_length;\n\t\t\tmax_chain_length = config_table[level].max_chain;\n\n\t\t\tstrstart = 0;\n\t\t\tblock_start = 0;\n\t\t\tlookahead = 0;\n\t\t\tmatch_length = prev_length = MIN_MATCH - 1;\n\t\t\tmatch_available = 0;\n\t\t\tins_h = 0;\n\t\t}\n\n\t\tfunction init_block() {\n\t\t\tvar i;\n\t\t\t// Initialize the trees.\n\t\t\tfor (i = 0; i < L_CODES; i++)\n\t\t\t\tdyn_ltree[i * 2] = 0;\n\t\t\tfor (i = 0; i < D_CODES; i++)\n\t\t\t\tdyn_dtree[i * 2] = 0;\n\t\t\tfor (i = 0; i < BL_CODES; i++)\n\t\t\t\tbl_tree[i * 2] = 0;\n\n\t\t\tdyn_ltree[END_BLOCK * 2] = 1;\n\t\t\tthat.opt_len = that.static_len = 0;\n\t\t\tlast_lit = matches = 0;\n\t\t}\n\n\t\t// Initialize the tree data structures for a new zlib stream.\n\t\tfunction tr_init() {\n\n\t\t\tl_desc.dyn_tree = dyn_ltree;\n\t\t\tl_desc.stat_desc = StaticTree.static_l_desc;\n\n\t\t\td_desc.dyn_tree = dyn_dtree;\n\t\t\td_desc.stat_desc = StaticTree.static_d_desc;\n\n\t\t\tbl_desc.dyn_tree = bl_tree;\n\t\t\tbl_desc.stat_desc = StaticTree.static_bl_desc;\n\n\t\t\tbi_buf = 0;\n\t\t\tbi_valid = 0;\n\t\t\tlast_eob_len = 8; // enough lookahead for inflate\n\n\t\t\t// Initialize the first block of the first file:\n\t\t\tinit_block();\n\t\t}\n\n\t\t// Restore the heap property by moving down the tree starting at node k,\n\t\t// exchanging a node with the smallest of its two sons if necessary,\n\t\t// stopping\n\t\t// when the heap property is re-established (each father smaller than its\n\t\t// two sons).\n\t\tthat.pqdownheap = function(tree, // the tree to restore\n\t\tk // node to move down\n\t\t) {\n\t\t\tvar heap = that.heap;\n\t\t\tvar v = heap[k];\n\t\t\tvar j = k << 1; // left son of k\n\t\t\twhile (j <= that.heap_len) {\n\t\t\t\t// Set j to the smallest of the two sons:\n\t\t\t\tif (j < that.heap_len && smaller(tree, heap[j + 1], heap[j], that.depth)) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t// Exit if v is smaller than both sons\n\t\t\t\tif (smaller(tree, v, heap[j], that.depth))\n\t\t\t\t\tbreak;\n\n\t\t\t\t// Exchange v with the smallest son\n\t\t\t\theap[k] = heap[j];\n\t\t\t\tk = j;\n\t\t\t\t// And continue down the tree, setting j to the left son of k\n\t\t\t\tj <<= 1;\n\t\t\t}\n\t\t\theap[k] = v;\n\t\t};\n\n\t\t// Scan a literal or distance tree to determine the frequencies of the codes\n\t\t// in the bit length tree.\n\t\tfunction scan_tree(tree,// the tree to be scanned\n\t\tmax_code // and its largest code of non zero frequency\n\t\t) {\n\t\t\tvar n; // iterates over all tree elements\n\t\t\tvar prevlen = -1; // last emitted length\n\t\t\tvar curlen; // length of current code\n\t\t\tvar nextlen = tree[0 * 2 + 1]; // length of next code\n\t\t\tvar count = 0; // repeat count of the current code\n\t\t\tvar max_count = 7; // max repeat count\n\t\t\tvar min_count = 4; // min repeat count\n\n\t\t\tif (nextlen === 0) {\n\t\t\t\tmax_count = 138;\n\t\t\t\tmin_count = 3;\n\t\t\t}\n\t\t\ttree[(max_code + 1) * 2 + 1] = 0xffff; // guard\n\n\t\t\tfor (n = 0; n <= max_code; n++) {\n\t\t\t\tcurlen = nextlen;\n\t\t\t\tnextlen = tree[(n + 1) * 2 + 1];\n\t\t\t\tif (++count < max_count && curlen == nextlen) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (count < min_count) {\n\t\t\t\t\tbl_tree[curlen * 2] += count;\n\t\t\t\t} else if (curlen !== 0) {\n\t\t\t\t\tif (curlen != prevlen)\n\t\t\t\t\t\tbl_tree[curlen * 2]++;\n\t\t\t\t\tbl_tree[REP_3_6 * 2]++;\n\t\t\t\t} else if (count <= 10) {\n\t\t\t\t\tbl_tree[REPZ_3_10 * 2]++;\n\t\t\t\t} else {\n\t\t\t\t\tbl_tree[REPZ_11_138 * 2]++;\n\t\t\t\t}\n\t\t\t\tcount = 0;\n\t\t\t\tprevlen = curlen;\n\t\t\t\tif (nextlen === 0) {\n\t\t\t\t\tmax_count = 138;\n\t\t\t\t\tmin_count = 3;\n\t\t\t\t} else if (curlen == nextlen) {\n\t\t\t\t\tmax_count = 6;\n\t\t\t\t\tmin_count = 3;\n\t\t\t\t} else {\n\t\t\t\t\tmax_count = 7;\n\t\t\t\t\tmin_count = 4;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Construct the Huffman tree for the bit lengths and return the index in\n\t\t// bl_order of the last bit length code to send.\n\t\tfunction build_bl_tree() {\n\t\t\tvar max_blindex; // index of last bit length code of non zero freq\n\n\t\t\t// Determine the bit length frequencies for literal and distance trees\n\t\t\tscan_tree(dyn_ltree, l_desc.max_code);\n\t\t\tscan_tree(dyn_dtree, d_desc.max_code);\n\n\t\t\t// Build the bit length tree:\n\t\t\tbl_desc.build_tree(that);\n\t\t\t// opt_len now includes the length of the tree representations, except\n\t\t\t// the lengths of the bit lengths codes and the 5+5+4 bits for the\n\t\t\t// counts.\n\n\t\t\t// Determine the number of bit length codes to send. The pkzip format\n\t\t\t// requires that at least 4 bit length codes be sent. (appnote.txt says\n\t\t\t// 3 but the actual value used is 4.)\n\t\t\tfor (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n\t\t\t\tif (bl_tree[Tree.bl_order[max_blindex] * 2 + 1] !== 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// Update opt_len to include the bit length tree and counts\n\t\t\tthat.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n\n\t\t\treturn max_blindex;\n\t\t}\n\n\t\t// Output a byte on the stream.\n\t\t// IN assertion: there is enough room in pending_buf.\n\t\tfunction put_byte(p) {\n\t\t\tthat.pending_buf[that.pending++] = p;\n\t\t}\n\n\t\tfunction put_short(w) {\n\t\t\tput_byte(w & 0xff);\n\t\t\tput_byte((w >>> 8) & 0xff);\n\t\t}\n\n\t\tfunction putShortMSB(b) {\n\t\t\tput_byte((b >> 8) & 0xff);\n\t\t\tput_byte((b & 0xff) & 0xff);\n\t\t}\n\n\t\tfunction send_bits(value, length) {\n\t\t\tvar val, len = length;\n\t\t\tif (bi_valid > Buf_size - len) {\n\t\t\t\tval = value;\n\t\t\t\t// bi_buf |= (val << bi_valid);\n\t\t\t\tbi_buf |= ((val << bi_valid) & 0xffff);\n\t\t\t\tput_short(bi_buf);\n\t\t\t\tbi_buf = val >>> (Buf_size - bi_valid);\n\t\t\t\tbi_valid += len - Buf_size;\n\t\t\t} else {\n\t\t\t\t// bi_buf |= (value) << bi_valid;\n\t\t\t\tbi_buf |= (((value) << bi_valid) & 0xffff);\n\t\t\t\tbi_valid += len;\n\t\t\t}\n\t\t}\n\n\t\tfunction send_code(c, tree) {\n\t\t\tvar c2 = c * 2;\n\t\t\tsend_bits(tree[c2] & 0xffff, tree[c2 + 1] & 0xffff);\n\t\t}\n\n\t\t// Send a literal or distance tree in compressed form, using the codes in\n\t\t// bl_tree.\n\t\tfunction send_tree(tree,// the tree to be sent\n\t\tmax_code // and its largest code of non zero frequency\n\t\t) {\n\t\t\tvar n; // iterates over all tree elements\n\t\t\tvar prevlen = -1; // last emitted length\n\t\t\tvar curlen; // length of current code\n\t\t\tvar nextlen = tree[0 * 2 + 1]; // length of next code\n\t\t\tvar count = 0; // repeat count of the current code\n\t\t\tvar max_count = 7; // max repeat count\n\t\t\tvar min_count = 4; // min repeat count\n\n\t\t\tif (nextlen === 0) {\n\t\t\t\tmax_count = 138;\n\t\t\t\tmin_count = 3;\n\t\t\t}\n\n\t\t\tfor (n = 0; n <= max_code; n++) {\n\t\t\t\tcurlen = nextlen;\n\t\t\t\tnextlen = tree[(n + 1) * 2 + 1];\n\t\t\t\tif (++count < max_count && curlen == nextlen) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (count < min_count) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tsend_code(curlen, bl_tree);\n\t\t\t\t\t} while (--count !== 0);\n\t\t\t\t} else if (curlen !== 0) {\n\t\t\t\t\tif (curlen != prevlen) {\n\t\t\t\t\t\tsend_code(curlen, bl_tree);\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t}\n\t\t\t\t\tsend_code(REP_3_6, bl_tree);\n\t\t\t\t\tsend_bits(count - 3, 2);\n\t\t\t\t} else if (count <= 10) {\n\t\t\t\t\tsend_code(REPZ_3_10, bl_tree);\n\t\t\t\t\tsend_bits(count - 3, 3);\n\t\t\t\t} else {\n\t\t\t\t\tsend_code(REPZ_11_138, bl_tree);\n\t\t\t\t\tsend_bits(count - 11, 7);\n\t\t\t\t}\n\t\t\t\tcount = 0;\n\t\t\t\tprevlen = curlen;\n\t\t\t\tif (nextlen === 0) {\n\t\t\t\t\tmax_count = 138;\n\t\t\t\t\tmin_count = 3;\n\t\t\t\t} else if (curlen == nextlen) {\n\t\t\t\t\tmax_count = 6;\n\t\t\t\t\tmin_count = 3;\n\t\t\t\t} else {\n\t\t\t\t\tmax_count = 7;\n\t\t\t\t\tmin_count = 4;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Send the header for a block using dynamic Huffman trees: the counts, the\n\t\t// lengths of the bit length codes, the literal tree and the distance tree.\n\t\t// IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n\t\tfunction send_all_trees(lcodes, dcodes, blcodes) {\n\t\t\tvar rank; // index in bl_order\n\n\t\t\tsend_bits(lcodes - 257, 5); // not +255 as stated in appnote.txt\n\t\t\tsend_bits(dcodes - 1, 5);\n\t\t\tsend_bits(blcodes - 4, 4); // not -3 as stated in appnote.txt\n\t\t\tfor (rank = 0; rank < blcodes; rank++) {\n\t\t\t\tsend_bits(bl_tree[Tree.bl_order[rank] * 2 + 1], 3);\n\t\t\t}\n\t\t\tsend_tree(dyn_ltree, lcodes - 1); // literal tree\n\t\t\tsend_tree(dyn_dtree, dcodes - 1); // distance tree\n\t\t}\n\n\t\t// Flush the bit buffer, keeping at most 7 bits in it.\n\t\tfunction bi_flush() {\n\t\t\tif (bi_valid == 16) {\n\t\t\t\tput_short(bi_buf);\n\t\t\t\tbi_buf = 0;\n\t\t\t\tbi_valid = 0;\n\t\t\t} else if (bi_valid >= 8) {\n\t\t\t\tput_byte(bi_buf & 0xff);\n\t\t\t\tbi_buf >>>= 8;\n\t\t\t\tbi_valid -= 8;\n\t\t\t}\n\t\t}\n\n\t\t// Send one empty static block to give enough lookahead for inflate.\n\t\t// This takes 10 bits, of which 7 may remain in the bit buffer.\n\t\t// The current inflate code requires 9 bits of lookahead. If the\n\t\t// last two codes for the previous block (real code plus EOB) were coded\n\t\t// on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode\n\t\t// the last real code. In this case we send two empty static blocks instead\n\t\t// of one. (There are no problems if the previous block is stored or fixed.)\n\t\t// To simplify the code, we assume the worst case of last real code encoded\n\t\t// on one bit only.\n\t\tfunction _tr_align() {\n\t\t\tsend_bits(STATIC_TREES << 1, 3);\n\t\t\tsend_code(END_BLOCK, StaticTree.static_ltree);\n\n\t\t\tbi_flush();\n\n\t\t\t// Of the 10 bits for the empty block, we have already sent\n\t\t\t// (10 - bi_valid) bits. The lookahead for the last real code (before\n\t\t\t// the EOB of the previous block) was thus at least one plus the length\n\t\t\t// of the EOB plus what we have just sent of the empty static block.\n\t\t\tif (1 + last_eob_len + 10 - bi_valid < 9) {\n\t\t\t\tsend_bits(STATIC_TREES << 1, 3);\n\t\t\t\tsend_code(END_BLOCK, StaticTree.static_ltree);\n\t\t\t\tbi_flush();\n\t\t\t}\n\t\t\tlast_eob_len = 7;\n\t\t}\n\n\t\t// Save the match info and tally the frequency counts. Return true if\n\t\t// the current block must be flushed.\n\t\tfunction _tr_tally(dist, // distance of matched string\n\t\tlc // match length-MIN_MATCH or unmatched char (if dist==0)\n\t\t) {\n\t\t\tvar out_length, in_length, dcode;\n\t\t\tthat.pending_buf[d_buf + last_lit * 2] = (dist >>> 8) & 0xff;\n\t\t\tthat.pending_buf[d_buf + last_lit * 2 + 1] = dist & 0xff;\n\n\t\t\tthat.pending_buf[l_buf + last_lit] = lc & 0xff;\n\t\t\tlast_lit++;\n\n\t\t\tif (dist === 0) {\n\t\t\t\t// lc is the unmatched char\n\t\t\t\tdyn_ltree[lc * 2]++;\n\t\t\t} else {\n\t\t\t\tmatches++;\n\t\t\t\t// Here, lc is the match length - MIN_MATCH\n\t\t\t\tdist--; // dist = match distance - 1\n\t\t\t\tdyn_ltree[(Tree._length_code[lc] + LITERALS + 1) * 2]++;\n\t\t\t\tdyn_dtree[Tree.d_code(dist) * 2]++;\n\t\t\t}\n\n\t\t\tif ((last_lit & 0x1fff) === 0 && level > 2) {\n\t\t\t\t// Compute an upper bound for the compressed length\n\t\t\t\tout_length = last_lit * 8;\n\t\t\t\tin_length = strstart - block_start;\n\t\t\t\tfor (dcode = 0; dcode < D_CODES; dcode++) {\n\t\t\t\t\tout_length += dyn_dtree[dcode * 2] * (5 + Tree.extra_dbits[dcode]);\n\t\t\t\t}\n\t\t\t\tout_length >>>= 3;\n\t\t\t\tif ((matches < Math.floor(last_lit / 2)) && out_length < Math.floor(in_length / 2))\n\t\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn (last_lit == lit_bufsize - 1);\n\t\t\t// We avoid equality with lit_bufsize because of wraparound at 64K\n\t\t\t// on 16 bit machines and because stored blocks are restricted to\n\t\t\t// 64K-1 bytes.\n\t\t}\n\n\t\t// Send the block data compressed using the given Huffman trees\n\t\tfunction compress_block(ltree, dtree) {\n\t\t\tvar dist; // distance of matched string\n\t\t\tvar lc; // match length or unmatched char (if dist === 0)\n\t\t\tvar lx = 0; // running index in l_buf\n\t\t\tvar code; // the code to send\n\t\t\tvar extra; // number of extra bits to send\n\n\t\t\tif (last_lit !== 0) {\n\t\t\t\tdo {\n\t\t\t\t\tdist = ((that.pending_buf[d_buf + lx * 2] << 8) & 0xff00) | (that.pending_buf[d_buf + lx * 2 + 1] & 0xff);\n\t\t\t\t\tlc = (that.pending_buf[l_buf + lx]) & 0xff;\n\t\t\t\t\tlx++;\n\n\t\t\t\t\tif (dist === 0) {\n\t\t\t\t\t\tsend_code(lc, ltree); // send a literal byte\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Here, lc is the match length - MIN_MATCH\n\t\t\t\t\t\tcode = Tree._length_code[lc];\n\n\t\t\t\t\t\tsend_code(code + LITERALS + 1, ltree); // send the length\n\t\t\t\t\t\t// code\n\t\t\t\t\t\textra = Tree.extra_lbits[code];\n\t\t\t\t\t\tif (extra !== 0) {\n\t\t\t\t\t\t\tlc -= Tree.base_length[code];\n\t\t\t\t\t\t\tsend_bits(lc, extra); // send the extra length bits\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdist--; // dist is now the match distance - 1\n\t\t\t\t\t\tcode = Tree.d_code(dist);\n\n\t\t\t\t\t\tsend_code(code, dtree); // send the distance code\n\t\t\t\t\t\textra = Tree.extra_dbits[code];\n\t\t\t\t\t\tif (extra !== 0) {\n\t\t\t\t\t\t\tdist -= Tree.base_dist[code];\n\t\t\t\t\t\t\tsend_bits(dist, extra); // send the extra distance bits\n\t\t\t\t\t\t}\n\t\t\t\t\t} // literal or match pair ?\n\n\t\t\t\t\t// Check that the overlay between pending_buf and d_buf+l_buf is\n\t\t\t\t\t// ok:\n\t\t\t\t} while (lx < last_lit);\n\t\t\t}\n\n\t\t\tsend_code(END_BLOCK, ltree);\n\t\t\tlast_eob_len = ltree[END_BLOCK * 2 + 1];\n\t\t}\n\n\t\t// Flush the bit buffer and align the output on a byte boundary\n\t\tfunction bi_windup() {\n\t\t\tif (bi_valid > 8) {\n\t\t\t\tput_short(bi_buf);\n\t\t\t} else if (bi_valid > 0) {\n\t\t\t\tput_byte(bi_buf & 0xff);\n\t\t\t}\n\t\t\tbi_buf = 0;\n\t\t\tbi_valid = 0;\n\t\t}\n\n\t\t// Copy a stored block, storing first the length and its\n\t\t// one's complement if requested.\n\t\tfunction copy_block(buf, // the input data\n\t\tlen, // its length\n\t\theader // true if block header must be written\n\t\t) {\n\t\t\tbi_windup(); // align on byte boundary\n\t\t\tlast_eob_len = 8; // enough lookahead for inflate\n\n\t\t\tif (header) {\n\t\t\t\tput_short(len);\n\t\t\t\tput_short(~len);\n\t\t\t}\n\n\t\t\tthat.pending_buf.set(window.subarray(buf, buf + len), that.pending);\n\t\t\tthat.pending += len;\n\t\t}\n\n\t\t// Send a stored block\n\t\tfunction _tr_stored_block(buf, // input block\n\t\tstored_len, // length of input block\n\t\teof // true if this is the last block for a file\n\t\t) {\n\t\t\tsend_bits((STORED_BLOCK << 1) + (eof ? 1 : 0), 3); // send block type\n\t\t\tcopy_block(buf, stored_len, true); // with header\n\t\t}\n\n\t\t// Determine the best encoding for the current block: dynamic trees, static\n\t\t// trees or store, and output the encoded block to the zip file.\n\t\tfunction _tr_flush_block(buf, // input block, or NULL if too old\n\t\tstored_len, // length of input block\n\t\teof // true if this is the last block for a file\n\t\t) {\n\t\t\tvar opt_lenb, static_lenb;// opt_len and static_len in bytes\n\t\t\tvar max_blindex = 0; // index of last bit length code of non zero freq\n\n\t\t\t// Build the Huffman trees unless a stored block is forced\n\t\t\tif (level > 0) {\n\t\t\t\t// Construct the literal and distance trees\n\t\t\t\tl_desc.build_tree(that);\n\n\t\t\t\td_desc.build_tree(that);\n\n\t\t\t\t// At this point, opt_len and static_len are the total bit lengths\n\t\t\t\t// of\n\t\t\t\t// the compressed block data, excluding the tree representations.\n\n\t\t\t\t// Build the bit length tree for the above two trees, and get the\n\t\t\t\t// index\n\t\t\t\t// in bl_order of the last bit length code to send.\n\t\t\t\tmax_blindex = build_bl_tree();\n\n\t\t\t\t// Determine the best encoding. Compute first the block length in\n\t\t\t\t// bytes\n\t\t\t\topt_lenb = (that.opt_len + 3 + 7) >>> 3;\n\t\t\t\tstatic_lenb = (that.static_len + 3 + 7) >>> 3;\n\n\t\t\t\tif (static_lenb <= opt_lenb)\n\t\t\t\t\topt_lenb = static_lenb;\n\t\t\t} else {\n\t\t\t\topt_lenb = static_lenb = stored_len + 5; // force a stored block\n\t\t\t}\n\n\t\t\tif ((stored_len + 4 <= opt_lenb) && buf != -1) {\n\t\t\t\t// 4: two words for the lengths\n\t\t\t\t// The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n\t\t\t\t// Otherwise we can't have processed more than WSIZE input bytes\n\t\t\t\t// since\n\t\t\t\t// the last block flush, because compression would have been\n\t\t\t\t// successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n\t\t\t\t// transform a block into a stored block.\n\t\t\t\t_tr_stored_block(buf, stored_len, eof);\n\t\t\t} else if (static_lenb == opt_lenb) {\n\t\t\t\tsend_bits((STATIC_TREES << 1) + (eof ? 1 : 0), 3);\n\t\t\t\tcompress_block(StaticTree.static_ltree, StaticTree.static_dtree);\n\t\t\t} else {\n\t\t\t\tsend_bits((DYN_TREES << 1) + (eof ? 1 : 0), 3);\n\t\t\t\tsend_all_trees(l_desc.max_code + 1, d_desc.max_code + 1, max_blindex + 1);\n\t\t\t\tcompress_block(dyn_ltree, dyn_dtree);\n\t\t\t}\n\n\t\t\t// The above check is made mod 2^32, for files larger than 512 MB\n\t\t\t// and uLong implemented on 32 bits.\n\n\t\t\tinit_block();\n\n\t\t\tif (eof) {\n\t\t\t\tbi_windup();\n\t\t\t}\n\t\t}\n\n\t\tfunction flush_block_only(eof) {\n\t\t\t_tr_flush_block(block_start >= 0 ? block_start : -1, strstart - block_start, eof);\n\t\t\tblock_start = strstart;\n\t\t\tstrm.flush_pending();\n\t\t}\n\n\t\t// Fill the window when the lookahead becomes insufficient.\n\t\t// Updates strstart and lookahead.\n\t\t//\n\t\t// IN assertion: lookahead < MIN_LOOKAHEAD\n\t\t// OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n\t\t// At least one byte has been read, or avail_in === 0; reads are\n\t\t// performed for at least two bytes (required for the zip translate_eol\n\t\t// option -- not supported here).\n\t\tfunction fill_window() {\n\t\t\tvar n, m;\n\t\t\tvar p;\n\t\t\tvar more; // Amount of free space at the end of the window.\n\n\t\t\tdo {\n\t\t\t\tmore = (window_size - lookahead - strstart);\n\n\t\t\t\t// Deal with !@#$% 64K limit:\n\t\t\t\tif (more === 0 && strstart === 0 && lookahead === 0) {\n\t\t\t\t\tmore = w_size;\n\t\t\t\t} else if (more == -1) {\n\t\t\t\t\t// Very unlikely, but possible on 16 bit machine if strstart ==\n\t\t\t\t\t// 0\n\t\t\t\t\t// and lookahead == 1 (input done one byte at time)\n\t\t\t\t\tmore--;\n\n\t\t\t\t\t// If the window is almost full and there is insufficient\n\t\t\t\t\t// lookahead,\n\t\t\t\t\t// move the upper half to the lower one to make room in the\n\t\t\t\t\t// upper half.\n\t\t\t\t} else if (strstart >= w_size + w_size - MIN_LOOKAHEAD) {\n\t\t\t\t\twindow.set(window.subarray(w_size, w_size + w_size), 0);\n\n\t\t\t\t\tmatch_start -= w_size;\n\t\t\t\t\tstrstart -= w_size; // we now have strstart >= MAX_DIST\n\t\t\t\t\tblock_start -= w_size;\n\n\t\t\t\t\t// Slide the hash table (could be avoided with 32 bit values\n\t\t\t\t\t// at the expense of memory usage). We slide even when level ==\n\t\t\t\t\t// 0\n\t\t\t\t\t// to keep the hash table consistent if we switch back to level\n\t\t\t\t\t// > 0\n\t\t\t\t\t// later. (Using level 0 permanently is not an optimal usage of\n\t\t\t\t\t// zlib, so we don't care about this pathological case.)\n\n\t\t\t\t\tn = hash_size;\n\t\t\t\t\tp = n;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tm = (head[--p] & 0xffff);\n\t\t\t\t\t\thead[p] = (m >= w_size ? m - w_size : 0);\n\t\t\t\t\t} while (--n !== 0);\n\n\t\t\t\t\tn = w_size;\n\t\t\t\t\tp = n;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tm = (prev[--p] & 0xffff);\n\t\t\t\t\t\tprev[p] = (m >= w_size ? m - w_size : 0);\n\t\t\t\t\t\t// If n is not on any hash chain, prev[n] is garbage but\n\t\t\t\t\t\t// its value will never be used.\n\t\t\t\t\t} while (--n !== 0);\n\t\t\t\t\tmore += w_size;\n\t\t\t\t}\n\n\t\t\t\tif (strm.avail_in === 0)\n\t\t\t\t\treturn;\n\n\t\t\t\t// If there was no sliding:\n\t\t\t\t// strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n\t\t\t\t// more == window_size - lookahead - strstart\n\t\t\t\t// => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n\t\t\t\t// => more >= window_size - 2*WSIZE + 2\n\t\t\t\t// In the BIG_MEM or MMAP case (not yet supported),\n\t\t\t\t// window_size == input_size + MIN_LOOKAHEAD &&\n\t\t\t\t// strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n\t\t\t\t// Otherwise, window_size == 2*WSIZE so more >= 2.\n\t\t\t\t// If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n\n\t\t\t\tn = strm.read_buf(window, strstart + lookahead, more);\n\t\t\t\tlookahead += n;\n\n\t\t\t\t// Initialize the hash value now that we have some input:\n\t\t\t\tif (lookahead >= MIN_MATCH) {\n\t\t\t\t\tins_h = window[strstart] & 0xff;\n\t\t\t\t\tins_h = (((ins_h) << hash_shift) ^ (window[strstart + 1] & 0xff)) & hash_mask;\n\t\t\t\t}\n\t\t\t\t// If the whole input has less than MIN_MATCH bytes, ins_h is\n\t\t\t\t// garbage,\n\t\t\t\t// but this is not important since only literal bytes will be\n\t\t\t\t// emitted.\n\t\t\t} while (lookahead < MIN_LOOKAHEAD && strm.avail_in !== 0);\n\t\t}\n\n\t\t// Copy without compression as much as possible from the input stream,\n\t\t// return\n\t\t// the current block state.\n\t\t// This function does not insert new strings in the dictionary since\n\t\t// uncompressible data is probably not useful. This function is used\n\t\t// only for the level=0 compression option.\n\t\t// NOTE: this function should be optimized to avoid extra copying from\n\t\t// window to pending_buf.\n\t\tfunction deflate_stored(flush) {\n\t\t\t// Stored blocks are limited to 0xffff bytes, pending_buf is limited\n\t\t\t// to pending_buf_size, and each stored block has a 5 byte header:\n\n\t\t\tvar max_block_size = 0xffff;\n\t\t\tvar max_start;\n\n\t\t\tif (max_block_size > pending_buf_size - 5) {\n\t\t\t\tmax_block_size = pending_buf_size - 5;\n\t\t\t}\n\n\t\t\t// Copy as much as possible from input to output:\n\t\t\twhile (true) {\n\t\t\t\t// Fill the window as much as possible:\n\t\t\t\tif (lookahead <= 1) {\n\t\t\t\t\tfill_window();\n\t\t\t\t\tif (lookahead === 0 && flush == Z_NO_FLUSH)\n\t\t\t\t\t\treturn NeedMore;\n\t\t\t\t\tif (lookahead === 0)\n\t\t\t\t\t\tbreak; // flush the current block\n\t\t\t\t}\n\n\t\t\t\tstrstart += lookahead;\n\t\t\t\tlookahead = 0;\n\n\t\t\t\t// Emit a stored block if pending_buf will be full:\n\t\t\t\tmax_start = block_start + max_block_size;\n\t\t\t\tif (strstart === 0 || strstart >= max_start) {\n\t\t\t\t\t// strstart === 0 is possible when wraparound on 16-bit machine\n\t\t\t\t\tlookahead = (strstart - max_start);\n\t\t\t\t\tstrstart = max_start;\n\n\t\t\t\t\tflush_block_only(false);\n\t\t\t\t\tif (strm.avail_out === 0)\n\t\t\t\t\t\treturn NeedMore;\n\n\t\t\t\t}\n\n\t\t\t\t// Flush if we may have to slide, otherwise block_start may become\n\t\t\t\t// negative and the data will be gone:\n\t\t\t\tif (strstart - block_start >= w_size - MIN_LOOKAHEAD) {\n\t\t\t\t\tflush_block_only(false);\n\t\t\t\t\tif (strm.avail_out === 0)\n\t\t\t\t\t\treturn NeedMore;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tflush_block_only(flush == Z_FINISH);\n\t\t\tif (strm.avail_out === 0)\n\t\t\t\treturn (flush == Z_FINISH) ? FinishStarted : NeedMore;\n\n\t\t\treturn flush == Z_FINISH ? FinishDone : BlockDone;\n\t\t}\n\n\t\tfunction longest_match(cur_match) {\n\t\t\tvar chain_length = max_chain_length; // max hash chain length\n\t\t\tvar scan = strstart; // current string\n\t\t\tvar match; // matched string\n\t\t\tvar len; // length of current match\n\t\t\tvar best_len = prev_length; // best match length so far\n\t\t\tvar limit = strstart > (w_size - MIN_LOOKAHEAD) ? strstart - (w_size - MIN_LOOKAHEAD) : 0;\n\t\t\tvar _nice_match = nice_match;\n\n\t\t\t// Stop when cur_match becomes <= limit. To simplify the code,\n\t\t\t// we prevent matches with the string of window index 0.\n\n\t\t\tvar wmask = w_mask;\n\n\t\t\tvar strend = strstart + MAX_MATCH;\n\t\t\tvar scan_end1 = window[scan + best_len - 1];\n\t\t\tvar scan_end = window[scan + best_len];\n\n\t\t\t// The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of\n\t\t\t// 16.\n\t\t\t// It is easy to get rid of this optimization if necessary.\n\n\t\t\t// Do not waste too much time if we already have a good match:\n\t\t\tif (prev_length >= good_match) {\n\t\t\t\tchain_length >>= 2;\n\t\t\t}\n\n\t\t\t// Do not look for matches beyond the end of the input. This is\n\t\t\t// necessary\n\t\t\t// to make deflate deterministic.\n\t\t\tif (_nice_match > lookahead)\n\t\t\t\t_nice_match = lookahead;\n\n\t\t\tdo {\n\t\t\t\tmatch = cur_match;\n\n\t\t\t\t// Skip to next match if the match length cannot increase\n\t\t\t\t// or if the match length is less than 2:\n\t\t\t\tif (window[match + best_len] != scan_end || window[match + best_len - 1] != scan_end1 || window[match] != window[scan]\n\t\t\t\t\t\t|| window[++match] != window[scan + 1])\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// The check at best_len-1 can be removed because it will be made\n\t\t\t\t// again later. (This heuristic is not always a win.)\n\t\t\t\t// It is not necessary to compare scan[2] and match[2] since they\n\t\t\t\t// are always equal when the other bytes match, given that\n\t\t\t\t// the hash keys are equal and that HASH_BITS >= 8.\n\t\t\t\tscan += 2;\n\t\t\t\tmatch++;\n\n\t\t\t\t// We check for insufficient lookahead only every 8th comparison;\n\t\t\t\t// the 256th check will be made at strstart+258.\n\t\t\t\tdo {\n\t\t\t\t} while (window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match]\n\t\t\t\t\t\t&& window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match]\n\t\t\t\t\t\t&& window[++scan] == window[++match] && window[++scan] == window[++match] && scan < strend);\n\n\t\t\t\tlen = MAX_MATCH - (strend - scan);\n\t\t\t\tscan = strend - MAX_MATCH;\n\n\t\t\t\tif (len > best_len) {\n\t\t\t\t\tmatch_start = cur_match;\n\t\t\t\t\tbest_len = len;\n\t\t\t\t\tif (len >= _nice_match)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tscan_end1 = window[scan + best_len - 1];\n\t\t\t\t\tscan_end = window[scan + best_len];\n\t\t\t\t}\n\n\t\t\t} while ((cur_match = (prev[cur_match & wmask] & 0xffff)) > limit && --chain_length !== 0);\n\n\t\t\tif (best_len <= lookahead)\n\t\t\t\treturn best_len;\n\t\t\treturn lookahead;\n\t\t}\n\n\t\t// Compress as much as possible from the input stream, return the current\n\t\t// block state.\n\t\t// This function does not perform lazy evaluation of matches and inserts\n\t\t// new strings in the dictionary only for unmatched strings or for short\n\t\t// matches. It is used only for the fast compression options.\n\t\tfunction deflate_fast(flush) {\n\t\t\t// short hash_head = 0; // head of the hash chain\n\t\t\tvar hash_head = 0; // head of the hash chain\n\t\t\tvar bflush; // set if current block must be flushed\n\n\t\t\twhile (true) {\n\t\t\t\t// Make sure that we always have enough lookahead, except\n\t\t\t\t// at the end of the input file. We need MAX_MATCH bytes\n\t\t\t\t// for the next match, plus MIN_MATCH bytes to insert the\n\t\t\t\t// string following the next match.\n\t\t\t\tif (lookahead < MIN_LOOKAHEAD) {\n\t\t\t\t\tfill_window();\n\t\t\t\t\tif (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {\n\t\t\t\t\t\treturn NeedMore;\n\t\t\t\t\t}\n\t\t\t\t\tif (lookahead === 0)\n\t\t\t\t\t\tbreak; // flush the current block\n\t\t\t\t}\n\n\t\t\t\t// Insert the string window[strstart .. strstart+2] in the\n\t\t\t\t// dictionary, and set hash_head to the head of the hash chain:\n\t\t\t\tif (lookahead >= MIN_MATCH) {\n\t\t\t\t\tins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;\n\n\t\t\t\t\t// prev[strstart&w_mask]=hash_head=head[ins_h];\n\t\t\t\t\thash_head = (head[ins_h] & 0xffff);\n\t\t\t\t\tprev[strstart & w_mask] = head[ins_h];\n\t\t\t\t\thead[ins_h] = strstart;\n\t\t\t\t}\n\n\t\t\t\t// Find the longest match, discarding those <= prev_length.\n\t\t\t\t// At this point we have always match_length < MIN_MATCH\n\n\t\t\t\tif (hash_head !== 0 && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD) {\n\t\t\t\t\t// To simplify the code, we prevent matches with the string\n\t\t\t\t\t// of window index 0 (in particular we have to avoid a match\n\t\t\t\t\t// of the string with itself at the start of the input file).\n\t\t\t\t\tif (strategy != Z_HUFFMAN_ONLY) {\n\t\t\t\t\t\tmatch_length = longest_match(hash_head);\n\t\t\t\t\t}\n\t\t\t\t\t// longest_match() sets match_start\n\t\t\t\t}\n\t\t\t\tif (match_length >= MIN_MATCH) {\n\t\t\t\t\t// check_match(strstart, match_start, match_length);\n\n\t\t\t\t\tbflush = _tr_tally(strstart - match_start, match_length - MIN_MATCH);\n\n\t\t\t\t\tlookahead -= match_length;\n\n\t\t\t\t\t// Insert new strings in the hash table only if the match length\n\t\t\t\t\t// is not too large. This saves time but degrades compression.\n\t\t\t\t\tif (match_length <= max_lazy_match && lookahead >= MIN_MATCH) {\n\t\t\t\t\t\tmatch_length--; // string at strstart already in hash table\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tstrstart++;\n\n\t\t\t\t\t\t\tins_h = ((ins_h << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;\n\t\t\t\t\t\t\t// prev[strstart&w_mask]=hash_head=head[ins_h];\n\t\t\t\t\t\t\thash_head = (head[ins_h] & 0xffff);\n\t\t\t\t\t\t\tprev[strstart & w_mask] = head[ins_h];\n\t\t\t\t\t\t\thead[ins_h] = strstart;\n\n\t\t\t\t\t\t\t// strstart never exceeds WSIZE-MAX_MATCH, so there are\n\t\t\t\t\t\t\t// always MIN_MATCH bytes ahead.\n\t\t\t\t\t\t} while (--match_length !== 0);\n\t\t\t\t\t\tstrstart++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstrstart += match_length;\n\t\t\t\t\t\tmatch_length = 0;\n\t\t\t\t\t\tins_h = window[strstart] & 0xff;\n\n\t\t\t\t\t\tins_h = (((ins_h) << hash_shift) ^ (window[strstart + 1] & 0xff)) & hash_mask;\n\t\t\t\t\t\t// If lookahead < MIN_MATCH, ins_h is garbage, but it does\n\t\t\t\t\t\t// not\n\t\t\t\t\t\t// matter since it will be recomputed at next deflate call.\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// No match, output a literal byte\n\n\t\t\t\t\tbflush = _tr_tally(0, window[strstart] & 0xff);\n\t\t\t\t\tlookahead--;\n\t\t\t\t\tstrstart++;\n\t\t\t\t}\n\t\t\t\tif (bflush) {\n\n\t\t\t\t\tflush_block_only(false);\n\t\t\t\t\tif (strm.avail_out === 0)\n\t\t\t\t\t\treturn NeedMore;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tflush_block_only(flush == Z_FINISH);\n\t\t\tif (strm.avail_out === 0) {\n\t\t\t\tif (flush == Z_FINISH)\n\t\t\t\t\treturn FinishStarted;\n\t\t\t\telse\n\t\t\t\t\treturn NeedMore;\n\t\t\t}\n\t\t\treturn flush == Z_FINISH ? FinishDone : BlockDone;\n\t\t}\n\n\t\t// Same as above, but achieves better compression. We use a lazy\n\t\t// evaluation for matches: a match is finally adopted only if there is\n\t\t// no better match at the next window position.\n\t\tfunction deflate_slow(flush) {\n\t\t\t// short hash_head = 0; // head of hash chain\n\t\t\tvar hash_head = 0; // head of hash chain\n\t\t\tvar bflush; // set if current block must be flushed\n\t\t\tvar max_insert;\n\n\t\t\t// Process the input block.\n\t\t\twhile (true) {\n\t\t\t\t// Make sure that we always have enough lookahead, except\n\t\t\t\t// at the end of the input file. We need MAX_MATCH bytes\n\t\t\t\t// for the next match, plus MIN_MATCH bytes to insert the\n\t\t\t\t// string following the next match.\n\n\t\t\t\tif (lookahead < MIN_LOOKAHEAD) {\n\t\t\t\t\tfill_window();\n\t\t\t\t\tif (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {\n\t\t\t\t\t\treturn NeedMore;\n\t\t\t\t\t}\n\t\t\t\t\tif (lookahead === 0)\n\t\t\t\t\t\tbreak; // flush the current block\n\t\t\t\t}\n\n\t\t\t\t// Insert the string window[strstart .. strstart+2] in the\n\t\t\t\t// dictionary, and set hash_head to the head of the hash chain:\n\n\t\t\t\tif (lookahead >= MIN_MATCH) {\n\t\t\t\t\tins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;\n\t\t\t\t\t// prev[strstart&w_mask]=hash_head=head[ins_h];\n\t\t\t\t\thash_head = (head[ins_h] & 0xffff);\n\t\t\t\t\tprev[strstart & w_mask] = head[ins_h];\n\t\t\t\t\thead[ins_h] = strstart;\n\t\t\t\t}\n\n\t\t\t\t// Find the longest match, discarding those <= prev_length.\n\t\t\t\tprev_length = match_length;\n\t\t\t\tprev_match = match_start;\n\t\t\t\tmatch_length = MIN_MATCH - 1;\n\n\t\t\t\tif (hash_head !== 0 && prev_length < max_lazy_match && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD) {\n\t\t\t\t\t// To simplify the code, we prevent matches with the string\n\t\t\t\t\t// of window index 0 (in particular we have to avoid a match\n\t\t\t\t\t// of the string with itself at the start of the input file).\n\n\t\t\t\t\tif (strategy != Z_HUFFMAN_ONLY) {\n\t\t\t\t\t\tmatch_length = longest_match(hash_head);\n\t\t\t\t\t}\n\t\t\t\t\t// longest_match() sets match_start\n\n\t\t\t\t\tif (match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096))) {\n\n\t\t\t\t\t\t// If prev_match is also MIN_MATCH, match_start is garbage\n\t\t\t\t\t\t// but we will ignore the current match anyway.\n\t\t\t\t\t\tmatch_length = MIN_MATCH - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If there was a match at the previous step and the current\n\t\t\t\t// match is not better, output the previous match:\n\t\t\t\tif (prev_length >= MIN_MATCH && match_length <= prev_length) {\n\t\t\t\t\tmax_insert = strstart + lookahead - MIN_MATCH;\n\t\t\t\t\t// Do not insert strings in hash table beyond this.\n\n\t\t\t\t\t// check_match(strstart-1, prev_match, prev_length);\n\n\t\t\t\t\tbflush = _tr_tally(strstart - 1 - prev_match, prev_length - MIN_MATCH);\n\n\t\t\t\t\t// Insert in hash table all strings up to the end of the match.\n\t\t\t\t\t// strstart-1 and strstart are already inserted. If there is not\n\t\t\t\t\t// enough lookahead, the last two strings are not inserted in\n\t\t\t\t\t// the hash table.\n\t\t\t\t\tlookahead -= prev_length - 1;\n\t\t\t\t\tprev_length -= 2;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (++strstart <= max_insert) {\n\t\t\t\t\t\t\tins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;\n\t\t\t\t\t\t\t// prev[strstart&w_mask]=hash_head=head[ins_h];\n\t\t\t\t\t\t\thash_head = (head[ins_h] & 0xffff);\n\t\t\t\t\t\t\tprev[strstart & w_mask] = head[ins_h];\n\t\t\t\t\t\t\thead[ins_h] = strstart;\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (--prev_length !== 0);\n\t\t\t\t\tmatch_available = 0;\n\t\t\t\t\tmatch_length = MIN_MATCH - 1;\n\t\t\t\t\tstrstart++;\n\n\t\t\t\t\tif (bflush) {\n\t\t\t\t\t\tflush_block_only(false);\n\t\t\t\t\t\tif (strm.avail_out === 0)\n\t\t\t\t\t\t\treturn NeedMore;\n\t\t\t\t\t}\n\t\t\t\t} else if (match_available !== 0) {\n\n\t\t\t\t\t// If there was no match at the previous position, output a\n\t\t\t\t\t// single literal. If there was a match but the current match\n\t\t\t\t\t// is longer, truncate the previous match to a single literal.\n\n\t\t\t\t\tbflush = _tr_tally(0, window[strstart - 1] & 0xff);\n\n\t\t\t\t\tif (bflush) {\n\t\t\t\t\t\tflush_block_only(false);\n\t\t\t\t\t}\n\t\t\t\t\tstrstart++;\n\t\t\t\t\tlookahead--;\n\t\t\t\t\tif (strm.avail_out === 0)\n\t\t\t\t\t\treturn NeedMore;\n\t\t\t\t} else {\n\t\t\t\t\t// There is no previous match to compare with, wait for\n\t\t\t\t\t// the next step to decide.\n\n\t\t\t\t\tmatch_available = 1;\n\t\t\t\t\tstrstart++;\n\t\t\t\t\tlookahead--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (match_available !== 0) {\n\t\t\t\tbflush = _tr_tally(0, window[strstart - 1] & 0xff);\n\t\t\t\tmatch_available = 0;\n\t\t\t}\n\t\t\tflush_block_only(flush == Z_FINISH);\n\n\t\t\tif (strm.avail_out === 0) {\n\t\t\t\tif (flush == Z_FINISH)\n\t\t\t\t\treturn FinishStarted;\n\t\t\t\telse\n\t\t\t\t\treturn NeedMore;\n\t\t\t}\n\n\t\t\treturn flush == Z_FINISH ? FinishDone : BlockDone;\n\t\t}\n\n\t\tfunction deflateReset(strm) {\n\t\t\tstrm.total_in = strm.total_out = 0;\n\t\t\tstrm.msg = null; //\n\t\t\t\n\t\t\tthat.pending = 0;\n\t\t\tthat.pending_out = 0;\n\n\t\t\tstatus = BUSY_STATE;\n\n\t\t\tlast_flush = Z_NO_FLUSH;\n\n\t\t\ttr_init();\n\t\t\tlm_init();\n\t\t\treturn Z_OK;\n\t\t}\n\n\t\tthat.deflateInit = function(strm, _level, bits, _method, memLevel, _strategy) {\n\t\t\tif (!_method)\n\t\t\t\t_method = Z_DEFLATED;\n\t\t\tif (!memLevel)\n\t\t\t\tmemLevel = DEF_MEM_LEVEL;\n\t\t\tif (!_strategy)\n\t\t\t\t_strategy = Z_DEFAULT_STRATEGY;\n\n\t\t\t// byte[] my_version=ZLIB_VERSION;\n\n\t\t\t//\n\t\t\t// if (!version || version[0] != my_version[0]\n\t\t\t// || stream_size != sizeof(z_stream)) {\n\t\t\t// return Z_VERSION_ERROR;\n\t\t\t// }\n\n\t\t\tstrm.msg = null;\n\n\t\t\tif (_level == Z_DEFAULT_COMPRESSION)\n\t\t\t\t_level = 6;\n\n\t\t\tif (memLevel < 1 || memLevel > MAX_MEM_LEVEL || _method != Z_DEFLATED || bits < 9 || bits > 15 || _level < 0 || _level > 9 || _strategy < 0\n\t\t\t\t\t|| _strategy > Z_HUFFMAN_ONLY) {\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\t}\n\n\t\t\tstrm.dstate = that;\n\n\t\t\tw_bits = bits;\n\t\t\tw_size = 1 << w_bits;\n\t\t\tw_mask = w_size - 1;\n\n\t\t\thash_bits = memLevel + 7;\n\t\t\thash_size = 1 << hash_bits;\n\t\t\thash_mask = hash_size - 1;\n\t\t\thash_shift = Math.floor((hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n\t\t\twindow = new Uint8Array(w_size * 2);\n\t\t\tprev = [];\n\t\t\thead = [];\n\n\t\t\tlit_bufsize = 1 << (memLevel + 6); // 16K elements by default\n\n\t\t\t// We overlay pending_buf and d_buf+l_buf. This works since the average\n\t\t\t// output size for (length,distance) codes is <= 24 bits.\n\t\t\tthat.pending_buf = new Uint8Array(lit_bufsize * 4);\n\t\t\tpending_buf_size = lit_bufsize * 4;\n\n\t\t\td_buf = Math.floor(lit_bufsize / 2);\n\t\t\tl_buf = (1 + 2) * lit_bufsize;\n\n\t\t\tlevel = _level;\n\n\t\t\tstrategy = _strategy;\n\t\t\tmethod = _method & 0xff;\n\n\t\t\treturn deflateReset(strm);\n\t\t};\n\n\t\tthat.deflateEnd = function() {\n\t\t\tif (status != INIT_STATE && status != BUSY_STATE && status != FINISH_STATE) {\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\t}\n\t\t\t// Deallocate in reverse order of allocations:\n\t\t\tthat.pending_buf = null;\n\t\t\thead = null;\n\t\t\tprev = null;\n\t\t\twindow = null;\n\t\t\t// free\n\t\t\tthat.dstate = null;\n\t\t\treturn status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;\n\t\t};\n\n\t\tthat.deflateParams = function(strm, _level, _strategy) {\n\t\t\tvar err = Z_OK;\n\n\t\t\tif (_level == Z_DEFAULT_COMPRESSION) {\n\t\t\t\t_level = 6;\n\t\t\t}\n\t\t\tif (_level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY) {\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\t}\n\n\t\t\tif (config_table[level].func != config_table[_level].func && strm.total_in !== 0) {\n\t\t\t\t// Flush the last buffer:\n\t\t\t\terr = strm.deflate(Z_PARTIAL_FLUSH);\n\t\t\t}\n\n\t\t\tif (level != _level) {\n\t\t\t\tlevel = _level;\n\t\t\t\tmax_lazy_match = config_table[level].max_lazy;\n\t\t\t\tgood_match = config_table[level].good_length;\n\t\t\t\tnice_match = config_table[level].nice_length;\n\t\t\t\tmax_chain_length = config_table[level].max_chain;\n\t\t\t}\n\t\t\tstrategy = _strategy;\n\t\t\treturn err;\n\t\t};\n\n\t\tthat.deflateSetDictionary = function(strm, dictionary, dictLength) {\n\t\t\tvar length = dictLength;\n\t\t\tvar n, index = 0;\n\n\t\t\tif (!dictionary || status != INIT_STATE)\n\t\t\t\treturn Z_STREAM_ERROR;\n\n\t\t\tif (length < MIN_MATCH)\n\t\t\t\treturn Z_OK;\n\t\t\tif (length > w_size - MIN_LOOKAHEAD) {\n\t\t\t\tlength = w_size - MIN_LOOKAHEAD;\n\t\t\t\tindex = dictLength - length; // use the tail of the dictionary\n\t\t\t}\n\t\t\twindow.set(dictionary.subarray(index, index + length), 0);\n\n\t\t\tstrstart = length;\n\t\t\tblock_start = length;\n\n\t\t\t// Insert all strings in the hash table (except for the last two bytes).\n\t\t\t// s->lookahead stays null, so s->ins_h will be recomputed at the next\n\t\t\t// call of fill_window.\n\n\t\t\tins_h = window[0] & 0xff;\n\t\t\tins_h = (((ins_h) << hash_shift) ^ (window[1] & 0xff)) & hash_mask;\n\n\t\t\tfor (n = 0; n <= length - MIN_MATCH; n++) {\n\t\t\t\tins_h = (((ins_h) << hash_shift) ^ (window[(n) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;\n\t\t\t\tprev[n & w_mask] = head[ins_h];\n\t\t\t\thead[ins_h] = n;\n\t\t\t}\n\t\t\treturn Z_OK;\n\t\t};\n\n\t\tthat.deflate = function(_strm, flush) {\n\t\t\tvar i, header, level_flags, old_flush, bstate;\n\n\t\t\tif (flush > Z_FINISH || flush < 0) {\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\t}\n\n\t\t\tif (!_strm.next_out || (!_strm.next_in && _strm.avail_in !== 0) || (status == FINISH_STATE && flush != Z_FINISH)) {\n\t\t\t\t_strm.msg = z_errmsg[Z_NEED_DICT - (Z_STREAM_ERROR)];\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\t}\n\t\t\tif (_strm.avail_out === 0) {\n\t\t\t\t_strm.msg = z_errmsg[Z_NEED_DICT - (Z_BUF_ERROR)];\n\t\t\t\treturn Z_BUF_ERROR;\n\t\t\t}\n\n\t\t\tstrm = _strm; // just in case\n\t\t\told_flush = last_flush;\n\t\t\tlast_flush = flush;\n\n\t\t\t// Write the zlib header\n\t\t\tif (status == INIT_STATE) {\n\t\t\t\theader = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;\n\t\t\t\tlevel_flags = ((level - 1) & 0xff) >> 1;\n\n\t\t\t\tif (level_flags > 3)\n\t\t\t\t\tlevel_flags = 3;\n\t\t\t\theader |= (level_flags << 6);\n\t\t\t\tif (strstart !== 0)\n\t\t\t\t\theader |= PRESET_DICT;\n\t\t\t\theader += 31 - (header % 31);\n\n\t\t\t\tstatus = BUSY_STATE;\n\t\t\t\tputShortMSB(header);\n\t\t\t}\n\n\t\t\t// Flush as much pending output as possible\n\t\t\tif (that.pending !== 0) {\n\t\t\t\tstrm.flush_pending();\n\t\t\t\tif (strm.avail_out === 0) {\n\t\t\t\t\t// console.log(\" avail_out==0\");\n\t\t\t\t\t// Since avail_out is 0, deflate will be called again with\n\t\t\t\t\t// more output space, but possibly with both pending and\n\t\t\t\t\t// avail_in equal to zero. There won't be anything to do,\n\t\t\t\t\t// but this is not an error situation so make sure we\n\t\t\t\t\t// return OK instead of BUF_ERROR at next call of deflate:\n\t\t\t\t\tlast_flush = -1;\n\t\t\t\t\treturn Z_OK;\n\t\t\t\t}\n\n\t\t\t\t// Make sure there is something to do and avoid duplicate\n\t\t\t\t// consecutive\n\t\t\t\t// flushes. For repeated and useless calls with Z_FINISH, we keep\n\t\t\t\t// returning Z_STREAM_END instead of Z_BUFF_ERROR.\n\t\t\t} else if (strm.avail_in === 0 && flush <= old_flush && flush != Z_FINISH) {\n\t\t\t\tstrm.msg = z_errmsg[Z_NEED_DICT - (Z_BUF_ERROR)];\n\t\t\t\treturn Z_BUF_ERROR;\n\t\t\t}\n\n\t\t\t// User must not provide more input after the first FINISH:\n\t\t\tif (status == FINISH_STATE && strm.avail_in !== 0) {\n\t\t\t\t_strm.msg = z_errmsg[Z_NEED_DICT - (Z_BUF_ERROR)];\n\t\t\t\treturn Z_BUF_ERROR;\n\t\t\t}\n\n\t\t\t// Start a new block or continue the current one.\n\t\t\tif (strm.avail_in !== 0 || lookahead !== 0 || (flush != Z_NO_FLUSH && status != FINISH_STATE)) {\n\t\t\t\tbstate = -1;\n\t\t\t\tswitch (config_table[level].func) {\n\t\t\t\tcase STORED:\n\t\t\t\t\tbstate = deflate_stored(flush);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FAST:\n\t\t\t\t\tbstate = deflate_fast(flush);\n\t\t\t\t\tbreak;\n\t\t\t\tcase SLOW:\n\t\t\t\t\tbstate = deflate_slow(flush);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t}\n\n\t\t\t\tif (bstate == FinishStarted || bstate == FinishDone) {\n\t\t\t\t\tstatus = FINISH_STATE;\n\t\t\t\t}\n\t\t\t\tif (bstate == NeedMore || bstate == FinishStarted) {\n\t\t\t\t\tif (strm.avail_out === 0) {\n\t\t\t\t\t\tlast_flush = -1; // avoid BUF_ERROR next call, see above\n\t\t\t\t\t}\n\t\t\t\t\treturn Z_OK;\n\t\t\t\t\t// If flush != Z_NO_FLUSH && avail_out === 0, the next call\n\t\t\t\t\t// of deflate should use the same flush parameter to make sure\n\t\t\t\t\t// that the flush is complete. So we don't have to output an\n\t\t\t\t\t// empty block here, this will be done at next call. This also\n\t\t\t\t\t// ensures that for a very small output buffer, we emit at most\n\t\t\t\t\t// one empty block.\n\t\t\t\t}\n\n\t\t\t\tif (bstate == BlockDone) {\n\t\t\t\t\tif (flush == Z_PARTIAL_FLUSH) {\n\t\t\t\t\t\t_tr_align();\n\t\t\t\t\t} else { // FULL_FLUSH or SYNC_FLUSH\n\t\t\t\t\t\t_tr_stored_block(0, 0, false);\n\t\t\t\t\t\t// For a full flush, this empty block will be recognized\n\t\t\t\t\t\t// as a special marker by inflate_sync().\n\t\t\t\t\t\tif (flush == Z_FULL_FLUSH) {\n\t\t\t\t\t\t\t// state.head[s.hash_size-1]=0;\n\t\t\t\t\t\t\tfor (i = 0; i < hash_size/*-1*/; i++)\n\t\t\t\t\t\t\t\t// forget history\n\t\t\t\t\t\t\t\thead[i] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstrm.flush_pending();\n\t\t\t\t\tif (strm.avail_out === 0) {\n\t\t\t\t\t\tlast_flush = -1; // avoid BUF_ERROR at next call, see above\n\t\t\t\t\t\treturn Z_OK;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (flush != Z_FINISH)\n\t\t\t\treturn Z_OK;\n\t\t\treturn Z_STREAM_END;\n\t\t};\n\t}\n\n\t// ZStream\n\n\tfunction ZStream() {\n\t\tvar that = this;\n\t\tthat.next_in_index = 0;\n\t\tthat.next_out_index = 0;\n\t\t// that.next_in; // next input byte\n\t\tthat.avail_in = 0; // number of bytes available at next_in\n\t\tthat.total_in = 0; // total nb of input bytes read so far\n\t\t// that.next_out; // next output byte should be put there\n\t\tthat.avail_out = 0; // remaining free space at next_out\n\t\tthat.total_out = 0; // total nb of bytes output so far\n\t\t// that.msg;\n\t\t// that.dstate;\n\t}\n\n\tZStream.prototype = {\n\t\tdeflateInit : function(level, bits) {\n\t\t\tvar that = this;\n\t\t\tthat.dstate = new Deflate();\n\t\t\tif (!bits)\n\t\t\t\tbits = MAX_BITS;\n\t\t\treturn that.dstate.deflateInit(that, level, bits);\n\t\t},\n\n\t\tdeflate : function(flush) {\n\t\t\tvar that = this;\n\t\t\tif (!that.dstate) {\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\t}\n\t\t\treturn that.dstate.deflate(that, flush);\n\t\t},\n\n\t\tdeflateEnd : function() {\n\t\t\tvar that = this;\n\t\t\tif (!that.dstate)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\tvar ret = that.dstate.deflateEnd();\n\t\t\tthat.dstate = null;\n\t\t\treturn ret;\n\t\t},\n\n\t\tdeflateParams : function(level, strategy) {\n\t\t\tvar that = this;\n\t\t\tif (!that.dstate)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\treturn that.dstate.deflateParams(that, level, strategy);\n\t\t},\n\n\t\tdeflateSetDictionary : function(dictionary, dictLength) {\n\t\t\tvar that = this;\n\t\t\tif (!that.dstate)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\treturn that.dstate.deflateSetDictionary(that, dictionary, dictLength);\n\t\t},\n\n\t\t// Read a new buffer from the current input stream, update the\n\t\t// total number of bytes read. All deflate() input goes through\n\t\t// this function so some applications may wish to modify it to avoid\n\t\t// allocating a large strm->next_in buffer and copying from it.\n\t\t// (See also flush_pending()).\n\t\tread_buf : function(buf, start, size) {\n\t\t\tvar that = this;\n\t\t\tvar len = that.avail_in;\n\t\t\tif (len > size)\n\t\t\t\tlen = size;\n\t\t\tif (len === 0)\n\t\t\t\treturn 0;\n\t\t\tthat.avail_in -= len;\n\t\t\tbuf.set(that.next_in.subarray(that.next_in_index, that.next_in_index + len), start);\n\t\t\tthat.next_in_index += len;\n\t\t\tthat.total_in += len;\n\t\t\treturn len;\n\t\t},\n\n\t\t// Flush as much pending output as possible. All deflate() output goes\n\t\t// through this function so some applications may wish to modify it\n\t\t// to avoid allocating a large strm->next_out buffer and copying into it.\n\t\t// (See also read_buf()).\n\t\tflush_pending : function() {\n\t\t\tvar that = this;\n\t\t\tvar len = that.dstate.pending;\n\n\t\t\tif (len > that.avail_out)\n\t\t\t\tlen = that.avail_out;\n\t\t\tif (len === 0)\n\t\t\t\treturn;\n\n\t\t\t// if (that.dstate.pending_buf.length <= that.dstate.pending_out || that.next_out.length <= that.next_out_index\n\t\t\t// || that.dstate.pending_buf.length < (that.dstate.pending_out + len) || that.next_out.length < (that.next_out_index +\n\t\t\t// len)) {\n\t\t\t// console.log(that.dstate.pending_buf.length + \", \" + that.dstate.pending_out + \", \" + that.next_out.length + \", \" +\n\t\t\t// that.next_out_index + \", \" + len);\n\t\t\t// console.log(\"avail_out=\" + that.avail_out);\n\t\t\t// }\n\n\t\t\tthat.next_out.set(that.dstate.pending_buf.subarray(that.dstate.pending_out, that.dstate.pending_out + len), that.next_out_index);\n\n\t\t\tthat.next_out_index += len;\n\t\t\tthat.dstate.pending_out += len;\n\t\t\tthat.total_out += len;\n\t\t\tthat.avail_out -= len;\n\t\t\tthat.dstate.pending -= len;\n\t\t\tif (that.dstate.pending === 0) {\n\t\t\t\tthat.dstate.pending_out = 0;\n\t\t\t}\n\t\t}\n\t};\n\n\t// Deflater\n\n\tfunction Deflater(options) {\n\t\tvar that = this;\n\t\tvar z = new ZStream();\n\t\tvar bufsize = 512;\n\t\tvar flush = Z_NO_FLUSH;\n\t\tvar buf = new Uint8Array(bufsize);\n\t\tvar level = options ? options.level : Z_DEFAULT_COMPRESSION;\n\t\tif (typeof level == \"undefined\")\n\t\t\tlevel = Z_DEFAULT_COMPRESSION;\n\t\tz.deflateInit(level);\n\t\tz.next_out = buf;\n\n\t\tthat.append = function(data, onprogress) {\n\t\t\tvar err, buffers = [], lastIndex = 0, bufferIndex = 0, bufferSize = 0, array;\n\t\t\tif (!data.length)\n\t\t\t\treturn;\n\t\t\tz.next_in_index = 0;\n\t\t\tz.next_in = data;\n\t\t\tz.avail_in = data.length;\n\t\t\tdo {\n\t\t\t\tz.next_out_index = 0;\n\t\t\t\tz.avail_out = bufsize;\n\t\t\t\terr = z.deflate(flush);\n\t\t\t\tif (err != Z_OK)\n\t\t\t\t\tthrow new Error(\"deflating: \" + z.msg);\n\t\t\t\tif (z.next_out_index)\n\t\t\t\t\tif (z.next_out_index == bufsize)\n\t\t\t\t\t\tbuffers.push(new Uint8Array(buf));\n\t\t\t\t\telse\n\t\t\t\t\t\tbuffers.push(new Uint8Array(buf.subarray(0, z.next_out_index)));\n\t\t\t\tbufferSize += z.next_out_index;\n\t\t\t\tif (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {\n\t\t\t\t\tonprogress(z.next_in_index);\n\t\t\t\t\tlastIndex = z.next_in_index;\n\t\t\t\t}\n\t\t\t} while (z.avail_in > 0 || z.avail_out === 0);\n\t\t\tarray = new Uint8Array(bufferSize);\n\t\t\tbuffers.forEach(function(chunk) {\n\t\t\t\tarray.set(chunk, bufferIndex);\n\t\t\t\tbufferIndex += chunk.length;\n\t\t\t});\n\t\t\treturn array;\n\t\t};\n\t\tthat.flush = function() {\n\t\t\tvar err, buffers = [], bufferIndex = 0, bufferSize = 0, array;\n\t\t\tdo {\n\t\t\t\tz.next_out_index = 0;\n\t\t\t\tz.avail_out = bufsize;\n\t\t\t\terr = z.deflate(Z_FINISH);\n\t\t\t\tif (err != Z_STREAM_END && err != Z_OK)\n\t\t\t\t\tthrow new Error(\"deflating: \" + z.msg);\n\t\t\t\tif (bufsize - z.avail_out > 0)\n\t\t\t\t\tbuffers.push(new Uint8Array(buf.subarray(0, z.next_out_index)));\n\t\t\t\tbufferSize += z.next_out_index;\n\t\t\t} while (z.avail_in > 0 || z.avail_out === 0);\n\t\t\tz.deflateEnd();\n\t\t\tarray = new Uint8Array(bufferSize);\n\t\t\tbuffers.forEach(function(chunk) {\n\t\t\t\tarray.set(chunk, bufferIndex);\n\t\t\t\tbufferIndex += chunk.length;\n\t\t\t});\n\t\t\treturn array;\n\t\t};\n\t}\n\n\t// 'zip' may not be defined in z-worker and some tests\n\tvar env = global.zip || global;\n\tenv.Deflater = env._jzlib_Deflater = Deflater;\n})(this);\n")],
  inflater: [zWorker, createUrl("/*\n Copyright (c) 2013 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright \n notice, this list of conditions and the following disclaimer in \n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * This program is based on JZlib 1.0.2 ymnk, JCraft,Inc.\n * JZlib is based on zlib-1.1.3, so all credit should go authors\n * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)\n * and contributors of zlib.\n */\n\n(function(global) {\n\t\"use strict\";\n\n\t// Global\n\tvar MAX_BITS = 15;\n\n\tvar Z_OK = 0;\n\tvar Z_STREAM_END = 1;\n\tvar Z_NEED_DICT = 2;\n\tvar Z_STREAM_ERROR = -2;\n\tvar Z_DATA_ERROR = -3;\n\tvar Z_MEM_ERROR = -4;\n\tvar Z_BUF_ERROR = -5;\n\n\tvar inflate_mask = [ 0x00000000, 0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff,\n\t\t\t0x000007ff, 0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff ];\n\n\tvar MANY = 1440;\n\n\t// JZlib version : \"1.0.2\"\n\tvar Z_NO_FLUSH = 0;\n\tvar Z_FINISH = 4;\n\n\t// InfTree\n\tvar fixed_bl = 9;\n\tvar fixed_bd = 5;\n\n\tvar fixed_tl = [ 96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9, 192, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 160, 0, 8, 0,\n\t\t\t0, 8, 128, 0, 8, 64, 0, 9, 224, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 144, 83, 7, 59, 0, 8, 120, 0, 8, 56, 0, 9, 208, 81, 7, 17, 0, 8, 104, 0, 8, 40,\n\t\t\t0, 9, 176, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 240, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 200, 81, 7, 13,\n\t\t\t0, 8, 100, 0, 8, 36, 0, 9, 168, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 232, 80, 7, 8, 0, 8, 92, 0, 8, 28, 0, 9, 152, 84, 7, 83, 0, 8, 124, 0, 8, 60,\n\t\t\t0, 9, 216, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 184, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 248, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7,\n\t\t\t35, 0, 8, 114, 0, 8, 50, 0, 9, 196, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 164, 0, 8, 2, 0, 8, 130, 0, 8, 66, 0, 9, 228, 80, 7, 7, 0, 8, 90, 0, 8,\n\t\t\t26, 0, 9, 148, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 212, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 180, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 244, 80,\n\t\t\t7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 204, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0, 9, 172, 0, 8, 6, 0, 8, 134, 0,\n\t\t\t8, 70, 0, 9, 236, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 156, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 220, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 188, 0,\n\t\t\t8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 252, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 194, 80, 7, 10, 0, 8, 97,\n\t\t\t0, 8, 33, 0, 9, 162, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 226, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 146, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 210,\n\t\t\t81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 178, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 242, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117,\n\t\t\t0, 8, 53, 0, 9, 202, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 170, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 234, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 154,\n\t\t\t84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 218, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 186, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9, 250, 80, 7, 3, 0, 8, 83,\n\t\t\t0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 198, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 166, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 230,\n\t\t\t80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 150, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 214, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9, 182, 0, 8, 11, 0, 8, 139,\n\t\t\t0, 8, 75, 0, 9, 246, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9, 206, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 174,\n\t\t\t0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 238, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 158, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9, 222, 82, 7, 27, 0, 8, 111,\n\t\t\t0, 8, 47, 0, 9, 190, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 254, 96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9,\n\t\t\t193, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 161, 0, 8, 0, 0, 8, 128, 0, 8, 64, 0, 9, 225, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 145, 83, 7, 59, 0, 8,\n\t\t\t120, 0, 8, 56, 0, 9, 209, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 177, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 241, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8,\n\t\t\t227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 201, 81, 7, 13, 0, 8, 100, 0, 8, 36, 0, 9, 169, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 233, 80, 7, 8, 0, 8,\n\t\t\t92, 0, 8, 28, 0, 9, 153, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 217, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 185, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9,\n\t\t\t249, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9, 197, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 165, 0, 8, 2, 0, 8,\n\t\t\t130, 0, 8, 66, 0, 9, 229, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 149, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 213, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9,\n\t\t\t181, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 245, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 205, 81, 7, 15, 0, 8,\n\t\t\t102, 0, 8, 38, 0, 9, 173, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 237, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 157, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9,\n\t\t\t221, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 189, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 253, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0,\n\t\t\t8, 113, 0, 8, 49, 0, 9, 195, 80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 163, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 227, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9,\n\t\t\t147, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 211, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 179, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 243, 80, 7, 4, 0, 8,\n\t\t\t85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117, 0, 8, 53, 0, 9, 203, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 171, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9,\n\t\t\t235, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 155, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 219, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 187, 0, 8, 13, 0, 8,\n\t\t\t141, 0, 8, 77, 0, 9, 251, 80, 7, 3, 0, 8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 199, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9,\n\t\t\t167, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 231, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 151, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 215, 82, 7, 19, 0, 8,\n\t\t\t107, 0, 8, 43, 0, 9, 183, 0, 8, 11, 0, 8, 139, 0, 8, 75, 0, 9, 247, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9,\n\t\t\t207, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 175, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 239, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 159, 84, 7, 99, 0, 8,\n\t\t\t127, 0, 8, 63, 0, 9, 223, 82, 7, 27, 0, 8, 111, 0, 8, 47, 0, 9, 191, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 255 ];\n\tvar fixed_td = [ 80, 5, 1, 87, 5, 257, 83, 5, 17, 91, 5, 4097, 81, 5, 5, 89, 5, 1025, 85, 5, 65, 93, 5, 16385, 80, 5, 3, 88, 5, 513, 84, 5, 33, 92, 5,\n\t\t\t8193, 82, 5, 9, 90, 5, 2049, 86, 5, 129, 192, 5, 24577, 80, 5, 2, 87, 5, 385, 83, 5, 25, 91, 5, 6145, 81, 5, 7, 89, 5, 1537, 85, 5, 97, 93, 5,\n\t\t\t24577, 80, 5, 4, 88, 5, 769, 84, 5, 49, 92, 5, 12289, 82, 5, 13, 90, 5, 3073, 86, 5, 193, 192, 5, 24577 ];\n\n\t// Tables for deflate from PKZIP's appnote.txt.\n\tvar cplens = [ // Copy lengths for literal codes 257..285\n\t3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0 ];\n\n\t// see note #13 above about 258\n\tvar cplext = [ // Extra bits for literal codes 257..285\n\t0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112 // 112==invalid\n\t];\n\n\tvar cpdist = [ // Copy offsets for distance codes 0..29\n\t1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577 ];\n\n\tvar cpdext = [ // Extra bits for distance codes\n\t0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ];\n\n\t// If BMAX needs to be larger than 16, then h and x[] should be uLong.\n\tvar BMAX = 15; // maximum bit length of any code\n\n\tfunction InfTree() {\n\t\tvar that = this;\n\n\t\tvar hn; // hufts used in space\n\t\tvar v; // work area for huft_build\n\t\tvar c; // bit length count table\n\t\tvar r; // table entry for structure assignment\n\t\tvar u; // table stack\n\t\tvar x; // bit offsets, then code stack\n\n\t\tfunction huft_build(b, // code lengths in bits (all assumed <=\n\t\t// BMAX)\n\t\tbindex, n, // number of codes (assumed <= 288)\n\t\ts, // number of simple-valued codes (0..s-1)\n\t\td, // list of base values for non-simple codes\n\t\te, // list of extra bits for non-simple codes\n\t\tt, // result: starting table\n\t\tm, // maximum lookup bits, returns actual\n\t\thp,// space for trees\n\t\thn,// hufts used in space\n\t\tv // working area: values in order of bit length\n\t\t) {\n\t\t\t// Given a list of code lengths and a maximum table size, make a set of\n\t\t\t// tables to decode that set of codes. Return Z_OK on success,\n\t\t\t// Z_BUF_ERROR\n\t\t\t// if the given code set is incomplete (the tables are still built in\n\t\t\t// this\n\t\t\t// case), Z_DATA_ERROR if the input is invalid (an over-subscribed set\n\t\t\t// of\n\t\t\t// lengths), or Z_MEM_ERROR if not enough memory.\n\n\t\t\tvar a; // counter for codes of length k\n\t\t\tvar f; // i repeats in table every f entries\n\t\t\tvar g; // maximum code length\n\t\t\tvar h; // table level\n\t\t\tvar i; // counter, current code\n\t\t\tvar j; // counter\n\t\t\tvar k; // number of bits in current code\n\t\t\tvar l; // bits per table (returned in m)\n\t\t\tvar mask; // (1 << w) - 1, to avoid cc -O bug on HP\n\t\t\tvar p; // pointer into c[], b[], or v[]\n\t\t\tvar q; // points to current table\n\t\t\tvar w; // bits before this table == (l * h)\n\t\t\tvar xp; // pointer into x\n\t\t\tvar y; // number of dummy codes added\n\t\t\tvar z; // number of entries in current table\n\n\t\t\t// Generate counts for each bit length\n\n\t\t\tp = 0;\n\t\t\ti = n;\n\t\t\tdo {\n\t\t\t\tc[b[bindex + p]]++;\n\t\t\t\tp++;\n\t\t\t\ti--; // assume all entries <= BMAX\n\t\t\t} while (i !== 0);\n\n\t\t\tif (c[0] == n) { // null input--all zero length codes\n\t\t\t\tt[0] = -1;\n\t\t\t\tm[0] = 0;\n\t\t\t\treturn Z_OK;\n\t\t\t}\n\n\t\t\t// Find minimum and maximum length, bound *m by those\n\t\t\tl = m[0];\n\t\t\tfor (j = 1; j <= BMAX; j++)\n\t\t\t\tif (c[j] !== 0)\n\t\t\t\t\tbreak;\n\t\t\tk = j; // minimum code length\n\t\t\tif (l < j) {\n\t\t\t\tl = j;\n\t\t\t}\n\t\t\tfor (i = BMAX; i !== 0; i--) {\n\t\t\t\tif (c[i] !== 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tg = i; // maximum code length\n\t\t\tif (l > i) {\n\t\t\t\tl = i;\n\t\t\t}\n\t\t\tm[0] = l;\n\n\t\t\t// Adjust last length count to fill out codes, if needed\n\t\t\tfor (y = 1 << j; j < i; j++, y <<= 1) {\n\t\t\t\tif ((y -= c[j]) < 0) {\n\t\t\t\t\treturn Z_DATA_ERROR;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((y -= c[i]) < 0) {\n\t\t\t\treturn Z_DATA_ERROR;\n\t\t\t}\n\t\t\tc[i] += y;\n\n\t\t\t// Generate starting offsets into the value table for each length\n\t\t\tx[1] = j = 0;\n\t\t\tp = 1;\n\t\t\txp = 2;\n\t\t\twhile (--i !== 0) { // note that i == g from above\n\t\t\t\tx[xp] = (j += c[p]);\n\t\t\t\txp++;\n\t\t\t\tp++;\n\t\t\t}\n\n\t\t\t// Make a table of values in order of bit lengths\n\t\t\ti = 0;\n\t\t\tp = 0;\n\t\t\tdo {\n\t\t\t\tif ((j = b[bindex + p]) !== 0) {\n\t\t\t\t\tv[x[j]++] = i;\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t} while (++i < n);\n\t\t\tn = x[g]; // set n to length of v\n\n\t\t\t// Generate the Huffman codes and for each, make the table entries\n\t\t\tx[0] = i = 0; // first Huffman code is zero\n\t\t\tp = 0; // grab values in bit order\n\t\t\th = -1; // no tables yet--level -1\n\t\t\tw = -l; // bits decoded == (l * h)\n\t\t\tu[0] = 0; // just to keep compilers happy\n\t\t\tq = 0; // ditto\n\t\t\tz = 0; // ditto\n\n\t\t\t// go through the bit lengths (k already is bits in shortest code)\n\t\t\tfor (; k <= g; k++) {\n\t\t\t\ta = c[k];\n\t\t\t\twhile (a-- !== 0) {\n\t\t\t\t\t// here i is the Huffman code of length k bits for value *p\n\t\t\t\t\t// make tables up to required level\n\t\t\t\t\twhile (k > w + l) {\n\t\t\t\t\t\th++;\n\t\t\t\t\t\tw += l; // previous table always l bits\n\t\t\t\t\t\t// compute minimum size table less than or equal to l bits\n\t\t\t\t\t\tz = g - w;\n\t\t\t\t\t\tz = (z > l) ? l : z; // table size upper limit\n\t\t\t\t\t\tif ((f = 1 << (j = k - w)) > a + 1) { // try a k-w bit table\n\t\t\t\t\t\t\t// too few codes for\n\t\t\t\t\t\t\t// k-w bit table\n\t\t\t\t\t\t\tf -= a + 1; // deduct codes from patterns left\n\t\t\t\t\t\t\txp = k;\n\t\t\t\t\t\t\tif (j < z) {\n\t\t\t\t\t\t\t\twhile (++j < z) { // try smaller tables up to z bits\n\t\t\t\t\t\t\t\t\tif ((f <<= 1) <= c[++xp])\n\t\t\t\t\t\t\t\t\t\tbreak; // enough codes to use up j bits\n\t\t\t\t\t\t\t\t\tf -= c[xp]; // else deduct codes from patterns\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tz = 1 << j; // table entries for j-bit table\n\n\t\t\t\t\t\t// allocate new table\n\t\t\t\t\t\tif (hn[0] + z > MANY) { // (note: doesn't matter for fixed)\n\t\t\t\t\t\t\treturn Z_DATA_ERROR; // overflow of MANY\n\t\t\t\t\t\t}\n\t\t\t\t\t\tu[h] = q = /* hp+ */hn[0]; // DEBUG\n\t\t\t\t\t\thn[0] += z;\n\n\t\t\t\t\t\t// connect to last table, if there is one\n\t\t\t\t\t\tif (h !== 0) {\n\t\t\t\t\t\t\tx[h] = i; // save pattern for backing up\n\t\t\t\t\t\t\tr[0] = /* (byte) */j; // bits in this table\n\t\t\t\t\t\t\tr[1] = /* (byte) */l; // bits to dump before this table\n\t\t\t\t\t\t\tj = i >>> (w - l);\n\t\t\t\t\t\t\tr[2] = /* (int) */(q - u[h - 1] - j); // offset to this table\n\t\t\t\t\t\t\thp.set(r, (u[h - 1] + j) * 3);\n\t\t\t\t\t\t\t// to\n\t\t\t\t\t\t\t// last\n\t\t\t\t\t\t\t// table\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tt[0] = q; // first table is returned result\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// set up table entry in r\n\t\t\t\t\tr[1] = /* (byte) */(k - w);\n\t\t\t\t\tif (p >= n) {\n\t\t\t\t\t\tr[0] = 128 + 64; // out of values--invalid code\n\t\t\t\t\t} else if (v[p] < s) {\n\t\t\t\t\t\tr[0] = /* (byte) */(v[p] < 256 ? 0 : 32 + 64); // 256 is\n\t\t\t\t\t\t// end-of-block\n\t\t\t\t\t\tr[2] = v[p++]; // simple code is just the value\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr[0] = /* (byte) */(e[v[p] - s] + 16 + 64); // non-simple--look\n\t\t\t\t\t\t// up in lists\n\t\t\t\t\t\tr[2] = d[v[p++] - s];\n\t\t\t\t\t}\n\n\t\t\t\t\t// fill code-like entries with r\n\t\t\t\t\tf = 1 << (k - w);\n\t\t\t\t\tfor (j = i >>> w; j < z; j += f) {\n\t\t\t\t\t\thp.set(r, (q + j) * 3);\n\t\t\t\t\t}\n\n\t\t\t\t\t// backwards increment the k-bit code i\n\t\t\t\t\tfor (j = 1 << (k - 1); (i & j) !== 0; j >>>= 1) {\n\t\t\t\t\t\ti ^= j;\n\t\t\t\t\t}\n\t\t\t\t\ti ^= j;\n\n\t\t\t\t\t// backup over finished tables\n\t\t\t\t\tmask = (1 << w) - 1; // needed on HP, cc -O bug\n\t\t\t\t\twhile ((i & mask) != x[h]) {\n\t\t\t\t\t\th--; // don't need to update q\n\t\t\t\t\t\tw -= l;\n\t\t\t\t\t\tmask = (1 << w) - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Return Z_BUF_ERROR if we were given an incomplete table\n\t\t\treturn y !== 0 && g != 1 ? Z_BUF_ERROR : Z_OK;\n\t\t}\n\n\t\tfunction initWorkArea(vsize) {\n\t\t\tvar i;\n\t\t\tif (!hn) {\n\t\t\t\thn = []; // []; //new Array(1);\n\t\t\t\tv = []; // new Array(vsize);\n\t\t\t\tc = new Int32Array(BMAX + 1); // new Array(BMAX + 1);\n\t\t\t\tr = []; // new Array(3);\n\t\t\t\tu = new Int32Array(BMAX); // new Array(BMAX);\n\t\t\t\tx = new Int32Array(BMAX + 1); // new Array(BMAX + 1);\n\t\t\t}\n\t\t\tif (v.length < vsize) {\n\t\t\t\tv = []; // new Array(vsize);\n\t\t\t}\n\t\t\tfor (i = 0; i < vsize; i++) {\n\t\t\t\tv[i] = 0;\n\t\t\t}\n\t\t\tfor (i = 0; i < BMAX + 1; i++) {\n\t\t\t\tc[i] = 0;\n\t\t\t}\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\tr[i] = 0;\n\t\t\t}\n\t\t\t// for(int i=0; i<BMAX; i++){u[i]=0;}\n\t\t\tu.set(c.subarray(0, BMAX), 0);\n\t\t\t// for(int i=0; i<BMAX+1; i++){x[i]=0;}\n\t\t\tx.set(c.subarray(0, BMAX + 1), 0);\n\t\t}\n\n\t\tthat.inflate_trees_bits = function(c, // 19 code lengths\n\t\tbb, // bits tree desired/actual depth\n\t\ttb, // bits tree result\n\t\thp, // space for trees\n\t\tz // for messages\n\t\t) {\n\t\t\tvar result;\n\t\t\tinitWorkArea(19);\n\t\t\thn[0] = 0;\n\t\t\tresult = huft_build(c, 0, 19, 19, null, null, tb, bb, hp, hn, v);\n\n\t\t\tif (result == Z_DATA_ERROR) {\n\t\t\t\tz.msg = \"oversubscribed dynamic bit lengths tree\";\n\t\t\t} else if (result == Z_BUF_ERROR || bb[0] === 0) {\n\t\t\t\tz.msg = \"incomplete dynamic bit lengths tree\";\n\t\t\t\tresult = Z_DATA_ERROR;\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\n\t\tthat.inflate_trees_dynamic = function(nl, // number of literal/length codes\n\t\tnd, // number of distance codes\n\t\tc, // that many (total) code lengths\n\t\tbl, // literal desired/actual bit depth\n\t\tbd, // distance desired/actual bit depth\n\t\ttl, // literal/length tree result\n\t\ttd, // distance tree result\n\t\thp, // space for trees\n\t\tz // for messages\n\t\t) {\n\t\t\tvar result;\n\n\t\t\t// build literal/length tree\n\t\t\tinitWorkArea(288);\n\t\t\thn[0] = 0;\n\t\t\tresult = huft_build(c, 0, nl, 257, cplens, cplext, tl, bl, hp, hn, v);\n\t\t\tif (result != Z_OK || bl[0] === 0) {\n\t\t\t\tif (result == Z_DATA_ERROR) {\n\t\t\t\t\tz.msg = \"oversubscribed literal/length tree\";\n\t\t\t\t} else if (result != Z_MEM_ERROR) {\n\t\t\t\t\tz.msg = \"incomplete literal/length tree\";\n\t\t\t\t\tresult = Z_DATA_ERROR;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\t// build distance tree\n\t\t\tinitWorkArea(288);\n\t\t\tresult = huft_build(c, nl, nd, 0, cpdist, cpdext, td, bd, hp, hn, v);\n\n\t\t\tif (result != Z_OK || (bd[0] === 0 && nl > 257)) {\n\t\t\t\tif (result == Z_DATA_ERROR) {\n\t\t\t\t\tz.msg = \"oversubscribed distance tree\";\n\t\t\t\t} else if (result == Z_BUF_ERROR) {\n\t\t\t\t\tz.msg = \"incomplete distance tree\";\n\t\t\t\t\tresult = Z_DATA_ERROR;\n\t\t\t\t} else if (result != Z_MEM_ERROR) {\n\t\t\t\t\tz.msg = \"empty distance tree with lengths\";\n\t\t\t\t\tresult = Z_DATA_ERROR;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\treturn Z_OK;\n\t\t};\n\n\t}\n\n\tInfTree.inflate_trees_fixed = function(bl, // literal desired/actual bit depth\n\tbd, // distance desired/actual bit depth\n\ttl,// literal/length tree result\n\ttd// distance tree result\n\t) {\n\t\tbl[0] = fixed_bl;\n\t\tbd[0] = fixed_bd;\n\t\ttl[0] = fixed_tl;\n\t\ttd[0] = fixed_td;\n\t\treturn Z_OK;\n\t};\n\n\t// InfCodes\n\n\t// waiting for \"i:\"=input,\n\t// \"o:\"=output,\n\t// \"x:\"=nothing\n\tvar START = 0; // x: set up for LEN\n\tvar LEN = 1; // i: get length/literal/eob next\n\tvar LENEXT = 2; // i: getting length extra (have base)\n\tvar DIST = 3; // i: get distance next\n\tvar DISTEXT = 4;// i: getting distance extra\n\tvar COPY = 5; // o: copying bytes in window, waiting\n\t// for space\n\tvar LIT = 6; // o: got literal, waiting for output\n\t// space\n\tvar WASH = 7; // o: got eob, possibly still output\n\t// waiting\n\tvar END = 8; // x: got eob and all data flushed\n\tvar BADCODE = 9;// x: got error\n\n\tfunction InfCodes() {\n\t\tvar that = this;\n\n\t\tvar mode; // current inflate_codes mode\n\n\t\t// mode dependent information\n\t\tvar len = 0;\n\n\t\tvar tree; // pointer into tree\n\t\tvar tree_index = 0;\n\t\tvar need = 0; // bits needed\n\n\t\tvar lit = 0;\n\n\t\t// if EXT or COPY, where and how much\n\t\tvar get = 0; // bits to get for extra\n\t\tvar dist = 0; // distance back to copy from\n\n\t\tvar lbits = 0; // ltree bits decoded per branch\n\t\tvar dbits = 0; // dtree bits decoder per branch\n\t\tvar ltree; // literal/length/eob tree\n\t\tvar ltree_index = 0; // literal/length/eob tree\n\t\tvar dtree; // distance tree\n\t\tvar dtree_index = 0; // distance tree\n\n\t\t// Called with number of bytes left to write in window at least 258\n\t\t// (the maximum string length) and number of input bytes available\n\t\t// at least ten. The ten bytes are six bytes for the longest length/\n\t\t// distance pair plus four bytes for overloading the bit buffer.\n\n\t\tfunction inflate_fast(bl, bd, tl, tl_index, td, td_index, s, z) {\n\t\t\tvar t; // temporary pointer\n\t\t\tvar tp; // temporary pointer\n\t\t\tvar tp_index; // temporary pointer\n\t\t\tvar e; // extra bits or operation\n\t\t\tvar b; // bit buffer\n\t\t\tvar k; // bits in bit buffer\n\t\t\tvar p; // input data pointer\n\t\t\tvar n; // bytes available there\n\t\t\tvar q; // output window write pointer\n\t\t\tvar m; // bytes to end of window or read pointer\n\t\t\tvar ml; // mask for literal/length tree\n\t\t\tvar md; // mask for distance tree\n\t\t\tvar c; // bytes to copy\n\t\t\tvar d; // distance back to copy from\n\t\t\tvar r; // copy source pointer\n\n\t\t\tvar tp_index_t_3; // (tp_index+t)*3\n\n\t\t\t// load input, output, bit values\n\t\t\tp = z.next_in_index;\n\t\t\tn = z.avail_in;\n\t\t\tb = s.bitb;\n\t\t\tk = s.bitk;\n\t\t\tq = s.write;\n\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\n\t\t\t// initialize masks\n\t\t\tml = inflate_mask[bl];\n\t\t\tmd = inflate_mask[bd];\n\n\t\t\t// do until not enough input or output space for fast loop\n\t\t\tdo { // assume called with m >= 258 && n >= 10\n\t\t\t\t// get literal/length code\n\t\t\t\twhile (k < (20)) { // max bits for literal/length code\n\t\t\t\t\tn--;\n\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\tk += 8;\n\t\t\t\t}\n\n\t\t\t\tt = b & ml;\n\t\t\t\ttp = tl;\n\t\t\t\ttp_index = tl_index;\n\t\t\t\ttp_index_t_3 = (tp_index + t) * 3;\n\t\t\t\tif ((e = tp[tp_index_t_3]) === 0) {\n\t\t\t\t\tb >>= (tp[tp_index_t_3 + 1]);\n\t\t\t\t\tk -= (tp[tp_index_t_3 + 1]);\n\n\t\t\t\t\ts.window[q++] = /* (byte) */tp[tp_index_t_3 + 2];\n\t\t\t\t\tm--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdo {\n\n\t\t\t\t\tb >>= (tp[tp_index_t_3 + 1]);\n\t\t\t\t\tk -= (tp[tp_index_t_3 + 1]);\n\n\t\t\t\t\tif ((e & 16) !== 0) {\n\t\t\t\t\t\te &= 15;\n\t\t\t\t\t\tc = tp[tp_index_t_3 + 2] + (/* (int) */b & inflate_mask[e]);\n\n\t\t\t\t\t\tb >>= e;\n\t\t\t\t\t\tk -= e;\n\n\t\t\t\t\t\t// decode distance base of block to copy\n\t\t\t\t\t\twhile (k < (15)) { // max bits for distance code\n\t\t\t\t\t\t\tn--;\n\t\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\t\tk += 8;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tt = b & md;\n\t\t\t\t\t\ttp = td;\n\t\t\t\t\t\ttp_index = td_index;\n\t\t\t\t\t\ttp_index_t_3 = (tp_index + t) * 3;\n\t\t\t\t\t\te = tp[tp_index_t_3];\n\n\t\t\t\t\t\tdo {\n\n\t\t\t\t\t\t\tb >>= (tp[tp_index_t_3 + 1]);\n\t\t\t\t\t\t\tk -= (tp[tp_index_t_3 + 1]);\n\n\t\t\t\t\t\t\tif ((e & 16) !== 0) {\n\t\t\t\t\t\t\t\t// get extra bits to add to distance base\n\t\t\t\t\t\t\t\te &= 15;\n\t\t\t\t\t\t\t\twhile (k < (e)) { // get extra bits (up to 13)\n\t\t\t\t\t\t\t\t\tn--;\n\t\t\t\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\t\t\t\tk += 8;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\td = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);\n\n\t\t\t\t\t\t\t\tb >>= (e);\n\t\t\t\t\t\t\t\tk -= (e);\n\n\t\t\t\t\t\t\t\t// do the copy\n\t\t\t\t\t\t\t\tm -= c;\n\t\t\t\t\t\t\t\tif (q >= d) { // offset before dest\n\t\t\t\t\t\t\t\t\t// just copy\n\t\t\t\t\t\t\t\t\tr = q - d;\n\t\t\t\t\t\t\t\t\tif (q - r > 0 && 2 > (q - r)) {\n\t\t\t\t\t\t\t\t\t\ts.window[q++] = s.window[r++]; // minimum\n\t\t\t\t\t\t\t\t\t\t// count is\n\t\t\t\t\t\t\t\t\t\t// three,\n\t\t\t\t\t\t\t\t\t\ts.window[q++] = s.window[r++]; // so unroll\n\t\t\t\t\t\t\t\t\t\t// loop a\n\t\t\t\t\t\t\t\t\t\t// little\n\t\t\t\t\t\t\t\t\t\tc -= 2;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ts.window.set(s.window.subarray(r, r + 2), q);\n\t\t\t\t\t\t\t\t\t\tq += 2;\n\t\t\t\t\t\t\t\t\t\tr += 2;\n\t\t\t\t\t\t\t\t\t\tc -= 2;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else { // else offset after destination\n\t\t\t\t\t\t\t\t\tr = q - d;\n\t\t\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t\t\tr += s.end; // force pointer in window\n\t\t\t\t\t\t\t\t\t} while (r < 0); // covers invalid distances\n\t\t\t\t\t\t\t\t\te = s.end - r;\n\t\t\t\t\t\t\t\t\tif (c > e) { // if source crosses,\n\t\t\t\t\t\t\t\t\t\tc -= e; // wrapped copy\n\t\t\t\t\t\t\t\t\t\tif (q - r > 0 && e > (q - r)) {\n\t\t\t\t\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t\t\t\t\ts.window[q++] = s.window[r++];\n\t\t\t\t\t\t\t\t\t\t\t} while (--e !== 0);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\ts.window.set(s.window.subarray(r, r + e), q);\n\t\t\t\t\t\t\t\t\t\t\tq += e;\n\t\t\t\t\t\t\t\t\t\t\tr += e;\n\t\t\t\t\t\t\t\t\t\t\te = 0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tr = 0; // copy rest from start of window\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// copy all or what's left\n\t\t\t\t\t\t\t\tif (q - r > 0 && c > (q - r)) {\n\t\t\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t\t\ts.window[q++] = s.window[r++];\n\t\t\t\t\t\t\t\t\t} while (--c !== 0);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts.window.set(s.window.subarray(r, r + c), q);\n\t\t\t\t\t\t\t\t\tq += c;\n\t\t\t\t\t\t\t\t\tr += c;\n\t\t\t\t\t\t\t\t\tc = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else if ((e & 64) === 0) {\n\t\t\t\t\t\t\t\tt += tp[tp_index_t_3 + 2];\n\t\t\t\t\t\t\t\tt += (b & inflate_mask[e]);\n\t\t\t\t\t\t\t\ttp_index_t_3 = (tp_index + t) * 3;\n\t\t\t\t\t\t\t\te = tp[tp_index_t_3];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tz.msg = \"invalid distance code\";\n\n\t\t\t\t\t\t\t\tc = z.avail_in - n;\n\t\t\t\t\t\t\t\tc = (k >> 3) < c ? k >> 3 : c;\n\t\t\t\t\t\t\t\tn += c;\n\t\t\t\t\t\t\t\tp -= c;\n\t\t\t\t\t\t\t\tk -= c << 3;\n\n\t\t\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\t\ts.write = q;\n\n\t\t\t\t\t\t\t\treturn Z_DATA_ERROR;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while (true);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((e & 64) === 0) {\n\t\t\t\t\t\tt += tp[tp_index_t_3 + 2];\n\t\t\t\t\t\tt += (b & inflate_mask[e]);\n\t\t\t\t\t\ttp_index_t_3 = (tp_index + t) * 3;\n\t\t\t\t\t\tif ((e = tp[tp_index_t_3]) === 0) {\n\n\t\t\t\t\t\t\tb >>= (tp[tp_index_t_3 + 1]);\n\t\t\t\t\t\t\tk -= (tp[tp_index_t_3 + 1]);\n\n\t\t\t\t\t\t\ts.window[q++] = /* (byte) */tp[tp_index_t_3 + 2];\n\t\t\t\t\t\t\tm--;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if ((e & 32) !== 0) {\n\n\t\t\t\t\t\tc = z.avail_in - n;\n\t\t\t\t\t\tc = (k >> 3) < c ? k >> 3 : c;\n\t\t\t\t\t\tn += c;\n\t\t\t\t\t\tp -= c;\n\t\t\t\t\t\tk -= c << 3;\n\n\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\ts.write = q;\n\n\t\t\t\t\t\treturn Z_STREAM_END;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tz.msg = \"invalid literal/length code\";\n\n\t\t\t\t\t\tc = z.avail_in - n;\n\t\t\t\t\t\tc = (k >> 3) < c ? k >> 3 : c;\n\t\t\t\t\t\tn += c;\n\t\t\t\t\t\tp -= c;\n\t\t\t\t\t\tk -= c << 3;\n\n\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\ts.write = q;\n\n\t\t\t\t\t\treturn Z_DATA_ERROR;\n\t\t\t\t\t}\n\t\t\t\t} while (true);\n\t\t\t} while (m >= 258 && n >= 10);\n\n\t\t\t// not enough input or output--restore pointers and return\n\t\t\tc = z.avail_in - n;\n\t\t\tc = (k >> 3) < c ? k >> 3 : c;\n\t\t\tn += c;\n\t\t\tp -= c;\n\t\t\tk -= c << 3;\n\n\t\t\ts.bitb = b;\n\t\t\ts.bitk = k;\n\t\t\tz.avail_in = n;\n\t\t\tz.total_in += p - z.next_in_index;\n\t\t\tz.next_in_index = p;\n\t\t\ts.write = q;\n\n\t\t\treturn Z_OK;\n\t\t}\n\n\t\tthat.init = function(bl, bd, tl, tl_index, td, td_index) {\n\t\t\tmode = START;\n\t\t\tlbits = /* (byte) */bl;\n\t\t\tdbits = /* (byte) */bd;\n\t\t\tltree = tl;\n\t\t\tltree_index = tl_index;\n\t\t\tdtree = td;\n\t\t\tdtree_index = td_index;\n\t\t\ttree = null;\n\t\t};\n\n\t\tthat.proc = function(s, z, r) {\n\t\t\tvar j; // temporary storage\n\t\t\tvar tindex; // temporary pointer\n\t\t\tvar e; // extra bits or operation\n\t\t\tvar b = 0; // bit buffer\n\t\t\tvar k = 0; // bits in bit buffer\n\t\t\tvar p = 0; // input data pointer\n\t\t\tvar n; // bytes available there\n\t\t\tvar q; // output window write pointer\n\t\t\tvar m; // bytes to end of window or read pointer\n\t\t\tvar f; // pointer to copy strings from\n\n\t\t\t// copy input/output information to locals (UPDATE macro restores)\n\t\t\tp = z.next_in_index;\n\t\t\tn = z.avail_in;\n\t\t\tb = s.bitb;\n\t\t\tk = s.bitk;\n\t\t\tq = s.write;\n\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\n\t\t\t// process input and output based on current state\n\t\t\twhile (true) {\n\t\t\t\tswitch (mode) {\n\t\t\t\t// waiting for \"i:\"=input, \"o:\"=output, \"x:\"=nothing\n\t\t\t\tcase START: // x: set up for LEN\n\t\t\t\t\tif (m >= 258 && n >= 10) {\n\n\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\tr = inflate_fast(lbits, dbits, ltree, ltree_index, dtree, dtree_index, s, z);\n\n\t\t\t\t\t\tp = z.next_in_index;\n\t\t\t\t\t\tn = z.avail_in;\n\t\t\t\t\t\tb = s.bitb;\n\t\t\t\t\t\tk = s.bitk;\n\t\t\t\t\t\tq = s.write;\n\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\n\t\t\t\t\t\tif (r != Z_OK) {\n\t\t\t\t\t\t\tmode = r == Z_STREAM_END ? WASH : BADCODE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tneed = lbits;\n\t\t\t\t\ttree = ltree;\n\t\t\t\t\ttree_index = ltree_index;\n\n\t\t\t\t\tmode = LEN;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase LEN: // i: get length/literal/eob next\n\t\t\t\t\tj = need;\n\n\t\t\t\t\twhile (k < (j)) {\n\t\t\t\t\t\tif (n !== 0)\n\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\telse {\n\n\t\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn--;\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\tk += 8;\n\t\t\t\t\t}\n\n\t\t\t\t\ttindex = (tree_index + (b & inflate_mask[j])) * 3;\n\n\t\t\t\t\tb >>>= (tree[tindex + 1]);\n\t\t\t\t\tk -= (tree[tindex + 1]);\n\n\t\t\t\t\te = tree[tindex];\n\n\t\t\t\t\tif (e === 0) { // literal\n\t\t\t\t\t\tlit = tree[tindex + 2];\n\t\t\t\t\t\tmode = LIT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ((e & 16) !== 0) { // length\n\t\t\t\t\t\tget = e & 15;\n\t\t\t\t\t\tlen = tree[tindex + 2];\n\t\t\t\t\t\tmode = LENEXT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ((e & 64) === 0) { // next table\n\t\t\t\t\t\tneed = e;\n\t\t\t\t\t\ttree_index = tindex / 3 + tree[tindex + 2];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ((e & 32) !== 0) { // end of block\n\t\t\t\t\t\tmode = WASH;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tmode = BADCODE; // invalid code\n\t\t\t\t\tz.msg = \"invalid literal/length code\";\n\t\t\t\t\tr = Z_DATA_ERROR;\n\n\t\t\t\t\ts.bitb = b;\n\t\t\t\t\ts.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\ts.write = q;\n\t\t\t\t\treturn s.inflate_flush(z, r);\n\n\t\t\t\tcase LENEXT: // i: getting length extra (have base)\n\t\t\t\t\tj = get;\n\n\t\t\t\t\twhile (k < (j)) {\n\t\t\t\t\t\tif (n !== 0)\n\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\telse {\n\n\t\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn--;\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\tk += 8;\n\t\t\t\t\t}\n\n\t\t\t\t\tlen += (b & inflate_mask[j]);\n\n\t\t\t\t\tb >>= j;\n\t\t\t\t\tk -= j;\n\n\t\t\t\t\tneed = dbits;\n\t\t\t\t\ttree = dtree;\n\t\t\t\t\ttree_index = dtree_index;\n\t\t\t\t\tmode = DIST;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DIST: // i: get distance next\n\t\t\t\t\tj = need;\n\n\t\t\t\t\twhile (k < (j)) {\n\t\t\t\t\t\tif (n !== 0)\n\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\telse {\n\n\t\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn--;\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\tk += 8;\n\t\t\t\t\t}\n\n\t\t\t\t\ttindex = (tree_index + (b & inflate_mask[j])) * 3;\n\n\t\t\t\t\tb >>= tree[tindex + 1];\n\t\t\t\t\tk -= tree[tindex + 1];\n\n\t\t\t\t\te = (tree[tindex]);\n\t\t\t\t\tif ((e & 16) !== 0) { // distance\n\t\t\t\t\t\tget = e & 15;\n\t\t\t\t\t\tdist = tree[tindex + 2];\n\t\t\t\t\t\tmode = DISTEXT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ((e & 64) === 0) { // next table\n\t\t\t\t\t\tneed = e;\n\t\t\t\t\t\ttree_index = tindex / 3 + tree[tindex + 2];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tmode = BADCODE; // invalid code\n\t\t\t\t\tz.msg = \"invalid distance code\";\n\t\t\t\t\tr = Z_DATA_ERROR;\n\n\t\t\t\t\ts.bitb = b;\n\t\t\t\t\ts.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\ts.write = q;\n\t\t\t\t\treturn s.inflate_flush(z, r);\n\n\t\t\t\tcase DISTEXT: // i: getting distance extra\n\t\t\t\t\tj = get;\n\n\t\t\t\t\twhile (k < (j)) {\n\t\t\t\t\t\tif (n !== 0)\n\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\telse {\n\n\t\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn--;\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\tk += 8;\n\t\t\t\t\t}\n\n\t\t\t\t\tdist += (b & inflate_mask[j]);\n\n\t\t\t\t\tb >>= j;\n\t\t\t\t\tk -= j;\n\n\t\t\t\t\tmode = COPY;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase COPY: // o: copying bytes in window, waiting for space\n\t\t\t\t\tf = q - dist;\n\t\t\t\t\twhile (f < 0) { // modulo window size-\"while\" instead\n\t\t\t\t\t\tf += s.end; // of \"if\" handles invalid distances\n\t\t\t\t\t}\n\t\t\t\t\twhile (len !== 0) {\n\n\t\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\t\tif (q == s.end && s.read !== 0) {\n\t\t\t\t\t\t\t\tq = 0;\n\t\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\t\t\tr = s.inflate_flush(z, r);\n\t\t\t\t\t\t\t\tq = s.write;\n\t\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\n\t\t\t\t\t\t\t\tif (q == s.end && s.read !== 0) {\n\t\t\t\t\t\t\t\t\tq = 0;\n\t\t\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ts.window[q++] = s.window[f++];\n\t\t\t\t\t\tm--;\n\n\t\t\t\t\t\tif (f == s.end)\n\t\t\t\t\t\t\tf = 0;\n\t\t\t\t\t\tlen--;\n\t\t\t\t\t}\n\t\t\t\t\tmode = START;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LIT: // o: got literal, waiting for output space\n\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\tif (q == s.end && s.read !== 0) {\n\t\t\t\t\t\t\tq = 0;\n\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\t\tr = s.inflate_flush(z, r);\n\t\t\t\t\t\t\tq = s.write;\n\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\n\t\t\t\t\t\t\tif (q == s.end && s.read !== 0) {\n\t\t\t\t\t\t\t\tq = 0;\n\t\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tr = Z_OK;\n\n\t\t\t\t\ts.window[q++] = /* (byte) */lit;\n\t\t\t\t\tm--;\n\n\t\t\t\t\tmode = START;\n\t\t\t\t\tbreak;\n\t\t\t\tcase WASH: // o: got eob, possibly more output\n\t\t\t\t\tif (k > 7) { // return unused byte, if any\n\t\t\t\t\t\tk -= 8;\n\t\t\t\t\t\tn++;\n\t\t\t\t\t\tp--; // can always return one\n\t\t\t\t\t}\n\n\t\t\t\t\ts.write = q;\n\t\t\t\t\tr = s.inflate_flush(z, r);\n\t\t\t\t\tq = s.write;\n\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\n\t\t\t\t\tif (s.read != s.write) {\n\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\treturn s.inflate_flush(z, r);\n\t\t\t\t\t}\n\t\t\t\t\tmode = END;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase END:\n\t\t\t\t\tr = Z_STREAM_END;\n\t\t\t\t\ts.bitb = b;\n\t\t\t\t\ts.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\ts.write = q;\n\t\t\t\t\treturn s.inflate_flush(z, r);\n\n\t\t\t\tcase BADCODE: // x: got error\n\n\t\t\t\t\tr = Z_DATA_ERROR;\n\n\t\t\t\t\ts.bitb = b;\n\t\t\t\t\ts.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\ts.write = q;\n\t\t\t\t\treturn s.inflate_flush(z, r);\n\n\t\t\t\tdefault:\n\t\t\t\t\tr = Z_STREAM_ERROR;\n\n\t\t\t\t\ts.bitb = b;\n\t\t\t\t\ts.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\ts.write = q;\n\t\t\t\t\treturn s.inflate_flush(z, r);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tthat.free = function() {\n\t\t\t// ZFREE(z, c);\n\t\t};\n\n\t}\n\n\t// InfBlocks\n\n\t// Table for deflate from PKZIP's appnote.txt.\n\tvar border = [ // Order of the bit length code lengths\n\t16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];\n\n\tvar TYPE = 0; // get type bits (3, including end bit)\n\tvar LENS = 1; // get lengths for stored\n\tvar STORED = 2;// processing stored block\n\tvar TABLE = 3; // get table lengths\n\tvar BTREE = 4; // get bit lengths tree for a dynamic\n\t// block\n\tvar DTREE = 5; // get length, distance trees for a\n\t// dynamic block\n\tvar CODES = 6; // processing fixed or dynamic block\n\tvar DRY = 7; // output remaining window bytes\n\tvar DONELOCKS = 8; // finished last block, done\n\tvar BADBLOCKS = 9; // ot a data error--stuck here\n\n\tfunction InfBlocks(z, w) {\n\t\tvar that = this;\n\n\t\tvar mode = TYPE; // current inflate_block mode\n\n\t\tvar left = 0; // if STORED, bytes left to copy\n\n\t\tvar table = 0; // table lengths (14 bits)\n\t\tvar index = 0; // index into blens (or border)\n\t\tvar blens; // bit lengths of codes\n\t\tvar bb = [ 0 ]; // bit length tree depth\n\t\tvar tb = [ 0 ]; // bit length decoding tree\n\n\t\tvar codes = new InfCodes(); // if CODES, current state\n\n\t\tvar last = 0; // true if this block is the last block\n\n\t\tvar hufts = new Int32Array(MANY * 3); // single malloc for tree space\n\t\tvar check = 0; // check on output\n\t\tvar inftree = new InfTree();\n\n\t\tthat.bitk = 0; // bits in bit buffer\n\t\tthat.bitb = 0; // bit buffer\n\t\tthat.window = new Uint8Array(w); // sliding window\n\t\tthat.end = w; // one byte after sliding window\n\t\tthat.read = 0; // window read pointer\n\t\tthat.write = 0; // window write pointer\n\n\t\tthat.reset = function(z, c) {\n\t\t\tif (c)\n\t\t\t\tc[0] = check;\n\t\t\t// if (mode == BTREE || mode == DTREE) {\n\t\t\t// }\n\t\t\tif (mode == CODES) {\n\t\t\t\tcodes.free(z);\n\t\t\t}\n\t\t\tmode = TYPE;\n\t\t\tthat.bitk = 0;\n\t\t\tthat.bitb = 0;\n\t\t\tthat.read = that.write = 0;\n\t\t};\n\n\t\tthat.reset(z, null);\n\n\t\t// copy as much as possible from the sliding window to the output area\n\t\tthat.inflate_flush = function(z, r) {\n\t\t\tvar n;\n\t\t\tvar p;\n\t\t\tvar q;\n\n\t\t\t// local copies of source and destination pointers\n\t\t\tp = z.next_out_index;\n\t\t\tq = that.read;\n\n\t\t\t// compute number of bytes to copy as far as end of window\n\t\t\tn = /* (int) */((q <= that.write ? that.write : that.end) - q);\n\t\t\tif (n > z.avail_out)\n\t\t\t\tn = z.avail_out;\n\t\t\tif (n !== 0 && r == Z_BUF_ERROR)\n\t\t\t\tr = Z_OK;\n\n\t\t\t// update counters\n\t\t\tz.avail_out -= n;\n\t\t\tz.total_out += n;\n\n\t\t\t// copy as far as end of window\n\t\t\tz.next_out.set(that.window.subarray(q, q + n), p);\n\t\t\tp += n;\n\t\t\tq += n;\n\n\t\t\t// see if more to copy at beginning of window\n\t\t\tif (q == that.end) {\n\t\t\t\t// wrap pointers\n\t\t\t\tq = 0;\n\t\t\t\tif (that.write == that.end)\n\t\t\t\t\tthat.write = 0;\n\n\t\t\t\t// compute bytes to copy\n\t\t\t\tn = that.write - q;\n\t\t\t\tif (n > z.avail_out)\n\t\t\t\t\tn = z.avail_out;\n\t\t\t\tif (n !== 0 && r == Z_BUF_ERROR)\n\t\t\t\t\tr = Z_OK;\n\n\t\t\t\t// update counters\n\t\t\t\tz.avail_out -= n;\n\t\t\t\tz.total_out += n;\n\n\t\t\t\t// copy\n\t\t\t\tz.next_out.set(that.window.subarray(q, q + n), p);\n\t\t\t\tp += n;\n\t\t\t\tq += n;\n\t\t\t}\n\n\t\t\t// update pointers\n\t\t\tz.next_out_index = p;\n\t\t\tthat.read = q;\n\n\t\t\t// done\n\t\t\treturn r;\n\t\t};\n\n\t\tthat.proc = function(z, r) {\n\t\t\tvar t; // temporary storage\n\t\t\tvar b; // bit buffer\n\t\t\tvar k; // bits in bit buffer\n\t\t\tvar p; // input data pointer\n\t\t\tvar n; // bytes available there\n\t\t\tvar q; // output window write pointer\n\t\t\tvar m; // bytes to end of window or read pointer\n\n\t\t\tvar i;\n\n\t\t\t// copy input/output information to locals (UPDATE macro restores)\n\t\t\t// {\n\t\t\tp = z.next_in_index;\n\t\t\tn = z.avail_in;\n\t\t\tb = that.bitb;\n\t\t\tk = that.bitk;\n\t\t\t// }\n\t\t\t// {\n\t\t\tq = that.write;\n\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\n\t\t\t// }\n\n\t\t\t// process input based on current state\n\t\t\t// DEBUG dtree\n\t\t\twhile (true) {\n\t\t\t\tswitch (mode) {\n\t\t\t\tcase TYPE:\n\n\t\t\t\t\twhile (k < (3)) {\n\t\t\t\t\t\tif (n !== 0) {\n\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn--;\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\tk += 8;\n\t\t\t\t\t}\n\t\t\t\t\tt = /* (int) */(b & 7);\n\t\t\t\t\tlast = t & 1;\n\n\t\t\t\t\tswitch (t >>> 1) {\n\t\t\t\t\tcase 0: // stored\n\t\t\t\t\t\t// {\n\t\t\t\t\t\tb >>>= (3);\n\t\t\t\t\t\tk -= (3);\n\t\t\t\t\t\t// }\n\t\t\t\t\t\tt = k & 7; // go to byte boundary\n\n\t\t\t\t\t\t// {\n\t\t\t\t\t\tb >>>= (t);\n\t\t\t\t\t\tk -= (t);\n\t\t\t\t\t\t// }\n\t\t\t\t\t\tmode = LENS; // get length of stored block\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1: // fixed\n\t\t\t\t\t\t// {\n\t\t\t\t\t\tvar bl = []; // new Array(1);\n\t\t\t\t\t\tvar bd = []; // new Array(1);\n\t\t\t\t\t\tvar tl = [ [] ]; // new Array(1);\n\t\t\t\t\t\tvar td = [ [] ]; // new Array(1);\n\n\t\t\t\t\t\tInfTree.inflate_trees_fixed(bl, bd, tl, td);\n\t\t\t\t\t\tcodes.init(bl[0], bd[0], tl[0], 0, td[0], 0);\n\t\t\t\t\t\t// }\n\n\t\t\t\t\t\t// {\n\t\t\t\t\t\tb >>>= (3);\n\t\t\t\t\t\tk -= (3);\n\t\t\t\t\t\t// }\n\n\t\t\t\t\t\tmode = CODES;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2: // dynamic\n\n\t\t\t\t\t\t// {\n\t\t\t\t\t\tb >>>= (3);\n\t\t\t\t\t\tk -= (3);\n\t\t\t\t\t\t// }\n\n\t\t\t\t\t\tmode = TABLE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3: // illegal\n\n\t\t\t\t\t\t// {\n\t\t\t\t\t\tb >>>= (3);\n\t\t\t\t\t\tk -= (3);\n\t\t\t\t\t\t// }\n\t\t\t\t\t\tmode = BADBLOCKS;\n\t\t\t\t\t\tz.msg = \"invalid block type\";\n\t\t\t\t\t\tr = Z_DATA_ERROR;\n\n\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase LENS:\n\n\t\t\t\t\twhile (k < (32)) {\n\t\t\t\t\t\tif (n !== 0) {\n\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn--;\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\tk += 8;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((((~b) >>> 16) & 0xffff) != (b & 0xffff)) {\n\t\t\t\t\t\tmode = BADBLOCKS;\n\t\t\t\t\t\tz.msg = \"invalid stored block lengths\";\n\t\t\t\t\t\tr = Z_DATA_ERROR;\n\n\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t}\n\t\t\t\t\tleft = (b & 0xffff);\n\t\t\t\t\tb = k = 0; // dump bits\n\t\t\t\t\tmode = left !== 0 ? STORED : (last !== 0 ? DRY : TYPE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase STORED:\n\t\t\t\t\tif (n === 0) {\n\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\tif (q == that.end && that.read !== 0) {\n\t\t\t\t\t\t\tq = 0;\n\t\t\t\t\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\tr = that.inflate_flush(z, r);\n\t\t\t\t\t\t\tq = that.write;\n\t\t\t\t\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\n\t\t\t\t\t\t\tif (q == that.end && that.read !== 0) {\n\t\t\t\t\t\t\t\tq = 0;\n\t\t\t\t\t\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tr = Z_OK;\n\n\t\t\t\t\tt = left;\n\t\t\t\t\tif (t > n)\n\t\t\t\t\t\tt = n;\n\t\t\t\t\tif (t > m)\n\t\t\t\t\t\tt = m;\n\t\t\t\t\tthat.window.set(z.read_buf(p, t), q);\n\t\t\t\t\tp += t;\n\t\t\t\t\tn -= t;\n\t\t\t\t\tq += t;\n\t\t\t\t\tm -= t;\n\t\t\t\t\tif ((left -= t) !== 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tmode = last !== 0 ? DRY : TYPE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TABLE:\n\n\t\t\t\t\twhile (k < (14)) {\n\t\t\t\t\t\tif (n !== 0) {\n\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tn--;\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\tk += 8;\n\t\t\t\t\t}\n\n\t\t\t\t\ttable = t = (b & 0x3fff);\n\t\t\t\t\tif ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {\n\t\t\t\t\t\tmode = BADBLOCKS;\n\t\t\t\t\t\tz.msg = \"too many length or distance symbols\";\n\t\t\t\t\t\tr = Z_DATA_ERROR;\n\n\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t}\n\t\t\t\t\tt = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);\n\t\t\t\t\tif (!blens || blens.length < t) {\n\t\t\t\t\t\tblens = []; // new Array(t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (i = 0; i < t; i++) {\n\t\t\t\t\t\t\tblens[i] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// {\n\t\t\t\t\tb >>>= (14);\n\t\t\t\t\tk -= (14);\n\t\t\t\t\t// }\n\n\t\t\t\t\tindex = 0;\n\t\t\t\t\tmode = BTREE;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase BTREE:\n\t\t\t\t\twhile (index < 4 + (table >>> 10)) {\n\t\t\t\t\t\twhile (k < (3)) {\n\t\t\t\t\t\t\tif (n !== 0) {\n\t\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tn--;\n\t\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\t\tk += 8;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tblens[border[index++]] = b & 7;\n\n\t\t\t\t\t\t// {\n\t\t\t\t\t\tb >>>= (3);\n\t\t\t\t\t\tk -= (3);\n\t\t\t\t\t\t// }\n\t\t\t\t\t}\n\n\t\t\t\t\twhile (index < 19) {\n\t\t\t\t\t\tblens[border[index++]] = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tbb[0] = 7;\n\t\t\t\t\tt = inftree.inflate_trees_bits(blens, bb, tb, hufts, z);\n\t\t\t\t\tif (t != Z_OK) {\n\t\t\t\t\t\tr = t;\n\t\t\t\t\t\tif (r == Z_DATA_ERROR) {\n\t\t\t\t\t\t\tblens = null;\n\t\t\t\t\t\t\tmode = BADBLOCKS;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t}\n\n\t\t\t\t\tindex = 0;\n\t\t\t\t\tmode = DTREE;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DTREE:\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tt = table;\n\t\t\t\t\t\tif (index >= 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar j, c;\n\n\t\t\t\t\t\tt = bb[0];\n\n\t\t\t\t\t\twhile (k < (t)) {\n\t\t\t\t\t\t\tif (n !== 0) {\n\t\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tn--;\n\t\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\t\tk += 8;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if (tb[0] == -1) {\n\t\t\t\t\t\t// System.err.println(\"null...\");\n\t\t\t\t\t\t// }\n\n\t\t\t\t\t\tt = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];\n\t\t\t\t\t\tc = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];\n\n\t\t\t\t\t\tif (c < 16) {\n\t\t\t\t\t\t\tb >>>= (t);\n\t\t\t\t\t\t\tk -= (t);\n\t\t\t\t\t\t\tblens[index++] = c;\n\t\t\t\t\t\t} else { // c == 16..18\n\t\t\t\t\t\t\ti = c == 18 ? 7 : c - 14;\n\t\t\t\t\t\t\tj = c == 18 ? 11 : 3;\n\n\t\t\t\t\t\t\twhile (k < (t + i)) {\n\t\t\t\t\t\t\t\tif (n !== 0) {\n\t\t\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tn--;\n\t\t\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\t\t\tk += 8;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tb >>>= (t);\n\t\t\t\t\t\t\tk -= (t);\n\n\t\t\t\t\t\t\tj += (b & inflate_mask[i]);\n\n\t\t\t\t\t\t\tb >>>= (i);\n\t\t\t\t\t\t\tk -= (i);\n\n\t\t\t\t\t\t\ti = index;\n\t\t\t\t\t\t\tt = table;\n\t\t\t\t\t\t\tif (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {\n\t\t\t\t\t\t\t\tblens = null;\n\t\t\t\t\t\t\t\tmode = BADBLOCKS;\n\t\t\t\t\t\t\t\tz.msg = \"invalid bit length repeat\";\n\t\t\t\t\t\t\t\tr = Z_DATA_ERROR;\n\n\t\t\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tc = c == 16 ? blens[i - 1] : 0;\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tblens[i++] = c;\n\t\t\t\t\t\t\t} while (--j !== 0);\n\t\t\t\t\t\t\tindex = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\ttb[0] = -1;\n\t\t\t\t\t// {\n\t\t\t\t\tvar bl_ = []; // new Array(1);\n\t\t\t\t\tvar bd_ = []; // new Array(1);\n\t\t\t\t\tvar tl_ = []; // new Array(1);\n\t\t\t\t\tvar td_ = []; // new Array(1);\n\t\t\t\t\tbl_[0] = 9; // must be <= 9 for lookahead assumptions\n\t\t\t\t\tbd_[0] = 6; // must be <= 9 for lookahead assumptions\n\n\t\t\t\t\tt = table;\n\t\t\t\t\tt = inftree.inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f), blens, bl_, bd_, tl_, td_, hufts, z);\n\n\t\t\t\t\tif (t != Z_OK) {\n\t\t\t\t\t\tif (t == Z_DATA_ERROR) {\n\t\t\t\t\t\t\tblens = null;\n\t\t\t\t\t\t\tmode = BADBLOCKS;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr = t;\n\n\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t}\n\t\t\t\t\tcodes.init(bl_[0], bd_[0], hufts, tl_[0], hufts, td_[0]);\n\t\t\t\t\t// }\n\t\t\t\t\tmode = CODES;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase CODES:\n\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\tthat.write = q;\n\n\t\t\t\t\tif ((r = codes.proc(that, z, r)) != Z_STREAM_END) {\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t}\n\t\t\t\t\tr = Z_OK;\n\t\t\t\t\tcodes.free(z);\n\n\t\t\t\t\tp = z.next_in_index;\n\t\t\t\t\tn = z.avail_in;\n\t\t\t\t\tb = that.bitb;\n\t\t\t\t\tk = that.bitk;\n\t\t\t\t\tq = that.write;\n\t\t\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\n\n\t\t\t\t\tif (last === 0) {\n\t\t\t\t\t\tmode = TYPE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tmode = DRY;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DRY:\n\t\t\t\t\tthat.write = q;\n\t\t\t\t\tr = that.inflate_flush(z, r);\n\t\t\t\t\tq = that.write;\n\t\t\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\n\t\t\t\t\tif (that.read != that.write) {\n\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t}\n\t\t\t\t\tmode = DONELOCKS;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DONELOCKS:\n\t\t\t\t\tr = Z_STREAM_END;\n\n\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\tthat.write = q;\n\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\tcase BADBLOCKS:\n\t\t\t\t\tr = Z_DATA_ERROR;\n\n\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\tthat.write = q;\n\t\t\t\t\treturn that.inflate_flush(z, r);\n\n\t\t\t\tdefault:\n\t\t\t\t\tr = Z_STREAM_ERROR;\n\n\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\tthat.write = q;\n\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tthat.free = function(z) {\n\t\t\tthat.reset(z, null);\n\t\t\tthat.window = null;\n\t\t\thufts = null;\n\t\t\t// ZFREE(z, s);\n\t\t};\n\n\t\tthat.set_dictionary = function(d, start, n) {\n\t\t\tthat.window.set(d.subarray(start, start + n), 0);\n\t\t\tthat.read = that.write = n;\n\t\t};\n\n\t\t// Returns true if inflate is currently at the end of a block generated\n\t\t// by Z_SYNC_FLUSH or Z_FULL_FLUSH.\n\t\tthat.sync_point = function() {\n\t\t\treturn mode == LENS ? 1 : 0;\n\t\t};\n\n\t}\n\n\t// Inflate\n\n\t// preset dictionary flag in zlib header\n\tvar PRESET_DICT = 0x20;\n\n\tvar Z_DEFLATED = 8;\n\n\tvar METHOD = 0; // waiting for method byte\n\tvar FLAG = 1; // waiting for flag byte\n\tvar DICT4 = 2; // four dictionary check bytes to go\n\tvar DICT3 = 3; // three dictionary check bytes to go\n\tvar DICT2 = 4; // two dictionary check bytes to go\n\tvar DICT1 = 5; // one dictionary check byte to go\n\tvar DICT0 = 6; // waiting for inflateSetDictionary\n\tvar BLOCKS = 7; // decompressing blocks\n\tvar DONE = 12; // finished check, done\n\tvar BAD = 13; // got an error--stay here\n\n\tvar mark = [ 0, 0, 0xff, 0xff ];\n\n\tfunction Inflate() {\n\t\tvar that = this;\n\n\t\tthat.mode = 0; // current inflate mode\n\n\t\t// mode dependent information\n\t\tthat.method = 0; // if FLAGS, method byte\n\n\t\t// if CHECK, check values to compare\n\t\tthat.was = [ 0 ]; // new Array(1); // computed check value\n\t\tthat.need = 0; // stream check value\n\n\t\t// if BAD, inflateSync's marker bytes count\n\t\tthat.marker = 0;\n\n\t\t// mode independent information\n\t\tthat.wbits = 0; // log2(window size) (8..15, defaults to 15)\n\n\t\t// this.blocks; // current inflate_blocks state\n\n\t\tfunction inflateReset(z) {\n\t\t\tif (!z || !z.istate)\n\t\t\t\treturn Z_STREAM_ERROR;\n\n\t\t\tz.total_in = z.total_out = 0;\n\t\t\tz.msg = null;\n\t\t\tz.istate.mode = BLOCKS;\n\t\t\tz.istate.blocks.reset(z, null);\n\t\t\treturn Z_OK;\n\t\t}\n\n\t\tthat.inflateEnd = function(z) {\n\t\t\tif (that.blocks)\n\t\t\t\tthat.blocks.free(z);\n\t\t\tthat.blocks = null;\n\t\t\t// ZFREE(z, z->state);\n\t\t\treturn Z_OK;\n\t\t};\n\n\t\tthat.inflateInit = function(z, w) {\n\t\t\tz.msg = null;\n\t\t\tthat.blocks = null;\n\n\t\t\t// set window size\n\t\t\tif (w < 8 || w > 15) {\n\t\t\t\tthat.inflateEnd(z);\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\t}\n\t\t\tthat.wbits = w;\n\n\t\t\tz.istate.blocks = new InfBlocks(z, 1 << w);\n\n\t\t\t// reset state\n\t\t\tinflateReset(z);\n\t\t\treturn Z_OK;\n\t\t};\n\n\t\tthat.inflate = function(z, f) {\n\t\t\tvar r;\n\t\t\tvar b;\n\n\t\t\tif (!z || !z.istate || !z.next_in)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\tf = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;\n\t\t\tr = Z_BUF_ERROR;\n\t\t\twhile (true) {\n\t\t\t\t// System.out.println(\"mode: \"+z.istate.mode);\n\t\t\t\tswitch (z.istate.mode) {\n\t\t\t\tcase METHOD:\n\n\t\t\t\t\tif (z.avail_in === 0)\n\t\t\t\t\t\treturn r;\n\t\t\t\t\tr = f;\n\n\t\t\t\t\tz.avail_in--;\n\t\t\t\t\tz.total_in++;\n\t\t\t\t\tif (((z.istate.method = z.read_byte(z.next_in_index++)) & 0xf) != Z_DEFLATED) {\n\t\t\t\t\t\tz.istate.mode = BAD;\n\t\t\t\t\t\tz.msg = \"unknown compression method\";\n\t\t\t\t\t\tz.istate.marker = 5; // can't try inflateSync\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ((z.istate.method >> 4) + 8 > z.istate.wbits) {\n\t\t\t\t\t\tz.istate.mode = BAD;\n\t\t\t\t\t\tz.msg = \"invalid window size\";\n\t\t\t\t\t\tz.istate.marker = 5; // can't try inflateSync\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tz.istate.mode = FLAG;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase FLAG:\n\n\t\t\t\t\tif (z.avail_in === 0)\n\t\t\t\t\t\treturn r;\n\t\t\t\t\tr = f;\n\n\t\t\t\t\tz.avail_in--;\n\t\t\t\t\tz.total_in++;\n\t\t\t\t\tb = (z.read_byte(z.next_in_index++)) & 0xff;\n\n\t\t\t\t\tif ((((z.istate.method << 8) + b) % 31) !== 0) {\n\t\t\t\t\t\tz.istate.mode = BAD;\n\t\t\t\t\t\tz.msg = \"incorrect header check\";\n\t\t\t\t\t\tz.istate.marker = 5; // can't try inflateSync\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((b & PRESET_DICT) === 0) {\n\t\t\t\t\t\tz.istate.mode = BLOCKS;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tz.istate.mode = DICT4;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DICT4:\n\n\t\t\t\t\tif (z.avail_in === 0)\n\t\t\t\t\t\treturn r;\n\t\t\t\t\tr = f;\n\n\t\t\t\t\tz.avail_in--;\n\t\t\t\t\tz.total_in++;\n\t\t\t\t\tz.istate.need = ((z.read_byte(z.next_in_index++) & 0xff) << 24) & 0xff000000;\n\t\t\t\t\tz.istate.mode = DICT3;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DICT3:\n\n\t\t\t\t\tif (z.avail_in === 0)\n\t\t\t\t\t\treturn r;\n\t\t\t\t\tr = f;\n\n\t\t\t\t\tz.avail_in--;\n\t\t\t\t\tz.total_in++;\n\t\t\t\t\tz.istate.need += ((z.read_byte(z.next_in_index++) & 0xff) << 16) & 0xff0000;\n\t\t\t\t\tz.istate.mode = DICT2;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DICT2:\n\n\t\t\t\t\tif (z.avail_in === 0)\n\t\t\t\t\t\treturn r;\n\t\t\t\t\tr = f;\n\n\t\t\t\t\tz.avail_in--;\n\t\t\t\t\tz.total_in++;\n\t\t\t\t\tz.istate.need += ((z.read_byte(z.next_in_index++) & 0xff) << 8) & 0xff00;\n\t\t\t\t\tz.istate.mode = DICT1;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DICT1:\n\n\t\t\t\t\tif (z.avail_in === 0)\n\t\t\t\t\t\treturn r;\n\t\t\t\t\tr = f;\n\n\t\t\t\t\tz.avail_in--;\n\t\t\t\t\tz.total_in++;\n\t\t\t\t\tz.istate.need += (z.read_byte(z.next_in_index++) & 0xff);\n\t\t\t\t\tz.istate.mode = DICT0;\n\t\t\t\t\treturn Z_NEED_DICT;\n\t\t\t\tcase DICT0:\n\t\t\t\t\tz.istate.mode = BAD;\n\t\t\t\t\tz.msg = \"need dictionary\";\n\t\t\t\t\tz.istate.marker = 0; // can try inflateSync\n\t\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\t\tcase BLOCKS:\n\n\t\t\t\t\tr = z.istate.blocks.proc(z, r);\n\t\t\t\t\tif (r == Z_DATA_ERROR) {\n\t\t\t\t\t\tz.istate.mode = BAD;\n\t\t\t\t\t\tz.istate.marker = 0; // can try inflateSync\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (r == Z_OK) {\n\t\t\t\t\t\tr = f;\n\t\t\t\t\t}\n\t\t\t\t\tif (r != Z_STREAM_END) {\n\t\t\t\t\t\treturn r;\n\t\t\t\t\t}\n\t\t\t\t\tr = f;\n\t\t\t\t\tz.istate.blocks.reset(z, z.istate.was);\n\t\t\t\t\tz.istate.mode = DONE;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DONE:\n\t\t\t\t\treturn Z_STREAM_END;\n\t\t\t\tcase BAD:\n\t\t\t\t\treturn Z_DATA_ERROR;\n\t\t\t\tdefault:\n\t\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tthat.inflateSetDictionary = function(z, dictionary, dictLength) {\n\t\t\tvar index = 0;\n\t\t\tvar length = dictLength;\n\t\t\tif (!z || !z.istate || z.istate.mode != DICT0)\n\t\t\t\treturn Z_STREAM_ERROR;\n\n\t\t\tif (length >= (1 << z.istate.wbits)) {\n\t\t\t\tlength = (1 << z.istate.wbits) - 1;\n\t\t\t\tindex = dictLength - length;\n\t\t\t}\n\t\t\tz.istate.blocks.set_dictionary(dictionary, index, length);\n\t\t\tz.istate.mode = BLOCKS;\n\t\t\treturn Z_OK;\n\t\t};\n\n\t\tthat.inflateSync = function(z) {\n\t\t\tvar n; // number of bytes to look at\n\t\t\tvar p; // pointer to bytes\n\t\t\tvar m; // number of marker bytes found in a row\n\t\t\tvar r, w; // temporaries to save total_in and total_out\n\n\t\t\t// set up\n\t\t\tif (!z || !z.istate)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\tif (z.istate.mode != BAD) {\n\t\t\t\tz.istate.mode = BAD;\n\t\t\t\tz.istate.marker = 0;\n\t\t\t}\n\t\t\tif ((n = z.avail_in) === 0)\n\t\t\t\treturn Z_BUF_ERROR;\n\t\t\tp = z.next_in_index;\n\t\t\tm = z.istate.marker;\n\n\t\t\t// search\n\t\t\twhile (n !== 0 && m < 4) {\n\t\t\t\tif (z.read_byte(p) == mark[m]) {\n\t\t\t\t\tm++;\n\t\t\t\t} else if (z.read_byte(p) !== 0) {\n\t\t\t\t\tm = 0;\n\t\t\t\t} else {\n\t\t\t\t\tm = 4 - m;\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t\tn--;\n\t\t\t}\n\n\t\t\t// restore\n\t\t\tz.total_in += p - z.next_in_index;\n\t\t\tz.next_in_index = p;\n\t\t\tz.avail_in = n;\n\t\t\tz.istate.marker = m;\n\n\t\t\t// return no joy or set up to restart on a new block\n\t\t\tif (m != 4) {\n\t\t\t\treturn Z_DATA_ERROR;\n\t\t\t}\n\t\t\tr = z.total_in;\n\t\t\tw = z.total_out;\n\t\t\tinflateReset(z);\n\t\t\tz.total_in = r;\n\t\t\tz.total_out = w;\n\t\t\tz.istate.mode = BLOCKS;\n\t\t\treturn Z_OK;\n\t\t};\n\n\t\t// Returns true if inflate is currently at the end of a block generated\n\t\t// by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP\n\t\t// implementation to provide an additional safety check. PPP uses\n\t\t// Z_SYNC_FLUSH\n\t\t// but removes the length bytes of the resulting empty stored block. When\n\t\t// decompressing, PPP checks that at the end of input packet, inflate is\n\t\t// waiting for these length bytes.\n\t\tthat.inflateSyncPoint = function(z) {\n\t\t\tif (!z || !z.istate || !z.istate.blocks)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\treturn z.istate.blocks.sync_point();\n\t\t};\n\t}\n\n\t// ZStream\n\n\tfunction ZStream() {\n\t}\n\n\tZStream.prototype = {\n\t\tinflateInit : function(bits) {\n\t\t\tvar that = this;\n\t\t\tthat.istate = new Inflate();\n\t\t\tif (!bits)\n\t\t\t\tbits = MAX_BITS;\n\t\t\treturn that.istate.inflateInit(that, bits);\n\t\t},\n\n\t\tinflate : function(f) {\n\t\t\tvar that = this;\n\t\t\tif (!that.istate)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\treturn that.istate.inflate(that, f);\n\t\t},\n\n\t\tinflateEnd : function() {\n\t\t\tvar that = this;\n\t\t\tif (!that.istate)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\tvar ret = that.istate.inflateEnd(that);\n\t\t\tthat.istate = null;\n\t\t\treturn ret;\n\t\t},\n\n\t\tinflateSync : function() {\n\t\t\tvar that = this;\n\t\t\tif (!that.istate)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\treturn that.istate.inflateSync(that);\n\t\t},\n\t\tinflateSetDictionary : function(dictionary, dictLength) {\n\t\t\tvar that = this;\n\t\t\tif (!that.istate)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\treturn that.istate.inflateSetDictionary(that, dictionary, dictLength);\n\t\t},\n\t\tread_byte : function(start) {\n\t\t\tvar that = this;\n\t\t\treturn that.next_in.subarray(start, start + 1)[0];\n\t\t},\n\t\tread_buf : function(start, size) {\n\t\t\tvar that = this;\n\t\t\treturn that.next_in.subarray(start, start + size);\n\t\t}\n\t};\n\n\t// Inflater\n\n\tfunction Inflater() {\n\t\tvar that = this;\n\t\tvar z = new ZStream();\n\t\tvar bufsize = 512;\n\t\tvar flush = Z_NO_FLUSH;\n\t\tvar buf = new Uint8Array(bufsize);\n\t\tvar nomoreinput = false;\n\n\t\tz.inflateInit();\n\t\tz.next_out = buf;\n\n\t\tthat.append = function(data, onprogress) {\n\t\t\tvar err, buffers = [], lastIndex = 0, bufferIndex = 0, bufferSize = 0, array;\n\t\t\tif (data.length === 0)\n\t\t\t\treturn;\n\t\t\tz.next_in_index = 0;\n\t\t\tz.next_in = data;\n\t\t\tz.avail_in = data.length;\n\t\t\tdo {\n\t\t\t\tz.next_out_index = 0;\n\t\t\t\tz.avail_out = bufsize;\n\t\t\t\tif ((z.avail_in === 0) && (!nomoreinput)) { // if buffer is empty and more input is available, refill it\n\t\t\t\t\tz.next_in_index = 0;\n\t\t\t\t\tnomoreinput = true;\n\t\t\t\t}\n\t\t\t\terr = z.inflate(flush);\n\t\t\t\tif (nomoreinput && (err === Z_BUF_ERROR)) {\n\t\t\t\t\tif (z.avail_in !== 0)\n\t\t\t\t\t\tthrow new Error(\"inflating: bad input\");\n\t\t\t\t} else if (err !== Z_OK && err !== Z_STREAM_END)\n\t\t\t\t\tthrow new Error(\"inflating: \" + z.msg);\n\t\t\t\tif ((nomoreinput || err === Z_STREAM_END) && (z.avail_in === data.length))\n\t\t\t\t\tthrow new Error(\"inflating: bad input\");\n\t\t\t\tif (z.next_out_index)\n\t\t\t\t\tif (z.next_out_index === bufsize)\n\t\t\t\t\t\tbuffers.push(new Uint8Array(buf));\n\t\t\t\t\telse\n\t\t\t\t\t\tbuffers.push(new Uint8Array(buf.subarray(0, z.next_out_index)));\n\t\t\t\tbufferSize += z.next_out_index;\n\t\t\t\tif (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {\n\t\t\t\t\tonprogress(z.next_in_index);\n\t\t\t\t\tlastIndex = z.next_in_index;\n\t\t\t\t}\n\t\t\t} while (z.avail_in > 0 || z.avail_out === 0);\n\t\t\tarray = new Uint8Array(bufferSize);\n\t\t\tbuffers.forEach(function(chunk) {\n\t\t\t\tarray.set(chunk, bufferIndex);\n\t\t\t\tbufferIndex += chunk.length;\n\t\t\t});\n\t\t\treturn array;\n\t\t};\n\t\tthat.flush = function() {\n\t\t\tz.inflateEnd();\n\t\t};\n\t}\n\n\t// 'zip' may not be defined in z-worker and some tests\n\tvar env = global.zip || global;\n\tenv.Inflater = env._jzlib_Inflater = Inflater;\n})(this);\n")]
};

module.exports = zip;


},{"zip":54}],54:[function(require,module,exports){
(function (global){
; var __browserify_shim_require__=require;(function browserifyShim(module, exports, require, define, browserify_shim__define__module__export__) {
/*
 Copyright (c) 2013 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

(function(obj) {
	"use strict";

	var ERR_BAD_FORMAT = "File format is not recognized.";
	var ERR_CRC = "CRC failed.";
	var ERR_ENCRYPTED = "File contains encrypted entry.";
	var ERR_ZIP64 = "File is using Zip64 (4gb+ file size).";
	var ERR_READ = "Error while reading zip file.";
	var ERR_WRITE = "Error while writing zip file.";
	var ERR_WRITE_DATA = "Error while writing file data.";
	var ERR_READ_DATA = "Error while reading file data.";
	var ERR_DUPLICATED_NAME = "File already exists.";
	var CHUNK_SIZE = 512 * 1024;
	
	var TEXT_PLAIN = "text/plain";

	var appendABViewSupported;
	try {
		appendABViewSupported = new Blob([ new DataView(new ArrayBuffer(0)) ]).size === 0;
	} catch (e) {
	}

	function Crc32() {
		this.crc = -1;
	}
	Crc32.prototype.append = function append(data) {
		var crc = this.crc | 0, table = this.table;
		for (var offset = 0, len = data.length | 0; offset < len; offset++)
			crc = (crc >>> 8) ^ table[(crc ^ data[offset]) & 0xFF];
		this.crc = crc;
	};
	Crc32.prototype.get = function get() {
		return ~this.crc;
	};
	Crc32.prototype.table = (function() {
		var i, j, t, table = []; // Uint32Array is actually slower than []
		for (i = 0; i < 256; i++) {
			t = i;
			for (j = 0; j < 8; j++)
				if (t & 1)
					t = (t >>> 1) ^ 0xEDB88320;
				else
					t = t >>> 1;
			table[i] = t;
		}
		return table;
	})();
	
	// "no-op" codec
	function NOOP() {}
	NOOP.prototype.append = function append(bytes, onprogress) {
		return bytes;
	};
	NOOP.prototype.flush = function flush() {};

	function blobSlice(blob, index, length) {
		if (index < 0 || length < 0 || index + length > blob.size)
			throw new RangeError('offset:' + index + ', length:' + length + ', size:' + blob.size);
		if (blob.slice)
			return blob.slice(index, index + length);
		else if (blob.webkitSlice)
			return blob.webkitSlice(index, index + length);
		else if (blob.mozSlice)
			return blob.mozSlice(index, index + length);
		else if (blob.msSlice)
			return blob.msSlice(index, index + length);
	}

	function getDataHelper(byteLength, bytes) {
		var dataBuffer, dataArray;
		dataBuffer = new ArrayBuffer(byteLength);
		dataArray = new Uint8Array(dataBuffer);
		if (bytes)
			dataArray.set(bytes, 0);
		return {
			buffer : dataBuffer,
			array : dataArray,
			view : new DataView(dataBuffer)
		};
	}

	// Readers
	function Reader() {
	}

	function TextReader(text) {
		var that = this, blobReader;

		function init(callback, onerror) {
			var blob = new Blob([ text ], {
				type : TEXT_PLAIN
			});
			blobReader = new BlobReader(blob);
			blobReader.init(function() {
				that.size = blobReader.size;
				callback();
			}, onerror);
		}

		function readUint8Array(index, length, callback, onerror) {
			blobReader.readUint8Array(index, length, callback, onerror);
		}

		that.size = 0;
		that.init = init;
		that.readUint8Array = readUint8Array;
	}
	TextReader.prototype = new Reader();
	TextReader.prototype.constructor = TextReader;

	function Data64URIReader(dataURI) {
		var that = this, dataStart;

		function init(callback) {
			var dataEnd = dataURI.length;
			while (dataURI.charAt(dataEnd - 1) == "=")
				dataEnd--;
			dataStart = dataURI.indexOf(",") + 1;
			that.size = Math.floor((dataEnd - dataStart) * 0.75);
			callback();
		}

		function readUint8Array(index, length, callback) {
			var i, data = getDataHelper(length);
			var start = Math.floor(index / 3) * 4;
			var end = Math.ceil((index + length) / 3) * 4;
			var bytes = obj.atob(dataURI.substring(start + dataStart, end + dataStart));
			var delta = index - Math.floor(start / 4) * 3;
			for (i = delta; i < delta + length; i++)
				data.array[i - delta] = bytes.charCodeAt(i);
			callback(data.array);
		}

		that.size = 0;
		that.init = init;
		that.readUint8Array = readUint8Array;
	}
	Data64URIReader.prototype = new Reader();
	Data64URIReader.prototype.constructor = Data64URIReader;

	function BlobReader(blob) {
		var that = this;

		function init(callback) {
			that.size = blob.size;
			callback();
		}

		function readUint8Array(index, length, callback, onerror) {
			var reader = new FileReader();
			reader.onload = function(e) {
				callback(new Uint8Array(e.target.result));
			};
			reader.onerror = onerror;
			try {
				reader.readAsArrayBuffer(blobSlice(blob, index, length));
			} catch (e) {
				onerror(e);
			}
		}

		that.size = 0;
		that.init = init;
		that.readUint8Array = readUint8Array;
	}
	BlobReader.prototype = new Reader();
	BlobReader.prototype.constructor = BlobReader;

	// Writers

	function Writer() {
	}
	Writer.prototype.getData = function(callback) {
		callback(this.data);
	};

	function TextWriter(encoding) {
		var that = this, blob;

		function init(callback) {
			blob = new Blob([], {
				type : TEXT_PLAIN
			});
			callback();
		}

		function writeUint8Array(array, callback) {
			blob = new Blob([ blob, appendABViewSupported ? array : array.buffer ], {
				type : TEXT_PLAIN
			});
			callback();
		}

		function getData(callback, onerror) {
			var reader = new FileReader();
			reader.onload = function(e) {
				callback(e.target.result);
			};
			reader.onerror = onerror;
			reader.readAsText(blob, encoding);
		}

		that.init = init;
		that.writeUint8Array = writeUint8Array;
		that.getData = getData;
	}
	TextWriter.prototype = new Writer();
	TextWriter.prototype.constructor = TextWriter;

	function Data64URIWriter(contentType) {
		var that = this, data = "", pending = "";

		function init(callback) {
			data += "data:" + (contentType || "") + ";base64,";
			callback();
		}

		function writeUint8Array(array, callback) {
			var i, delta = pending.length, dataString = pending;
			pending = "";
			for (i = 0; i < (Math.floor((delta + array.length) / 3) * 3) - delta; i++)
				dataString += String.fromCharCode(array[i]);
			for (; i < array.length; i++)
				pending += String.fromCharCode(array[i]);
			if (dataString.length > 2)
				data += obj.btoa(dataString);
			else
				pending = dataString;
			callback();
		}

		function getData(callback) {
			callback(data + obj.btoa(pending));
		}

		that.init = init;
		that.writeUint8Array = writeUint8Array;
		that.getData = getData;
	}
	Data64URIWriter.prototype = new Writer();
	Data64URIWriter.prototype.constructor = Data64URIWriter;

	function BlobWriter(contentType) {
		var blob, that = this;

		function init(callback) {
			blob = new Blob([], {
				type : contentType
			});
			callback();
		}

		function writeUint8Array(array, callback) {
			blob = new Blob([ blob, appendABViewSupported ? array : array.buffer ], {
				type : contentType
			});
			callback();
		}

		function getData(callback) {
			callback(blob);
		}

		that.init = init;
		that.writeUint8Array = writeUint8Array;
		that.getData = getData;
	}
	BlobWriter.prototype = new Writer();
	BlobWriter.prototype.constructor = BlobWriter;

	/** 
	 * inflate/deflate core functions
	 * @param worker {Worker} web worker for the task.
	 * @param initialMessage {Object} initial message to be sent to the worker. should contain
	 *   sn(serial number for distinguishing multiple tasks sent to the worker), and codecClass.
	 *   This function may add more properties before sending.
	 */
	function launchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror) {
		var chunkIndex = 0, index, outputSize, sn = initialMessage.sn, crc;

		function onflush() {
			worker.removeEventListener('message', onmessage, false);
			onend(outputSize, crc);
		}

		function onmessage(event) {
			var message = event.data, data = message.data, err = message.error;
			if (err) {
				err.toString = function () { return 'Error: ' + this.message; };
				onreaderror(err);
				return;
			}
			if (message.sn !== sn)
				return;
			if (typeof message.codecTime === 'number')
				worker.codecTime += message.codecTime; // should be before onflush()
			if (typeof message.crcTime === 'number')
				worker.crcTime += message.crcTime;

			switch (message.type) {
				case 'append':
					if (data) {
						outputSize += data.length;
						writer.writeUint8Array(data, function() {
							step();
						}, onwriteerror);
					} else
						step();
					break;
				case 'flush':
					crc = message.crc;
					if (data) {
						outputSize += data.length;
						writer.writeUint8Array(data, function() {
							onflush();
						}, onwriteerror);
					} else
						onflush();
					break;
				case 'progress':
					if (onprogress)
						onprogress(index + message.loaded, size);
					break;
				case 'importScripts': //no need to handle here
				case 'newTask':
				case 'echo':
					break;
				default:
					console.warn('zip.js:launchWorkerProcess: unknown message: ', message);
			}
		}

		function step() {
			index = chunkIndex * CHUNK_SIZE;
			// use `<=` instead of `<`, because `size` may be 0.
			if (index <= size) {
				reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function(array) {
					if (onprogress)
						onprogress(index, size);
					var msg = index === 0 ? initialMessage : {sn : sn};
					msg.type = 'append';
					msg.data = array;
					
					// posting a message with transferables will fail on IE10
					try {
						worker.postMessage(msg, [array.buffer]);
					} catch(ex) {
						worker.postMessage(msg); // retry without transferables
					}
					chunkIndex++;
				}, onreaderror);
			} else {
				worker.postMessage({
					sn: sn,
					type: 'flush'
				});
			}
		}

		outputSize = 0;
		worker.addEventListener('message', onmessage, false);
		step();
	}

	function launchProcess(process, reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror) {
		var chunkIndex = 0, index, outputSize = 0,
			crcInput = crcType === 'input',
			crcOutput = crcType === 'output',
			crc = new Crc32();
		function step() {
			var outputData;
			index = chunkIndex * CHUNK_SIZE;
			if (index < size)
				reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function(inputData) {
					var outputData;
					try {
						outputData = process.append(inputData, function(loaded) {
							if (onprogress)
								onprogress(index + loaded, size);
						});
					} catch (e) {
						onreaderror(e);
						return;
					}
					if (outputData) {
						outputSize += outputData.length;
						writer.writeUint8Array(outputData, function() {
							chunkIndex++;
							setTimeout(step, 1);
						}, onwriteerror);
						if (crcOutput)
							crc.append(outputData);
					} else {
						chunkIndex++;
						setTimeout(step, 1);
					}
					if (crcInput)
						crc.append(inputData);
					if (onprogress)
						onprogress(index, size);
				}, onreaderror);
			else {
				try {
					outputData = process.flush();
				} catch (e) {
					onreaderror(e);
					return;
				}
				if (outputData) {
					if (crcOutput)
						crc.append(outputData);
					outputSize += outputData.length;
					writer.writeUint8Array(outputData, function() {
						onend(outputSize, crc.get());
					}, onwriteerror);
				} else
					onend(outputSize, crc.get());
			}
		}

		step();
	}

	function inflate(worker, sn, reader, writer, offset, size, computeCrc32, onend, onprogress, onreaderror, onwriteerror) {
		var crcType = computeCrc32 ? 'output' : 'none';
		if (obj.zip.useWebWorkers) {
			var initialMessage = {
				sn: sn,
				codecClass: 'Inflater',
				crcType: crcType,
			};
			launchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror);
		} else
			launchProcess(new obj.zip.Inflater(), reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror);
	}

	function deflate(worker, sn, reader, writer, level, onend, onprogress, onreaderror, onwriteerror) {
		var crcType = 'input';
		if (obj.zip.useWebWorkers) {
			var initialMessage = {
				sn: sn,
				options: {level: level},
				codecClass: 'Deflater',
				crcType: crcType,
			};
			launchWorkerProcess(worker, initialMessage, reader, writer, 0, reader.size, onprogress, onend, onreaderror, onwriteerror);
		} else
			launchProcess(new obj.zip.Deflater(), reader, writer, 0, reader.size, crcType, onprogress, onend, onreaderror, onwriteerror);
	}

	function copy(worker, sn, reader, writer, offset, size, computeCrc32, onend, onprogress, onreaderror, onwriteerror) {
		var crcType = 'input';
		if (obj.zip.useWebWorkers && computeCrc32) {
			var initialMessage = {
				sn: sn,
				codecClass: 'NOOP',
				crcType: crcType,
			};
			launchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror);
		} else
			launchProcess(new NOOP(), reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror);
	}

	// ZipReader

	function decodeASCII(str) {
		var i, out = "", charCode, extendedASCII = [ '\u00C7', '\u00FC', '\u00E9', '\u00E2', '\u00E4', '\u00E0', '\u00E5', '\u00E7', '\u00EA', '\u00EB',
				'\u00E8', '\u00EF', '\u00EE', '\u00EC', '\u00C4', '\u00C5', '\u00C9', '\u00E6', '\u00C6', '\u00F4', '\u00F6', '\u00F2', '\u00FB', '\u00F9',
				'\u00FF', '\u00D6', '\u00DC', '\u00F8', '\u00A3', '\u00D8', '\u00D7', '\u0192', '\u00E1', '\u00ED', '\u00F3', '\u00FA', '\u00F1', '\u00D1',
				'\u00AA', '\u00BA', '\u00BF', '\u00AE', '\u00AC', '\u00BD', '\u00BC', '\u00A1', '\u00AB', '\u00BB', '_', '_', '_', '\u00A6', '\u00A6',
				'\u00C1', '\u00C2', '\u00C0', '\u00A9', '\u00A6', '\u00A6', '+', '+', '\u00A2', '\u00A5', '+', '+', '-', '-', '+', '-', '+', '\u00E3',
				'\u00C3', '+', '+', '-', '-', '\u00A6', '-', '+', '\u00A4', '\u00F0', '\u00D0', '\u00CA', '\u00CB', '\u00C8', 'i', '\u00CD', '\u00CE',
				'\u00CF', '+', '+', '_', '_', '\u00A6', '\u00CC', '_', '\u00D3', '\u00DF', '\u00D4', '\u00D2', '\u00F5', '\u00D5', '\u00B5', '\u00FE',
				'\u00DE', '\u00DA', '\u00DB', '\u00D9', '\u00FD', '\u00DD', '\u00AF', '\u00B4', '\u00AD', '\u00B1', '_', '\u00BE', '\u00B6', '\u00A7',
				'\u00F7', '\u00B8', '\u00B0', '\u00A8', '\u00B7', '\u00B9', '\u00B3', '\u00B2', '_', ' ' ];
		for (i = 0; i < str.length; i++) {
			charCode = str.charCodeAt(i) & 0xFF;
			if (charCode > 127)
				out += extendedASCII[charCode - 128];
			else
				out += String.fromCharCode(charCode);
		}
		return out;
	}

	function decodeUTF8(string) {
		return decodeURIComponent(escape(string));
	}

	function getString(bytes) {
		var i, str = "";
		for (i = 0; i < bytes.length; i++)
			str += String.fromCharCode(bytes[i]);
		return str;
	}

	function getDate(timeRaw) {
		var date = (timeRaw & 0xffff0000) >> 16, time = timeRaw & 0x0000ffff;
		try {
			return new Date(1980 + ((date & 0xFE00) >> 9), ((date & 0x01E0) >> 5) - 1, date & 0x001F, (time & 0xF800) >> 11, (time & 0x07E0) >> 5,
					(time & 0x001F) * 2, 0);
		} catch (e) {
		}
	}

	function readCommonHeader(entry, data, index, centralDirectory, onerror) {
		entry.version = data.view.getUint16(index, true);
		entry.bitFlag = data.view.getUint16(index + 2, true);
		entry.compressionMethod = data.view.getUint16(index + 4, true);
		entry.lastModDateRaw = data.view.getUint32(index + 6, true);
		entry.lastModDate = getDate(entry.lastModDateRaw);
		if ((entry.bitFlag & 0x01) === 0x01) {
			onerror(ERR_ENCRYPTED);
			return;
		}
		if (centralDirectory || (entry.bitFlag & 0x0008) != 0x0008) {
			entry.crc32 = data.view.getUint32(index + 10, true);
			entry.compressedSize = data.view.getUint32(index + 14, true);
			entry.uncompressedSize = data.view.getUint32(index + 18, true);
		}
		if (entry.compressedSize === 0xFFFFFFFF || entry.uncompressedSize === 0xFFFFFFFF) {
			onerror(ERR_ZIP64);
			return;
		}
		entry.filenameLength = data.view.getUint16(index + 22, true);
		entry.extraFieldLength = data.view.getUint16(index + 24, true);
	}

	function createZipReader(reader, callback, onerror) {
		var inflateSN = 0;

		function Entry() {
		}

		Entry.prototype.getData = function(writer, onend, onprogress, checkCrc32) {
			var that = this;

			function testCrc32(crc32) {
				var dataCrc32 = getDataHelper(4);
				dataCrc32.view.setUint32(0, crc32);
				return that.crc32 == dataCrc32.view.getUint32(0);
			}

			function getWriterData(uncompressedSize, crc32) {
				if (checkCrc32 && !testCrc32(crc32))
					onerror(ERR_CRC);
				else
					writer.getData(function(data) {
						onend(data);
					});
			}

			function onreaderror(err) {
				onerror(err || ERR_READ_DATA);
			}

			function onwriteerror(err) {
				onerror(err || ERR_WRITE_DATA);
			}

			reader.readUint8Array(that.offset, 30, function(bytes) {
				var data = getDataHelper(bytes.length, bytes), dataOffset;
				if (data.view.getUint32(0) != 0x504b0304) {
					onerror(ERR_BAD_FORMAT);
					return;
				}
				readCommonHeader(that, data, 4, false, onerror);
				dataOffset = that.offset + 30 + that.filenameLength + that.extraFieldLength;
				writer.init(function() {
					if (that.compressionMethod === 0)
						copy(that._worker, inflateSN++, reader, writer, dataOffset, that.compressedSize, checkCrc32, getWriterData, onprogress, onreaderror, onwriteerror);
					else
						inflate(that._worker, inflateSN++, reader, writer, dataOffset, that.compressedSize, checkCrc32, getWriterData, onprogress, onreaderror, onwriteerror);
				}, onwriteerror);
			}, onreaderror);
		};

		function seekEOCDR(eocdrCallback) {
			// "End of central directory record" is the last part of a zip archive, and is at least 22 bytes long.
			// Zip file comment is the last part of EOCDR and has max length of 64KB,
			// so we only have to search the last 64K + 22 bytes of a archive for EOCDR signature (0x06054b50).
			var EOCDR_MIN = 22;
			if (reader.size < EOCDR_MIN) {
				onerror(ERR_BAD_FORMAT);
				return;
			}
			var ZIP_COMMENT_MAX = 256 * 256, EOCDR_MAX = EOCDR_MIN + ZIP_COMMENT_MAX;

			// In most cases, the EOCDR is EOCDR_MIN bytes long
			doSeek(EOCDR_MIN, function() {
				// If not found, try within EOCDR_MAX bytes
				doSeek(Math.min(EOCDR_MAX, reader.size), function() {
					onerror(ERR_BAD_FORMAT);
				});
			});

			// seek last length bytes of file for EOCDR
			function doSeek(length, eocdrNotFoundCallback) {
				reader.readUint8Array(reader.size - length, length, function(bytes) {
					for (var i = bytes.length - EOCDR_MIN; i >= 0; i--) {
						if (bytes[i] === 0x50 && bytes[i + 1] === 0x4b && bytes[i + 2] === 0x05 && bytes[i + 3] === 0x06) {
							eocdrCallback(new DataView(bytes.buffer, i, EOCDR_MIN));
							return;
						}
					}
					eocdrNotFoundCallback();
				}, function() {
					onerror(ERR_READ);
				});
			}
		}

		var zipReader = {
			getEntries : function(callback) {
				var worker = this._worker;
				// look for End of central directory record
				seekEOCDR(function(dataView) {
					var datalength, fileslength;
					datalength = dataView.getUint32(16, true);
					fileslength = dataView.getUint16(8, true);
					if (datalength < 0 || datalength >= reader.size) {
						onerror(ERR_BAD_FORMAT);
						return;
					}
					reader.readUint8Array(datalength, reader.size - datalength, function(bytes) {
						var i, index = 0, entries = [], entry, filename, comment, data = getDataHelper(bytes.length, bytes);
						for (i = 0; i < fileslength; i++) {
							entry = new Entry();
							entry._worker = worker;
							if (data.view.getUint32(index) != 0x504b0102) {
								onerror(ERR_BAD_FORMAT);
								return;
							}
							readCommonHeader(entry, data, index + 6, true, onerror);
							entry.commentLength = data.view.getUint16(index + 32, true);
							entry.directory = ((data.view.getUint8(index + 38) & 0x10) == 0x10);
							entry.offset = data.view.getUint32(index + 42, true);
							filename = getString(data.array.subarray(index + 46, index + 46 + entry.filenameLength));
							entry.filename = ((entry.bitFlag & 0x0800) === 0x0800) ? decodeUTF8(filename) : decodeASCII(filename);
							if (!entry.directory && entry.filename.charAt(entry.filename.length - 1) == "/")
								entry.directory = true;
							comment = getString(data.array.subarray(index + 46 + entry.filenameLength + entry.extraFieldLength, index + 46
									+ entry.filenameLength + entry.extraFieldLength + entry.commentLength));
							entry.comment = ((entry.bitFlag & 0x0800) === 0x0800) ? decodeUTF8(comment) : decodeASCII(comment);
							entries.push(entry);
							index += 46 + entry.filenameLength + entry.extraFieldLength + entry.commentLength;
						}
						callback(entries);
					}, function() {
						onerror(ERR_READ);
					});
				});
			},
			close : function(callback) {
				if (this._worker) {
					this._worker.terminate();
					this._worker = null;
				}
				if (callback)
					callback();
			},
			_worker: null
		};

		if (!obj.zip.useWebWorkers)
			callback(zipReader);
		else {
			createWorker('inflater',
				function(worker) {
					zipReader._worker = worker;
					callback(zipReader);
				},
				function(err) {
					onerror(err);
				}
			);
		}
	}

	// ZipWriter

	function encodeUTF8(string) {
		return unescape(encodeURIComponent(string));
	}

	function getBytes(str) {
		var i, array = [];
		for (i = 0; i < str.length; i++)
			array.push(str.charCodeAt(i));
		return array;
	}

	function createZipWriter(writer, callback, onerror, dontDeflate) {
		var files = {}, filenames = [], datalength = 0;
		var deflateSN = 0;

		function onwriteerror(err) {
			onerror(err || ERR_WRITE);
		}

		function onreaderror(err) {
			onerror(err || ERR_READ_DATA);
		}

		var zipWriter = {
			add : function(name, reader, onend, onprogress, options) {
				var header, filename, date;
				var worker = this._worker;

				function writeHeader(callback) {
					var data;
					date = options.lastModDate || new Date();
					header = getDataHelper(26);
					files[name] = {
						headerArray : header.array,
						directory : options.directory,
						filename : filename,
						offset : datalength,
						comment : getBytes(encodeUTF8(options.comment || ""))
					};
					header.view.setUint32(0, 0x14000808);
					if (options.version)
						header.view.setUint8(0, options.version);
					if (!dontDeflate && options.level !== 0 && !options.directory)
						header.view.setUint16(4, 0x0800);
					header.view.setUint16(6, (((date.getHours() << 6) | date.getMinutes()) << 5) | date.getSeconds() / 2, true);
					header.view.setUint16(8, ((((date.getFullYear() - 1980) << 4) | (date.getMonth() + 1)) << 5) | date.getDate(), true);
					header.view.setUint16(22, filename.length, true);
					data = getDataHelper(30 + filename.length);
					data.view.setUint32(0, 0x504b0304);
					data.array.set(header.array, 4);
					data.array.set(filename, 30);
					datalength += data.array.length;
					writer.writeUint8Array(data.array, callback, onwriteerror);
				}

				function writeFooter(compressedLength, crc32) {
					var footer = getDataHelper(16);
					datalength += compressedLength || 0;
					footer.view.setUint32(0, 0x504b0708);
					if (typeof crc32 != "undefined") {
						header.view.setUint32(10, crc32, true);
						footer.view.setUint32(4, crc32, true);
					}
					if (reader) {
						footer.view.setUint32(8, compressedLength, true);
						header.view.setUint32(14, compressedLength, true);
						footer.view.setUint32(12, reader.size, true);
						header.view.setUint32(18, reader.size, true);
					}
					writer.writeUint8Array(footer.array, function() {
						datalength += 16;
						onend();
					}, onwriteerror);
				}

				function writeFile() {
					options = options || {};
					name = name.trim();
					if (options.directory && name.charAt(name.length - 1) != "/")
						name += "/";
					if (files.hasOwnProperty(name)) {
						onerror(ERR_DUPLICATED_NAME);
						return;
					}
					filename = getBytes(encodeUTF8(name));
					filenames.push(name);
					writeHeader(function() {
						if (reader)
							if (dontDeflate || options.level === 0)
								copy(worker, deflateSN++, reader, writer, 0, reader.size, true, writeFooter, onprogress, onreaderror, onwriteerror);
							else
								deflate(worker, deflateSN++, reader, writer, options.level, writeFooter, onprogress, onreaderror, onwriteerror);
						else
							writeFooter();
					}, onwriteerror);
				}

				if (reader)
					reader.init(writeFile, onreaderror);
				else
					writeFile();
			},
			close : function(callback) {
				if (this._worker) {
					this._worker.terminate();
					this._worker = null;
				}

				var data, length = 0, index = 0, indexFilename, file;
				for (indexFilename = 0; indexFilename < filenames.length; indexFilename++) {
					file = files[filenames[indexFilename]];
					length += 46 + file.filename.length + file.comment.length;
				}
				data = getDataHelper(length + 22);
				for (indexFilename = 0; indexFilename < filenames.length; indexFilename++) {
					file = files[filenames[indexFilename]];
					data.view.setUint32(index, 0x504b0102);
					data.view.setUint16(index + 4, 0x1400);
					data.array.set(file.headerArray, index + 6);
					data.view.setUint16(index + 32, file.comment.length, true);
					if (file.directory)
						data.view.setUint8(index + 38, 0x10);
					data.view.setUint32(index + 42, file.offset, true);
					data.array.set(file.filename, index + 46);
					data.array.set(file.comment, index + 46 + file.filename.length);
					index += 46 + file.filename.length + file.comment.length;
				}
				data.view.setUint32(index, 0x504b0506);
				data.view.setUint16(index + 8, filenames.length, true);
				data.view.setUint16(index + 10, filenames.length, true);
				data.view.setUint32(index + 12, length, true);
				data.view.setUint32(index + 16, datalength, true);
				writer.writeUint8Array(data.array, function() {
					writer.getData(callback);
				}, onwriteerror);
			},
			_worker: null
		};

		if (!obj.zip.useWebWorkers)
			callback(zipWriter);
		else {
			createWorker('deflater',
				function(worker) {
					zipWriter._worker = worker;
					callback(zipWriter);
				},
				function(err) {
					onerror(err);
				}
			);
		}
	}

	function resolveURLs(urls) {
		var a = document.createElement('a');
		return urls.map(function(url) {
			a.href = url;
			return a.href;
		});
	}

	var DEFAULT_WORKER_SCRIPTS = {
		deflater: ['z-worker.js', 'deflate.js'],
		inflater: ['z-worker.js', 'inflate.js']
	};
	function createWorker(type, callback, onerror) {
		if (obj.zip.workerScripts !== null && obj.zip.workerScriptsPath !== null) {
			onerror(new Error('Either zip.workerScripts or zip.workerScriptsPath may be set, not both.'));
			return;
		}
		var scripts;
		if (obj.zip.workerScripts) {
			scripts = obj.zip.workerScripts[type];
			if (!Array.isArray(scripts)) {
				onerror(new Error('zip.workerScripts.' + type + ' is not an array!'));
				return;
			}
			scripts = resolveURLs(scripts);
		} else {
			scripts = DEFAULT_WORKER_SCRIPTS[type].slice(0);
			scripts[0] = (obj.zip.workerScriptsPath || '') + scripts[0];
		}
		var worker = new Worker(scripts[0]);
		// record total consumed time by inflater/deflater/crc32 in this worker
		worker.codecTime = worker.crcTime = 0;
		worker.postMessage({ type: 'importScripts', scripts: scripts.slice(1) });
		worker.addEventListener('message', onmessage);
		function onmessage(ev) {
			var msg = ev.data;
			if (msg.error) {
				worker.terminate(); // should before onerror(), because onerror() may throw.
				onerror(msg.error);
				return;
			}
			if (msg.type === 'importScripts') {
				worker.removeEventListener('message', onmessage);
				worker.removeEventListener('error', errorHandler);
				callback(worker);
			}
		}
		// catch entry script loading error and other unhandled errors
		worker.addEventListener('error', errorHandler);
		function errorHandler(err) {
			worker.terminate();
			onerror(err);
		}
	}

	function onerror_default(error) {
		console.error(error);
	}
	obj.zip = {
		Reader : Reader,
		Writer : Writer,
		BlobReader : BlobReader,
		Data64URIReader : Data64URIReader,
		TextReader : TextReader,
		BlobWriter : BlobWriter,
		Data64URIWriter : Data64URIWriter,
		TextWriter : TextWriter,
		createReader : function(reader, callback, onerror) {
			onerror = onerror || onerror_default;

			reader.init(function() {
				createZipReader(reader, callback, onerror);
			}, onerror);
		},
		createWriter : function(writer, callback, onerror, dontDeflate) {
			onerror = onerror || onerror_default;
			dontDeflate = !!dontDeflate;

			writer.init(function() {
				createZipWriter(writer, callback, onerror, dontDeflate);
			}, onerror);
		},
		useWebWorkers : true,
		/**
		 * Directory containing the default worker scripts (z-worker.js, deflate.js, and inflate.js), relative to current base url.
		 * E.g.: zip.workerScripts = './';
		 */
		workerScriptsPath : null,
		/**
		 * Advanced option to control which scripts are loaded in the Web worker. If this option is specified, then workerScriptsPath must not be set.
		 * workerScripts.deflater/workerScripts.inflater should be arrays of urls to scripts for deflater/inflater, respectively.
		 * Scripts in the array are executed in order, and the first one should be z-worker.js, which is used to start the worker.
		 * All urls are relative to current base url.
		 * E.g.:
		 * zip.workerScripts = {
		 *   deflater: ['z-worker.js', 'deflate.js'],
		 *   inflater: ['z-worker.js', 'inflate.js']
		 * };
		 */
		workerScripts : null,
	};

})(this);

; browserify_shim__define__module__export__(typeof zip != "undefined" ? zip : window.zip);

}).call(global, undefined, undefined, undefined, undefined, function defineExport(ex) { module.exports = ex; });

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[25])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJhcHAvY29tcG9uZW50cy9jYW52YXMvY2FudmFzLXJ1bGVyLmpzIiwiYXBwL2NvbXBvbmVudHMvY2FudmFzL2NhbnZhcy5qcyIsImFwcC9jb21wb25lbnRzL2ZpbGVoYW5kbGVycy9maWxlZHJvcHRhcmdldC5qcyIsImFwcC9jb21wb25lbnRzL2ZpbGVoYW5kbGVycy9maWxlb3BlbmhhbmRsZXIuanMiLCJhcHAvY29tcG9uZW50cy9sYXllcnRpbWVsaW5lL2NvbnN0cy5qcyIsImFwcC9jb21wb25lbnRzL2xheWVydGltZWxpbmUvbGF5ZXJ0aW1lbGluZS5qcyIsImFwcC9jb21wb25lbnRzL2xheWVydGltZWxpbmUvdGltZWxpbmVncmlkLmpzIiwiYXBwL2NvbXBvbmVudHMvcHJvcGVydHlpbnNwZWN0b3IvcHJvcGVydHlpbnNwZWN0b3IuanMiLCJhcHAvY29tcG9uZW50cy9zY3JvbGxncm91cC9zY3JvbGxncm91cC5qcyIsImFwcC9jb21wb25lbnRzL3NwbGl0dGVyL3NwbGl0dGVyLmpzIiwiYXBwL3BhZ2VzL3N0dWRpby9zdHVkaW8uanMiLCJhcHAvcGFnZXMvc3R1ZGlvL3N0dWRpb3N0YXRlLmpzIiwiYXBwL3NjcmlwdHMvQW5pbWF0aW9uUmVuZGVyZXIuanMiLCJhcHAvc2NyaXB0cy9BdmRTZXJpYWxpemVyLmpzIiwiYXBwL3NjcmlwdHMvQ29sb3JVdGlsLmpzIiwiYXBwL3NjcmlwdHMvRHJhZ0hlbHBlci5qcyIsImFwcC9zY3JpcHRzL0VsZW1lbnRSZXNpemVXYXRjaGVyLmpzIiwiYXBwL3NjcmlwdHMvTWF0aFV0aWwuanMiLCJhcHAvc2NyaXB0cy9Nb2RlbFV0aWwuanMiLCJhcHAvc2NyaXB0cy9SZW5kZXJVdGlsLmpzIiwiYXBwL3NjcmlwdHMvU3ZnTG9hZGVyLmpzIiwiYXBwL3NjcmlwdHMvU3ZnUGF0aERhdGEuanMiLCJhcHAvc2NyaXB0cy9VaVV0aWwuanMiLCJhcHAvc2NyaXB0cy9WZWN0b3JEcmF3YWJsZUxvYWRlci5qcyIsImFwcC9zY3JpcHRzL2FwcC5qcyIsImFwcC9zY3JpcHRzL2ljb25zLmpzIiwiYXBwL3NjcmlwdHMvbWF0ZXJpYWx0aGVtZS5qcyIsImFwcC9zY3JpcHRzL21vZGVsL0FuaW1hdGlvbi5qcyIsImFwcC9zY3JpcHRzL21vZGVsL0FuaW1hdGlvbkJsb2NrLmpzIiwiYXBwL3NjcmlwdHMvbW9kZWwvQXJ0d29yay5qcyIsImFwcC9zY3JpcHRzL21vZGVsL0Jhc2VMYXllci5qcyIsImFwcC9zY3JpcHRzL21vZGVsL0xheWVyR3JvdXAuanMiLCJhcHAvc2NyaXB0cy9tb2RlbC9NYXNrTGF5ZXIuanMiLCJhcHAvc2NyaXB0cy9tb2RlbC9QYXRoTGF5ZXIuanMiLCJhcHAvc2NyaXB0cy9tb2RlbC9pbmRleC5qcyIsImFwcC9zY3JpcHRzL21vZGVsL3Byb3BlcnRpZXMvQ29sb3JQcm9wZXJ0eS5qcyIsImFwcC9zY3JpcHRzL21vZGVsL3Byb3BlcnRpZXMvRW51bVByb3BlcnR5LmpzIiwiYXBwL3NjcmlwdHMvbW9kZWwvcHJvcGVydGllcy9GcmFjdGlvblByb3BlcnR5LmpzIiwiYXBwL3NjcmlwdHMvbW9kZWwvcHJvcGVydGllcy9JZFByb3BlcnR5LmpzIiwiYXBwL3NjcmlwdHMvbW9kZWwvcHJvcGVydGllcy9OdW1iZXJQcm9wZXJ0eS5qcyIsImFwcC9zY3JpcHRzL21vZGVsL3Byb3BlcnRpZXMvUGF0aERhdGFQcm9wZXJ0eS5qcyIsImFwcC9zY3JpcHRzL21vZGVsL3Byb3BlcnRpZXMvUHJvcGVydHkuanMiLCJhcHAvc2NyaXB0cy9tb2RlbC9wcm9wZXJ0aWVzL1N0cmluZ1Byb3BlcnR5LmpzIiwiYXBwL3NjcmlwdHMvbW9kZWwvcHJvcGVydGllcy9pbmRleC5qcyIsImFwcC9zY3JpcHRzL3JvdXRlcy5qcyIsImFwcC9zY3JpcHRzL3htbHNlcmlhbGl6ZXIuanMiLCJub2RlX21vZHVsZXMvYmV6aWVyLWVhc2luZy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmV6aWVyLWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jlemllci1qcy9saWIvYmV6aWVyLmpzIiwibm9kZV9tb2R1bGVzL2Jlemllci1qcy9saWIvcG9seS1iZXppZXIuanMiLCJub2RlX21vZHVsZXMvYmV6aWVyLWpzL2xpYi91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy90aW55Y29sb3IyL3Rpbnljb2xvci5qcyIsIm5vZGVfbW9kdWxlcy96aXBqcy1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ppcGpzLWJyb3dzZXJpZnkvdmVuZG9yL3ppcC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkEsSUFBTSxnQkFBZ0IsRUFBdEI7QUFDQSxJQUFNLG9CQUFvQixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxFQUFiLEVBQWlCLEVBQWpCLEVBQXFCLEVBQXJCLEVBQXlCLEdBQXpCLEVBQThCLEdBQTlCLEVBQW1DLEdBQW5DLENBQTFCO0FBQ0EsSUFBTSxlQUFlLEVBQXJCO0FBQ0EsSUFBTSxZQUFZLENBQWxCOztBQUdBLFFBQVEsTUFBUixDQUFlLFdBQWYsRUFBNEIsU0FBNUIsQ0FBc0MsYUFBdEMsRUFBcUQsWUFBVztBQUM5RCxTQUFPO0FBQ0wsY0FBVSxHQURMO0FBRUwsV0FBTyxFQUZGO0FBR0wsY0FBVSxtQkFITDtBQUlMLGFBQVMsSUFKSjtBQUtMLGFBQVMsZUFMSjtBQU1MLFVBQU0sY0FBUyxLQUFULEVBQWdCLE9BQWhCLEVBQXlCLEtBQXpCLEVBQWdDLGdCQUFoQyxFQUFrRDtBQUN0RCxVQUFJLFVBQVUsT0FBZDtBQUNBLFVBQUksU0FBUyxRQUFRLEdBQVIsQ0FBWSxDQUFaLENBQWI7QUFDQSxVQUFJLGVBQWdCLE1BQU0sV0FBTixJQUFxQixZQUF6QztBQUNBLFVBQUkscUJBQUo7QUFBQSxVQUFrQixzQkFBbEI7QUFDQSxVQUFJLGVBQUo7QUFBQSxVQUFZLGVBQVo7O0FBRUEs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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hHQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzcUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmNvbnN0IEVYVFJBX1BBRERJTkcgPSAxMjtcbmNvbnN0IEdSSURfSU5URVJWQUxTX1BYID0gWzEsIDIsIDQsIDgsIDE2LCAyNCwgNDgsIDEwMCwgMTAwLCAyNTBdO1xuY29uc3QgTEFCRUxfT0ZGU0VUID0gMTI7XG5jb25zdCBUSUNLX1NJWkUgPSA2O1xuXG5cbmFuZ3VsYXIubW9kdWxlKCdBVkRTdHVkaW8nKS5kaXJlY3RpdmUoJ2NhbnZhc1J1bGVyJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFJyxcbiAgICBzY29wZToge30sXG4gICAgdGVtcGxhdGU6ICc8Y2FudmFzPjwvY2FudmFzPicsXG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICByZXF1aXJlOiAnXnN0dWRpb0NhbnZhcycsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBzdHVkaW9DYW52YXNDdHJsKSB7XG4gICAgICBsZXQgJGNhbnZhcyA9IGVsZW1lbnQ7XG4gICAgICBsZXQgY2FudmFzID0gJGNhbnZhcy5nZXQoMCk7XG4gICAgICBsZXQgaXNIb3Jpem9udGFsID0gKGF0dHJzLm9yaWVudGF0aW9uID09ICdob3Jpem9udGFsJyk7XG4gICAgICBsZXQgYXJ0d29ya1dpZHRoLCBhcnR3b3JrSGVpZ2h0O1xuICAgICAgbGV0IG1vdXNlWCwgbW91c2VZO1xuXG4gICAgICAkY2FudmFzXG4gICAgICAgICAgLmFkZENsYXNzKCdjYW52YXMtcnVsZXInKVxuICAgICAgICAgIC5hZGRDbGFzcygnb3JpZW50YXRpb24tJyArIGF0dHJzLm9yaWVudGF0aW9uKTtcblxuICAgICAgLy8gbW9zdCBzY29wZSBtZXRob2RzIGNhbGxlZCBieSBjYW52YXNcblxuICAgICAgc2NvcGUuaGlkZU1vdXNlID0gKCkgPT4ge1xuICAgICAgICBtb3VzZVggPSAtMTtcbiAgICAgICAgbW91c2VZID0gLTE7XG4gICAgICAgIHNjb3BlLnJlZHJhdygpO1xuICAgICAgfTtcblxuICAgICAgc2NvcGUuc2hvd01vdXNlUG9zaXRpb24gPSAoeCwgeSkgPT4ge1xuICAgICAgICBtb3VzZVggPSB4O1xuICAgICAgICBtb3VzZVkgPSB5O1xuICAgICAgICBzY29wZS5yZWRyYXcoKTtcbiAgICAgIH07XG5cbiAgICAgIHNjb3BlLnNldEFydHdvcmtTaXplID0gc2l6ZSA9PiB7XG4gICAgICAgIGFydHdvcmtXaWR0aCA9IHNpemUud2lkdGg7XG4gICAgICAgIGFydHdvcmtIZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgICAgICAgc2NvcGUucmVkcmF3KCk7XG4gICAgICB9O1xuXG4gICAgICBzY29wZS5yZWRyYXcgPSAoKSA9PiB7XG4gICAgICAgIGxldCB3aWR0aCA9ICRjYW52YXMud2lkdGgoKTtcbiAgICAgICAgbGV0IGhlaWdodCA9ICRjYW52YXMuaGVpZ2h0KCk7XG4gICAgICAgICRjYW52YXMuYXR0cignd2lkdGgnLCB3aWR0aCAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICAgICAgJGNhbnZhcy5hdHRyKCdoZWlnaHQnLCBoZWlnaHQgKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XG5cbiAgICAgICAgbGV0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBjdHguc2NhbGUod2luZG93LmRldmljZVBpeGVsUmF0aW8sIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZShcbiAgICAgICAgICAgIGlzSG9yaXpvbnRhbCA/IEVYVFJBX1BBRERJTkcgOiAwLFxuICAgICAgICAgICAgaXNIb3Jpem9udGFsID8gMCA6IEVYVFJBX1BBRERJTkcpO1xuXG4gICAgICAgIGxldCB6b29tID0gTWF0aC5tYXgoMSwgaXNIb3Jpem9udGFsXG4gICAgICAgICAgICA/ICh3aWR0aCAtIEVYVFJBX1BBRERJTkcgKiAyKSAvIGFydHdvcmtXaWR0aFxuICAgICAgICAgICAgOiAoaGVpZ2h0IC0gRVhUUkFfUEFERElORyAqIDIpIC8gYXJ0d29ya0hlaWdodCk7XG5cbiAgICAgICAgLy8gY29tcHV0ZSBncmlkIHNwYWNpbmcgKDQwID0gbWluaW11bSBncmlkIHNwYWNpbmcgaW4gcGl4ZWxzKVxuICAgICAgICBsZXQgaW50ZXJ2YWwgPSAwO1xuICAgICAgICBsZXQgc3BhY2luZ0FydFB4ID0gR1JJRF9JTlRFUlZBTFNfUFhbaW50ZXJ2YWxdO1xuICAgICAgICB3aGlsZSAoKHNwYWNpbmdBcnRQeCAqIHpvb20pIDwgNDAgfHwgaW50ZXJ2YWwgPj0gR1JJRF9JTlRFUlZBTFNfUFgubGVuZ3RoKSB7XG4gICAgICAgICAgKytpbnRlcnZhbDtcbiAgICAgICAgICBzcGFjaW5nQXJ0UHggPSBHUklEX0lOVEVSVkFMU19QWFtpbnRlcnZhbF07XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3BhY2luZ1J1bGVyUHggPSBzcGFjaW5nQXJ0UHggKiB6b29tO1xuXG4gICAgICAgIC8vIHRleHQgbGFiZWxzXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSAncmdiYSgyNTUsMjU1LDI1NSwuMyknO1xuICAgICAgICBjdHguZm9udCA9ICcxMHB4IFJvYm90byc7XG4gICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ2FscGhhYmV0aWMnO1xuICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICBmb3IgKGxldCB4ID0gMCwgdCA9IDA7XG4gICAgICAgICAgICAgICB4IDw9ICh3aWR0aCAtIEVYVFJBX1BBRERJTkcgKiAyKTtcbiAgICAgICAgICAgICAgIHggKz0gc3BhY2luZ1J1bGVyUHgsIHQgKz0gc3BhY2luZ0FydFB4KSB7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQodCwgeCwgaGVpZ2h0IC0gTEFCRUxfT0ZGU0VUKTtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCh4IC0gMC41LCBoZWlnaHQgLSBUSUNLX1NJWkUsIDEsIFRJQ0tfU0laRSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgICBjdHgudGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICBmb3IgKGxldCB5ID0gMCwgdCA9IDA7XG4gICAgICAgICAgICAgICB5IDw9IChoZWlnaHQgLSBFWFRSQV9QQURESU5HICogMik7XG4gICAgICAgICAgICAgICB5ICs9IHNwYWNpbmdSdWxlclB4LCB0ICs9IHNwYWNpbmdBcnRQeCkge1xuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHQsIHdpZHRoIC0gTEFCRUxfT0ZGU0VULCB5KTtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCh3aWR0aCAtIFRJQ0tfU0laRSwgeSAtIDAuNSwgVElDS19TSVpFLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMjU1LDI1NSwyNTUsLjcpJztcbiAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCAmJiBtb3VzZVggPj0gMCkge1xuICAgICAgICAgIGN0eC5maWxsVGV4dChtb3VzZVgsIG1vdXNlWCAqIHpvb20sIGhlaWdodCAtIExBQkVMX09GRlNFVCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzSG9yaXpvbnRhbCAmJiBtb3VzZVkgPj0gMCkge1xuICAgICAgICAgIGN0eC5maWxsVGV4dChtb3VzZVksIHdpZHRoIC0gTEFCRUxfT0ZGU0VULCBtb3VzZVkgKiB6b29tKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdHVkaW9DYW52YXNDdHJsLnJlZ2lzdGVyUnVsZXIoc2NvcGUpO1xuICAgICAgc2NvcGUuJG9uKCckZGVzdHJveScsICgpID0+IHN0dWRpb0NhbnZhc0N0cmwudW5yZWdpc3RlclJ1bGVyKHNjb3BlKSk7XG4gICAgfVxuICB9O1xufSk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtMYXllckdyb3VwLCBNYXNrTGF5ZXIsIFBhdGhMYXllciwgRGVmYXVsdFZhbHVlc30gZnJvbSAnbW9kZWwnO1xuaW1wb3J0IHtDb2xvclV0aWx9IGZyb20gJ0NvbG9yVXRpbCc7XG5pbXBvcnQge1JlbmRlclV0aWx9IGZyb20gJ1JlbmRlclV0aWwnO1xuaW1wb3J0IHtFbGVtZW50UmVzaXplV2F0Y2hlcn0gZnJvbSAnRWxlbWVudFJlc2l6ZVdhdGNoZXInO1xuXG5cbmNvbnN0IENBTlZBU19NQVJHSU4gPSA3MjsgLy8gcGl4ZWxzXG5cblxuY2xhc3MgQ2FudmFzQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKCRzY29wZSwgJGVsZW1lbnQsICRhdHRycywgU3R1ZGlvU3RhdGVTZXJ2aWNlLCAkdGltZW91dCkge1xuICAgIHRoaXMuc2NvcGVfID0gJHNjb3BlO1xuICAgIHRoaXMuZWxlbWVudF8gPSAkZWxlbWVudDtcbiAgICB0aGlzLmF0dHJzXyA9ICRhdHRycztcbiAgICB0aGlzLmNhbnZhc18gPSAkZWxlbWVudC5maW5kKCdjYW52YXMnKTtcbiAgICB0aGlzLm9mZnNjcmVlbkNhbnZhc18gPSAkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpKTtcbiAgICB0aGlzLnN0dWRpb1N0YXRlXyA9IFN0dWRpb1N0YXRlU2VydmljZTtcbiAgICB0aGlzLnJlZ2lzdGVyZWRSdWxlcnNfID0gW107XG5cbiAgICB0aGlzLmlzUHJldmlld01vZGUgPSAncHJldmlld01vZGUnIGluICRhdHRycztcbiAgICBpZiAodGhpcy5pc1ByZXZpZXdNb2RlKSB7XG4gICAgICB0aGlzLmVsZW1lbnRfLmFkZENsYXNzKCdwcmV2aWV3LW1vZGUnKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldHVwTW91c2VFdmVudEhhbmRsZXJzXygpO1xuXG4gICAgbGV0IGNoYW5nZUhhbmRsZXJfID0gKGV2ZW50LCBjaGFuZ2VzKSA9PiB7XG4gICAgICBpZiAoY2hhbmdlcy5wbGF5aW5nKSB7XG4gICAgICAgIGlmICh0aGlzLnN0dWRpb1N0YXRlXy5wbGF5aW5nKSB7XG4gICAgICAgICAgdGhpcy5hbmltU3RhcnQgPSBOdW1iZXIobmV3IERhdGUoKSlcbiAgICAgICAgICAgICAgLSB0aGlzLnN0dWRpb1N0YXRlXy5hY3RpdmVUaW1lIC8gdGhpcy5zdHVkaW9TdGF0ZV8ucGxheWJhY2tTcGVlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZHJhd0NhbnZhc18oKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5nZXMuYWN0aXZlVGltZSkge1xuICAgICAgICB0aGlzLmFuaW1UaW1lID0gdGhpcy5zdHVkaW9TdGF0ZV8uYWN0aXZlVGltZTtcbiAgICAgICAgdGhpcy5kcmF3Q2FudmFzXygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hhbmdlcy5zZWxlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5kcmF3Q2FudmFzXygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hhbmdlcy5hcnR3b3JrIHx8IGNoYW5nZXMuYW5pbWF0aW9ucyB8fCBjaGFuZ2VzLmFjdGl2ZUFuaW1hdGlvbikge1xuICAgICAgICB0aGlzLnJlc2l6ZUFuZERyYXdDYW52YXNfKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNoYW5nZUhhbmRsZXJfKG51bGwsIHtwbGF5aW5nOiB0cnVlLCBhY3RpdmVUaW1lOiB0cnVlLCBhcnR3b3JrOiB0cnVlfSk7XG5cbiAgICB0aGlzLnN0dWRpb1N0YXRlXy5vbkNoYW5nZShjaGFuZ2VIYW5kbGVyXywgJHNjb3BlKTtcblxuICAgIGlmICghdGhpcy5pc1ByZXZpZXdNb2RlKSB7XG4gICAgICBsZXQgcmVzaXplV2F0Y2hlciA9IG5ldyBFbGVtZW50UmVzaXplV2F0Y2hlcihcbiAgICAgICAgICB0aGlzLmVsZW1lbnRfLCAoKSA9PiB0aGlzLnJlc2l6ZUFuZERyYXdDYW52YXNfKCkpO1xuICAgICAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCAoKSA9PiByZXNpemVXYXRjaGVyLmRlc3Ryb3koKSk7XG4gICAgfVxuXG4gICAgJHRpbWVvdXQoKCkgPT4gdGhpcy5yZXNpemVBbmREcmF3Q2FudmFzXygpLCAwKTtcbiAgfVxuXG4gIGhpdFRlc3RfKHBvaW50LCByb290TGF5ZXIgPSBudWxsKSB7XG4gICAgcm9vdExheWVyID0gcm9vdExheWVyIHx8IHRoaXMuYXJ0d29yaztcblxuICAgIGNvbnN0IG1hdHJpY2VzID0gW107XG5cbiAgICAvLyBUT0RPKGFsb2Nrd29vZCk6IHNlbGVjdCBjbGlwcyBhbmQvb3IgZ3JvdXBzIGluIGFkZGl0aW9uIHRvIHBhdGhzP1xuICAgIGNvbnN0IGhpdFRlc3RMYXllcl8gPSBsYXllciA9PiB7XG4gICAgICBpZiAobGF5ZXIgaW5zdGFuY2VvZiBMYXllckdyb3VwKSB7XG4gICAgICAgIG1hdHJpY2VzLnVuc2hpZnQoUmVuZGVyVXRpbC50cmFuc2Zvcm1NYXRyaXhGb3JMYXllcihsYXllcikpO1xuICAgICAgICAvLyBoaXRUZXN0TGF5ZXIgfHwgaCBhbmQgbm90IHRoZSBvdGhlciB3YXkgYXJvdW5kIGJlY2F1c2Ugb2YgcmV2ZXJzZSB6LW9yZGVyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGxheWVyLmxheWVycy5yZWR1Y2UoKGgsIGxheWVyKSA9PiBoaXRUZXN0TGF5ZXJfKGxheWVyKSB8fCBoLCBudWxsKTtcbiAgICAgICAgbWF0cmljZXMuc2hpZnQoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgfSBlbHNlIGlmIChsYXllciBpbnN0YW5jZW9mIFBhdGhMYXllciAmJiBsYXllci5wYXRoRGF0YSkge1xuICAgICAgICBjb25zdCBwb2ludFRyYW5zZm9ybWVyRm4gPSBwID0+IFJlbmRlclV0aWwudHJhbnNmb3JtUG9pbnQobWF0cmljZXMsIHApO1xuICAgICAgICBpZiAoKGxheWVyLmZpbGxDb2xvciAmJlxuICAgICAgICAgICAgIGxheWVyLnBhdGhEYXRhLmhpdFRlc3RGaWxsKHBvaW50LCBwb2ludFRyYW5zZm9ybWVyRm4pKSB8fFxuICAgICAgICAgICAgKGxheWVyLnN0cm9rZUNvbG9yICYmXG4gICAgICAgICAgICAgbGF5ZXIucGF0aERhdGEuaGl0VGVzdFN0cm9rZShwb2ludCwgcG9pbnRUcmFuc2Zvcm1lckZuLCBsYXllci5zdHJva2VXaWR0aCkpKSB7XG4gICAgICAgICAgcmV0dXJuIGxheWVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICByZXR1cm4gaGl0VGVzdExheWVyXyhyb290TGF5ZXIpO1xuICB9XG5cbiAgc2V0dXBNb3VzZUV2ZW50SGFuZGxlcnNfKCkge1xuICAgIHRoaXMuY2FudmFzX1xuICAgICAgICAub24oJ21vdXNlZG93bicsIGV2ZW50ID0+IHtcbiAgICAgICAgICBjb25zdCBjYW52YXNPZmZzZXQgPSB0aGlzLmNhbnZhc18ub2Zmc2V0KCk7XG4gICAgICAgICAgY29uc3QgeCA9IChldmVudC5wYWdlWCAtIGNhbnZhc09mZnNldC5sZWZ0KSAvIHRoaXMuc2NhbGVfO1xuICAgICAgICAgIGNvbnN0IHkgPSAoZXZlbnQucGFnZVkgLSBjYW52YXNPZmZzZXQudG9wKSAvIHRoaXMuc2NhbGVfO1xuXG4gICAgICAgICAgbGV0IGN1cnJlbnRBcnR3b3JrO1xuICAgICAgICAgIGlmICh0aGlzLnN0dWRpb1N0YXRlXy5hbmltYXRpb25SZW5kZXJlcikge1xuICAgICAgICAgICAgdGhpcy5zdHVkaW9TdGF0ZV8uYW5pbWF0aW9uUmVuZGVyZXIuc2V0QW5pbWF0aW9uVGltZSh0aGlzLmFuaW1UaW1lIHx8IDApO1xuICAgICAgICAgICAgY3VycmVudEFydHdvcmsgPSB0aGlzLnN0dWRpb1N0YXRlXy5hbmltYXRpb25SZW5kZXJlci5yZW5kZXJlZEFydHdvcms7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnRBcnR3b3JrID0gdGhpcy5hcnR3b3JrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCB0YXJnZXRMYXllciA9IHRoaXMuaGl0VGVzdF8oe3gsIHl9LCBjdXJyZW50QXJ0d29yayk7XG4gICAgICAgICAgdGhpcy5zY29wZV8uJGFwcGx5KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0YXJnZXRMYXllcikge1xuICAgICAgICAgICAgICB0YXJnZXRMYXllciA9IHRoaXMuYXJ0d29yay5maW5kTGF5ZXJCeUlkKHRhcmdldExheWVyLmlkKTtcbiAgICAgICAgICAgICAgaWYgKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0dWRpb1N0YXRlXy50b2dnbGVTZWxlY3RlZCh0YXJnZXRMYXllcik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHVkaW9TdGF0ZV8uc2VsZWN0aW9uID0gW3RhcmdldExheWVyXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghZXZlbnQubWV0YUtleSAmJiAhZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgdGhpcy5zdHVkaW9TdGF0ZV8uc2VsZWN0aW9uID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignbW91c2Vtb3ZlJywgZXZlbnQgPT4ge1xuICAgICAgICAgIGxldCBjYW52YXNPZmZzZXQgPSB0aGlzLmNhbnZhc18ub2Zmc2V0KCk7XG4gICAgICAgICAgbGV0IHggPSBNYXRoLnJvdW5kKChldmVudC5wYWdlWCAtIGNhbnZhc09mZnNldC5sZWZ0KSAvIHRoaXMuc2NhbGVfKTtcbiAgICAgICAgICBsZXQgeSA9IE1hdGgucm91bmQoKGV2ZW50LnBhZ2VZIC0gY2FudmFzT2Zmc2V0LnRvcCkgLyB0aGlzLnNjYWxlXyk7XG4gICAgICAgICAgdGhpcy5yZWdpc3RlcmVkUnVsZXJzXy5mb3JFYWNoKHIgPT4gci5zaG93TW91c2VQb3NpdGlvbih4LCB5KSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignbW91c2VsZWF2ZScsICgpID0+IHtcbiAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRSdWxlcnNfLmZvckVhY2gociA9PiByLmhpZGVNb3VzZSgpKTtcbiAgICAgICAgfSk7XG4gIH1cblxuICBnZXQgYXJ0d29yaygpIHtcbiAgICByZXR1cm4gdGhpcy5zdHVkaW9TdGF0ZV8uYXJ0d29yaztcbiAgfVxuXG4gIGdldCBhbmltYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3R1ZGlvU3RhdGVfLmFjdGl2ZUFuaW1hdGlvbjtcbiAgfVxuXG4gIHJlZ2lzdGVyUnVsZXIocnVsZXJTY29wZSkge1xuICAgIHRoaXMucmVnaXN0ZXJlZFJ1bGVyc18ucHVzaChydWxlclNjb3BlKTtcbiAgICB0aGlzLnJlZHJhd1J1bGVyc18oKTtcbiAgfVxuXG4gIHVucmVnaXN0ZXJSdWxlcihydWxlclNjb3BlKSB7XG4gICAgbGV0IGlkeCA9IHRoaXMucmVnaXN0ZXJlZFJ1bGVyc18uaW5kZXhPZihydWxlclNjb3BlKTtcbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJlZFJ1bGVyc18uc3BsaWNlKGlkeCwgMSk7XG4gICAgfVxuICB9XG5cbiAgcmVkcmF3UnVsZXJzXygpIHtcbiAgICB0aGlzLnJlZ2lzdGVyZWRSdWxlcnNfLmZvckVhY2gociA9PiB7XG4gICAgICByLnNldEFydHdvcmtTaXplKHtcbiAgICAgICAgd2lkdGg6IHRoaXMuYXJ0d29yay53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmFydHdvcmsuaGVpZ2h0XG4gICAgICB9KTtcbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfSk7XG4gIH1cblxuICByZXNpemVBbmREcmF3Q2FudmFzXygpIHtcbiAgICBpZiAodGhpcy5pc1ByZXZpZXdNb2RlKSB7XG4gICAgICB0aGlzLnNjYWxlXyA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBjb250YWluZXJXaWR0aCA9IE1hdGgubWF4KDEsIHRoaXMuZWxlbWVudF8ud2lkdGgoKSAtIENBTlZBU19NQVJHSU4gKiAyKTtcbiAgICAgIGxldCBjb250YWluZXJIZWlnaHQgPSBNYXRoLm1heCgxLCB0aGlzLmVsZW1lbnRfLmhlaWdodCgpIC0gQ0FOVkFTX01BUkdJTiAqIDIpO1xuICAgICAgbGV0IGNvbnRhaW5lckFzcGVjdFJhdGlvID0gY29udGFpbmVyV2lkdGggLyBjb250YWluZXJIZWlnaHQ7XG4gICAgICBsZXQgYXJ0d29ya0FzcGVjdFJhdGlvID0gdGhpcy5hcnR3b3JrLndpZHRoIC8gKHRoaXMuYXJ0d29yay5oZWlnaHQgfHwgMSk7XG5cbiAgICAgIGlmIChhcnR3b3JrQXNwZWN0UmF0aW8gPiBjb250YWluZXJBc3BlY3RSYXRpbykge1xuICAgICAgICB0aGlzLnNjYWxlXyA9IGNvbnRhaW5lcldpZHRoIC8gdGhpcy5hcnR3b3JrLndpZHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zY2FsZV8gPSBjb250YWluZXJIZWlnaHQgLyB0aGlzLmFydHdvcmsuaGVpZ2h0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2NhbGVfID0gdGhpcy5zY2FsZV8gPiAxXG4gICAgICAgID8gTWF0aC5mbG9vcih0aGlzLnNjYWxlXylcbiAgICAgICAgOiBNYXRoLm1heCguMSwgdGhpcy5zY2FsZV8pO1xuICAgIHRoaXMuYmFja2luZ1N0b3JlU2NhbGVfID0gdGhpcy5zY2FsZV8gKiAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSk7XG4gICAgW3RoaXMuY2FudmFzXywgdGhpcy5vZmZzY3JlZW5DYW52YXNfXS5mb3JFYWNoKGNhbnZhcyA9PiB7XG4gICAgICBjYW52YXNcbiAgICAgICAgICAuYXR0cih7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy5hcnR3b3JrLndpZHRoICogdGhpcy5iYWNraW5nU3RvcmVTY2FsZV8sXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuYXJ0d29yay5oZWlnaHQgKiB0aGlzLmJhY2tpbmdTdG9yZVNjYWxlXyxcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jc3Moe1xuICAgICAgICAgICAgd2lkdGg6IHRoaXMuYXJ0d29yay53aWR0aCAqIHRoaXMuc2NhbGVfLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmFydHdvcmsuaGVpZ2h0ICogdGhpcy5zY2FsZV8sXG4gICAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmRyYXdDYW52YXNfKCk7XG4gICAgdGhpcy5yZWRyYXdSdWxlcnNfKCk7XG4gIH1cblxuICBkcmF3Q2FudmFzXygpIHtcbiAgICBpZiAodGhpcy5hbmltYXRpb25GcmFtZVJlcXVlc3RfKSB7XG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25GcmFtZVJlcXVlc3RfKTtcbiAgICAgIHRoaXMuYW5pbWF0aW9uRnJhbWVSZXF1ZXN0XyA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmFydHdvcmspIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgY3R4ID0gdGhpcy5jYW52YXNfLmdldCgwKS5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnNjYWxlKHRoaXMuYmFja2luZ1N0b3JlU2NhbGVfLCB0aGlzLmJhY2tpbmdTdG9yZVNjYWxlXyk7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmFydHdvcmsud2lkdGgsIHRoaXMuYXJ0d29yay5oZWlnaHQpO1xuICAgIGlmICh0aGlzLmFydHdvcmsuY2FudmFzQ29sb3IpIHtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBDb2xvclV0aWwuYW5kcm9pZFRvQ3NzQ29sb3IodGhpcy5hcnR3b3JrLmNhbnZhc0NvbG9yKTtcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB0aGlzLmFydHdvcmsud2lkdGgsIHRoaXMuYXJ0d29yay5oZWlnaHQpO1xuICAgIH1cblxuICAgIGxldCBzZWxlY3Rpb25TdHJva2VfID0gZXh0cmFTZXR1cEZuID0+IHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAvLyBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2V4Y2x1c2lvbic7XG4gICAgICBleHRyYVNldHVwRm4gJiYgZXh0cmFTZXR1cEZuKCk7XG4gICAgICBjdHgubGluZVdpZHRoID0gNiAvIHRoaXMuc2NhbGVfOyAvLyAycHhcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjZmZmJztcbiAgICAgIGN0eC5saW5lQ2FwID0gJ3JvdW5kJztcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjMjE5NmYzJztcbiAgICAgIGN0eC5saW5lV2lkdGggPSAzIC8gdGhpcy5zY2FsZV87IC8vIDJweFxuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuXG4gICAgbGV0IHRyYW5zZm9ybXMgPSBbXTtcblxuICAgIGxldCBkcmF3TGF5ZXJfID0gKGN0eCwgbGF5ZXIsIHNlbGVjdGlvbk1vZGUpID0+IHtcbiAgICAgIGlmIChsYXllciBpbnN0YW5jZW9mIExheWVyR3JvdXApIHtcbiAgICAgICAgaWYgKCFzZWxlY3Rpb25Nb2RlICYmICFsYXllci52aXNpYmxlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJhbnNmb3Jtcy51bnNoaWZ0KFJlbmRlclV0aWwudHJhbnNmb3JtTWF0cml4Rm9yTGF5ZXIobGF5ZXIpKTtcblxuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBsYXllci5sYXllcnMuZm9yRWFjaChsYXllciA9PiBkcmF3TGF5ZXJfKGN0eCwgbGF5ZXIsIHNlbGVjdGlvbk1vZGUpKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uTW9kZSAmJiBsYXllci5zZWxlY3RlZCkge1xuICAgICAgICAgIGxldCBib3VuZHMgPSBsYXllci5jb21wdXRlQm91bmRzKCk7XG4gICAgICAgICAgaWYgKGJvdW5kcykge1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2Zvcm0oLi4uUmVuZGVyVXRpbC5mbGF0dGVuVHJhbnNmb3Jtcyh0cmFuc2Zvcm1zKSk7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgucmVjdChib3VuZHMubCwgYm91bmRzLnQsIGJvdW5kcy5yIC0gYm91bmRzLmwsIGJvdW5kcy5iIC0gYm91bmRzLnQpO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIHNlbGVjdGlvblN0cm9rZV8oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0cmFuc2Zvcm1zLnNoaWZ0KCk7XG4gICAgICB9IGVsc2UgaWYgKGxheWVyIGluc3RhbmNlb2YgTWFza0xheWVyKSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0oLi4uUmVuZGVyVXRpbC5mbGF0dGVuVHJhbnNmb3Jtcyh0cmFuc2Zvcm1zKSk7XG4gICAgICAgIGxheWVyLnBhdGhEYXRhICYmIGxheWVyLnBhdGhEYXRhLmV4ZWN1dGUoY3R4KTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgICBpZiAoIXNlbGVjdGlvbk1vZGUpIHtcbiAgICAgICAgICAvLyBjbGlwIGZ1cnRoZXIgbGF5ZXJzXG4gICAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxlY3Rpb25Nb2RlICYmIGxheWVyLnNlbGVjdGVkKSB7XG4gICAgICAgICAgLy8gdGhpcyBsYXllciBpcyBzZWxlY3RlZCwgZHJhdyB0aGUgbGF5ZXIgc2VsZWN0aW9uIHN0dWZmXG4gICAgICAgICAgc2VsZWN0aW9uU3Ryb2tlXygoKSA9PiBjdHguc2V0TGluZURhc2goWzUgLyB0aGlzLnNjYWxlXywgNSAvIHRoaXMuc2NhbGVfXSkpO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghc2VsZWN0aW9uTW9kZSAmJiAhbGF5ZXIudmlzaWJsZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmbGF0dGVuZWRUcmFuc2Zvcm1zID0gUmVuZGVyVXRpbC5mbGF0dGVuVHJhbnNmb3Jtcyh0cmFuc2Zvcm1zKTtcblxuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHgudHJhbnNmb3JtKC4uLmZsYXR0ZW5lZFRyYW5zZm9ybXMpO1xuICAgICAgICBpZiAoc2VsZWN0aW9uTW9kZSkge1xuICAgICAgICAgIGxheWVyLnBhdGhEYXRhICYmIGxheWVyLnBhdGhEYXRhLmV4ZWN1dGUoY3R4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXllci5wYXRoRGF0YSAmJiBsYXllci5wYXRoRGF0YS5leGVjdXRlVHJpbW1lZChcbiAgICAgICAgICAgICAgY3R4LCBsYXllci50cmltUGF0aFN0YXJ0LCBsYXllci50cmltUGF0aEVuZCwgbGF5ZXIudHJpbVBhdGhPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgICAgaWYgKCFzZWxlY3Rpb25Nb2RlKSB7XG4gICAgICAgICAgbGV0IHN0cm9rZVdpZHRoTXVsdGlwbGllciA9IFJlbmRlclV0aWwuY29tcHV0ZVN0cm9rZVdpZHRoTXVsdGlwbGllcihmbGF0dGVuZWRUcmFuc2Zvcm1zKTtcblxuICAgICAgICAgIC8vIGRyYXcgdGhlIGFjdHVhbCBsYXllclxuICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IENvbG9yVXRpbC5hbmRyb2lkVG9Dc3NDb2xvcihsYXllci5zdHJva2VDb2xvciwgbGF5ZXIuc3Ryb2tlQWxwaGEpO1xuICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBsYXllci5zdHJva2VXaWR0aCAqIHN0cm9rZVdpZHRoTXVsdGlwbGllcjtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gQ29sb3JVdGlsLmFuZHJvaWRUb0Nzc0NvbG9yKGxheWVyLmZpbGxDb2xvciwgbGF5ZXIuZmlsbEFscGhhKTtcbiAgICAgICAgICBjdHgubGluZUNhcCA9IGxheWVyLnN0cm9rZUxpbmVjYXAgfHwgRGVmYXVsdFZhbHVlcy5MSU5FQ0FQO1xuICAgICAgICAgIGN0eC5saW5lSm9pbiA9IGxheWVyLnN0cm9rZUxpbmVqb2luIHx8IERlZmF1bHRWYWx1ZXMuTElORUpPSU47XG4gICAgICAgICAgY3R4Lm1pdGVyTGltaXQgPSBsYXllci5taXRlckxpbWl0IHx8IERlZmF1bHRWYWx1ZXMuTUlURVJfTElNSVQ7XG5cbiAgICAgICAgICBpZiAobGF5ZXIuc3Ryb2tlQ29sb3JcbiAgICAgICAgICAgICAgJiYgbGF5ZXIuc3Ryb2tlV2lkdGhcbiAgICAgICAgICAgICAgJiYgbGF5ZXIudHJpbVBhdGhTdGFydCAhPSBsYXllci50cmltUGF0aEVuZCkge1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGF5ZXIuZmlsbENvbG9yKSB7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzZWxlY3Rpb25Nb2RlICYmIGxheWVyLnNlbGVjdGVkKSB7XG4gICAgICAgICAgLy8gdGhpcyBsYXllciBpcyBzZWxlY3RlZCwgZHJhdyB0aGUgbGF5ZXIgc2VsZWN0aW9uIHN0dWZmXG4gICAgICAgICAgc2VsZWN0aW9uU3Ryb2tlXygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGRyYXcgYXJ0d29ya1xuICAgIGxldCBvZmZzY3JlZW5DdHggPSB0aGlzLm9mZnNjcmVlbkNhbnZhc18uZ2V0KDApLmdldENvbnRleHQoJzJkJyk7XG4gICAgbGV0IGN1cnJlbnRBcnR3b3JrO1xuICAgIGlmICh0aGlzLnN0dWRpb1N0YXRlXy5hbmltYXRpb25SZW5kZXJlcikge1xuICAgICAgdGhpcy5zdHVkaW9TdGF0ZV8uYW5pbWF0aW9uUmVuZGVyZXIuc2V0QW5pbWF0aW9uVGltZSh0aGlzLmFuaW1UaW1lIHx8IDApO1xuICAgICAgY3VycmVudEFydHdvcmsgPSB0aGlzLnN0dWRpb1N0YXRlXy5hbmltYXRpb25SZW5kZXJlci5yZW5kZXJlZEFydHdvcms7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRBcnR3b3JrID0gdGhpcy5hcnR3b3JrO1xuICAgIH1cbiAgICBsZXQgY3VycmVudEFscGhhID0gY3VycmVudEFydHdvcmsuYWxwaGE7XG4gICAgaWYgKGN1cnJlbnRBbHBoYSAhPSAxKSB7XG4gICAgICBvZmZzY3JlZW5DdHguc2F2ZSgpO1xuICAgICAgb2Zmc2NyZWVuQ3R4LnNjYWxlKHRoaXMuYmFja2luZ1N0b3JlU2NhbGVfLCB0aGlzLmJhY2tpbmdTdG9yZVNjYWxlXyk7XG4gICAgICBvZmZzY3JlZW5DdHguY2xlYXJSZWN0KDAsIDAsIGN1cnJlbnRBcnR3b3JrLndpZHRoLCBjdXJyZW50QXJ0d29yay5oZWlnaHQpO1xuICAgIH1cbiAgICBsZXQgYXJ0d29ya0N0eCA9IGN1cnJlbnRBbHBoYSA9PSAxID8gY3R4IDogb2Zmc2NyZWVuQ3R4O1xuICAgIGRyYXdMYXllcl8oYXJ0d29ya0N0eCwgY3VycmVudEFydHdvcmspO1xuXG4gICAgaWYgKGN1cnJlbnRBcnR3b3JrLmFscGhhICE9IDEpIHtcbiAgICAgIGxldCBvbGRHbG9iYWxBbHBoYSA9IGN0eC5nbG9iYWxBbHBoYTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGN1cnJlbnRBbHBoYTtcbiAgICAgIGN0eC5zY2FsZSgxIC8gdGhpcy5iYWNraW5nU3RvcmVTY2FsZV8sIDEgLyB0aGlzLmJhY2tpbmdTdG9yZVNjYWxlXyk7XG4gICAgICBjdHguZHJhd0ltYWdlKG9mZnNjcmVlbkN0eC5jYW52YXMsIDAsIDApO1xuICAgICAgY3R4LnNjYWxlKHRoaXMuYmFja2luZ1N0b3JlU2NhbGVfLCB0aGlzLmJhY2tpbmdTdG9yZVNjYWxlXyk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSBvbGRHbG9iYWxBbHBoYTtcbiAgICAgIG9mZnNjcmVlbkN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc1ByZXZpZXdNb2RlKSB7XG4gICAgICBkcmF3TGF5ZXJfKGN0eCwgY3VycmVudEFydHdvcmssIHRydWUpO1xuICAgIH1cblxuICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAvLyBkcmF3IHBpeGVsIGdyaWRcbiAgICBpZiAoIXRoaXMuaXNQcmV2aWV3TW9kZSAmJiB0aGlzLnNjYWxlXyA+IDQpIHtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAncmdiYSgxMjgsIDEyOCwgMTI4LCAuMjUpJztcblxuICAgICAgZm9yIChsZXQgeCA9IDE7IHggPCB0aGlzLmFydHdvcmsud2lkdGg7ICsreCkge1xuICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgICB4ICogdGhpcy5iYWNraW5nU3RvcmVTY2FsZV8gLSAwLjUgKiAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSksXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMSAqICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSxcbiAgICAgICAgICAgIHRoaXMuYXJ0d29yay5oZWlnaHQgKiB0aGlzLmJhY2tpbmdTdG9yZVNjYWxlXyk7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IHkgPSAxOyB5IDwgdGhpcy5hcnR3b3JrLmhlaWdodDsgKyt5KSB7XG4gICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICB5ICogdGhpcy5iYWNraW5nU3RvcmVTY2FsZV8gLSAwLjUgKiAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSksXG4gICAgICAgICAgICB0aGlzLmFydHdvcmsud2lkdGggKiB0aGlzLmJhY2tpbmdTdG9yZVNjYWxlXyxcbiAgICAgICAgICAgIDEgKiAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnN0dWRpb1N0YXRlXy5wbGF5aW5nKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbkZyYW1lUmVxdWVzdF8gPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgdGhpcy5hbmltVGltZSA9ICgoTnVtYmVyKG5ldyBEYXRlKCkpIC0gdGhpcy5hbmltU3RhcnQpICogdGhpcy5zdHVkaW9TdGF0ZV8ucGxheWJhY2tTcGVlZClcbiAgICAgICAgICAgICUgdGhpcy5hbmltYXRpb24uZHVyYXRpb247XG4gICAgICAgIHRoaXMuc2NvcGVfLiRhcHBseSgoKSA9PiB0aGlzLnN0dWRpb1N0YXRlXy5hY3RpdmVUaW1lID0gdGhpcy5hbmltVGltZSk7XG4gICAgICAgIHRoaXMuZHJhd0NhbnZhc18oKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5cbmFuZ3VsYXIubW9kdWxlKCdBVkRTdHVkaW8nKS5kaXJlY3RpdmUoJ3N0dWRpb0NhbnZhcycsICgpID0+IHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0UnLFxuICAgIHNjb3BlOiB7fSxcbiAgICB0ZW1wbGF0ZVVybDogJ2NvbXBvbmVudHMvY2FudmFzL2NhbnZhcy5odG1sJyxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIGJpbmRUb0NvbnRyb2xsZXI6IHRydWUsXG4gICAgY29udHJvbGxlcjogQ2FudmFzQ29udHJvbGxlcixcbiAgICBjb250cm9sbGVyQXM6ICdjdHJsJ1xuICB9O1xufSk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuY29uc3QgU3RhdGUgPSB7XG4gIE5PTkU6IDAsXG4gIERSQUdHSU5HOiAxLFxuICBMT0FESU5HOiAyLFxufTtcblxuY2xhc3MgRmlsZURyb3BUYXJnZXRDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoJHNjb3BlLCAkZWxlbWVudCwgJGF0dHJzKSB7XG4gICAgdGhpcy5zY29wZV8gPSAkc2NvcGU7XG4gICAgdGhpcy5lbGVtZW50XyA9ICRlbGVtZW50O1xuICAgIHRoaXMuZWxlbWVudF8uYWRkQ2xhc3MoJ2ZpbGUtZHJvcC10YXJnZXQnKTtcblxuICAgIHRoaXMub25Ecm9wRmlsZV8gPSAkYXR0cnMuZmlsZURyb3BUYXJnZXRcbiAgICAgICAgPyAoZmlsZUluZm8gPT4gJHNjb3BlLiRldmFsKCRhdHRycy5maWxlRHJvcFRhcmdldCwge2ZpbGVJbmZvfSkpXG4gICAgICAgIDogKCgpID0+IHt9KTtcblxuICAgIHRoaXMuc3RhdGVfID0gU3RhdGUuTk9ORTtcblxuICAgIC8vIHNldCB1cCBkcmFnIGV2ZW50IGxpc3RlbmVycywgd2l0aCBkZWJvdW5jaW5nIGJlY2F1c2UgZHJhZ2dpbmcgb3Zlci9vdXQgb2YgZWFjaCBjaGlsZFxuICAgIC8vIHRyaWdnZXJzIHRoZXNlIGV2ZW50cyBvbiB0aGUgZWxlbWVudFxuXG4gICAgbGV0IG5vdERyYWdnaW5nVGltZW91dF87XG5cbiAgICBsZXQgc2V0RHJhZ2dpbmdfID0gZHJhZ2dpbmcgPT4ge1xuICAgICAgaWYgKGRyYWdnaW5nKSB7XG4gICAgICAgIC8vIHdoZW4gbW92aW5nIGZyb20gY2hpbGQgdG8gY2hpbGQsIGRyYWdlbnRlciBpcyBzZW50IGJlZm9yZSBkcmFnbGVhdmVcbiAgICAgICAgLy8gb24gcHJldmlvdXMgY2hpbGRcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmIChub3REcmFnZ2luZ1RpbWVvdXRfKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KG5vdERyYWdnaW5nVGltZW91dF8pO1xuICAgICAgICAgICAgbm90RHJhZ2dpbmdUaW1lb3V0XyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc2V0U3RhdGVfKFN0YXRlLkRSQUdHSU5HKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobm90RHJhZ2dpbmdUaW1lb3V0Xykge1xuICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQobm90RHJhZ2dpbmdUaW1lb3V0Xyk7XG4gICAgICAgIH1cbiAgICAgICAgbm90RHJhZ2dpbmdUaW1lb3V0XyA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHRoaXMuc2V0U3RhdGVfKFN0YXRlLk5PTkUpLCAxMDApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmVsZW1lbnRfXG4gICAgICAgIC5vbignZHJhZ2VudGVyJywgZXZlbnQgPT4ge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgc2V0RHJhZ2dpbmdfKHRydWUpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdkcmFnb3ZlcicsIGV2ZW50ID0+IHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGV2ZW50Lm9yaWdpbmFsRXZlbnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSAnY29weSc7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ2RyYWdsZWF2ZScsIGV2ZW50ID0+IHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHNldERyYWdnaW5nXyhmYWxzZSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ2Ryb3AnLCBldmVudCA9PiB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLnNldFN0YXRlXyhTdGF0ZS5OT05FKTtcbiAgICAgICAgICB0aGlzLmhhbmRsZURyb3BGaWxlc18oZXZlbnQub3JpZ2luYWxFdmVudC5kYXRhVHJhbnNmZXIuZmlsZXMpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gIH1cblxuICBzZXRTdGF0ZV8oc3RhdGUpIHtcbiAgICB0aGlzLnN0YXRlXyA9IHN0YXRlO1xuICAgIHRoaXMuZWxlbWVudF8udG9nZ2xlQ2xhc3MoJ2lzLWRyYWdnaW5nLW92ZXInLCB0aGlzLnN0YXRlXyA9PT0gU3RhdGUuRFJBR0dJTkcpO1xuICAgIHRoaXMuZWxlbWVudF8udG9nZ2xlQ2xhc3MoJ2lzLWxvYWRpbmcnLCB0aGlzLnN0YXRlXyA9PT0gU3RhdGUuTE9BRElORyk7XG4gIH1cblxuICBoYW5kbGVEcm9wRmlsZXNfKGZpbGVMaXN0KSB7XG4gICAgZmlsZUxpc3QgPSBBcnJheS5mcm9tKGZpbGVMaXN0IHx8IFtdKTtcbiAgICBmaWxlTGlzdCA9IGZpbGVMaXN0LmZpbHRlcihmaWxlID0+XG4gICAgICAgIChmaWxlLnR5cGUgPT09ICdpbWFnZS9zdmcreG1sJ1xuICAgICAgICAgIHx8IGZpbGUudHlwZSA9PT0gJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgICAgfHwgZmlsZS50eXBlID09PSAnYXBwbGljYXRpb24veG1sJ1xuICAgICAgICAgIHx8IGZpbGUudHlwZSA9PT0gJ3RleHQveG1sJ1xuICAgICAgICAgIHx8IGZpbGUubmFtZS5tYXRjaCgvXFwuaWNvbmFuaW0kLykpKTtcbiAgICBpZiAoIWZpbGVMaXN0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBmaWxlID0gZmlsZUxpc3RbMF07XG5cbiAgICBsZXQgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGV2ZW50ID0+IHtcbiAgICAgIHRoaXMuc2V0U3RhdGVfKFN0YXRlLk5PTkUpO1xuICAgICAgdGhpcy5zY29wZV8uJGFwcGx5KCgpID0+IHRoaXMub25Ecm9wRmlsZV8oe1xuICAgICAgICB0ZXh0Q29udGVudDogZXZlbnQudGFyZ2V0LnJlc3VsdCxcbiAgICAgICAgbmFtZTogZmlsZS5uYW1lLFxuICAgICAgICB0eXBlOiBmaWxlLnR5cGVcbiAgICAgIH0pKTtcbiAgICB9O1xuXG4gICAgZmlsZVJlYWRlci5vbmVycm9yID0gZXZlbnQgPT4ge1xuICAgICAgdGhpcy5zZXRTdGF0ZV8oU3RhdGUuTk9ORSk7XG4gICAgICBzd2l0Y2ggKGV2ZW50LnRhcmdldC5lcnJvci5jb2RlKSB7XG4gICAgICAgIGNhc2UgZXZlbnQudGFyZ2V0LmVycm9yLk5PVF9GT1VORF9FUlI6XG4gICAgICAgICAgYWxlcnQoJ0ZpbGUgbm90IGZvdW5kIScpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGV2ZW50LnRhcmdldC5lcnJvci5OT1RfUkVBREFCTEVfRVJSOlxuICAgICAgICAgIGFsZXJ0KCdGaWxlIGlzIG5vdCByZWFkYWJsZScpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGV2ZW50LnRhcmdldC5lcnJvci5BQk9SVF9FUlI6XG4gICAgICAgICAgYnJlYWs7IC8vIG5vb3BcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBhbGVydCgnQW4gZXJyb3Igb2NjdXJyZWQgcmVhZGluZyB0aGlzIGZpbGUuJyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZpbGVSZWFkZXIub25hYm9ydCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGVfKFN0YXRlLk5PTkUpO1xuICAgICAgYWxlcnQoJ0ZpbGUgcmVhZCBjYW5jZWxsZWQnKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zZXRTdGF0ZV8oU3RhdGUuTE9BRElORyk7XG4gICAgZmlsZVJlYWRlci5yZWFkQXNUZXh0KGZpbGUpO1xuICB9XG59XG5cblxuYW5ndWxhci5tb2R1bGUoJ0FWRFN0dWRpbycpLmRpcmVjdGl2ZSgnZmlsZURyb3BUYXJnZXQnLCAoKSA9PiB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdBJyxcbiAgICBjb250cm9sbGVyOiBGaWxlRHJvcFRhcmdldENvbnRyb2xsZXJcbiAgfTtcbn0pO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmNsYXNzIEZpbGVPcGVuSGFuZGxlckNvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3Rvcigkc2NvcGUsICRlbGVtZW50LCAkYXR0cnMpIHtcbiAgICB0aGlzLnNjb3BlXyA9ICRzY29wZTtcbiAgICB0aGlzLmVsZW1lbnRfID0gJGVsZW1lbnQ7XG4gICAgdGhpcy5lbGVtZW50Xy5hZGRDbGFzcygnZmlsZS1vcGVuLXByb3h5Jyk7XG5cbiAgICB0aGlzLm9uT3BlbkZpbGVfID0gJGF0dHJzLmZpbGVPcGVuSGFuZGxlclxuICAgICAgICA/IChmaWxlSW5mbyA9PiAkc2NvcGUuJGV2YWwoJGF0dHJzLmZpbGVPcGVuSGFuZGxlciwge2ZpbGVJbmZvfSkpXG4gICAgICAgIDogKCgpID0+IHt9KTtcbiAgfVxuXG4gIG9uTGluaygpIHtcbiAgICB0aGlzLmlucHV0RWxlbWVudF8gPSB0aGlzLmVsZW1lbnRfLmZpbmQoJ2lucHV0Jyk7XG4gICAgdGhpcy5pbnB1dEVsZW1lbnRfLm9uKCdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICBsZXQgZmlsZXMgPSB0aGlzLmlucHV0RWxlbWVudF8uZ2V0KDApLmZpbGVzO1xuICAgICAgaWYgKGZpbGVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmhhbmRsZURyb3BGaWxlc18oZmlsZXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaGFuZGxlRHJvcEZpbGVzXyhmaWxlTGlzdCkge1xuICAgIGZpbGVMaXN0ID0gQXJyYXkuZnJvbShmaWxlTGlzdCB8fCBbXSk7XG4gICAgZmlsZUxpc3QgPSBmaWxlTGlzdC5maWx0ZXIoZmlsZSA9PlxuICAgICAgICAoZmlsZS50eXBlID09PSAnaW1hZ2Uvc3ZnK3htbCdcbiAgICAgICAgICB8fCBmaWxlLnR5cGUgPT09ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICAgIHx8IGZpbGUudHlwZSA9PT0gJ2FwcGxpY2F0aW9uL3htbCdcbiAgICAgICAgICB8fCBmaWxlLnR5cGUgPT09ICd0ZXh0L3htbCdcbiAgICAgICAgICB8fCBmaWxlLm5hbWUubWF0Y2goL1xcLmljb25hbmltJC8pKSk7XG4gICAgaWYgKCFmaWxlTGlzdC5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgZmlsZSA9IGZpbGVMaXN0WzBdO1xuXG4gICAgbGV0IGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXG4gICAgZmlsZVJlYWRlci5vbmxvYWQgPSBldmVudCA9PiB7XG4gICAgICB0aGlzLnNjb3BlXy4kYXBwbHkoKCkgPT4gdGhpcy5vbk9wZW5GaWxlXyh7XG4gICAgICAgIHRleHRDb250ZW50OiBldmVudC50YXJnZXQucmVzdWx0LFxuICAgICAgICBuYW1lOiBmaWxlLm5hbWUsXG4gICAgICAgIHR5cGU6IGZpbGUudHlwZVxuICAgICAgfSkpO1xuICAgIH07XG5cbiAgICBmaWxlUmVhZGVyLm9uZXJyb3IgPSBldmVudCA9PiB7XG4gICAgICBzd2l0Y2ggKGV2ZW50LnRhcmdldC5lcnJvci5jb2RlKSB7XG4gICAgICAgIGNhc2UgZXZlbnQudGFyZ2V0LmVycm9yLk5PVF9GT1VORF9FUlI6XG4gICAgICAgICAgYWxlcnQoJ0ZpbGUgbm90IGZvdW5kIScpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGV2ZW50LnRhcmdldC5lcnJvci5OT1RfUkVBREFCTEVfRVJSOlxuICAgICAgICAgIGFsZXJ0KCdGaWxlIGlzIG5vdCByZWFkYWJsZScpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGV2ZW50LnRhcmdldC5lcnJvci5BQk9SVF9FUlI6XG4gICAgICAgICAgYnJlYWs7IC8vIG5vb3BcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBhbGVydCgnQW4gZXJyb3Igb2NjdXJyZWQgcmVhZGluZyB0aGlzIGZpbGUuJyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZpbGVSZWFkZXIub25hYm9ydCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGFsZXJ0KCdGaWxlIHJlYWQgY2FuY2VsbGVkJyk7XG4gICAgfTtcblxuICAgIGZpbGVSZWFkZXIucmVhZEFzVGV4dChmaWxlKTtcbiAgfVxufVxuXG5cbmFuZ3VsYXIubW9kdWxlKCdBVkRTdHVkaW8nKS5kaXJlY3RpdmUoJ2ZpbGVPcGVuSGFuZGxlcicsICgpID0+IHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0EnLFxuICAgIGNvbnRyb2xsZXI6IEZpbGVPcGVuSGFuZGxlckNvbnRyb2xsZXIsXG4gICAgcmVxdWlyZTogJ15maWxlT3BlbkhhbmRsZXInLFxuICAgIGxpbms6ICgkZWxlbWVudCwgJHNjb3BlLCAkYXR0cnMsIGN0cmwpID0+IHtcbiAgICAgIGN0cmwub25MaW5rKCRlbGVtZW50KTtcbiAgICB9XG4gIH07XG59KTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgY29uc3QgVGltZWxpbmVDb25zdHMgPSB7XG4gIFRJTUVMSU5FX0FOSU1BVElPTl9QQURESU5HOiAyMCwgLy8gMjBweFxufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge0FydHdvcmssIFBhdGhMYXllciwgTGF5ZXJHcm91cCwgTWFza0xheWVyLCBBbmltYXRpb24sIEFuaW1hdGlvbkJsb2NrfSBmcm9tICdtb2RlbCc7XG5pbXBvcnQge01vZGVsVXRpbH0gZnJvbSAnTW9kZWxVdGlsJztcbmltcG9ydCB7TWF0aFV0aWx9IGZyb20gJ01hdGhVdGlsJztcbmltcG9ydCB7VWlVdGlsfSBmcm9tICdVaVV0aWwnO1xuaW1wb3J0IHtEcmFnSGVscGVyfSBmcm9tICdEcmFnSGVscGVyJztcbmltcG9ydCB7U3ZnTG9hZGVyfSBmcm9tICdTdmdMb2FkZXInO1xuaW1wb3J0IHtWZWN0b3JEcmF3YWJsZUxvYWRlcn0gZnJvbSAnVmVjdG9yRHJhd2FibGVMb2FkZXInO1xuXG5pbXBvcnQge1RpbWVsaW5lQ29uc3RzfSBmcm9tICcuL2NvbnN0cyc7XG5cblxuY29uc3QgTEFZRVJfSU5ERU5UID0gMjA7IC8vIHBpeGVsc1xuXG5jb25zdCBTTkFQX1BJWEVMUyA9IDEwOyAvLyBkaXN0YW5jZSBpbiBwaXhlbHMgZnJvbSBhIHNuYXAgcG9pbnQgYmVmb3JlIHNuYXBwaW5nIHRvIHRoZSBwb2ludFxuXG5jb25zdCBNSU5fQkxPQ0tfRFVSQVRJT04gPSAxMDsgLy8gMTBtc1xuXG5jb25zdCBNQVhfWk9PTSA9IDEwO1xuY29uc3QgTUlOX1pPT00gPSAwLjAxO1xuXG5cbmNvbnN0IE1vdXNlQWN0aW9ucyA9IHtcbiAgTU9WSU5HOiAwLFxuICBTQ0FMSU5HX1VOSUZPUk1fU1RBUlQ6IDEsXG4gIFNDQUxJTkdfVU5JRk9STV9FTkQ6IDIsXG4gIFNDQUxJTkdfVE9HRVRIRVJfU1RBUlQ6IDMsXG4gIFNDQUxJTkdfVE9HRVRIRVJfRU5EOiA0LFxufTtcblxuXG5jbGFzcyBMYXllclRpbWVsaW5lQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKCRzY29wZSwgJGVsZW1lbnQsICR0aW1lb3V0LCBTdHVkaW9TdGF0ZVNlcnZpY2UpIHtcbiAgICB0aGlzLnNjb3BlXyA9ICRzY29wZTtcbiAgICB0aGlzLmVsZW1lbnRfID0gJGVsZW1lbnQ7XG4gICAgdGhpcy50aW1lb3V0XyA9ICR0aW1lb3V0O1xuICAgIHRoaXMuc3R1ZGlvU3RhdGVfID0gU3R1ZGlvU3RhdGVTZXJ2aWNlO1xuICAgIHRoaXMuc3R1ZGlvU3RhdGVfLm9uQ2hhbmdlKChldmVudCwgY2hhbmdlcykgPT4ge1xuICAgICAgaWYgKGNoYW5nZXMuYXJ0d29yayB8fCBjaGFuZ2VzLmFuaW1hdGlvbnMpIHtcbiAgICAgICAgdGhpcy5yZWJ1aWxkTW9kZWxfKCk7XG4gICAgICAgIHRoaXMucmVidWlsZFNuYXBUaW1lc18oKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFuZ2VzLmlzUmVzZXQpIHtcbiAgICAgICAgdGhpcy5hdXRvWm9vbVRvQW5pbWF0aW9uKCk7XG4gICAgICB9XG4gICAgfSwgJHNjb3BlKTtcblxuICAgIHRoaXMuaG9yaXpab29tID0gMjsgLy8gMW1zID0gMnB4XG5cbiAgICB0aGlzLnNldHVwTW91c2VXaGVlbFpvb21fKCk7XG5cbiAgICB0aGlzLnJlYnVpbGRNb2RlbF8oKTtcbiAgICB0aGlzLnJlYnVpbGRTbmFwVGltZXNfKCk7XG4gICAgdGhpcy5hdXRvWm9vbVRvQW5pbWF0aW9uKCk7XG4gIH1cblxuICBnZXQgaG9yaXpab29tKCkge1xuICAgIHJldHVybiB0aGlzLmhvcml6Wm9vbV87XG4gIH1cblxuICBzZXQgaG9yaXpab29tKHZhbCkge1xuICAgIHRoaXMuaG9yaXpab29tXyA9IE1hdGhVdGlsLmNvbnN0cmFpbih2YWwsIE1JTl9aT09NLCBNQVhfWk9PTSk7XG4gIH1cblxuICBnZXQgYXJ0d29yaygpIHtcbiAgICByZXR1cm4gdGhpcy5zdHVkaW9TdGF0ZV8uYXJ0d29yaztcbiAgfVxuXG4gIGdldCBhY3RpdmVUaW1lKCkge1xuICAgIHJldHVybiB0aGlzLnN0dWRpb1N0YXRlXy5hY3RpdmVUaW1lO1xuICB9XG5cbiAgZ2V0IGFuaW1hdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3R1ZGlvU3RhdGVfLmFuaW1hdGlvbnM7XG4gIH1cblxuICBnZXQgYWN0aXZlQW5pbWF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnN0dWRpb1N0YXRlXy5hY3RpdmVBbmltYXRpb247XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhbHQrbW91c2V3aGVlbCBmb3Igem9vbWluZyBpbnRvIGFuZCBvdXQgb2YgdGhlIHRpbWVsaW5lLlxuICAgKi9cbiAgc2V0dXBNb3VzZVdoZWVsWm9vbV8oKSB7XG4gICAgbGV0ICR0aW1lbGluZSA9IHRoaXMuZWxlbWVudF8uZmluZCgnLnNsdC10aW1lbGluZScpO1xuICAgIGxldCAkem9vbVN0YXJ0QWN0aXZlQW5pbWF0aW9uO1xuICAgIGxldCB0YXJnZXRIb3Jpelpvb207XG4gICAgbGV0IHBlcmZvcm1ab29tUkFGID0gbnVsbDtcbiAgICBsZXQgZW5kWm9vbVRpbWVvdXQgPSBudWxsO1xuICAgIGxldCB6b29tU3RhcnRUaW1lQ3Vyc29yUG9zO1xuXG4gICAgJHRpbWVsaW5lLm9uKCd3aGVlbCcsIGV2ZW50ID0+IHtcbiAgICAgIGlmIChldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSkgeyAvLyBjaHJvbWUrbWFjIHRyYWNrcGFkIHBpbmNoLXpvb20gPSBjdHJsS2V5XG4gICAgICAgIGlmICghdGFyZ2V0SG9yaXpab29tKSB7XG4gICAgICAgIC8vIG11bHRpcGxlIGNoYW5nZXMgY2FuIGhhcHBlbiB0byB0YXJnZXRIb3Jpelpvb20gYmVmb3JlIHRoZVxuICAgICAgICAvLyBhY3R1YWwgem9vbSBsZXZlbCBpcyB1cGRhdGVkIChzZWUgcGVyZm9ybVpvb21fKVxuICAgICAgICAgIHRhcmdldEhvcml6Wm9vbSA9IHRoaXMuaG9yaXpab29tO1xuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGFyZ2V0SG9yaXpab29tICo9IE1hdGgucG93KDEuMDEsIC1ldmVudC5vcmlnaW5hbEV2ZW50LmRlbHRhWSk7XG4gICAgICAgIHRhcmdldEhvcml6Wm9vbSA9IE1hdGhVdGlsLmNvbnN0cmFpbih0YXJnZXRIb3Jpelpvb20sIE1JTl9aT09NLCBNQVhfWk9PTSk7XG4gICAgICAgIGlmICh0YXJnZXRIb3Jpelpvb20gIT0gdGhpcy5ob3Jpelpvb20pIHtcbiAgICAgICAgICAvLyB6b29tIGhhcyBjaGFuZ2VkXG4gICAgICAgICAgaWYgKHBlcmZvcm1ab29tUkFGKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUocGVyZm9ybVpvb21SQUYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwZXJmb3JtWm9vbVJBRiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gcGVyZm9ybVpvb21fKCkpO1xuXG4gICAgICAgICAgaWYgKGVuZFpvb21UaW1lb3V0KSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGVuZFpvb21UaW1lb3V0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRab29tXygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVuZFpvb21UaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4gZW5kWm9vbV8oKSwgMTAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBsZXQgc3RhcnRab29tXyA9ICgpID0+IHtcbiAgICAgICR6b29tU3RhcnRBY3RpdmVBbmltYXRpb24gPSAkKCcuc2x0LXRpbWVsaW5lLWFuaW1hdGlvbi5pcy1hY3RpdmUnKTtcbiAgICAgIHpvb21TdGFydFRpbWVDdXJzb3JQb3MgPSAkem9vbVN0YXJ0QWN0aXZlQW5pbWF0aW9uLnBvc2l0aW9uKCkubGVmdFxuICAgICAgICAgICsgdGhpcy5hY3RpdmVUaW1lICogdGhpcy5ob3Jpelpvb20gKyBUaW1lbGluZUNvbnN0cy5USU1FTElORV9BTklNQVRJT05fUEFERElORztcbiAgICB9O1xuXG4gICAgbGV0IHBlcmZvcm1ab29tXyA9ICgpID0+IHtcbiAgICAgIHRoaXMuaG9yaXpab29tID0gdGFyZ2V0SG9yaXpab29tO1xuICAgICAgdGhpcy5zY29wZV8uJGFwcGx5KCk7XG5cbiAgICAgIC8vIHNldCB0aGUgc2Nyb2xsIG9mZnNldCBzdWNoIHRoYXQgdGhlIHRpbWUgY3Vyc29yIHJlbWFpbnMgYXRcbiAgICAgIC8vIHpvb21TdGFydFRpbWVDdXJzb3JQb3NcbiAgICAgIGlmICgkem9vbVN0YXJ0QWN0aXZlQW5pbWF0aW9uKSB7XG4gICAgICAgIGxldCBuZXdTY3JvbGxMZWZ0ID0gJHpvb21TdGFydEFjdGl2ZUFuaW1hdGlvbi5wb3NpdGlvbigpLmxlZnRcbiAgICAgICAgICAgICsgJHRpbWVsaW5lLnNjcm9sbExlZnQoKVxuICAgICAgICAgICAgKyB0aGlzLmFjdGl2ZVRpbWUgKiB0aGlzLmhvcml6Wm9vbSArIFRpbWVsaW5lQ29uc3RzLlRJTUVMSU5FX0FOSU1BVElPTl9QQURESU5HXG4gICAgICAgICAgICAtIHpvb21TdGFydFRpbWVDdXJzb3JQb3M7XG4gICAgICAgICR0aW1lbGluZS5zY3JvbGxMZWZ0KG5ld1Njcm9sbExlZnQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsZXQgZW5kWm9vbV8gPSAoKSA9PiB7XG4gICAgICB6b29tU3RhcnRUaW1lQ3Vyc29yUG9zID0gMDtcbiAgICAgICR6b29tU3RhcnRBY3RpdmVBbmltYXRpb24gPSBudWxsO1xuICAgICAgZW5kWm9vbVRpbWVvdXQgPSBudWxsO1xuICAgICAgdGFyZ2V0SG9yaXpab29tID0gMDtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYnVpbGRzIGludGVybmFsIGxheWVyL3RpbWVsaW5lIHJlbGF0ZWQgZGF0YSBzdHJ1Y3R1cmVzIChfc2x0KSBhYm91dCB0aGUgY3VycmVudFxuICAgKiBhcnR3b3JrIGFuZCBhbmltYXRpb25zLlxuICAgKi9cbiAgcmVidWlsZE1vZGVsXygpIHtcbiAgICBpZiAoIXRoaXMuYXJ0d29yayB8fCAhdGhpcy5hbmltYXRpb25zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGlzRW1wdHlPYmpfID0gb2JqID0+IHtcbiAgICAgIGZvciAobGV0IGsgaW4gb2JqKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICB0aGlzLmFydHdvcmsud2FsayhsYXllciA9PiB7XG4gICAgICBsZXQgX3NsdCA9IHt9O1xuICAgICAgX3NsdC5sYXllclR5cGUgPSAobGF5ZXIgaW5zdGFuY2VvZiBMYXllckdyb3VwKVxuICAgICAgICAgID8gJ2dyb3VwJ1xuICAgICAgICAgIDogKChsYXllciBpbnN0YW5jZW9mIE1hc2tMYXllcikgPyAnbWFzaycgOiAnbGF5ZXInKTtcbiAgICAgIF9zbHQuYmxvY2tzQnlQcm9wZXJ0eSA9IHt9O1xuICAgICAgX3NsdC5hdmFpbGFibGVQcm9wZXJ0aWVzID0gbGF5ZXIuYW5pbWF0YWJsZVByb3BlcnRpZXM7XG4gICAgICBfc2x0Lmhhc0F2YWlsYWJsZVByb3BlcnRpZXMgPSAhaXNFbXB0eU9ial8oX3NsdC5hdmFpbGFibGVQcm9wZXJ0aWVzKTtcbiAgICAgIGxheWVyLl9zbHQgPSBfc2x0O1xuICAgIH0pO1xuXG4gICAgdGhpcy5hbmltYXRpb25zLmZvckVhY2goYW5pbWF0aW9uID0+IHtcbiAgICAgIGxldCBibG9ja3NCeUxheWVySWQgPSBNb2RlbFV0aWwuZ2V0T3JkZXJlZEFuaW1hdGlvbkJsb2Nrc0J5TGF5ZXJJZEFuZFByb3BlcnR5KGFuaW1hdGlvbik7XG4gICAgICBPYmplY3Qua2V5cyhibG9ja3NCeUxheWVySWQpLmZvckVhY2gobGF5ZXJJZCA9PiB7XG4gICAgICAgIGxldCBsYXllciA9IHRoaXMuYXJ0d29yay5maW5kTGF5ZXJCeUlkKGxheWVySWQpO1xuICAgICAgICBpZiAoIWxheWVyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmtleXMoYmxvY2tzQnlMYXllcklkW2xheWVySWRdKS5mb3JFYWNoKHByb3BlcnR5TmFtZSA9PiB7XG4gICAgICAgICAgbGF5ZXIuX3NsdC5ibG9ja3NCeVByb3BlcnR5W3Byb3BlcnR5TmFtZV1cbiAgICAgICAgICAgICAgPSBsYXllci5fc2x0LmJsb2Nrc0J5UHJvcGVydHlbcHJvcGVydHlOYW1lXSB8fCB7fTtcbiAgICAgICAgICBsYXllci5fc2x0LmJsb2Nrc0J5UHJvcGVydHlbcHJvcGVydHlOYW1lXVthbmltYXRpb24uaWRdXG4gICAgICAgICAgICAgID0gYmxvY2tzQnlMYXllcklkW2xheWVySWRdW3Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgZGVsZXRlIGxheWVyLl9zbHQuYXZhaWxhYmxlUHJvcGVydGllc1twcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgIGxheWVyLl9zbHQuaGFzQXZhaWxhYmxlUHJvcGVydGllcyA9ICFpc0VtcHR5T2JqXyhsYXllci5fc2x0LmF2YWlsYWJsZVByb3BlcnRpZXMpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFpvb21zIHRoZSB0aW1lbGluZSB0byBmaXQgdGhlIGZpcnN0IGFuaW1hdGlvbi5cbiAgICovXG4gIGF1dG9ab29tVG9BbmltYXRpb24oKSB7XG4gICAgaWYgKHRoaXMuYW5pbWF0aW9ucy5sZW5ndGgpIHtcbiAgICAgIFVpVXRpbC53YWl0Rm9yRWxlbWVudFdpZHRoXyh0aGlzLmVsZW1lbnRfLmZpbmQoJy5zbHQtdGltZWxpbmUnKSlcbiAgICAgICAgICAudGhlbih3aWR0aCA9PiB7XG4gICAgICAgICAgICB3aWR0aCAtPSAxMDA7IC8vIHNoYXZlIG9mZiBhIGh1bmRyZWQgcGl4ZWxzIGZvciBzYWZldHlcbiAgICAgICAgICAgIGxldCB6b29tID0gd2lkdGggLyB0aGlzLmFuaW1hdGlvbnNbMF0uZHVyYXRpb247XG4gICAgICAgICAgICB0aGlzLmhvcml6Wm9vbSA9IHpvb207XG4gICAgICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgc2NydWJiaW5nIChkcmFnZ2luZykgb3ZlciB0aGUgdGltZWxpbmUgaGVhZGVyIGFyZWEsIHdoaWNoIHNob3VsZFxuICAgKiBjaGFuZ2UgdGhlIHRpbWUgY3Vyc29yLlxuICAgKi9cbiAgb25UaW1lbGluZUhlYWRlclNjcnViKGFuaW1hdGlvbiwgdGltZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghb3B0aW9ucy5kaXNhYmxlU25hcCkge1xuICAgICAgdGltZSA9IHRoaXMuc25hcFRpbWVfKGFuaW1hdGlvbiwgdGltZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIHRoaXMuc3R1ZGlvU3RhdGVfLmRlc2VsZWN0SXRlbSh0aGlzLnN0dWRpb1N0YXRlXy5hY3RpdmVBbmltYXRpb24pO1xuICAgIHRoaXMuc3R1ZGlvU3RhdGVfLmFjdGl2ZUFuaW1hdGlvbiA9IGFuaW1hdGlvbjtcbiAgICB0aGlzLnN0dWRpb1N0YXRlXy5hY3RpdmVUaW1lID0gdGltZTtcbiAgICB0aGlzLnN0dWRpb1N0YXRlXy5wbGF5aW5nID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGEgY2FjaGUgb2Ygc25hcCB0aW1lcyBmb3IgYWxsIGF2YWlsYWJsZSBhbmltYXRpb25zLlxuICAgKi9cbiAgcmVidWlsZFNuYXBUaW1lc18oKSB7XG4gICAgaWYgKHRoaXMuc3VwcHJlc3NSZWJ1aWxkU25hcFRpbWVzXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc25hcFRpbWVzXyA9IHt9O1xuICAgIGlmICh0aGlzLmFuaW1hdGlvbnMpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9ucy5mb3JFYWNoKGFuaW1hdGlvbiA9PiB7XG4gICAgICAgIGxldCBzbmFwVGltZXMgPSBuZXcgU2V0KFtdKTtcbiAgICAgICAgc25hcFRpbWVzLmFkZCgwKTtcbiAgICAgICAgc25hcFRpbWVzLmFkZChhbmltYXRpb24uZHVyYXRpb24pO1xuICAgICAgICBhbmltYXRpb24uYmxvY2tzLmZvckVhY2goYmxvY2sgPT4ge1xuICAgICAgICAgIHNuYXBUaW1lcy5hZGQoYmxvY2suc3RhcnRUaW1lKTtcbiAgICAgICAgICBzbmFwVGltZXMuYWRkKGJsb2NrLmVuZFRpbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zbmFwVGltZXNfW2FuaW1hdGlvbi5pZF0gPSBBcnJheS5mcm9tKHNuYXBUaW1lcyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyB0aW1lLCBwb3NzaWJseSBzbmFwcGVkIHRvIGFuaW1hdGlvbiBib3VuZGFyaWVzXG4gICAqL1xuICBzbmFwVGltZV8oYW5pbWF0aW9uLCB0aW1lLCBpbmNsdWRlQWN0aXZlVGltZSA9IHRydWUpIHtcbiAgICBsZXQgc25hcFRpbWVzID0gdGhpcy5zbmFwVGltZXNfW2FuaW1hdGlvbi5pZF07XG4gICAgbGV0IHNuYXBEZWx0YSA9IFNOQVBfUElYRUxTIC8gdGhpcy5ob3Jpelpvb207XG4gICAgbGV0IHJlZHVjZXJfID0gKGJlc3RTbmFwVGltZSwgc25hcFRpbWUpID0+IHtcbiAgICAgIGxldCBkaXN0ID0gTWF0aC5hYnModGltZSAtIHNuYXBUaW1lKTtcbiAgICAgIHJldHVybiAoZGlzdCA8IHNuYXBEZWx0YSAmJiBkaXN0IDwgTWF0aC5hYnModGltZSAtIGJlc3RTbmFwVGltZSkpXG4gICAgICAgICAgPyBzbmFwVGltZVxuICAgICAgICAgIDogYmVzdFNuYXBUaW1lO1xuICAgIH07XG4gICAgbGV0IGJlc3RTbmFwVGltZSA9IHNuYXBUaW1lcy5yZWR1Y2UocmVkdWNlcl8sIEluZmluaXR5KTtcbiAgICBpZiAoaW5jbHVkZUFjdGl2ZVRpbWUpIHtcbiAgICAgIGJlc3RTbmFwVGltZSA9IHJlZHVjZXJfKGJlc3RTbmFwVGltZSwgdGhpcy5hY3RpdmVUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRmluaXRlKGJlc3RTbmFwVGltZSkgPyBiZXN0U25hcFRpbWUgOiB0aW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGFkZGluZyBhIG5ldyB0aW1lbGluZSBibG9jayB0byBhIHByb3BlcnR5IHRoYXQncyBhbHJlYWR5IGFuaW1hdGVkXG4gICAqL1xuICBvbkFkZFRpbWVsaW5lQmxvY2soJGV2ZW50LCBsYXllciwgcHJvcGVydHlOYW1lKSB7XG4gICAgbGV0IGFuaW1hdGlvbiA9IHRoaXMuc3R1ZGlvU3RhdGVfLmFjdGl2ZUFuaW1hdGlvbjtcblxuICAgIGxldCBuZXdCbG9ja0R1cmF0aW9uID0gMTAwOyAvLyBtaW4gZHVyYXRpb24gb2YgMTAwbXNcblxuICAgIC8vIGZpbmQgdGhlIHJpZ2h0IHN0YXJ0IHRpbWUgZm9yIHRoZSBibG9jaywgd2hpY2ggc2hvdWxkIGJlIGEgZ2FwIGJldHdlZW5cbiAgICAvLyBuZWlnaGJvcmluZyBibG9ja3MgY2xvc2VzdCB0byB0aGUgdGltZSBjdXJzb3IgKGFjdGl2ZVRpbWUpLCBvZiBhIG1pbmltdW0gc2l6ZVxuICAgIGxldCBibG9ja3NCeUxheWVySWQgPSBNb2RlbFV0aWwuZ2V0T3JkZXJlZEFuaW1hdGlvbkJsb2Nrc0J5TGF5ZXJJZEFuZFByb3BlcnR5KGFuaW1hdGlvbik7XG4gICAgbGV0IGJsb2NrTmVpZ2hib3JzID0gKGJsb2Nrc0J5TGF5ZXJJZFtsYXllci5pZF0gfHwge30pW3Byb3BlcnR5TmFtZV0gfHwgW107XG4gICAgbGV0IGdhcHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrTmVpZ2hib3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBnYXBzLnB1c2goe1xuICAgICAgICBzdGFydDogKGkgPT0gMCkgPyAwIDogYmxvY2tOZWlnaGJvcnNbaSAtIDFdLmVuZFRpbWUsXG4gICAgICAgIGVuZDogYmxvY2tOZWlnaGJvcnNbaV0uc3RhcnRUaW1lXG4gICAgICB9KTtcbiAgICB9XG4gICAgZ2Fwcy5wdXNoKHtcbiAgICAgIHN0YXJ0OiBibG9ja05laWdoYm9ycy5sZW5ndGggPyBibG9ja05laWdoYm9yc1tibG9ja05laWdoYm9ycy5sZW5ndGggLSAxXS5lbmRUaW1lIDogMCxcbiAgICAgIGVuZDogYW5pbWF0aW9uLmR1cmF0aW9uXG4gICAgfSk7XG4gICAgZ2FwcyA9IGdhcHNcbiAgICAgICAgLmZpbHRlcihnYXAgPT4gZ2FwLmVuZCAtIGdhcC5zdGFydCA+IG5ld0Jsb2NrRHVyYXRpb24pXG4gICAgICAgIC5tYXAoZ2FwID0+IE9iamVjdC5hc3NpZ24oZ2FwLCB7XG4gICAgICAgICAgZGlzdDogTWF0aC5taW4oXG4gICAgICAgICAgICAgIE1hdGguYWJzKGdhcC5lbmQgLSB0aGlzLnN0dWRpb1N0YXRlXy5hY3RpdmVUaW1lKSxcbiAgICAgICAgICAgICAgTWF0aC5hYnMoZ2FwLnN0YXJ0IC0gdGhpcy5zdHVkaW9TdGF0ZV8uYWN0aXZlVGltZSkpXG4gICAgICAgIH0pKVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5kaXN0IC0gYi5kaXN0KTtcblxuICAgIGlmICghZ2Fwcy5sZW5ndGgpIHtcbiAgICAgIC8vIG5vIGF2YWlsYWJsZSBnYXBzLCBjYW5jZWxcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgc3RhcnRUaW1lID0gTWF0aC5tYXgodGhpcy5zdHVkaW9TdGF0ZV8uYWN0aXZlVGltZSwgZ2Fwc1swXS5zdGFydCk7XG4gICAgbGV0IGVuZFRpbWUgPSBNYXRoLm1pbihzdGFydFRpbWUgKyBuZXdCbG9ja0R1cmF0aW9uLCBnYXBzWzBdLmVuZCk7XG4gICAgaWYgKGVuZFRpbWUgLSBzdGFydFRpbWUgPCBuZXdCbG9ja0R1cmF0aW9uKSB7XG4gICAgICBzdGFydFRpbWUgPSBlbmRUaW1lIC0gbmV3QmxvY2tEdXJhdGlvbjtcbiAgICB9XG5cbiAgICAvLyBnZW5lcmF0ZSB0aGUgbmV3IGJsb2NrLCBjbG9uaW5nIHRoZSBjdXJyZW50IHJlbmRlcmVkIHByb3BlcnR5IHZhbHVlXG4gICAgbGV0IHByb3BlcnR5T2JqID0gbGF5ZXIuYW5pbWF0YWJsZVByb3BlcnRpZXNbcHJvcGVydHlOYW1lXTtcbiAgICBsZXQgdmFsdWVBdEN1cnJlbnRUaW1lID0gdGhpcy5zdHVkaW9TdGF0ZV8uYW5pbWF0aW9uUmVuZGVyZXJcbiAgICAgICAgLmdldExheWVyUHJvcGVydHlWYWx1ZShsYXllci5pZCwgcHJvcGVydHlOYW1lKTtcbiAgICBsZXQgbmV3QmxvY2sgPSBuZXcgQW5pbWF0aW9uQmxvY2soe1xuICAgICAgbGF5ZXJJZDogbGF5ZXIuaWQsXG4gICAgICBwcm9wZXJ0eU5hbWUsXG4gICAgICBzdGFydFRpbWUsXG4gICAgICBlbmRUaW1lLFxuICAgICAgZnJvbVZhbHVlOiBwcm9wZXJ0eU9iai5jbG9uZVZhbHVlKHZhbHVlQXRDdXJyZW50VGltZSksXG4gICAgICB0b1ZhbHVlOiBwcm9wZXJ0eU9iai5jbG9uZVZhbHVlKHZhbHVlQXRDdXJyZW50VGltZSksXG4gICAgfSk7XG5cbiAgICAvLyBhZGQgdGhlIGJsb2NrXG4gICAgbmV3QmxvY2sucGFyZW50ID0gYW5pbWF0aW9uO1xuICAgIGFuaW1hdGlvbi5ibG9ja3MucHVzaChuZXdCbG9jayk7XG4gICAgdGhpcy5zdHVkaW9TdGF0ZV8uc2VsZWN0aW9uID0gW25ld0Jsb2NrXTtcbiAgICB0aGlzLnN0dWRpb1N0YXRlXy5hbmltQ2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgY2xpY2tzIG9uIGFuIGFuaW1hdGlvbiBpbiB0aGUgbGlzdCBvZiBjdXJyZW50IGFuaW1hdGlvbnMuXG4gICAqL1xuICBvbkFuaW1hdGlvbk1vdXNlRG93bigkZXZlbnQsIGFuaW1hdGlvbikge1xuICAgIGlmICh0aGlzLnN0dWRpb1N0YXRlXy5hY3RpdmVBbmltYXRpb24gIT09IGFuaW1hdGlvbikge1xuICAgICAgdGhpcy5zdHVkaW9TdGF0ZV8uZGVzZWxlY3RJdGVtKHRoaXMuc3R1ZGlvU3RhdGVfLmFjdGl2ZUFuaW1hdGlvbik7XG4gICAgfVxuICAgIHRoaXMuc3R1ZGlvU3RhdGVfLmFjdGl2ZUFuaW1hdGlvbiA9IGFuaW1hdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgaW4gcmVzcG9uc2UgdG8gYWRkaW5nIGEgbGF5ZXIgb2YgYSBnaXZlbiB0eXBlIHRvIHRoZSBhcnR3b3JrLlxuICAgKi9cbiAgb25BZGRMYXllcigkZXZlbnQsIHR5cGUpIHtcbiAgICBsZXQgY2xzID0gKHR5cGUgPT0gJ2dyb3VwJylcbiAgICAgICAgPyBMYXllckdyb3VwXG4gICAgICAgIDogKCh0eXBlID09ICdtYXNrJylcbiAgICAgICAgICAgID8gTWFza0xheWVyXG4gICAgICAgICAgICA6IFBhdGhMYXllcik7XG4gICAgbGV0IG5ld0xheWVyID0gbmV3IGNscygpO1xuICAgIG5ld0xheWVyLmlkID0gdGhpcy5zdHVkaW9TdGF0ZV8uZ2V0VW5pcXVlTGF5ZXJJZChudWxsLCBuZXdMYXllcik7XG5cbiAgICAvLyBUT0RPOiBhZGQganVzdCBiZWxvdyB0aGUgc2VsZWN0ZWQgbGF5ZXJcbiAgICBuZXdMYXllci5wYXJlbnQgPSB0aGlzLnN0dWRpb1N0YXRlXy5hcnR3b3JrOyAvLyBUT0RPOiB0aGlzIHNob3VsZCBiZSBhdXRvbWF0aWNcbiAgICB0aGlzLnN0dWRpb1N0YXRlXy5hcnR3b3JrLmxheWVycy5wdXNoKG5ld0xheWVyKTtcbiAgICB0aGlzLnN0dWRpb1N0YXRlXy5hcnR3b3JrQ2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgY2xpY2tzIG9uIGEgbGF5ZXIsIGVpdGhlciBzZWxlY3Rpbmcgb3IgZGVzZWxlY3RpbmcgaXQuXG4gICAqL1xuICBvbkxheWVyQ2xpY2soJGV2ZW50LCBsYXllcikge1xuICAgIGlmICh0aGlzLnN1cHByZXNzQ2xpY2tfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCRldmVudC5tZXRhS2V5IHx8ICRldmVudC5zaGlmdEtleSkge1xuICAgICAgdGhpcy5zdHVkaW9TdGF0ZV8udG9nZ2xlU2VsZWN0ZWQobGF5ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0dWRpb1N0YXRlXy5zZWxlY3Rpb24gPSBbbGF5ZXJdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgdG9nZ2xpbmcgZXhwYW5kZWQvY29sbGFwc2VkIHZpc3VhbCBzdGF0ZSBmb3IgYSBsYXllci5cbiAgICovXG4gIG9uTGF5ZXJUb2dnbGVFeHBhbmRlZCgkZXZlbnQsIGxheWVyKSB7XG4gICAgaWYgKCEobGF5ZXIgaW5zdGFuY2VvZiBMYXllckdyb3VwKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBleHBhbmQgPSAhbGF5ZXIuZXhwYW5kZWQ7XG4gICAgaWYgKCRldmVudC5hbHRLZXkpIHtcbiAgICAgIC8vIHJlY3Vyc2l2ZSBleHBhbmQvY29sbGFwc2VcbiAgICAgIGxheWVyLndhbGsobGF5ZXIgPT4ge1xuICAgICAgICBpZiAobGF5ZXIgaW5zdGFuY2VvZiBMYXllckdyb3VwKSB7XG4gICAgICAgICAgbGF5ZXIuZXhwYW5kZWQgPSBleHBhbmQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4cGFuZC9jb2xsYXBzZSBqdXN0IHRoaXMgbGF5ZXJcbiAgICAgIGxheWVyLmV4cGFuZGVkID0gZXhwYW5kO1xuICAgIH1cblxuICAgICRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgdG9nZ2xpbmcgb2YgdmlzaWJsZS9pbnZpc2libGUgc3RhdGUuXG4gICAqL1xuICBvbkxheWVyVG9nZ2xlVmlzaWJpbGl0eSgkZXZlbnQsIGxheWVyKSB7XG4gICAgbGF5ZXIudmlzaWJsZSA9ICFsYXllci52aXNpYmxlO1xuICAgIHRoaXMuc3R1ZGlvU3RhdGVfLmFydHdvcmtDaGFuZ2VkKCk7XG4gICAgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBnaXZlbiBwYXRoIGxheWVyIHRvIGEgY2xpcCBwYXRoLlxuICAgKi9cbiAgb25Db252ZXJ0TGF5ZXJUb0NsaXBQYXRoKCRldmVudCwgbGF5ZXIpIHtcbiAgICBsZXQgY2xpcFBhdGhMYXllciA9IG5ldyBNYXNrTGF5ZXIobGF5ZXIpO1xuICAgIHRoaXMuc3R1ZGlvU3RhdGVfLnN3YXBMYXllcihsYXllciwgY2xpcFBhdGhMYXllcik7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIGdpdmVuIGxheWVyIChjbGlwIHBhdGgpIHRvIGEgcGF0aCBsYXllci5cbiAgICovXG4gIG9uQ29udmVydExheWVyVG9QYXRoKCRldmVudCwgbGF5ZXIpIHtcbiAgICBsZXQgbmV3TGF5ZXIgPSBuZXcgUGF0aExheWVyKGxheWVyKTtcbiAgICB0aGlzLnN0dWRpb1N0YXRlXy5zd2FwTGF5ZXIobGF5ZXIsIG5ld0xheWVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGVtcHR5IGFuaW1hdGlvbiB0byB0aGUgbGlzdCBvZiBhbmltYXRpb25zLlxuICAgKi9cbiAgb25BZGROZXdBbmltYXRpb24oJGV2ZW50KSB7XG4gICAgbGV0IG5ld0FuaW0gPSBuZXcgQW5pbWF0aW9uKHtcbiAgICAgIGlkOiB0aGlzLnN0dWRpb1N0YXRlXy5nZXRVbmlxdWVBbmltYXRpb25JZCgpLFxuICAgICAgYmxvY2tzOiBbXSxcbiAgICAgIGR1cmF0aW9uOiAzMDBcbiAgICB9KTtcbiAgICB0aGlzLnN0dWRpb1N0YXRlXy5kZXNlbGVjdEl0ZW0odGhpcy5zdHVkaW9TdGF0ZV8uYWN0aXZlQW5pbWF0aW9uKTtcbiAgICB0aGlzLnN0dWRpb1N0YXRlXy5hbmltYXRpb25zLnB1c2gobmV3QW5pbSk7XG4gICAgdGhpcy5zdHVkaW9TdGF0ZV8uYWN0aXZlQW5pbWF0aW9uID0gbmV3QW5pbTtcbiAgICB0aGlzLnN0dWRpb1N0YXRlXy5hbmltQ2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdHMgdGhlIGdpdmVuIGFuaW1hdGlvbiwgZm9yIGluc3BlY3Rpb24gdy8gdGhlIHByb3BlcnR5IGluc3BlY3Rvci5cbiAgICovXG4gIG9uQW5pbWF0aW9uSGVhZGVyQ2xpY2soJGV2ZW50LCBhbmltKSB7XG4gICAgdGhpcy5zdHVkaW9TdGF0ZV8uc2VsZWN0aW9uID0gW2FuaW1dO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgY2xpY2tzIG9uIGEgdGltZWxpbmUgYmxvY2sgKGVpdGhlciBzZWxlY3Rpbmcgb3IgZGVzZWxlY3RpbmcgaXQpLlxuICAgKi9cbiAgb25UaW1lbGluZUJsb2NrQ2xpY2soJGV2ZW50LCBibG9jaywgbGF5ZXIpIHtcbiAgICBpZiAodGhpcy5zdXBwcmVzc0NsaWNrXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICgkZXZlbnQubWV0YUtleSB8fCAkZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgIHRoaXMuc3R1ZGlvU3RhdGVfLnRvZ2dsZVNlbGVjdGVkKGJsb2NrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdHVkaW9TdGF0ZV8uc2VsZWN0aW9uID0gW2Jsb2NrXTtcbiAgICB9XG4gIH1cblxuICBkaXJ0eUNoZWNrXygpIHtcbiAgICBpZiAodGhpcy5zdHVkaW9TdGF0ZV8uZGlydHkgJiYgIXdpbmRvdy5jb25maXJtKFxuICAgICAgICBgWW91J3ZlIG1hZGUgY2hhbmdlcyBidXQgaGF2ZW4ndCBzYXZlZC4gQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGNvbnRpbnVlP2ApKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBjcmVhdGluZyBhIG5ldyBmaWxlXG4gICAqL1xuICBvbk5ld0ZpbGUoKSB7XG4gICAgaWYgKHRoaXMuZGlydHlDaGVja18oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGdhKCdzZW5kJywgJ2V2ZW50JywgJ2ZpbGUnLCAnbmV3RmlsZScpO1xuICAgIHRoaXMuc3R1ZGlvU3RhdGVfLm5ldygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgb3BlbmluZyBhIGZpbGUgdXNpbmcgYSBmaWxlIG9wZW4gZGlhbG9nXG4gICAqL1xuICBvbk9wZW5GaWxlKGZpbGVJbmZvKSB7XG4gICAgaWYgKHRoaXMuZGlydHlDaGVja18oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGdhKCdzZW5kJywgJ2V2ZW50JywgJ2ZpbGUnLCAnb3BlbkZpbGUnKTtcbiAgICBsZXQganNvbk9iaiA9IEpTT04ucGFyc2UoZmlsZUluZm8udGV4dENvbnRlbnQpO1xuICAgIHRoaXMuc3R1ZGlvU3RhdGVfLmxvYWQoe1xuICAgICAgYXJ0d29yazogbmV3IEFydHdvcmsoanNvbk9iai5hcnR3b3JrKSxcbiAgICAgIGFuaW1hdGlvbnM6IGpzb25PYmouYW5pbWF0aW9ucy5tYXAoYW5pbSA9PiBuZXcgQW5pbWF0aW9uKGFuaW0pKVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgZXhwb3J0IHRvIEpTT04gZm9ybWF0LlxuICAgKi9cbiAgb25TYXZlRmlsZSgpIHtcbiAgICBnYSgnc2VuZCcsICdldmVudCcsICdmaWxlJywgJ3NhdmVGaWxlJyk7XG4gICAgdGhpcy5zdHVkaW9TdGF0ZV8uc2F2ZVRvRmlsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgaW1wb3J0aW5nIGFuIFNWRyBhcyBsYXllcnMuXG4gICAqL1xuICBvbkFkZExheWVyc0Zyb21TVkcoZmlsZUluZm8pIHtcbiAgICBnYSgnc2VuZCcsICdldmVudCcsICdmaWxlJywgJ2ltcG9ydFNWRy5hZGRMYXllcnMnKTtcbiAgICBsZXQgYXJ0d29yayA9IFN2Z0xvYWRlci5sb2FkQXJ0d29ya0Zyb21TdmdTdHJpbmcoZmlsZUluZm8udGV4dENvbnRlbnQpO1xuICAgIHRoaXMuc3R1ZGlvU3RhdGVfLmFkZExheWVycyhhcnR3b3JrLmxheWVycyk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBpbXBvcnRpbmcgYW4gU1ZHIGFzIGxheWVycy5cbiAgICovXG4gIG9uTmV3RnJvbVNWRyhmaWxlSW5mbykge1xuICAgIGlmICh0aGlzLmRpcnR5Q2hlY2tfKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBnYSgnc2VuZCcsICdldmVudCcsICdmaWxlJywgJ2ltcG9ydFNWRy5uZXcnKTtcbiAgICBsZXQgYXJ0d29yayA9IFN2Z0xvYWRlci5sb2FkQXJ0d29ya0Zyb21TdmdTdHJpbmcoZmlsZUluZm8udGV4dENvbnRlbnQpO1xuICAgIHRoaXMuc3R1ZGlvU3RhdGVfLmxvYWQoe2FydHdvcmt9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGltcG9ydGluZyBhIHZlY3RvciBkcmF3YWJsZSBmcm9tIFhNTC5cbiAgICovXG4gIG9uTmV3RnJvbVZEKGZpbGVJbmZvKSB7XG4gICAgaWYgKHRoaXMuZGlydHlDaGVja18oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGdhKCdzZW5kJywgJ2V2ZW50JywgJ2ZpbGUnLCAnaW1wb3J0VkQubmV3Jyk7XG4gICAgbGV0IGFydHdvcmsgPSBWZWN0b3JEcmF3YWJsZUxvYWRlci5sb2FkQXJ0d29ya0Zyb21YbWxTdHJpbmcoZmlsZUluZm8udGV4dENvbnRlbnQpO1xuICAgIHRoaXMuc3R1ZGlvU3RhdGVfLmxvYWQoe2FydHdvcmt9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGV4cG9ydCB0byBhbmltYXRlZCB2ZWN0b3IgZHJhd2FibGUgZm9ybWF0LlxuICAgKi9cbiAgb25FeHBvcnRBVkRzKCkge1xuICAgIGdhKCdzZW5kJywgJ2V2ZW50JywgJ2V4cG9ydCcsICdleHBvcnRWZWN0b3JBbmltYXRlZCcpO1xuICAgIHRoaXMuc3R1ZGlvU3RhdGVfLmV4cG9ydEFWRHMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGV4cG9ydCB0byB2ZWN0b3IgZHJhd2FibGUgZm9ybWF0LlxuICAgKi9cbiAgb25FeHBvcnRWZWN0b3JEcmF3YWJsZSgpIHtcbiAgICBnYSgnc2VuZCcsICdldmVudCcsICdleHBvcnQnLCAnZXhwb3J0VmVjdG9yU3RhdGljJyk7XG4gICAgdGhpcy5zdHVkaW9TdGF0ZV8uZXhwb3J0VmVjdG9yRHJhd2FibGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgdmFyaWV0eSBvZiBkcmFnIGJlaGF2aW9ycyBmb3IgdGltZWxpbmUgYmxvY2tzLCBpbmNsdWRpbmcgbW92ZW1lbnRcbiAgICogYW5kIHNjYWxpbmcuXG4gICAqL1xuICBvblRpbWVsaW5lQmxvY2tNb3VzZURvd24oZXZlbnQsIGRyYWdCbG9jaywgYW5pbWF0aW9uLCBsYXllcikge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIHByZXZlbnQgaHRtbDUgZHJhZ2dpbmdcbiAgICBsZXQgJHRhcmdldCA9ICQoZXZlbnQudGFyZ2V0KTtcblxuICAgIC8vIHNvbWUgZ2VvbWV0cnkgYW5kIGhpdC10ZXN0aW5nIGJhc2ljc1xuICAgIGxldCBhbmltUmVjdCA9ICQoZXZlbnQudGFyZ2V0KS5wYXJlbnRzKCcuc2x0LXByb3BlcnR5JykuZ2V0KDApLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCB4VG9UaW1lXyA9IHggPT4gKHggLSBhbmltUmVjdC5sZWZ0KSAvIGFuaW1SZWN0LndpZHRoICogYW5pbWF0aW9uLmR1cmF0aW9uO1xuICAgIGxldCBkb3duVGltZSA9IHhUb1RpbWVfKGV2ZW50LmNsaWVudFgpO1xuXG4gICAgLy8gZGV0ZXJtaW5lIHRoZSBhY3Rpb24gYmFzZWQgb24gd2hlcmUgdGhlIHVzZXIgY2xpY2tlZCBhbmQgdGhlIG1vZGlmaWVyIGtleXNcbiAgICBsZXQgYWN0aW9uID0gTW91c2VBY3Rpb25zLk1PVklORztcbiAgICBpZiAoJHRhcmdldC5oYXNDbGFzcygnc2x0LXRpbWVsaW5lLWJsb2NrLWVkZ2UtZW5kJykpIHtcbiAgICAgIGFjdGlvbiA9IGV2ZW50LmFsdEtleVxuICAgICAgICAgID8gTW91c2VBY3Rpb25zLlNDQUxJTkdfVE9HRVRIRVJfRU5EXG4gICAgICAgICAgOiBNb3VzZUFjdGlvbnMuU0NBTElOR19VTklGT1JNX0VORDtcbiAgICB9IGVsc2UgaWYgKCR0YXJnZXQuaGFzQ2xhc3MoJ3NsdC10aW1lbGluZS1ibG9jay1lZGdlLXN0YXJ0JykpIHtcbiAgICAgIGFjdGlvbiA9IGV2ZW50LmFsdEtleVxuICAgICAgICAgID8gTW91c2VBY3Rpb25zLlNDQUxJTkdfVE9HRVRIRVJfU1RBUlRcbiAgICAgICAgICA6IE1vdXNlQWN0aW9ucy5TQ0FMSU5HX1VOSUZPUk1fU1RBUlQ7XG4gICAgfVxuXG4gICAgLy8gc3RhcnQgdXAgYSBjYWNoZSBvZiBpbmZvIGZvciBlYWNoIHNlbGVjdGVkIGJsb2NrLCBjYWxjdWxhdGluZyB0aGUgbGVmdC0gYW5kIHJpZ2h0LVxuICAgIC8vIGJvdW5kcyBmb3IgZWFjaCBzZWxlY3RlZCBibG9jaywgYmFzZWQgb24gYWRqYWNlbnQgbm9uLWRyYWdnaW5nIGJsb2Nrc1xuICAgIGxldCBhY3RpdmVBbmltQmxvY2tzQnlMYXllcklkID0gTW9kZWxVdGlsLmdldE9yZGVyZWRBbmltYXRpb25CbG9ja3NCeUxheWVySWRBbmRQcm9wZXJ0eShcbiAgICAgICAgdGhpcy5zdHVkaW9TdGF0ZV8uYWN0aXZlQW5pbWF0aW9uKTtcbiAgICBsZXQgZHJhZ2dpbmdCbG9ja3MgPSAoZHJhZ0Jsb2NrLnNlbGVjdGVkX1xuICAgICAgICA/IHRoaXMuc3R1ZGlvU3RhdGVfLnNlbGVjdGVkQW5pbWF0aW9uQmxvY2tzXG4gICAgICAgIDogW2RyYWdCbG9ja10pOyAvLyBlaXRoZXIgZHJhZyBhbGwgc2VsZWN0ZWQgYmxvY2tzIG9yIGp1c3QgdGhlIG1vdXNlZG93bidkIGJsb2NrXG4gICAgbGV0IGJsb2NrSW5mb3MgPSBkcmFnZ2luZ0Jsb2Nrc1xuICAgICAgICAuZmlsdGVyKGJsb2NrID0+IGJsb2NrLnBhcmVudCA9PSB0aGlzLnN0dWRpb1N0YXRlXy5hY3RpdmVBbmltYXRpb24pXG4gICAgICAgIC5tYXAoYmxvY2sgPT4ge1xuICAgICAgICAgIC8vIGJ5IGRlZmF1bHQgdGhlIGJsb2NrIGlzIG9ubHkgYm91bmQgYnkgdGhlIGFuaW1hdGlvbiBkdXJhdGlvblxuICAgICAgICAgIGxldCBzdGFydEJvdW5kID0gMDtcbiAgICAgICAgICBsZXQgZW5kQm91bmQgPSBibG9jay5wYXJlbnQuZHVyYXRpb247XG5cbiAgICAgICAgICBsZXQgYmxvY2tOZWlnaGJvcnMgPSBhY3RpdmVBbmltQmxvY2tzQnlMYXllcklkW2Jsb2NrLmxheWVySWRdW2Jsb2NrLnByb3BlcnR5TmFtZV07XG4gICAgICAgICAgbGV0IGluZGV4SW50b05laWdoYm9ycyA9IGJsb2NrTmVpZ2hib3JzLmluZGV4T2YoYmxvY2spO1xuXG4gICAgICAgICAgLy8gZmluZCBzdGFydCB0aW1lIGJvdW5kXG4gICAgICAgICAgaWYgKGluZGV4SW50b05laWdoYm9ycyA+IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBpbmRleEludG9OZWlnaGJvcnMgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICBsZXQgbmVpZ2hib3IgPSBibG9ja05laWdoYm9yc1tpXTtcbiAgICAgICAgICAgICAgaWYgKCFkcmFnZ2luZ0Jsb2Nrcy5pbmNsdWRlcyhuZWlnaGJvcilcbiAgICAgICAgICAgICAgICAgIHx8IGFjdGlvbiA9PSBNb3VzZUFjdGlvbnMuU0NBTElOR19VTklGT1JNX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRCb3VuZCA9IG5laWdoYm9yLmVuZFRpbWU7IC8vIG9ubHkgYmUgYm91bmQgYnkgbmVpZ2hib3JzIG5vdCBiZWluZyBkcmFnZ2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4Y2VwdCB3aGVuIHVuaWZvcm1seSBjaGFuZ2luZyBqdXN0IHN0YXJ0IHRpbWVcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGZpbmQgZW5kIHRpbWUgYm91bmRcbiAgICAgICAgICBpZiAoaW5kZXhJbnRvTmVpZ2hib3JzIDwgYmxvY2tOZWlnaGJvcnMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGluZGV4SW50b05laWdoYm9ycyArIDE7IGkgPCBibG9ja05laWdoYm9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBsZXQgbmVpZ2hib3IgPSBibG9ja05laWdoYm9yc1tpXTtcbiAgICAgICAgICAgICAgaWYgKCFkcmFnZ2luZ0Jsb2Nrcy5pbmNsdWRlcyhuZWlnaGJvcilcbiAgICAgICAgICAgICAgICAgIHx8IGFjdGlvbiA9PSBNb3VzZUFjdGlvbnMuU0NBTElOR19VTklGT1JNX0VORCkge1xuICAgICAgICAgICAgICAgIGVuZEJvdW5kID0gbmVpZ2hib3Iuc3RhcnRUaW1lOyAvLyBvbmx5IGJlIGJvdW5kIGJ5IG5laWdoYm9ycyBub3QgYmVpbmcgZHJhZ2dlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBleGNlcHQgd2hlbiB1bmlmb3JtbHkgY2hhbmdpbmcganVzdCBlbmQgdGltZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtibG9jaywgc3RhcnRCb3VuZCwgZW5kQm91bmQsXG4gICAgICAgICAgICAgICAgICBkb3duU3RhcnRUaW1lOiBibG9jay5zdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgICBkb3duRW5kVGltZTogYmxvY2suZW5kVGltZX07XG4gICAgICAgIH0pO1xuXG4gICAgbGV0IGRyYWdCbG9ja0Rvd25TdGFydFRpbWUgPSBkcmFnQmxvY2suc3RhcnRUaW1lO1xuICAgIGxldCBkcmFnQmxvY2tEb3duRW5kVGltZSA9IGRyYWdCbG9jay5lbmRUaW1lO1xuXG4gICAgbGV0IG1pblN0YXJ0VGltZSwgbWF4RW5kVGltZTtcbiAgICBpZiAoYWN0aW9uID09IE1vdXNlQWN0aW9ucy5TQ0FMSU5HX1RPR0VUSEVSX0VORFxuICAgICAgICB8fCBhY3Rpb24gPT0gTW91c2VBY3Rpb25zLlNDQUxJTkdfVE9HRVRIRVJfU1RBUlQpIHtcbiAgICAgIG1pblN0YXJ0VGltZSA9IGJsb2NrSW5mb3MucmVkdWNlKFxuICAgICAgICAgICh0LCBpbmZvKSA9PiBNYXRoLm1pbih0LCBpbmZvLmJsb2NrLnN0YXJ0VGltZSksIEluZmluaXR5KTtcbiAgICAgIG1heEVuZFRpbWUgPSBibG9ja0luZm9zLnJlZHVjZShcbiAgICAgICAgICAodCwgaW5mbykgPT4gTWF0aC5tYXgodCwgaW5mby5ibG9jay5lbmRUaW1lKSwgMCk7XG4gICAgICBtYXhFbmRUaW1lID0gTWF0aC5tYXgobWF4RW5kVGltZSwgbWluU3RhcnRUaW1lICsgMTApOyAvLyBhdm9pZCBkaXZpZGUgYnkgemVyb1xuICAgIH1cblxuICAgIC8vIHNldCB1cCBkcmFnIGhhbmRsZXJzXG4gICAgbGV0IGRyYWdIZWxwZXIgPSBuZXcgRHJhZ0hlbHBlcih7XG4gICAgICBkb3duRXZlbnQ6IGV2ZW50LFxuICAgICAgZGlyZWN0aW9uOiAnaG9yaXpvbnRhbCcsXG4gICAgICBkcmFnZ2luZ0N1cnNvcjogKGFjdGlvbiA9PSBNb3VzZUFjdGlvbnMuTU9WSU5HKSA/ICdncmFiYmluZycgOiAnZXctcmVzaXplJyxcblxuICAgICAgb25CZWdpbkRyYWc6IGV2ZW50ID0+IHRoaXMuc2NvcGVfLiRhcHBseSgoKSA9PiB7XG4gICAgICAgIHRoaXMuc3VwcHJlc3NDbGlja18gPSB0cnVlO1xuICAgICAgICB0aGlzLnN1cHByZXNzUmVidWlsZFNuYXBUaW1lc18gPSB0cnVlO1xuICAgICAgfSksXG4gICAgICBvbkRyb3A6IGV2ZW50ID0+IHRoaXMudGltZW91dF8oKCkgPT4ge1xuICAgICAgICB0aGlzLnN1cHByZXNzQ2xpY2tfID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3VwcHJlc3NSZWJ1aWxkU25hcFRpbWVzXyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlYnVpbGRTbmFwVGltZXNfKCk7XG4gICAgICB9LCAwKSxcblxuICAgICAgb25EcmFnOiBldmVudCA9PiB0aGlzLnNjb3BlXy4kYXBwbHkoKCkgPT4ge1xuICAgICAgICBsZXQgdGltZURlbHRhID0gTWF0aC5yb3VuZCh4VG9UaW1lXyhldmVudC5jbGllbnRYKSAtIGRvd25UaW1lKTtcbiAgICAgICAgbGV0IGFsbG93U25hcCA9ICFldmVudC5hbHRLZXk7XG5cbiAgICAgICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgICAgICBjYXNlIE1vdXNlQWN0aW9ucy5NT1ZJTkc6IHtcbiAgICAgICAgICAgIGJsb2NrSW5mb3MuZm9yRWFjaChpbmZvID0+IHtcbiAgICAgICAgICAgICAgLy8gc25hcCB0aW1lZGVsdGFcbiAgICAgICAgICAgICAgaWYgKGFsbG93U25hcCAmJiBpbmZvLmJsb2NrID09IGRyYWdCbG9jaykge1xuICAgICAgICAgICAgICAgIGxldCBuZXdTdGFydFRpbWUgPSBpbmZvLmRvd25TdGFydFRpbWUgKyB0aW1lRGVsdGE7XG4gICAgICAgICAgICAgICAgbGV0IG5ld1N0YXJ0VGltZVNuYXBEZWx0YSA9IHRoaXMuc25hcFRpbWVfKGFuaW1hdGlvbiwgbmV3U3RhcnRUaW1lKSAtIG5ld1N0YXJ0VGltZTtcbiAgICAgICAgICAgICAgICBsZXQgbmV3RW5kVGltZSA9IGluZm8uZG93bkVuZFRpbWUgKyB0aW1lRGVsdGE7XG4gICAgICAgICAgICAgICAgbGV0IG5ld0VuZFRpbWVTbmFwRGVsdGEgPSB0aGlzLnNuYXBUaW1lXyhhbmltYXRpb24sIG5ld0VuZFRpbWUpIC0gbmV3RW5kVGltZTtcbiAgICAgICAgICAgICAgICBpZiAobmV3U3RhcnRUaW1lU25hcERlbHRhKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobmV3RW5kVGltZVNuYXBEZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aW1lRGVsdGEgKz0gTWF0aC5taW4obmV3U3RhcnRUaW1lU25hcERlbHRhLCBuZXdFbmRUaW1lU25hcERlbHRhKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVEZWx0YSArPSBuZXdTdGFydFRpbWVTbmFwRGVsdGE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXdFbmRUaW1lU25hcERlbHRhKSB7XG4gICAgICAgICAgICAgICAgICB0aW1lRGVsdGEgKz0gbmV3RW5kVGltZVNuYXBEZWx0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gY29uc3RyYWluIHRpbWVEZWx0YVxuICAgICAgICAgICAgICB0aW1lRGVsdGEgPSBNYXRoLm1pbih0aW1lRGVsdGEsIGluZm8uZW5kQm91bmQgLSBpbmZvLmRvd25FbmRUaW1lKTtcbiAgICAgICAgICAgICAgdGltZURlbHRhID0gTWF0aC5tYXgodGltZURlbHRhLCBpbmZvLnN0YXJ0Qm91bmQgLSBpbmZvLmRvd25TdGFydFRpbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBibG9ja0luZm9zLmZvckVhY2goaW5mbyA9PiB7XG4gICAgICAgICAgICAgIGxldCBibG9ja0R1cmF0aW9uICA9IChpbmZvLmJsb2NrLmVuZFRpbWUgLSBpbmZvLmJsb2NrLnN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgIGluZm8uYmxvY2suc3RhcnRUaW1lID0gaW5mby5kb3duU3RhcnRUaW1lICsgdGltZURlbHRhO1xuICAgICAgICAgICAgICBpbmZvLmJsb2NrLmVuZFRpbWUgPSBpbmZvLmJsb2NrLnN0YXJ0VGltZSArIGJsb2NrRHVyYXRpb247XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgTW91c2VBY3Rpb25zLlNDQUxJTkdfVU5JRk9STV9TVEFSVDoge1xuICAgICAgICAgICAgYmxvY2tJbmZvcy5mb3JFYWNoKGluZm8gPT4ge1xuICAgICAgICAgICAgICAvLyBzbmFwIHRpbWVkZWx0YVxuICAgICAgICAgICAgICBpZiAoYWxsb3dTbmFwICYmIGluZm8uYmxvY2sgPT0gZHJhZ0Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld1N0YXJ0VGltZSA9IGluZm8uZG93blN0YXJ0VGltZSArIHRpbWVEZWx0YTtcbiAgICAgICAgICAgICAgICBsZXQgbmV3U3RhcnRUaW1lU25hcERlbHRhID0gdGhpcy5zbmFwVGltZV8oYW5pbWF0aW9uLCBuZXdTdGFydFRpbWUpIC0gbmV3U3RhcnRUaW1lO1xuICAgICAgICAgICAgICAgIGlmIChuZXdTdGFydFRpbWVTbmFwRGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgIHRpbWVEZWx0YSArPSBuZXdTdGFydFRpbWVTbmFwRGVsdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGNvbnN0cmFpbiB0aW1lRGVsdGFcbiAgICAgICAgICAgICAgdGltZURlbHRhID0gTWF0aC5taW4odGltZURlbHRhLCAoaW5mby5ibG9jay5lbmRUaW1lIC0gTUlOX0JMT0NLX0RVUkFUSU9OKSAtIGluZm8uZG93blN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgIHRpbWVEZWx0YSA9IE1hdGgubWF4KHRpbWVEZWx0YSwgaW5mby5zdGFydEJvdW5kIC0gaW5mby5kb3duU3RhcnRUaW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYmxvY2tJbmZvcy5mb3JFYWNoKGluZm8gPT4gaW5mby5ibG9jay5zdGFydFRpbWUgPSBpbmZvLmRvd25TdGFydFRpbWUgKyB0aW1lRGVsdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBNb3VzZUFjdGlvbnMuU0NBTElOR19VTklGT1JNX0VORDoge1xuICAgICAgICAgICAgYmxvY2tJbmZvcy5mb3JFYWNoKGluZm8gPT4ge1xuICAgICAgICAgICAgICAvLyBzbmFwIHRpbWVkZWx0YVxuICAgICAgICAgICAgICBpZiAoYWxsb3dTbmFwICYmIGluZm8uYmxvY2sgPT0gZHJhZ0Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld0VuZFRpbWUgPSBpbmZvLmRvd25FbmRUaW1lICsgdGltZURlbHRhO1xuICAgICAgICAgICAgICAgIGxldCBuZXdFbmRUaW1lU25hcERlbHRhID0gdGhpcy5zbmFwVGltZV8oYW5pbWF0aW9uLCBuZXdFbmRUaW1lKSAtIG5ld0VuZFRpbWU7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0VuZFRpbWVTbmFwRGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgIHRpbWVEZWx0YSArPSBuZXdFbmRUaW1lU25hcERlbHRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBjb25zdHJhaW4gdGltZURlbHRhXG4gICAgICAgICAgICAgIHRpbWVEZWx0YSA9IE1hdGgubWluKHRpbWVEZWx0YSwgaW5mby5lbmRCb3VuZCAtIGluZm8uZG93bkVuZFRpbWUpO1xuICAgICAgICAgICAgICB0aW1lRGVsdGEgPSBNYXRoLm1heCh0aW1lRGVsdGEsIChpbmZvLmJsb2NrLnN0YXJ0VGltZSArIE1JTl9CTE9DS19EVVJBVElPTikgLSBpbmZvLmRvd25FbmRUaW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYmxvY2tJbmZvcy5mb3JFYWNoKGluZm8gPT4gaW5mby5ibG9jay5lbmRUaW1lID0gaW5mby5kb3duRW5kVGltZSArIHRpbWVEZWx0YSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIE1vdXNlQWN0aW9ucy5TQ0FMSU5HX1RPR0VUSEVSX1NUQVJUOiB7XG4gICAgICAgICAgICBsZXQgc2NhbGUgPSAoZHJhZ0Jsb2NrRG93blN0YXJ0VGltZSArIHRpbWVEZWx0YSAtIG1heEVuZFRpbWUpXG4gICAgICAgICAgICAgICAgLyAoZHJhZ0Jsb2NrRG93blN0YXJ0VGltZSAtIG1heEVuZFRpbWUpO1xuICAgICAgICAgICAgc2NhbGUgPSBNYXRoLm1pbihzY2FsZSwgbWF4RW5kVGltZSAvIChtYXhFbmRUaW1lIC0gbWluU3RhcnRUaW1lKSk7XG4gICAgICAgICAgICBsZXQgY2FuY2VsID0gZmFsc2U7XG4gICAgICAgICAgICBibG9ja0luZm9zLmZvckVhY2goaW5mbyA9PiB7XG4gICAgICAgICAgICAgIGluZm8ubmV3U3RhcnRUaW1lID0gbWF4RW5kVGltZSAtIChtYXhFbmRUaW1lIC0gaW5mby5kb3duU3RhcnRUaW1lKSAqIHNjYWxlO1xuICAgICAgICAgICAgICBpbmZvLm5ld0VuZFRpbWUgPSBNYXRoLm1heChcbiAgICAgICAgICAgICAgICAgIG1heEVuZFRpbWUgLSAobWF4RW5kVGltZSAtIGluZm8uZG93bkVuZFRpbWUpICogc2NhbGUsXG4gICAgICAgICAgICAgICAgICBpbmZvLm5ld1N0YXJ0VGltZSArIE1JTl9CTE9DS19EVVJBVElPTik7XG4gICAgICAgICAgICAgIGlmIChpbmZvLm5ld1N0YXJ0VGltZSA8IGluZm8uc3RhcnRCb3VuZCB8fCBpbmZvLm5ld0VuZFRpbWUgPiBpbmZvLmVuZEJvdW5kKSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWNhbmNlbCkge1xuICAgICAgICAgICAgICBibG9ja0luZm9zLmZvckVhY2goaW5mbyA9PiB7XG4gICAgICAgICAgICAgICAgaW5mby5ibG9jay5zdGFydFRpbWUgPSBpbmZvLm5ld1N0YXJ0VGltZTtcbiAgICAgICAgICAgICAgICBpbmZvLmJsb2NrLmVuZFRpbWUgPSBpbmZvLm5ld0VuZFRpbWU7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBNb3VzZUFjdGlvbnMuU0NBTElOR19UT0dFVEhFUl9FTkQ6IHtcbiAgICAgICAgICAgIGxldCBzY2FsZSA9IChkcmFnQmxvY2tEb3duRW5kVGltZSArIHRpbWVEZWx0YSAtIG1pblN0YXJ0VGltZSlcbiAgICAgICAgICAgICAgICAvIChkcmFnQmxvY2tEb3duRW5kVGltZSAtIG1pblN0YXJ0VGltZSk7XG4gICAgICAgICAgICBzY2FsZSA9IE1hdGgubWluKHNjYWxlLCAoYW5pbWF0aW9uLmR1cmF0aW9uIC0gbWluU3RhcnRUaW1lKSAvIChtYXhFbmRUaW1lIC0gbWluU3RhcnRUaW1lKSk7XG4gICAgICAgICAgICBsZXQgY2FuY2VsID0gZmFsc2U7XG4gICAgICAgICAgICBibG9ja0luZm9zLmZvckVhY2goaW5mbyA9PiB7XG4gICAgICAgICAgICAgIGluZm8ubmV3U3RhcnRUaW1lID0gbWluU3RhcnRUaW1lICsgKGluZm8uZG93blN0YXJ0VGltZSAtIG1pblN0YXJ0VGltZSkgKiBzY2FsZTtcbiAgICAgICAgICAgICAgaW5mby5uZXdFbmRUaW1lID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgICBtaW5TdGFydFRpbWUgKyAoaW5mby5kb3duRW5kVGltZSAtIG1pblN0YXJ0VGltZSkgKiBzY2FsZSxcbiAgICAgICAgICAgICAgICAgIGluZm8ubmV3U3RhcnRUaW1lICsgTUlOX0JMT0NLX0RVUkFUSU9OKTtcbiAgICAgICAgICAgICAgaWYgKGluZm8ubmV3U3RhcnRUaW1lIDwgaW5mby5zdGFydEJvdW5kIHx8IGluZm8ubmV3RW5kVGltZSA+IGluZm8uZW5kQm91bmQpIHtcbiAgICAgICAgICAgICAgICBjYW5jZWwgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghY2FuY2VsKSB7XG4gICAgICAgICAgICAgIGJsb2NrSW5mb3MuZm9yRWFjaChpbmZvID0+IHtcbiAgICAgICAgICAgICAgICBpbmZvLmJsb2NrLnN0YXJ0VGltZSA9IGluZm8ubmV3U3RhcnRUaW1lO1xuICAgICAgICAgICAgICAgIGluZm8uYmxvY2suZW5kVGltZSA9IGluZm8ubmV3RW5kVGltZTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0dWRpb1N0YXRlXy5hbmltQ2hhbmdlZCgpO1xuICAgICAgfSksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBkcmFnIGFuZCBkcm9wIGZvciBsYXllcnMsIGFsbG93aW5nIHJlLW9yZGVyaW5nIGFuZCByZS1wYXJlbnRpbmcgbGF5ZXJzIGluXG4gICAqIHRoZSBhcnR3b3JrLlxuICAgKi9cbiAgb25MYXllck1vdXNlRG93bihldmVudCwgZHJhZ0xheWVyKSB7XG4gICAgbGV0ICRsYXllcnNMaXN0ID0gJChldmVudC50YXJnZXQpLnBhcmVudHMoJy5zbHQtbGF5ZXJzLWxpc3QnKTtcbiAgICBsZXQgJHNjcm9sbGVyID0gJChldmVudC50YXJnZXQpLnBhcmVudHMoJy5zbHQtbGF5ZXJzLWxpc3Qtc2Nyb2xsZXInKTtcblxuICAgIGxldCBvcmRlcmVkTGF5ZXJJbmZvcyA9IFtdO1xuICAgIGxldCAkZHJhZ0luZGljYXRvcjtcbiAgICBsZXQgc2Nyb2xsZXJSZWN0O1xuXG4gICAgbGV0IHRhcmdldExheWVySW5mbyA9IG51bGw7XG4gICAgbGV0IHRhcmdldEVkZ2U7XG5cbiAgICBsZXQgRURHRVMgPSB7dG9wOnRydWUsIGJvdHRvbTp0cnVlfTtcblxuICAgIGxldCBkcmFnSGVscGVyID0gbmV3IERyYWdIZWxwZXIoe1xuICAgICAgZG93bkV2ZW50OiBldmVudCxcbiAgICAgIGRpcmVjdGlvbjogJ2JvdGgnLFxuXG4gICAgICBvbkJlZ2luRHJhZzogKCkgPT4ge1xuICAgICAgICB0aGlzLnN1cHByZXNzQ2xpY2tfID0gdHJ1ZTtcblxuICAgICAgICAvLyBidWlsZCB1cCBhIGxpc3Qgb2YgYWxsIGxheWVycyBvcmRlcmVkIGJ5IFkgcG9zaXRpb25cbiAgICAgICAgb3JkZXJlZExheWVySW5mb3MgPSBbXTtcbiAgICAgICAgc2Nyb2xsZXJSZWN0ID0gJHNjcm9sbGVyLmdldCgwKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IHNjcm9sbFRvcCA9ICRzY3JvbGxlci5zY3JvbGxUb3AoKTtcbiAgICAgICAgJGxheWVyc0xpc3QuZmluZCgnLnNsdC1sYXllci1jb250YWluZXInKS5lYWNoKChpLCBlbGVtZW50KSA9PiB7XG4gICAgICAgICAgaWYgKCEkKGVsZW1lbnQpLmRhdGEoJ2xheWVyLWlkJykpIHtcbiAgICAgICAgICAgIC8vIHRoZSBhcnR3b3JrIHJvb3QgbGF5ZXIgZG9lc24ndCBoYXZlIGFuIElEIHNldFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICByZWN0ID0ge1xuICAgICAgICAgICAgbGVmdDogcmVjdC5sZWZ0LFxuICAgICAgICAgICAgdG9wOiByZWN0LnRvcCArIHNjcm9sbFRvcCAtIHNjcm9sbGVyUmVjdC50b3AsXG4gICAgICAgICAgICBib3R0b206IHJlY3QuYm90dG9tICsgc2Nyb2xsVG9wIC0gc2Nyb2xsZXJSZWN0LnRvcFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBsZXQgbGF5ZXIgPSB0aGlzLnN0dWRpb1N0YXRlXy5hcnR3b3JrLmZpbmRMYXllckJ5SWQoJChlbGVtZW50KS5kYXRhKCdsYXllci1pZCcpKTtcbiAgICAgICAgICBvcmRlcmVkTGF5ZXJJbmZvcy5wdXNoKHtcbiAgICAgICAgICAgIGxheWVyLFxuICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgIGxvY2FsUmVjdDogcmVjdCxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIGFkZCBhIGZha2UgdGFyZ2V0IGZvciBlbXB0eSBncm91cHNcbiAgICAgICAgICBpZiAobGF5ZXIgaW5zdGFuY2VvZiBMYXllckdyb3VwICYmICFsYXllci5sYXllcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZWN0ID0gT2JqZWN0LmFzc2lnbih7fSwgcmVjdCwge2xlZnQ6IHJlY3QubGVmdCArIExBWUVSX0lOREVOVCwgdG9wOiByZWN0LmJvdHRvbX0pO1xuICAgICAgICAgICAgb3JkZXJlZExheWVySW5mb3MucHVzaCh7XG4gICAgICAgICAgICAgIGxheWVyLFxuICAgICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgICBsb2NhbFJlY3Q6IHJlY3QsXG4gICAgICAgICAgICAgIG1vdmVJbnRvRW1wdHlMYXllckdyb3VwOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBvcmRlcmVkTGF5ZXJJbmZvcy5zb3J0KChhLCBiKSA9PiBhLmxvY2FsUmVjdC50b3AgLSBiLmxvY2FsUmVjdC50b3ApO1xuXG4gICAgICAgICRkcmFnSW5kaWNhdG9yID0gJCgnPGRpdj4nKVxuICAgICAgICAgICAgLmFkZENsYXNzKCdzbHQtbGF5ZXJzLWxpc3QtZHJhZy1pbmRpY2F0b3InKVxuICAgICAgICAgICAgLmFwcGVuZFRvKCRzY3JvbGxlcik7XG4gICAgICB9LFxuXG4gICAgICBvbkRyYWc6IGV2ZW50ID0+IHtcbiAgICAgICAgbGV0IGxvY2FsRXZlbnRZID0gZXZlbnQuY2xpZW50WSAtIHNjcm9sbGVyUmVjdC50b3AgKyAkc2Nyb2xsZXIuc2Nyb2xsVG9wKCk7XG5cbiAgICAgICAgLy8gZmluZCB0aGUgdGFyZ2V0IGxheWVyIGFuZCBlZGdlICh0b3Agb3IgYm90dG9tKVxuICAgICAgICB0YXJnZXRMYXllckluZm8gPSBudWxsO1xuICAgICAgICBsZXQgbWluRGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICAgICAgbGV0IG1pbkRpc3RhbmNlSW5kZW50ID0gSW5maW5pdHk7IC8vIHRpZSBicmVhayB0byBtb3N0IGluZGVudGVkIGxheWVyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JkZXJlZExheWVySW5mb3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgbGF5ZXJJbmZvID0gb3JkZXJlZExheWVySW5mb3NbaV07XG5cbiAgICAgICAgICAvLyBza2lwIGlmIG1vdXNlIHRvIHRoZSBsZWZ0IG9mIHRoaXMgbGF5ZXJcbiAgICAgICAgICBpZiAoZXZlbnQuY2xpZW50WCA8IGxheWVySW5mby5sb2NhbFJlY3QubGVmdCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChsZXQgZWRnZSBpbiBFREdFUykge1xuICAgICAgICAgICAgLy8gdGVzdCBkaXN0YW5jZSB0byB0b3AgZWRnZVxuICAgICAgICAgICAgbGV0IGRpc3RhbmNlID0gTWF0aC5hYnMobG9jYWxFdmVudFkgLSBsYXllckluZm8ubG9jYWxSZWN0W2VkZ2VdKTtcbiAgICAgICAgICAgIGxldCBpbmRlbnQgPSBsYXllckluZm8ubG9jYWxSZWN0LmxlZnQ7XG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPD0gbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlICE9IG1pbkRpc3RhbmNlIHx8IGluZGVudCA+IG1pbkRpc3RhbmNlSW5kZW50KSB7XG4gICAgICAgICAgICAgICAgbWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBtaW5EaXN0YW5jZUluZGVudCA9IGluZGVudDtcbiAgICAgICAgICAgICAgICB0YXJnZXRMYXllckluZm8gPSBsYXllckluZm87XG4gICAgICAgICAgICAgICAgdGFyZ2V0RWRnZSA9IGVkZ2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkaXNhbGxvdyBkcmFnZ2luZyBhIGxheWVyIGludG8gaXRzZWxmIG9yIGl0cyBjaGlsZHJlblxuICAgICAgICBpZiAodGFyZ2V0TGF5ZXJJbmZvKSB7XG4gICAgICAgICAgbGV0IGxheWVyID0gdGFyZ2V0TGF5ZXJJbmZvLmxheWVyO1xuICAgICAgICAgIHdoaWxlIChsYXllcikge1xuICAgICAgICAgICAgaWYgKGxheWVyID09IGRyYWdMYXllcikge1xuICAgICAgICAgICAgICB0YXJnZXRMYXllckluZm8gPSBudWxsO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGF5ZXIgPSBsYXllci5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhcmdldExheWVySW5mbyAmJiB0YXJnZXRFZGdlID09ICdib3R0b20nXG4gICAgICAgICAgICAgICYmIHRhcmdldExheWVySW5mby5sYXllci5uZXh0U2libGluZyA9PSBkcmFnTGF5ZXIpIHtcbiAgICAgICAgICB0YXJnZXRMYXllckluZm8gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhcmdldExheWVySW5mbykge1xuICAgICAgICAgICRkcmFnSW5kaWNhdG9yLmNzcygnbGVmdCcsIHRhcmdldExheWVySW5mby5sb2NhbFJlY3QubGVmdCk7XG4gICAgICAgICAgJGRyYWdJbmRpY2F0b3IuY3NzKCd0b3AnLCB0YXJnZXRMYXllckluZm8ubG9jYWxSZWN0W3RhcmdldEVkZ2VdKTtcbiAgICAgICAgfVxuXG4gICAgICAgICRkcmFnSW5kaWNhdG9yLnRvZ2dsZSghIXRhcmdldExheWVySW5mbyk7XG4gICAgICB9LFxuXG4gICAgICBvbkRyb3A6IGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKCRkcmFnSW5kaWNhdG9yKSB7XG4gICAgICAgICAgJGRyYWdJbmRpY2F0b3IucmVtb3ZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFyZ2V0TGF5ZXJJbmZvKSB7XG4gICAgICAgICAgdGhpcy5zY29wZV8uJGFwcGx5KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0YXJnZXRMYXllckluZm8ubW92ZUludG9FbXB0eUxheWVyR3JvdXApIHtcbiAgICAgICAgICAgICAgLy8gbW92aW5nIGludG8gYW4gZW1wdHkgbGF5ZXIgZ3JvdXBcbiAgICAgICAgICAgICAgbGV0IG5ld1BhcmVudCA9IHRhcmdldExheWVySW5mby5sYXllcjtcbiAgICAgICAgICAgICAgZHJhZ0xheWVyLnJlbW92ZSgpO1xuICAgICAgICAgICAgICBuZXdQYXJlbnQubGF5ZXJzLnB1c2goZHJhZ0xheWVyKTtcbiAgICAgICAgICAgICAgZHJhZ0xheWVyLnBhcmVudCA9IG5ld1BhcmVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIG1vdmluZyBuZXh0IHRvIGFub3RoZXIgbGF5ZXJcbiAgICAgICAgICAgICAgbGV0IG5ld1BhcmVudCA9IHRhcmdldExheWVySW5mby5sYXllci5wYXJlbnQ7XG4gICAgICAgICAgICAgIGlmIChuZXdQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBkcmFnTGF5ZXIucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gbmV3UGFyZW50LmxheWVycy5pbmRleE9mKHRhcmdldExheWVySW5mby5sYXllcik7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgIGluZGV4ICs9ICh0YXJnZXRFZGdlID09ICd0b3AnKSA/IDAgOiAxO1xuICAgICAgICAgICAgICAgICAgbmV3UGFyZW50LmxheWVycy5zcGxpY2UoaW5kZXgsIDAsIGRyYWdMYXllcik7XG4gICAgICAgICAgICAgICAgICBkcmFnTGF5ZXIucGFyZW50ID0gbmV3UGFyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnN0dWRpb1N0YXRlXy5hcnR3b3JrQ2hhbmdlZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50aW1lb3V0XygoKSA9PiB0aGlzLnN1cHByZXNzQ2xpY2tfID0gZmFsc2UsIDApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cblxuYW5ndWxhci5tb2R1bGUoJ0FWRFN0dWRpbycpLmRpcmVjdGl2ZSgnc3R1ZGlvTGF5ZXJUaW1lbGluZScsICgpID0+IHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0UnLFxuICAgIHNjb3BlOiB7fSxcbiAgICB0ZW1wbGF0ZVVybDogJ2NvbXBvbmVudHMvbGF5ZXJ0aW1lbGluZS9sYXllcnRpbWVsaW5lLmh0bWwnLFxuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgYmluZFRvQ29udHJvbGxlcjogdHJ1ZSxcbiAgICBjb250cm9sbGVyOiBMYXllclRpbWVsaW5lQ29udHJvbGxlcixcbiAgICBjb250cm9sbGVyQXM6ICdjdHJsJ1xuICB9O1xufSk7XG5cblxuLy8gdGltZWxpbmUgZ3JpZFxuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7TWF0aFV0aWx9IGZyb20gJ01hdGhVdGlsJztcbmltcG9ydCB7RHJhZ0hlbHBlcn0gZnJvbSAnRHJhZ0hlbHBlcic7XG5cbmltcG9ydCB7VGltZWxpbmVDb25zdHN9IGZyb20gJy4vY29uc3RzJztcblxuXG5jb25zdCBHUklEX0lOVEVSVkFMU19NUyA9IFtcbiAgICAxMCwgMjUsIDUwLCAxMDAsIDI1MCwgNTAwLFxuICAgIDEwMDAsIDI1MDAsIDUwMDAsIDEwMDAwLCAzMDAwMCwgNjAwMDBcbiAgICBdO1xuXG5cbmFuZ3VsYXIubW9kdWxlKCdBVkRTdHVkaW8nKS5kaXJlY3RpdmUoJ3N0dWRpb1RpbWVsaW5lR3JpZCcsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnRScsXG4gICAgc2NvcGU6IHtcbiAgICAgIGlzQWN0aXZlOiAnPScsXG4gICAgICBhY3RpdmVUaW1lOiAnPScsXG4gICAgICBhbmltYXRpb246ICc9JyxcbiAgICAgIG9uU2NydWI6ICcmJ1xuICAgIH0sXG4gICAgdGVtcGxhdGU6ICc8Y2FudmFzPjwvY2FudmFzPicsXG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICByZXF1aXJlOiAnXnN0dWRpb0xheWVyVGltZWxpbmUnLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgbGF5ZXJUaW1lbGluZUN0cmwpIHtcbiAgICAgIGxldCAkY2FudmFzID0gZWxlbWVudDtcbiAgICAgIGxldCBjYW52YXMgPSAkY2FudmFzLmdldCgwKTtcblxuICAgICAgbGV0IGlzSGVhZGVyID0gJ2lzSGVhZGVyJyBpbiBhdHRycztcblxuICAgICAgc2NvcGUuJHdhdGNoKCgpID0+IHNjb3BlLnJlZHJhd18oKSk7XG5cbiAgICAgIGlmICgnb25TY3J1YicgaW4gYXR0cnMpIHtcbiAgICAgICAgbGV0IGhhbmRsZVNjcnViRXZlbnRfID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgbGV0IHggPSBldmVudC5jbGllbnRYO1xuICAgICAgICAgIHggLT0gJGNhbnZhcy5vZmZzZXQoKS5sZWZ0O1xuICAgICAgICAgIGxldCB0aW1lID0gKHggLSBUaW1lbGluZUNvbnN0cy5USU1FTElORV9BTklNQVRJT05fUEFERElORylcbiAgICAgICAgICAgICAgLyAoJGNhbnZhcy53aWR0aCgpIC0gVGltZWxpbmVDb25zdHMuVElNRUxJTkVfQU5JTUFUSU9OX1BBRERJTkcgKiAyKVxuICAgICAgICAgICAgICAqIHNjb3BlLmFuaW1hdGlvbi5kdXJhdGlvbjtcbiAgICAgICAgICB0aW1lID0gTWF0aFV0aWwuY29uc3RyYWluKHRpbWUsIDAsIHNjb3BlLmFuaW1hdGlvbi5kdXJhdGlvbik7XG4gICAgICAgICAgc2NvcGUub25TY3J1Yih7XG4gICAgICAgICAgICBhbmltYXRpb246IHNjb3BlLmFuaW1hdGlvbixcbiAgICAgICAgICAgIHRpbWUsXG4gICAgICAgICAgICBvcHRpb25zOiB7ZGlzYWJsZVNuYXA6ICEhZXZlbnQuYWx0S2V5fVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgICRjYW52YXMub24oJ21vdXNlZG93bicsIGV2ZW50ID0+IHNjb3BlLiRhcHBseSgoKSA9PiB7XG4gICAgICAgICAgaGFuZGxlU2NydWJFdmVudF8oZXZlbnQpO1xuICAgICAgICAgIG5ldyBEcmFnSGVscGVyKHtcbiAgICAgICAgICAgIGRvd25FdmVudDogZXZlbnQsXG4gICAgICAgICAgICBkaXJlY3Rpb246ICdob3Jpem9udGFsJyxcbiAgICAgICAgICAgIHNraXBTbG9wQ2hlY2s6IHRydWUsXG4gICAgICAgICAgICBvbkRyYWc6IGV2ZW50ID0+IHNjb3BlLiRhcHBseSgoKSA9PiBoYW5kbGVTY3J1YkV2ZW50XyhldmVudCkpLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIHNjb3BlLnJlZHJhd18gPSAoKSA9PiB7XG4gICAgICAgIGlmICghJGNhbnZhcy5pcygnOnZpc2libGUnKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB3aWR0aCA9ICRjYW52YXMud2lkdGgoKTtcbiAgICAgICAgbGV0IGhlaWdodCA9ICRjYW52YXMuaGVpZ2h0KCk7XG4gICAgICAgIGxldCBob3Jpelpvb20gPSBsYXllclRpbWVsaW5lQ3RybC5ob3Jpelpvb207XG4gICAgICAgICRjYW52YXMuYXR0cignd2lkdGgnLCB3aWR0aCAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICAgICAgJGNhbnZhcy5hdHRyKCdoZWlnaHQnLCBpc0hlYWRlciA/IGhlaWdodCAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDogMSk7XG5cbiAgICAgICAgbGV0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBjdHguc2NhbGUod2luZG93LmRldmljZVBpeGVsUmF0aW8sIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZShUaW1lbGluZUNvbnN0cy5USU1FTElORV9BTklNQVRJT05fUEFERElORywgMCk7XG5cbiAgICAgICAgLy8gY29tcHV0ZSBncmlkIHNwYWNpbmcgKDQwID0gbWluaW11bSBncmlkIHNwYWNpbmcgaW4gcGl4ZWxzKVxuICAgICAgICBsZXQgaW50ZXJ2YWwgPSAwO1xuICAgICAgICBsZXQgc3BhY2luZ01zID0gR1JJRF9JTlRFUlZBTFNfTVNbaW50ZXJ2YWxdO1xuICAgICAgICB3aGlsZSAoKHNwYWNpbmdNcyAqIGhvcml6Wm9vbSkgPCA0MCB8fCBpbnRlcnZhbCA+PSBHUklEX0lOVEVSVkFMU19NUy5sZW5ndGgpIHtcbiAgICAgICAgICArK2ludGVydmFsO1xuICAgICAgICAgIHNwYWNpbmdNcyA9IEdSSURfSU5URVJWQUxTX01TW2ludGVydmFsXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzcGFjaW5nUHggPSBzcGFjaW5nTXMgKiBob3Jpelpvb207XG5cbiAgICAgICAgaWYgKGlzSGVhZGVyKSB7XG4gICAgICAgICAgLy8gdGV4dCBsYWJlbHNcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwwLDAsMC40KSc7XG4gICAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgICBjdHguZm9udCA9ICcxMHB4IFJvYm90byc7XG4gICAgICAgICAgZm9yIChsZXQgeCA9IDAsIHQgPSAwOyB4IDw9IHdpZHRoOyB4ICs9IHNwYWNpbmdQeCwgdCArPSBzcGFjaW5nTXMpIHtcbiAgICAgICAgICAgIC8vY3R4LmZpbGxSZWN0KHggLSAwLjUsIDAsIDEsIGhlaWdodCk7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQoYCR7dCAvIDEwMDB9c2AsIHgsIGhlaWdodCAvIDIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzY29wZS5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDI0NCwgNjcsIDU0LCAuNyknO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmFyYyhzY29wZS5hY3RpdmVUaW1lICogaG9yaXpab29tLCBoZWlnaHQgLyAyLCA0LCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdChzY29wZS5hY3RpdmVUaW1lICogaG9yaXpab29tIC0gMSwgaGVpZ2h0IC8gMiArIDQsIDIsIGhlaWdodCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZ3JpZCBsaW5lc1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAncmdiYSgwLDAsMCwwLjEpJztcbiAgICAgICAgICBmb3IgKGxldCB4ID0gc3BhY2luZ1B4O1xuICAgICAgICAgICAgICAgeCA8IHdpZHRoIC0gVGltZWxpbmVDb25zdHMuVElNRUxJTkVfQU5JTUFUSU9OX1BBRERJTkcgKiAyO1xuICAgICAgICAgICAgICAgeCArPSBzcGFjaW5nUHgpIHtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCh4IC0gMC41LCAwLCAxLCAxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2NvcGUuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAncmdiYSgyNDQsIDY3LCA1NCwgLjcpJztcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdChzY29wZS5hY3RpdmVUaW1lICogaG9yaXpab29tIC0gMSwgMCwgMiwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNjb3BlLnJlZHJhd18oKTtcbiAgICB9XG4gIH07XG59KTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge0FydHdvcmssIEFuaW1hdGlvbn0gZnJvbSAnbW9kZWwnO1xuaW1wb3J0IHtQcm9wZXJ0eSwgU3R1YlByb3BlcnR5LCBGcmFjdGlvblByb3BlcnR5LCBJZFByb3BlcnR5LCBFbnVtUHJvcGVydHl9IGZyb20gJ21vZGVsL3Byb3BlcnRpZXMnO1xuaW1wb3J0IHtDb2xvclV0aWx9IGZyb20gJ0NvbG9yVXRpbCc7XG5pbXBvcnQge01vZGVsVXRpbH0gZnJvbSAnTW9kZWxVdGlsJztcblxuXG5jbGFzcyBQcm9wZXJ0eUluc3BlY3RvckNvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3Rvcigkc2NvcGUsICRlbGVtZW50LCBTdHVkaW9TdGF0ZVNlcnZpY2UpIHtcbiAgICB0aGlzLnNjb3BlXyA9ICRzY29wZTtcbiAgICB0aGlzLmVsZW1lbnRfID0gJGVsZW1lbnQ7XG5cbiAgICB0aGlzLnN0dWRpb1N0YXRlXyA9IFN0dWRpb1N0YXRlU2VydmljZTtcbiAgICB0aGlzLnN0dWRpb1N0YXRlXy5vbkNoYW5nZSgoZXZlbnQsIGNoYW5nZXMpID0+IHtcbiAgICAgIGlmIChjaGFuZ2VzLnNlbGVjdGlvbikge1xuICAgICAgICB0aGlzLnJlYnVpbGRTZWxlY3Rpb25fKCk7XG4gICAgICB9XG4gICAgfSwgJHNjb3BlKTtcblxuICAgIHRoaXMucmVidWlsZFNlbGVjdGlvbl8oKTtcbiAgfVxuXG4gIHJlYnVpbGRTZWxlY3Rpb25fKCkge1xuICAgIHRoaXMuc2VsZWN0aW9uSW5mbyA9IG51bGw7XG4gICAgaWYgKHRoaXMuc3R1ZGlvU3RhdGVfLnNlbGVjdGVkTGF5ZXJzLmxlbmd0aCkge1xuICAgICAgdGhpcy5yZWJ1aWxkTGF5ZXJzU2VsZWN0aW9uXygpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdHVkaW9TdGF0ZV8uc2VsZWN0ZWRBbmltYXRpb25CbG9ja3MubGVuZ3RoKSB7XG4gICAgICB0aGlzLnJlYnVpbGRBbmltYXRpb25CbG9ja3NTZWxlY3Rpb25fKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0dWRpb1N0YXRlXy5maXJzdFNlbGVjdGVkSXRlbSBpbnN0YW5jZW9mIEFuaW1hdGlvbikge1xuICAgICAgdGhpcy5yZWJ1aWxkQW5pbWF0aW9uc1NlbGVjdGlvbl8oKTtcbiAgICB9XG4gIH1cblxuICBhbmRyb2lkVG9Dc3NDb2xvcih2YWwpIHtcbiAgICByZXR1cm4gQ29sb3JVdGlsLmFuZHJvaWRUb0Nzc0NvbG9yKHZhbCk7XG4gIH1cblxuICBnZXQgc2VsZWN0aW9uRGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uSW5mbyAmJiB0aGlzLnNlbGVjdGlvbkluZm8uZGVzY3JpcHRpb247XG4gIH1cblxuICBjb21wdXRlU2hhcmVkUHJvcGVydHlOYW1lc18oaXRlbXMpIHtcbiAgICBpZiAoIWl0ZW1zIHx8ICFpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBsZXQgc2hhcmVkO1xuICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICBsZXQgbmFtZXMgPSBPYmplY3Qua2V5cyhpdGVtLmluc3BlY3RhYmxlUHJvcGVydGllcyk7XG4gICAgICBpZiAoIXNoYXJlZCkge1xuICAgICAgICBzaGFyZWQgPSBuYW1lcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBuYW1lc1NldCA9IG5ldyBTZXQobmFtZXMpO1xuICAgICAgICBzaGFyZWQgPSBzaGFyZWQuZmlsdGVyKG4gPT4gbmFtZXNTZXQuaGFzKG4pKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBzaGFyZWQ7XG4gIH1cblxuICByZWJ1aWxkTGF5ZXJzU2VsZWN0aW9uXygpIHtcbiAgICB0aGlzLnNlbGVjdGlvbkluZm8gPSB7XG4gICAgICB0eXBlOiAnbGF5ZXJzJyxcbiAgICAgIGluc3BlY3RlZFByb3BlcnRpZXM6IFtdXG4gICAgfTtcblxuICAgIGlmICh0aGlzLnN0dWRpb1N0YXRlXy5zZWxlY3Rpb24ubGVuZ3RoID4gMSkge1xuICAgICAgLy8gYmF0Y2ggbGF5ZXIgZWRpdGluZ1xuICAgICAgbGV0IGNvdW50ID0gdGhpcy5zdHVkaW9TdGF0ZV8uc2VsZWN0aW9uLmxlbmd0aDtcbiAgICAgIHRoaXMuc2VsZWN0aW9uSW5mby5tdWx0aXBsZSA9IHRydWU7XG4gICAgICB0aGlzLnNlbGVjdGlvbkluZm8uaWNvbiA9ICdjb2xsZWN0aW9uJztcbiAgICAgIHRoaXMuc2VsZWN0aW9uSW5mby5kZXNjcmlwdGlvbiA9IGAke2NvdW50fSBsYXllcnNgO1xuXG4gICAgICBsZXQgbGF5ZXJzID0gdGhpcy5zdHVkaW9TdGF0ZV8uc2VsZWN0aW9uO1xuICAgICAgbGV0IHNoYXJlZFByb3BlcnR5TmFtZXMgPSB0aGlzLmNvbXB1dGVTaGFyZWRQcm9wZXJ0eU5hbWVzXyhsYXllcnMpO1xuICAgICAgc2hhcmVkUHJvcGVydHlOYW1lcy5mb3JFYWNoKHByb3BlcnR5TmFtZSA9PiB7XG4gICAgICAgIGxldCBwcm9wZXJ0eSA9IGxheWVyc1swXS5pbnNwZWN0YWJsZVByb3BlcnRpZXNbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgaWYgKHByb3BlcnR5IGluc3RhbmNlb2YgSWRQcm9wZXJ0eSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSW5mby5pbnNwZWN0ZWRQcm9wZXJ0aWVzLnB1c2gobmV3IEluc3BlY3RlZFByb3BlcnR5KHtcbiAgICAgICAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbGF5ZXJzLnJlZHVjZShcbiAgICAgICAgICAgICAgICAodiwgbGF5ZXIpID0+ICh2ID09IGxheWVyW3Byb3BlcnR5TmFtZV0pID8gdiA6IG51bGwsXG4gICAgICAgICAgICAgICAgbGF5ZXJzWzBdW3Byb3BlcnR5TmFtZV0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0IHZhbHVlKHZhbCkge1xuICAgICAgICAgICAgbGF5ZXJzLmZvckVhY2gobGF5ZXIgPT4gbGF5ZXJbcHJvcGVydHlOYW1lXSA9IHZhbCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm9wZXJ0eU5hbWUsXG4gICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgb25DaGFuZ2U6ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3R1ZGlvU3RhdGVfLmFuaW1DaGFuZ2VkKCk7XG4gICAgICAgICAgICB0aGlzLnN0dWRpb1N0YXRlXy5hcnR3b3JrQ2hhbmdlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZWRpdCBhIHNpbmdsZSBsYXllclxuICAgICAgbGV0IGxheWVyID0gdGhpcy5zdHVkaW9TdGF0ZV8uZmlyc3RTZWxlY3RlZEl0ZW07XG4gICAgICB0aGlzLnNlbGVjdGlvbkluZm8uaWNvbiA9IGxheWVyLnR5cGVJY29uO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuc2VsZWN0aW9uSW5mbywgJ2Rlc2NyaXB0aW9uJywge1xuICAgICAgICBnZXQ6ICgpID0+IGxheWVyLmlkXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5rZXlzKGxheWVyLmluc3BlY3RhYmxlUHJvcGVydGllcykuZm9yRWFjaChwcm9wZXJ0eU5hbWUgPT4ge1xuICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgICAgIGxldCBwcm9wZXJ0eSA9IGxheWVyLmluc3BlY3RhYmxlUHJvcGVydGllc1twcm9wZXJ0eU5hbWVdO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkluZm8uaW5zcGVjdGVkUHJvcGVydGllcy5wdXNoKG5ldyBJbnNwZWN0ZWRQcm9wZXJ0eSh7XG4gICAgICAgICAgb2JqZWN0OiBsYXllcixcbiAgICAgICAgICBwcm9wZXJ0eU5hbWUsXG4gICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICAgICAgaWYgKCFzZWxmLnN0dWRpb1N0YXRlXy5hbmltYXRpb25SZW5kZXJlciB8fCBsYXllciA9PT0gc2VsZi5zdHVkaW9TdGF0ZV8uYXJ0d29yaykge1xuICAgICAgICAgICAgICByZXR1cm4gbGF5ZXJbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHJlbmRlcmVkTGF5ZXIgPSBzZWxmLnN0dWRpb1N0YXRlXy5hbmltYXRpb25SZW5kZXJlclxuICAgICAgICAgICAgICAgIC5yZW5kZXJlZEFydHdvcmsuZmluZExheWVyQnlJZChsYXllci5pZCk7XG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyZWRMYXllciA/IHJlbmRlcmVkTGF5ZXJbcHJvcGVydHlOYW1lXSA6IG51bGw7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eSBpbnN0YW5jZW9mIElkUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgc2VsZi5zdHVkaW9TdGF0ZV8udXBkYXRlTGF5ZXJJZChsYXllciwgdmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbGF5ZXJbcHJvcGVydHlOYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICBzZWxmLnN0dWRpb1N0YXRlXy5hcnR3b3JrQ2hhbmdlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdHJhbnNmb3JtRWRpdGVkVmFsdWU6IChwcm9wZXJ0eSBpbnN0YW5jZW9mIElkUHJvcGVydHkpXG4gICAgICAgICAgICAgID8gZW50ZXJlZFZhbHVlID0+IHRoaXMuc3R1ZGlvU3RhdGVfXG4gICAgICAgICAgICAgICAgICAgIC5nZXRVbmlxdWVMYXllcklkKElkUHJvcGVydHkuc2FuaXRpemUoZW50ZXJlZFZhbHVlKSwgbGF5ZXIpXG4gICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICBnZXQgZWRpdGFibGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5zdHVkaW9TdGF0ZV8uYW5pbWF0aW9uUmVuZGVyZXJcbiAgICAgICAgICAgICAgICA/ICFzZWxmLnN0dWRpb1N0YXRlXy5hbmltYXRpb25SZW5kZXJlclxuICAgICAgICAgICAgICAgICAgICAuZ2V0TGF5ZXJQcm9wZXJ0eVN0YXRlKGxheWVyLmlkLCBwcm9wZXJ0eU5hbWUpLmFjdGl2ZUJsb2NrXG4gICAgICAgICAgICAgICAgOiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmVidWlsZEFuaW1hdGlvbkJsb2Nrc1NlbGVjdGlvbl8oKSB7XG4gICAgdGhpcy5zZWxlY3Rpb25JbmZvID0ge1xuICAgICAgdHlwZTogJ2FuaW1hdGlvbkJsb2NrcycsXG4gICAgICBpbnNwZWN0ZWRQcm9wZXJ0aWVzOiBbXVxuICAgIH07XG5cbiAgICBpZiAodGhpcy5zdHVkaW9TdGF0ZV8uc2VsZWN0aW9uLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIGJhdGNoIGFuaW1hdGlvbiBibG9jayBlZGl0aW5nXG4gICAgICBsZXQgY291bnQgPSB0aGlzLnN0dWRpb1N0YXRlXy5zZWxlY3Rpb24ubGVuZ3RoO1xuICAgICAgdGhpcy5zZWxlY3Rpb25JbmZvLm11bHRpcGxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uSW5mby5pY29uID0gJ2NvbGxlY3Rpb24nO1xuICAgICAgdGhpcy5zZWxlY3Rpb25JbmZvLmRlc2NyaXB0aW9uID0gYCR7Y291bnR9IHByb3BlcnR5IGFuaW1hdGlvbnNgO1xuXG4gICAgICBsZXQgYmxvY2tzID0gdGhpcy5zdHVkaW9TdGF0ZV8uc2VsZWN0aW9uO1xuICAgICAgbGV0IHNoYXJlZFByb3BlcnR5TmFtZXMgPSB0aGlzLmNvbXB1dGVTaGFyZWRQcm9wZXJ0eU5hbWVzXyhibG9ja3MpO1xuICAgICAgc2hhcmVkUHJvcGVydHlOYW1lcy5mb3JFYWNoKHByb3BlcnR5TmFtZSA9PiB7XG4gICAgICAgIGxldCBwcm9wZXJ0eSA9IGJsb2Nrc1swXS5pbnNwZWN0YWJsZVByb3BlcnRpZXNbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgaWYgKHByb3BlcnR5IGluc3RhbmNlb2YgU3R1YlByb3BlcnR5KSB7XG4gICAgICAgICAgLy8gZnJvbVZhbHVlIGFuZCB0b1ZhbHVlIG9ubHkgd29yayB3aGVuIHRoZXkncmUgYW5pbWF0aW5nIGNvbXBhdGlibGUgcHJvcGVydHkgdHlwZXNcbiAgICAgICAgICBsZXQgcHJvcGVydGllcyA9IGJsb2Nrcy5tYXAoYmxvY2sgPT5cbiAgICAgICAgICAgICAgdGhpcy5zdHVkaW9TdGF0ZV8uYXJ0d29yay5maW5kTGF5ZXJCeUlkKGJsb2NrLmxheWVySWQpXG4gICAgICAgICAgICAgICAgICAuaW5zcGVjdGFibGVQcm9wZXJ0aWVzW2Jsb2NrLnByb3BlcnR5TmFtZV0pO1xuICAgICAgICAgIGxldCBwcm9wZXJ0aWVzQ29tcGF0aWJsZSA9IHByb3BlcnRpZXMucmVkdWNlKFxuICAgICAgICAgICAgICAoYywgcHJvcCkgPT4gYyAmJiBwcm9wLmNvbnN0cnVjdG9yID09PSBwcm9wZXJ0aWVzWzBdLmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgICB0cnVlKTtcbiAgICAgICAgICBpZiAoIXByb3BlcnRpZXNDb21wYXRpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHByb3BlcnR5ID0gcHJvcGVydGllc1swXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGlvbkluZm8uaW5zcGVjdGVkUHJvcGVydGllcy5wdXNoKG5ldyBJbnNwZWN0ZWRQcm9wZXJ0eSh7XG4gICAgICAgICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIGJsb2Nrcy5yZWR1Y2UoXG4gICAgICAgICAgICAgICAgKHYsIGJsb2NrKSA9PiAodiA9PSBibG9ja1twcm9wZXJ0eU5hbWVdKSA/IHYgOiBudWxsLFxuICAgICAgICAgICAgICAgIGJsb2Nrc1swXVtwcm9wZXJ0eU5hbWVdKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldCB2YWx1ZSh2YWwpIHtcbiAgICAgICAgICAgIGJsb2Nrcy5mb3JFYWNoKGJsb2NrID0+IGJsb2NrW3Byb3BlcnR5TmFtZV0gPSB2YWwpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJvcGVydHlOYW1lLFxuICAgICAgICAgIHByb3BlcnR5LFxuICAgICAgICAgIG9uQ2hhbmdlOiAoKSA9PiB0aGlzLnN0dWRpb1N0YXRlXy5hbmltQ2hhbmdlZCgpXG4gICAgICAgIH0pKTtcbiAgICAgIH0pO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVkaXQgYSBzaW5nbGUgYW5pbWF0aW9uIGJsb2NrXG4gICAgICBsZXQgYmxvY2sgPSB0aGlzLnN0dWRpb1N0YXRlXy5maXJzdFNlbGVjdGVkSXRlbTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uSW5mby5pY29uID0gJ2FuaW1hdGlvbl9ibG9jayc7XG4gICAgICB0aGlzLnNlbGVjdGlvbkluZm8uZGVzY3JpcHRpb24gPSBgJHtibG9jay5wcm9wZXJ0eU5hbWV9YDtcbiAgICAgIHRoaXMuc2VsZWN0aW9uSW5mby5zdWJEZXNjcmlwdGlvbiA9IGBmb3IgJyR7YmxvY2subGF5ZXJJZH0nYDtcbiAgICAgIE9iamVjdC5rZXlzKGJsb2NrLmluc3BlY3RhYmxlUHJvcGVydGllcykuZm9yRWFjaChwcm9wZXJ0eU5hbWUgPT4ge1xuICAgICAgICBsZXQgcHJvcGVydHkgPSBibG9jay5pbnNwZWN0YWJsZVByb3BlcnRpZXNbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgaWYgKHByb3BlcnR5IGluc3RhbmNlb2YgU3R1YlByb3BlcnR5KSB7XG4gICAgICAgICAgcHJvcGVydHkgPSB0aGlzLnN0dWRpb1N0YXRlXy5hcnR3b3JrLmZpbmRMYXllckJ5SWQoYmxvY2subGF5ZXJJZClcbiAgICAgICAgICAgICAgLmluc3BlY3RhYmxlUHJvcGVydGllc1tibG9jay5wcm9wZXJ0eU5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSW5mby5pbnNwZWN0ZWRQcm9wZXJ0aWVzLnB1c2gobmV3IEluc3BlY3RlZFByb3BlcnR5KHtcbiAgICAgICAgICBvYmplY3Q6IGJsb2NrLFxuICAgICAgICAgIHByb3BlcnR5TmFtZSxcbiAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICBvbkNoYW5nZTogKCkgPT4gdGhpcy5zdHVkaW9TdGF0ZV8uYW5pbUNoYW5nZWQoKVxuICAgICAgICB9KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZWJ1aWxkQW5pbWF0aW9uc1NlbGVjdGlvbl8oKSB7XG4gICAgdGhpcy5zZWxlY3Rpb25JbmZvID0ge1xuICAgICAgdHlwZTogJ2FuaW1hdGlvbnMnLFxuICAgICAgaW5zcGVjdGVkUHJvcGVydGllczogW11cbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuc3R1ZGlvU3RhdGVfLnNlbGVjdGlvbi5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBiYXRjaCBhbmltYXRpb24gZWRpdGluZ1xuICAgICAgbGV0IGNvdW50ID0gdGhpcy5zdHVkaW9TdGF0ZV8uc2VsZWN0aW9uLmxlbmd0aDtcbiAgICAgIHRoaXMuc2VsZWN0aW9uSW5mby5tdWx0aXBsZSA9IHRydWU7XG4gICAgICB0aGlzLnNlbGVjdGlvbkluZm8uaWNvbiA9ICdjb2xsZWN0aW9uJztcbiAgICAgIHRoaXMuc2VsZWN0aW9uSW5mby5kZXNjcmlwdGlvbiA9IGAke2NvdW50fSBhbmltYXRpb25zYDtcbiAgICAgIC8vIFRPRE9cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlZGl0IGEgc2luZ2xlIGFuaW1hdGlvblxuICAgICAgbGV0IGFuaW1hdGlvbiA9IHRoaXMuc3R1ZGlvU3RhdGVfLmZpcnN0U2VsZWN0ZWRJdGVtO1xuICAgICAgdGhpcy5zZWxlY3Rpb25JbmZvLmljb24gPSAnYW5pbWF0aW9uJztcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnNlbGVjdGlvbkluZm8sICdkZXNjcmlwdGlvbicsIHtcbiAgICAgICAgZ2V0OiAoKSA9PiBhbmltYXRpb24uaWRcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmtleXMoYW5pbWF0aW9uLmluc3BlY3RhYmxlUHJvcGVydGllcykuZm9yRWFjaChwcm9wZXJ0eU5hbWUgPT4ge1xuICAgICAgICBsZXQgcHJvcGVydHkgPSBhbmltYXRpb24uaW5zcGVjdGFibGVQcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV07XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSW5mby5pbnNwZWN0ZWRQcm9wZXJ0aWVzLnB1c2gobmV3IEluc3BlY3RlZFByb3BlcnR5KHtcbiAgICAgICAgICBvYmplY3Q6IGFuaW1hdGlvbixcbiAgICAgICAgICBwcm9wZXJ0eU5hbWUsXG4gICAgICAgICAgdHJhbnNmb3JtRWRpdGVkVmFsdWU6IChwcm9wZXJ0eSBpbnN0YW5jZW9mIElkUHJvcGVydHkpXG4gICAgICAgICAgICAgID8gZW50ZXJlZFZhbHVlID0+IHRoaXMuc3R1ZGlvU3RhdGVfXG4gICAgICAgICAgICAgICAgICAgIC5nZXRVbmlxdWVBbmltYXRpb25JZChJZFByb3BlcnR5LnNhbml0aXplKGVudGVyZWRWYWx1ZSksIGFuaW1hdGlvbilcbiAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgIHByb3BlcnR5LFxuICAgICAgICAgIG9uQ2hhbmdlOiAoKSA9PiB0aGlzLnN0dWRpb1N0YXRlXy5hbmltQ2hhbmdlZCgpXG4gICAgICAgIH0pKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIG9uVmFsdWVFZGl0b3JLZXlEb3duKGV2ZW50LCBpbnNwZWN0ZWRQcm9wZXJ0eSkge1xuICAgIHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xuICAgICAgLy8gdXAvZG93biBidXR0b25zXG4gICAgICBjYXNlIDM4OlxuICAgICAgY2FzZSA0MDpcbiAgICAgICAgaW5zcGVjdGVkUHJvcGVydHkucmVzb2x2ZUVudGVyZWRWYWx1ZSgpO1xuICAgICAgICBsZXQgJHRhcmdldCA9ICQoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgbGV0IG51bWJlclZhbHVlID0gTnVtYmVyKCR0YXJnZXQudmFsKCkpO1xuICAgICAgICBpZiAoIWlzTmFOKG51bWJlclZhbHVlKSkge1xuICAgICAgICAgIGxldCBkZWx0YSA9IChldmVudC5rZXlDb2RlID09IDM4KSA/IDEgOiAtMTtcblxuICAgICAgICAgIGlmIChpbnNwZWN0ZWRQcm9wZXJ0eS5wcm9wZXJ0eSBpbnN0YW5jZW9mIEZyYWN0aW9uUHJvcGVydHkpIHtcbiAgICAgICAgICAgIGRlbHRhICo9IC4xO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgZGVsdGEgKj0gMTA7XG4gICAgICAgICAgfSBlbHNlIGlmIChldmVudC5hbHRLZXkpIHtcbiAgICAgICAgICAgIGRlbHRhIC89IDEwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG51bWJlclZhbHVlICs9IGRlbHRhO1xuICAgICAgICAgIGluc3BlY3RlZFByb3BlcnR5LnByb3BlcnR5LnRyeVNldEVkaXRlZFZhbHVlKFxuICAgICAgICAgICAgICBpbnNwZWN0ZWRQcm9wZXJ0eSwgJ3ZhbHVlJywgTnVtYmVyKG51bWJlclZhbHVlLnRvRml4ZWQoNikpKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+ICR0YXJnZXQuZ2V0KDApLnNlbGVjdCgpLCAwKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuXG5jbGFzcyBJbnNwZWN0ZWRQcm9wZXJ0eSB7XG4gIGNvbnN0cnVjdG9yKGRlbGVnYXRlKSB7XG4gICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgIHRoaXMub2JqZWN0ID0gZGVsZWdhdGUub2JqZWN0O1xuICAgIHRoaXMucHJvcGVydHlOYW1lID0gZGVsZWdhdGUucHJvcGVydHlOYW1lO1xuICAgIHRoaXMucHJvcGVydHkgPSBkZWxlZ2F0ZS5wcm9wZXJ0eTtcbiAgICB0aGlzLmVudGVyZWRWYWx1ZV8gPSBudWxsO1xuICB9XG5cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiAoJ3ZhbHVlJyBpbiB0aGlzLmRlbGVnYXRlKVxuICAgICAgICA/IHRoaXMuZGVsZWdhdGUudmFsdWVcbiAgICAgICAgOiB0aGlzLm9iamVjdFt0aGlzLnByb3BlcnR5TmFtZV07XG4gIH1cblxuICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICAoJ3ZhbHVlJyBpbiB0aGlzLmRlbGVnYXRlKVxuICAgICAgICA/ICh0aGlzLmRlbGVnYXRlLnZhbHVlID0gdmFsdWUpXG4gICAgICAgIDogKHRoaXMub2JqZWN0W3RoaXMucHJvcGVydHlOYW1lXSA9IHZhbHVlKTtcbiAgICBpZiAodGhpcy5kZWxlZ2F0ZS5vbkNoYW5nZSkge1xuICAgICAgdGhpcy5kZWxlZ2F0ZS5vbkNoYW5nZSgpO1xuICAgIH1cbiAgfVxuXG4gIGdldCB0eXBlTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0eS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgZ2V0IGVkaXRhYmxlKCkge1xuICAgIHJldHVybiAnZWRpdGFibGUnIGluIHRoaXMuZGVsZWdhdGUgPyB0aGlzLmRlbGVnYXRlLmVkaXRhYmxlIDogdHJ1ZTtcbiAgfVxuXG4gIGdldCBkaXNwbGF5VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydHkuZGlzcGxheVZhbHVlRm9yVmFsdWUodGhpcy52YWx1ZSk7XG4gIH1cblxuICBnZXQgZWRpdGFibGVWYWx1ZSgpIHtcbiAgICByZXR1cm4gKHRoaXMuZW50ZXJlZFZhbHVlXyAhPT0gbnVsbClcbiAgICAgICAgPyB0aGlzLmVudGVyZWRWYWx1ZV9cbiAgICAgICAgOiB0aGlzLnByb3BlcnR5LmdldEVkaXRhYmxlVmFsdWUodGhpcywgJ3ZhbHVlJyk7XG4gIH1cblxuICBzZXQgZWRpdGFibGVWYWx1ZShlbnRlcmVkVmFsdWUpIHtcbiAgICB0aGlzLmVudGVyZWRWYWx1ZV8gPSBlbnRlcmVkVmFsdWU7XG4gICAgaWYgKHRoaXMuZGVsZWdhdGUudHJhbnNmb3JtRWRpdGVkVmFsdWUpIHtcbiAgICAgIGVudGVyZWRWYWx1ZSA9IHRoaXMuZGVsZWdhdGUudHJhbnNmb3JtRWRpdGVkVmFsdWUoZW50ZXJlZFZhbHVlKTtcbiAgICB9XG4gICAgdGhpcy5wcm9wZXJ0eS50cnlTZXRFZGl0ZWRWYWx1ZSh0aGlzLCAndmFsdWUnLCBlbnRlcmVkVmFsdWUpO1xuICB9XG5cbiAgcmVzb2x2ZUVudGVyZWRWYWx1ZSgpIHtcbiAgICB0aGlzLmVudGVyZWRWYWx1ZV8gPSBudWxsO1xuICB9XG59XG5cblxuYW5ndWxhci5tb2R1bGUoJ0FWRFN0dWRpbycpLmRpcmVjdGl2ZSgnc3R1ZGlvUHJvcGVydHlJbnNwZWN0b3InLCAoKSA9PiB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFJyxcbiAgICBzY29wZToge30sXG4gICAgdGVtcGxhdGVVcmw6ICdjb21wb25lbnRzL3Byb3BlcnR5aW5zcGVjdG9yL3Byb3BlcnR5aW5zcGVjdG9yLmh0bWwnLFxuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgYmluZFRvQ29udHJvbGxlcjogdHJ1ZSxcbiAgICBjb250cm9sbGVyOiBQcm9wZXJ0eUluc3BlY3RvckNvbnRyb2xsZXIsXG4gICAgY29udHJvbGxlckFzOiAnY3RybCdcbiAgfTtcbn0pO1xuXG5cbi8vIHRpbWVsaW5lIGdyaWRcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5sZXQgZ3JvdXBzID0ge307XG5cbmNsYXNzIFNjcm9sbEdyb3VwQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKCRzY29wZSwgJGVsZW1lbnQsICRhdHRycykge1xuICAgIGxldCBzY3JvbGxHcm91cCA9ICRhdHRycy5zY3JvbGxHcm91cCB8fCAnJztcbiAgICBncm91cHNbc2Nyb2xsR3JvdXBdID0gZ3JvdXBzW3Njcm9sbEdyb3VwXSB8fCBbXTtcbiAgICBncm91cHNbc2Nyb2xsR3JvdXBdLnB1c2goJGVsZW1lbnQpO1xuXG4gICAgJGVsZW1lbnQub24oJ3Njcm9sbCcsICgpID0+IHtcbiAgICAgIGxldCBzY3JvbGxUb3AgPSAkZWxlbWVudC5zY3JvbGxUb3AoKTtcbiAgICAgIGdyb3Vwc1tzY3JvbGxHcm91cF0uZm9yRWFjaChcbiAgICAgICAgICBlbCA9PiAoZWwgIT09ICRlbGVtZW50KSA/IGVsLnNjcm9sbFRvcChzY3JvbGxUb3ApIDogbnVsbCk7XG4gICAgfSk7XG5cbiAgICAkc2NvcGUuJG9uKCckZGVzdHJveScsICgpID0+IHtcbiAgICAgIGdyb3Vwc1tzY3JvbGxHcm91cF0uc3BsaWNlKGdyb3Vwc1tzY3JvbGxHcm91cF0uaW5kZXhPZigkZWxlbWVudCksIDEpO1xuICAgIH0pO1xuICB9XG59XG5cblxuYW5ndWxhci5tb2R1bGUoJ0FWRFN0dWRpbycpLmRpcmVjdGl2ZSgnc2Nyb2xsR3JvdXAnLCAoKSA9PiB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdBJyxcbiAgICBjb250cm9sbGVyOiBTY3JvbGxHcm91cENvbnRyb2xsZXJcbiAgfTtcbn0pO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7RHJhZ0hlbHBlcn0gZnJvbSAnRHJhZ0hlbHBlcic7XG5cblxuY2xhc3MgU3BsaXR0ZXJDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoJHNjb3BlLCAkZWxlbWVudCwgJGF0dHJzKSB7XG4gICAgdGhpcy5lZGdlXyA9ICRhdHRycy5lZGdlO1xuICAgIHRoaXMubWluXyA9IE51bWJlcigkYXR0cnMubWluKSB8fCAxMDA7XG4gICAgdGhpcy5wZXJzaXN0S2V5XyA9ICRhdHRycy5wZXJzaXN0SWQgPyBgXFwkXFwkc3BsaXR0ZXI6OiR7JGF0dHJzLnBlcnNpc3RJZH1gIDogbnVsbDtcbiAgICB0aGlzLm9yaWVudGF0aW9uXyA9ICh0aGlzLmVkZ2VfID09ICdsZWZ0JyB8fCB0aGlzLmVkZ2VfID09ICdyaWdodCcpXG4gICAgICAgID8gJ3ZlcnRpY2FsJ1xuICAgICAgICA6ICdob3Jpem9udGFsJztcbiAgICB0aGlzLmVsZW1lbnRfID0gJGVsZW1lbnQ7XG4gICAgdGhpcy5wYXJlbnRfID0gJGVsZW1lbnQucGFyZW50KCk7XG4gICAgdGhpcy5kcmFnZ2luZ18gPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLm9yaWVudGF0aW9uXyA9PSAndmVydGljYWwnKSB7XG4gICAgICB0aGlzLnNpemVHZXR0ZXJfID0gKCkgPT4gdGhpcy5wYXJlbnRfLndpZHRoKCk7XG4gICAgICB0aGlzLnNpemVTZXR0ZXJfID0gc2l6ZSA9PiB0aGlzLnBhcmVudF8ud2lkdGgoc2l6ZSk7XG4gICAgICB0aGlzLmNsaWVudFhZXyA9ICdjbGllbnRYJztcblxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNpemVHZXR0ZXJfID0gKCkgPT4gdGhpcy5wYXJlbnRfLmhlaWdodCgpO1xuICAgICAgdGhpcy5zaXplU2V0dGVyXyA9IHNpemUgPT4gdGhpcy5wYXJlbnRfLmhlaWdodChzaXplKTtcbiAgICAgIHRoaXMuY2xpZW50WFlfID0gJ2NsaWVudFknO1xuICAgIH1cblxuICAgIHRoaXMuYWRkQ2xhc3Nlc18oKTtcbiAgICB0aGlzLnNldHVwRXZlbnRMaXN0ZW5lcnNfKCk7XG4gICAgdGhpcy5kZXNlcmlhbGl6ZVN0YXRlXygpO1xuICB9XG5cbiAgZGVzZXJpYWxpemVTdGF0ZV8oKSB7XG4gICAgaWYgKHRoaXMucGVyc2lzdEtleV8gaW4gbG9jYWxTdG9yYWdlKSB7XG4gICAgICB0aGlzLnNldFNpemVfKE51bWJlcihsb2NhbFN0b3JhZ2VbdGhpcy5wZXJzaXN0S2V5X10pKTtcbiAgICB9XG4gIH1cblxuICBhZGRDbGFzc2VzXygpIHtcbiAgICB0aGlzLmVsZW1lbnRfXG4gICAgICAgIC5hZGRDbGFzcyhgc3BsdC0ke3RoaXMub3JpZW50YXRpb25ffWApXG4gICAgICAgIC5hZGRDbGFzcyhgc3BsdC1lZGdlLSR7dGhpcy5lZGdlX31gKTtcbiAgfVxuXG4gIHNldHVwRXZlbnRMaXN0ZW5lcnNfKCkge1xuICAgIHRoaXMuZWxlbWVudF8ub24oJ21vdXNlZG93bicsIGV2ZW50ID0+IHtcbiAgICAgIHRoaXMuZG93blhZXyA9IGV2ZW50W3RoaXMuY2xpZW50WFlfXTtcbiAgICAgIHRoaXMuZG93blNpemVfID0gdGhpcy5zaXplR2V0dGVyXygpO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgbmV3IERyYWdIZWxwZXIoe1xuICAgICAgICBkb3duRXZlbnQ6IGV2ZW50LFxuICAgICAgICBkaXJlY3Rpb246ICh0aGlzLm9yaWVudGF0aW9uXyA9PSAndmVydGljYWwnKSA/ICdob3Jpem9udGFsJyA6ICd2ZXJ0aWNhbCcsXG4gICAgICAgIGRyYWdnaW5nQ3Vyc29yOiAodGhpcy5vcmllbnRhdGlvbl8gPT0gJ3ZlcnRpY2FsJykgPyAnY29sLXJlc2l6ZScgOiAncm93LXJlc2l6ZScsXG5cbiAgICAgICAgb25CZWdpbkRyYWc6IGV2ZW50ID0+IHRoaXMuZWxlbWVudF8uYWRkQ2xhc3MoJ2lzLWRyYWdnaW5nJyksXG4gICAgICAgIG9uRHJvcDogZXZlbnQgPT4gdGhpcy5lbGVtZW50Xy5yZW1vdmVDbGFzcygnaXMtZHJhZ2dpbmcnKSxcbiAgICAgICAgb25EcmFnOiAoZXZlbnQsIGRlbHRhKSA9PiB7XG4gICAgICAgICAgbGV0IHNpZ24gPSAodGhpcy5lZGdlXyA9PSAnbGVmdCcgfHwgdGhpcy5lZGdlXyA9PSAndG9wJykgPyAtMSA6IDE7XG4gICAgICAgICAgdGhpcy5zZXRTaXplXyhNYXRoLm1heCh0aGlzLm1pbl8sXG4gICAgICAgICAgICAgIHRoaXMuZG93blNpemVfICsgc2lnbiAqIGRlbHRhWyh0aGlzLm9yaWVudGF0aW9uXyA9PSAndmVydGljYWwnKSA/ICd4JyA6ICd5J10pKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBzZXRTaXplXyhzaXplKSB7XG4gICAgaWYgKHRoaXMucGVyc2lzdEtleV8pIHtcbiAgICAgIGxvY2FsU3RvcmFnZVt0aGlzLnBlcnNpc3RLZXlfXSA9IHNpemU7XG4gICAgfVxuICAgIHRoaXMuc2l6ZVNldHRlcl8oc2l6ZSk7XG4gIH1cbn1cblxuXG5hbmd1bGFyLm1vZHVsZSgnQVZEU3R1ZGlvJykuZGlyZWN0aXZlKCdzdHVkaW9TcGxpdHRlcicsICgpID0+IHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0UnLFxuICAgIHNjb3BlOiB7fSxcbiAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJzdHVkaW8tc3BsaXR0ZXJcIj48L2Rpdj4nLFxuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgYmluZFRvQ29udHJvbGxlcjogdHJ1ZSxcbiAgICBjb250cm9sbGVyOiBTcGxpdHRlckNvbnRyb2xsZXIsXG4gICAgY29udHJvbGxlckFzOiAnY3RybCdcbiAgfTtcbn0pO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7TGF5ZXJHcm91cCwgQmFzZUxheWVyLCBBcnR3b3JrLCBBbmltYXRpb24sIEFuaW1hdGlvbkJsb2NrfSBmcm9tICdtb2RlbCc7XG5pbXBvcnQge01hdGhVdGlsfSBmcm9tICdNYXRoVXRpbCc7XG5pbXBvcnQge0NvbG9yVXRpbH0gZnJvbSAnQ29sb3JVdGlsJztcbmltcG9ydCB7U3ZnTG9hZGVyfSBmcm9tICdTdmdMb2FkZXInO1xuaW1wb3J0IHtWZWN0b3JEcmF3YWJsZUxvYWRlcn0gZnJvbSAnVmVjdG9yRHJhd2FibGVMb2FkZXInO1xuaW1wb3J0IHtBdmRTZXJpYWxpemVyfSBmcm9tICdBdmRTZXJpYWxpemVyJztcblxuLy9pbXBvcnQgVEVTVF9EQVRBIGZyb20gJy4uLy4uLy4uL19zYW5kYm94L2RlYnVnLmljb25hbmltLmpzb24nO1xuXG5cbmNvbnN0IFBMQVlCQUNLX1NQRUVEUyA9IFsuMSwgLjI1LCAuNSwgMSwgMiwgMywgNCwgOCwgMTBdO1xuXG5jb25zdCBERUJVRyA9ICEhd2luZG93LmxvY2F0aW9uLnNlYXJjaC5tYXRjaCgvZGVidWcvKTtcblxuXG5cbmNsYXNzIFN0dWRpb0N0cmwge1xuICBjb25zdHJ1Y3Rvcigkc2NvcGUsICRodHRwLCAkbWRUb2FzdCwgJG1kRGlhbG9nLCAkdGltZW91dCwgU3R1ZGlvU3RhdGVTZXJ2aWNlKSB7XG4gICAgdGhpcy52ZXJzaW9uSW5mbyA9IHdpbmRvdy5BUFBfVkVSU0lPTl9JTkZPO1xuXG4gICAgdGhpcy5zY29wZV8gPSAkc2NvcGU7XG4gICAgdGhpcy5odHRwXyA9ICRodHRwO1xuICAgIHRoaXMubWRUb2FzdF8gPSAkbWRUb2FzdDtcbiAgICB0aGlzLm1kRGlhbG9nXyA9ICRtZERpYWxvZztcbiAgICB0aGlzLnRpbWVvdXRfID0gJHRpbWVvdXQ7XG4gICAgdGhpcy5zdHVkaW9TdGF0ZV8gPSBTdHVkaW9TdGF0ZVNlcnZpY2U7XG5cbiAgICB0aGlzLnByZXZpZXdNb2RlID0gZmFsc2U7XG4gICAgdGhpcy5pc0xvYWRlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5zZXR1cEtleWJvYXJkQW5kVW5sb2FkRXZlbnRzXygpO1xuICAgIHRoaXMuc2V0dXBDbGlwYm9hcmRFdmVudHNfKCk7XG5cbiAgICB0aGlzLmxvYWRJbml0aWFsQXJ0d29ya18oKTtcbiAgfVxuXG4gIHNob3dFcnJvcl8obWVzc2FnZSwgZXJyb3IpIHtcbiAgICB0aGlzLm1kVG9hc3RfLnNob3coXG4gICAgICAgIHRoaXMubWRUb2FzdF8uc2ltcGxlKClcbiAgICAgICAgICAudGV4dENvbnRlbnQobWVzc2FnZSlcbiAgICAgICAgICAuaGlkZURlbGF5KDMwMDApKTtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgfVxuXG4gIGxvYWRJbml0aWFsQXJ0d29ya18oKSB7XG4gICAgbGV0IGV4YW1wbGVNYXRjaCA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gubWF0Y2goLyg/OmV4YW1wbGV8ZmlsZVVybCk9KC4rKS8pO1xuICAgIGlmIChleGFtcGxlTWF0Y2gpIHtcbiAgICAgIC8vIExvYWQgZXhhbXBsZVxuICAgICAgdGhpcy5odHRwXyh7XG4gICAgICAgIHVybDogZGVjb2RlVVJJQ29tcG9uZW50KGV4YW1wbGVNYXRjaFsxXSlcbiAgICAgIH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuc3R1ZGlvU3RhdGVfLmxvYWQoe1xuICAgICAgICAgICAgYXJ0d29yazogbmV3IEFydHdvcmsocmVzcG9uc2UuZGF0YS5hcnR3b3JrKSxcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IHJlc3BvbnNlLmRhdGEuYW5pbWF0aW9ucy5tYXAoYW5pbSA9PiBuZXcgQW5pbWF0aW9uKGFuaW0pKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhpcy5zaG93RXJyb3JfKCdFcnJvciBwYXJzaW5nIGV4YW1wbGUgYXJ0d29yaycsIGUpO1xuICAgICAgICAgIHRoaXMuc3R1ZGlvU3RhdGVfLm5ldygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNMb2FkZWQgPSB0cnVlO1xuXG4gICAgICB9LCBlcnJvciA9PiB7XG4gICAgICAgIHRoaXMuc2hvd0Vycm9yXygnRXJyb3IgbG9hZGluZyBleGFtcGxlIGFydHdvcmsnLCBlcnJvcik7XG4gICAgICAgIHRoaXMuc3R1ZGlvU3RhdGVfLm5ldygpO1xuICAgICAgICB0aGlzLmlzTG9hZGVkID0gdHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxvYWQgZW1wdHkgYXJ0d29ya1xuICAgICAgdGhpcy5zdHVkaW9TdGF0ZV8ubmV3KCk7XG4gICAgICB0aGlzLmlzTG9hZGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBzZXR1cENsaXBib2FyZEV2ZW50c18oKSB7XG4gICAgbGV0IGN1dENvcHlIYW5kbGVyXyA9IChldmVudCwgc2hvdWxkQ3V0KSA9PiB7XG4gICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5tYXRjaGVzKCdpbnB1dCcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBsZXQgc2VsZWN0ZWRMYXllcnMgPSB0aGlzLnN0dWRpb1N0YXRlXy5zZWxlY3RlZExheWVycztcbiAgICAgIGlmICghc2VsZWN0ZWRMYXllcnMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBsZXQgY2xpcGJvYXJkRGF0YSA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQuY2xpcGJvYXJkRGF0YTtcbiAgICAgIGNsaXBib2FyZERhdGEuc2V0RGF0YSgndGV4dC9wbGFpbicsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgY2xpcGJvYXJkVHlwZTogJ2xheWVycycsXG4gICAgICAgIGxheWVyczogc2VsZWN0ZWRMYXllcnNcbiAgICAgICAgICAgIC5maWx0ZXIobCA9PiAhKGwgaW5zdGFuY2VvZiBBcnR3b3JrKSlcbiAgICAgICAgICAgIC5tYXAobCA9PiBsLnRvSlNPTigpKVxuICAgICAgfSwgbnVsbCwgMikpO1xuXG4gICAgICBpZiAoc2hvdWxkQ3V0KSB7XG4gICAgICAgIHRoaXMuZGVsZXRlU2VsZWN0ZWRMYXllcnNfKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgbGV0IGN1dEhhbmRsZXJfID0gZXZlbnQgPT4gY3V0Q29weUhhbmRsZXJfKGV2ZW50LCB0cnVlKTtcbiAgICBsZXQgY29weUhhbmRsZXJfID0gZXZlbnQgPT4gY3V0Q29weUhhbmRsZXJfKGV2ZW50LCBmYWxzZSk7XG5cbiAgICBsZXQgcGFzdGVIYW5kbGVyXyA9IGV2ZW50ID0+IHtcbiAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50Lm1hdGNoZXMoJ2lucHV0JykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGxldCB0YXJnZXRQYXJlbnQgPSB0aGlzLnN0dWRpb1N0YXRlXy5hcnR3b3JrO1xuICAgICAgbGV0IGZpcnN0U2VsZWN0ZWRJdGVtID0gdGhpcy5zdHVkaW9TdGF0ZV8uZmlyc3RTZWxlY3RlZEl0ZW07XG4gICAgICBpZiAoZmlyc3RTZWxlY3RlZEl0ZW0gJiYgZmlyc3RTZWxlY3RlZEl0ZW0gaW5zdGFuY2VvZiBMYXllckdyb3VwKSB7XG4gICAgICAgIHRhcmdldFBhcmVudCA9IGZpcnN0U2VsZWN0ZWRJdGVtO1xuICAgICAgfVxuXG4gICAgICBsZXQgY2xpcGJvYXJkRGF0YSA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQuY2xpcGJvYXJkRGF0YTtcbiAgICAgIGxldCBzdHIgPSBjbGlwYm9hcmREYXRhLmdldERhdGEoJ3RleHQnKTtcblxuICAgICAgbGV0IHBhc3RlTGF5ZXJzID0gbnVsbDtcblxuICAgICAgaWYgKHN0ci5tYXRjaCgvPFxcL3N2Zz5cXHMqJC8pKSB7XG4gICAgICAgIC8vIHBhc3RlIFNWR1xuICAgICAgICBnYSgnc2VuZCcsICdldmVudCcsICdwYXN0ZScsICdzdmcnKTtcbiAgICAgICAgbGV0IGFydHdvcmsgPSBTdmdMb2FkZXIubG9hZEFydHdvcmtGcm9tU3ZnU3RyaW5nKHN0cik7XG4gICAgICAgIHBhc3RlTGF5ZXJzID0gYXJ0d29yay5sYXllcnM7XG5cbiAgICAgIH0gIGVsc2UgaWYgKHN0ci5tYXRjaCgvPFxcL3ZlY3Rvcj5cXHMqJC8pKSB7XG4gICAgICAgIC8vIHBhc3RlIFZEXG4gICAgICAgIGdhKCdzZW5kJywgJ2V2ZW50JywgJ3Bhc3RlJywgJ3ZkJyk7XG4gICAgICAgIGxldCBhcnR3b3JrID0gVmVjdG9yRHJhd2FibGVMb2FkZXIubG9hZEFydHdvcmtGcm9tWG1sU3RyaW5nKHN0cik7XG4gICAgICAgIHBhc3RlTGF5ZXJzID0gYXJ0d29yay5sYXllcnM7XG5cbiAgICAgIH0gZWxzZSBpZiAoc3RyLm1hdGNoKC9cXH1cXHMqJC8pKSB7XG4gICAgICAgIC8vIHBhc3RlIEpTT05cbiAgICAgICAgbGV0IHBhcnNlZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwYXJzZWQgPSBKU09OLnBhcnNlKHN0cik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBDb3VsZG4ndCBwYXJzZSBKU09OOiAke3N0cn1gKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyc2VkLmNsaXBib2FyZFR5cGUgPT0gJ2xheWVycycpIHtcbiAgICAgICAgICBnYSgnc2VuZCcsICdldmVudCcsICdwYXN0ZScsICdqc29uLmxheWVycycpO1xuICAgICAgICAgIHBhc3RlTGF5ZXJzID0gcGFyc2VkLmxheWVycy5tYXAobCA9PiBCYXNlTGF5ZXIubG9hZChsKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2EoJ3NlbmQnLCAnZXZlbnQnLCAncGFzdGUnLCAnanNvbi51bmtub3duJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHBhc3RlTGF5ZXJzICYmIHBhc3RlTGF5ZXJzLmxlbmd0aCkge1xuICAgICAgICBsZXQgbmV3U2VsZWN0aW9uID0gW107XG4gICAgICAgIHBhc3RlTGF5ZXJzLmZvckVhY2gobGF5ZXIgPT4ge1xuICAgICAgICAgIGxheWVyLnBhcmVudCA9IHRhcmdldFBhcmVudDtcbiAgICAgICAgICBsYXllci53YWxrKGxheWVyID0+IHtcbiAgICAgICAgICAgIGxheWVyLmlkID0gdGhpcy5zdHVkaW9TdGF0ZV8uZ2V0VW5pcXVlTGF5ZXJJZChsYXllci5pZCwgbGF5ZXIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRhcmdldFBhcmVudC5sYXllcnMucHVzaChsYXllcik7XG4gICAgICAgICAgbmV3U2VsZWN0aW9uLnB1c2gobGF5ZXIpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnN0dWRpb1N0YXRlXy5zZWxlY3Rpb24gPSBuZXdTZWxlY3Rpb247XG4gICAgICAgIHRoaXMuc3R1ZGlvU3RhdGVfLmFydHdvcmtDaGFuZ2VkKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGV0IGRpZ2VzdGVkQ3V0SGFuZGxlcl8gPSBldmVudCA9PiB0aGlzLnNjb3BlXy4kYXBwbHkoKCkgPT4gY3V0SGFuZGxlcl8oZXZlbnQpKTtcbiAgICBsZXQgZGlnZXN0ZWRDb3B5SGFuZGxlcl8gPSBldmVudCA9PiB0aGlzLnNjb3BlXy4kYXBwbHkoKCkgPT4gY29weUhhbmRsZXJfKGV2ZW50KSk7XG4gICAgbGV0IGRpZ2VzdGVkUGFzdGVIYW5kbGVyXyA9IGV2ZW50ID0+IHRoaXMuc2NvcGVfLiRhcHBseSgoKSA9PiBwYXN0ZUhhbmRsZXJfKGV2ZW50KSk7XG5cbiAgICAkKHdpbmRvdylcbiAgICAgICAgLm9uKCdjdXQnLCBkaWdlc3RlZEN1dEhhbmRsZXJfKVxuICAgICAgICAub24oJ2NvcHknLCBkaWdlc3RlZENvcHlIYW5kbGVyXylcbiAgICAgICAgLm9uKCdwYXN0ZScsIGRpZ2VzdGVkUGFzdGVIYW5kbGVyXyk7XG5cbiAgICB0aGlzLnNjb3BlXy4kb24oJyRkZXN0cm95JywgKCkgPT4ge1xuICAgICAgJCh3aW5kb3cpXG4gICAgICAgICAgLm9mZignY3V0JywgZGlnZXN0ZWRDdXRIYW5kbGVyXylcbiAgICAgICAgICAub2ZmKCdjb3B5JywgZGlnZXN0ZWRDb3B5SGFuZGxlcl8pXG4gICAgICAgICAgLm9mZigncGFzdGUnLCBkaWdlc3RlZFBhc3RlSGFuZGxlcl8pO1xuICAgIH0pO1xuICB9XG5cbiAgc2V0dXBLZXlib2FyZEFuZFVubG9hZEV2ZW50c18oKSB7XG4gICAgbGV0IGtleWRvd25IYW5kbGVyXyA9IGV2ZW50ID0+IHtcbiAgICAgIC8vIGRlbGV0ZS9iYWNrc3BhY2VcbiAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50Lm1hdGNoZXMoJ2lucHV0JykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudC5rZXlDb2RlID09IDMyKSB7XG4gICAgICAgIC8vIHNwYWNlYmFyXG4gICAgICAgIHRoaXMuYWxsb3dQbGF5QW5pbWF0ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuc3R1ZGlvU3RhdGVfLnBsYXlpbmcgPSAhdGhpcy5zdHVkaW9TdGF0ZV8ucGxheWluZztcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gOCkge1xuICAgICAgICAvLyBkZWxldGUga2V5XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIGluIGNhc2UgdGhlcmUncyBhIEpTIGVycm9yLCBuZXZlciBuYXZpZ2F0ZSBhd2F5XG4gICAgICAgIHRoaXMuZGVsZXRlU2VsZWN0ZWRMYXllcnNfKCk7XG4gICAgICAgIHRoaXMuZGVsZXRlU2VsZWN0ZWRBbmltYXRpb25CbG9ja3NfKCk7XG4gICAgICAgIHRoaXMuZGVsZXRlU2VsZWN0ZWRBbmltYXRpb25zXygpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSAyNykge1xuICAgICAgICAvLyBlc2NhcGUga2V5XG4gICAgICAgIGlmICh0aGlzLnByZXZpZXdNb2RlKSB7XG4gICAgICAgICAgdGhpcy5wcmV2aWV3TW9kZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgfSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09IFwiUFwiLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgLy8gcHJldmlldyBtb2RlIChQIGtleSlcbiAgICAgICAgdGhpcy5wcmV2aWV3TW9kZSA9ICF0aGlzLnByZXZpZXdNb2RlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSBcIlJcIi5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgIC8vIHJld2luZCAoUiBrZXkpXG4gICAgICAgIHRoaXMucmV3aW5kKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgfSBlbHNlIGlmIChldmVudC5tZXRhS2V5ICYmIGV2ZW50LmtleUNvZGUgPT0gXCJaXCIuY2hhckNvZGVBdCgwKSkge1xuICAgICAgICAvLyB1bmRvL3JlZG8gKFoga2V5KVxuICAgICAgICBldmVudC5zaGlmdEtleVxuICAgICAgICAgICAgPyB0aGlzLnN0dWRpb1N0YXRlXy50cnlSZWRvKClcbiAgICAgICAgICAgIDogdGhpcy5zdHVkaW9TdGF0ZV8udHJ5VW5kbygpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQubWV0YUtleSAmJiBldmVudC5rZXlDb2RlID09IFwiR1wiLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgLy8gZ3JvdXAvdW5ncm91cCAoRyBrZXkpXG4gICAgICAgIGV2ZW50LnNoaWZ0S2V5XG4gICAgICAgICAgICA/IHRoaXMudW5ncm91cFNlbGVjdGVkTGF5ZXJzXygpXG4gICAgICAgICAgICA6IHRoaXMuZ3JvdXBTZWxlY3RlZExheWVyc18oKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gMTg3XG4gICAgICAgICAgICAgIHx8IGV2ZW50LmtleUNvZGUgPT0gMTg5XG4gICAgICAgICAgICAgIHx8IGV2ZW50LmtleUNvZGUgPT0gXCIwXCIuY2hhckNvZGVBdCgwKSkge1xuICAgICAgICAvLyAtLysvMCBrZXlzIHRvIGNoYW5nZSBwbGF5YmFjayBzcGVlZFxuICAgICAgICBpZiAodGhpcy5zdHVkaW9TdGF0ZV8ucGxheWluZykge1xuICAgICAgICAgIHRoaXMuc3R1ZGlvU3RhdGVfLnBsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSBcIjBcIi5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgICAgICB0aGlzLnN0dWRpb1N0YXRlXy5wbGF5YmFja1NwZWVkID0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHNwZWVkVXAgPSAhIShldmVudC5rZXlDb2RlID09IDE4Nyk7XG4gICAgICAgICAgICBsZXQgY3VycmVudEluZGV4ID0gUExBWUJBQ0tfU1BFRURTLmluZGV4T2YodGhpcy5zdHVkaW9TdGF0ZV8ucGxheWJhY2tTcGVlZCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudEluZGV4IDwgMCkge1xuICAgICAgICAgICAgICB0aGlzLnN0dWRpb1N0YXRlXy5wbGF5YmFja1NwZWVkID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuc3R1ZGlvU3RhdGVfLnBsYXliYWNrU3BlZWQgPSBQTEFZQkFDS19TUEVFRFNbXG4gICAgICAgICAgICAgICAgICBNYXRoVXRpbC5jb25zdHJhaW4oXG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudEluZGV4ICsgKHNwZWVkVXAgPyAxIDogLTEpLFxuICAgICAgICAgICAgICAgICAgICAgIDAsIFBMQVlCQUNLX1NQRUVEUy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zdHVkaW9TdGF0ZV8ucGxheWluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsZXQgZGlnZXN0ZWRLZXlkb3duSGFuZGxlcl8gPSBldmVudCA9PiB0aGlzLnNjb3BlXy4kYXBwbHkoKCkgPT4ga2V5ZG93bkhhbmRsZXJfKGV2ZW50KSk7XG5cbiAgICBsZXQgYmVmb3JlVW5sb2FkSGFuZGxlcl8gPSBldmVudCA9PiB7XG4gICAgICBpZiAodGhpcy5zdHVkaW9TdGF0ZV8uZGlydHkgJiYgIURFQlVHKSB7XG4gICAgICAgIHJldHVybiAnWW91XFwndmUgbWFkZSBjaGFuZ2VzIGJ1dCBoYXZlblxcJ3Qgc2F2ZWQuICcgK1xuICAgICAgICAgICAgICAgJ0FyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBuYXZpZ2F0ZSBhd2F5Pyc7XG4gICAgICB9XG4gICAgfTtcblxuICAgICQod2luZG93KVxuICAgICAgICAub24oJ2tleWRvd24nLCBkaWdlc3RlZEtleWRvd25IYW5kbGVyXylcbiAgICAgICAgLm9uKCdiZWZvcmV1bmxvYWQnLCBiZWZvcmVVbmxvYWRIYW5kbGVyXyk7XG5cbiAgICB0aGlzLnNjb3BlXy4kb24oJyRkZXN0cm95JywgKCkgPT4ge1xuICAgICAgJCh3aW5kb3cpXG4gICAgICAgICAgLm9mZigna2V5ZG93bicsIGRpZ2VzdGVkS2V5ZG93bkhhbmRsZXJfKVxuICAgICAgICAgIC5vZmYoJ2JlZm9yZXVubG9hZCcsIGJlZm9yZVVubG9hZEhhbmRsZXJfKTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldCBwcmV2aWV3Q2FudmFzQ2xvc2VCdXR0b25UaGVtZSgpIHtcbiAgICByZXR1cm4gQ29sb3JVdGlsLmlzQW5kcm9pZENvbG9yRGFyayh0aGlzLnN0dWRpb1N0YXRlXy5hcnR3b3JrLmNhbnZhc0NvbG9yKVxuICAgICAgICA/ICdkYXJrJ1xuICAgICAgICA6ICdkZWZhdWx0JztcbiAgfVxuXG4gIGdldCBwcmV2aWV3Q2FudmFzQ29sb3IoKSB7XG4gICAgcmV0dXJuIENvbG9yVXRpbC5hbmRyb2lkVG9Dc3NDb2xvcih0aGlzLnN0dWRpb1N0YXRlXy5hcnR3b3JrLmNhbnZhc0NvbG9yKTtcbiAgfVxuXG4gIGlzUGxheWluZygpIHtcbiAgICByZXR1cm4gdGhpcy5zdHVkaW9TdGF0ZV8ucGxheWluZztcbiAgfVxuXG4gIHRvZ2dsZVBsYXlpbmcoKSB7XG4gICAgdGhpcy5hbGxvd1BsYXlBbmltYXRlID0gdHJ1ZTtcbiAgICB0aGlzLnN0dWRpb1N0YXRlXy5wbGF5aW5nID0gIXRoaXMuc3R1ZGlvU3RhdGVfLnBsYXlpbmc7XG4gIH1cblxuICByZXdpbmQoKSB7XG4gICAgdGhpcy5zdHVkaW9TdGF0ZV8ucGxheWluZyA9IGZhbHNlO1xuICAgIHRoaXMudGltZW91dF8oKCkgPT4gdGhpcy5zdHVkaW9TdGF0ZV8uYWN0aXZlVGltZSA9IDAsIDApO1xuICB9XG5cbiAgcmVzdGFydFBsYXliYWNrKCkge1xuICAgIHRoaXMuc3R1ZGlvU3RhdGVfLmFjdGl2ZVRpbWUgPSAwO1xuICAgIHRoaXMuc3R1ZGlvU3RhdGVfLnBsYXlpbmcgPSB0cnVlO1xuICB9XG5cbiAgb25Ecm9wRmlsZShmaWxlSW5mbykge1xuICAgIGxldCBjb25maXJtXyA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnN0dWRpb1N0YXRlXy5kaXJ0eSAmJiAhREVCVUcpIHtcbiAgICAgICAgaWYgKCF3aW5kb3cuY29uZmlybSgnWW91XFwndmUgbWFkZSBjaGFuZ2VzIGJ1dCBoYXZlblxcJ3Qgc2F2ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1JlYWxseSBsb2FkIHRoZSBkcm9wcGVkIGZpbGU/JykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIGlmIChmaWxlSW5mby50eXBlID09ICdhcHBsaWNhdGlvbi9qc29uJyB8fCBmaWxlSW5mby5uYW1lLm1hdGNoKC9cXC5pY29uYW5pbSQvKSkge1xuICAgICAgZ2EoJ3NlbmQnLCAnZXZlbnQnLCAnZmlsZScsICdvcGVuRmlsZS5kcmFnRHJvcCcpO1xuICAgICAgaWYgKCFjb25maXJtXygpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IGpzb25PYmogPSBKU09OLnBhcnNlKGZpbGVJbmZvLnRleHRDb250ZW50KTtcbiAgICAgIHRoaXMuc3R1ZGlvU3RhdGVfLmxvYWQoe1xuICAgICAgICBhcnR3b3JrOiBuZXcgQXJ0d29yayhqc29uT2JqLmFydHdvcmspLFxuICAgICAgICBhbmltYXRpb25zOiBqc29uT2JqLmFuaW1hdGlvbnMubWFwKGFuaW0gPT4gbmV3IEFuaW1hdGlvbihhbmltKSlcbiAgICAgIH0pO1xuXG4gICAgfSBlbHNlIGlmIChmaWxlSW5mby50eXBlID09ICdpbWFnZS9zdmcreG1sJykge1xuICAgICAgbGV0IGFydHdvcmsgPSBTdmdMb2FkZXIubG9hZEFydHdvcmtGcm9tU3ZnU3RyaW5nKGZpbGVJbmZvLnRleHRDb250ZW50KTtcblxuICAgICAgbGV0IHN0YXJ0RnJvbVNjcmF0Y2hfID0gKCkgPT4ge1xuICAgICAgICBpZiAoIWNvbmZpcm1fKCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBnYSgnc2VuZCcsICdldmVudCcsICdmaWxlJywgJ2ltcG9ydFNWRy5zdGFydEZyb21TY3JhdGNoLmRyYWdEcm9wJyk7XG4gICAgICAgIHRoaXMuc3R1ZGlvU3RhdGVfLmxvYWQoe2FydHdvcmt9KTtcbiAgICAgIH07XG5cbiAgICAgIGlmICghdGhpcy5zdHVkaW9TdGF0ZV8uYXJ0d29yay5sYXllcnMubGVuZ3RoKSB7XG4gICAgICAgIHN0YXJ0RnJvbVNjcmF0Y2hfKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5tZERpYWxvZ18uc2hvdyh7XG4gICAgICAgIHRpdGxlOiAnQXR0ZW50aW9uJyxcbiAgICAgICAgdGVtcGxhdGVVcmw6ICdwYWdlcy9zdHVkaW8vZGlhbG9nLXN2Zy1kcm9wLmh0bWwnLFxuICAgICAgICBjbGlja091dHNpZGVUb0Nsb3NlOiB0cnVlLFxuICAgICAgICBjb250cm9sbGVyOiAoJHNjb3BlLCAkbWREaWFsb2cpID0+IHtcbiAgICAgICAgICAkc2NvcGUuY2xvc2VEaWFsb2cgPSAoKSA9PiAkbWREaWFsb2cuaGlkZSgpO1xuXG4gICAgICAgICAgJHNjb3BlLnN0YXJ0RnJvbVNjcmF0Y2ggPSAoKSA9PiB7XG4gICAgICAgICAgICBzdGFydEZyb21TY3JhdGNoXygpO1xuICAgICAgICAgICAgJG1kRGlhbG9nLmhpZGUoKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgJHNjb3BlLmFkZExheWVycyA9ICgpID0+IHtcbiAgICAgICAgICAgIGdhKCdzZW5kJywgJ2V2ZW50JywgJ2ZpbGUnLCAnaW1wb3J0U1ZHLmFkZExheWVycy5kcmFnRHJvcCcpO1xuICAgICAgICAgICAgdGhpcy5zdHVkaW9TdGF0ZV8uYWRkTGF5ZXJzKGFydHdvcmsubGF5ZXJzKTtcbiAgICAgICAgICAgICRtZERpYWxvZy5oaWRlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChmaWxlSW5mby50eXBlID09PSAnYXBwbGljYXRpb24veG1sJyB8fCBmaWxlSW5mby50eXBlID09PSAndGV4dC94bWwnKSB7XG4gICAgICBnYSgnc2VuZCcsICdldmVudCcsICdmaWxlJywgJ2ltcG9ydFZELmRyYWdEcm9wJyk7XG4gICAgICBpZiAoIWNvbmZpcm1fKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGFydHdvcmsgPSBWZWN0b3JEcmF3YWJsZUxvYWRlci5sb2FkQXJ0d29ya0Zyb21YbWxTdHJpbmcoZmlsZUluZm8udGV4dENvbnRlbnQpO1xuICAgICAgdGhpcy5zdHVkaW9TdGF0ZV8ubG9hZCh7YXJ0d29ya30pO1xuICAgIH1cbiAgfVxuXG4gIGRlbGV0ZVNlbGVjdGVkTGF5ZXJzXygpIHtcbiAgICBpZiAodGhpcy5zdHVkaW9TdGF0ZV8uZmlyc3RTZWxlY3RlZEl0ZW0gaW5zdGFuY2VvZiBCYXNlTGF5ZXIpIHtcbiAgICAgIC8vIGRlbGV0ZSBsYXllcnNcbiAgICAgIHRoaXMuc3R1ZGlvU3RhdGVfLmRlbGV0ZUxheWVycyh0aGlzLnN0dWRpb1N0YXRlXy5zZWxlY3RlZExheWVycyk7XG4gICAgICB0aGlzLnN0dWRpb1N0YXRlXy5zZWxlY3Rpb24gPSBudWxsO1xuICAgICAgdGhpcy5zdHVkaW9TdGF0ZV8uYXJ0d29ya0NoYW5nZWQoKTtcbiAgICAgIHRoaXMuc3R1ZGlvU3RhdGVfLmFuaW1DaGFuZ2VkKCk7XG4gICAgfVxuICB9XG5cbiAgZGVsZXRlU2VsZWN0ZWRBbmltYXRpb25CbG9ja3NfKCkge1xuICAgIGlmICh0aGlzLnN0dWRpb1N0YXRlXy5maXJzdFNlbGVjdGVkSXRlbSBpbnN0YW5jZW9mIEFuaW1hdGlvbkJsb2NrKSB7XG4gICAgICAvLyBkZWxldGUgYW5pbWF0aW9uc1xuICAgICAgbGV0IHNlbGVjdGVkQW5pbWF0aW9uQmxvY2tzID0gdGhpcy5zdHVkaW9TdGF0ZV8uc2VsZWN0ZWRBbmltYXRpb25CbG9ja3M7XG4gICAgICB0aGlzLnN0dWRpb1N0YXRlXy5hbmltYXRpb25zLmZvckVhY2goYW5pbWF0aW9uID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGFuaW1hdGlvbi5ibG9ja3MubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICBsZXQgYmxvY2sgPSBhbmltYXRpb24uYmxvY2tzW2ldO1xuICAgICAgICAgIGlmIChzZWxlY3RlZEFuaW1hdGlvbkJsb2Nrcy5pbmRleE9mKGJsb2NrKSA+PSAwKSB7XG4gICAgICAgICAgICBhbmltYXRpb24uYmxvY2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnN0dWRpb1N0YXRlXy5zZWxlY3Rpb24gPSBudWxsO1xuICAgICAgdGhpcy5zdHVkaW9TdGF0ZV8uYW5pbUNoYW5nZWQoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBkZWxldGVTZWxlY3RlZEFuaW1hdGlvbnNfKCkge1xuICAgIGlmICh0aGlzLnN0dWRpb1N0YXRlXy5maXJzdFNlbGVjdGVkSXRlbSBpbnN0YW5jZW9mIEFuaW1hdGlvbikge1xuICAgICAgLy8gZGVsZXRlIGFuaW1hdGlvbnNcbiAgICAgIHRoaXMuc3R1ZGlvU3RhdGVfLmFjdGl2ZUFuaW1hdGlvbiA9IG51bGw7XG4gICAgICB0aGlzLnN0dWRpb1N0YXRlXy5hbmltYXRpb25zID0gdGhpcy5zdHVkaW9TdGF0ZV8uYW5pbWF0aW9ucy5maWx0ZXIoXG4gICAgICAgICAgYW5pbWF0aW9uID0+IGFuaW1hdGlvbiAhPT0gdGhpcy5zdHVkaW9TdGF0ZV8uZmlyc3RTZWxlY3RlZEl0ZW0pO1xuICAgICAgdGhpcy5zdHVkaW9TdGF0ZV8uc2VsZWN0aW9uID0gbnVsbDtcbiAgICAgIHRoaXMuc3R1ZGlvU3RhdGVfLmFuaW1DaGFuZ2VkKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZ3JvdXBPclVuZ3JvdXBTZWxlY3RlZExheWVyc18oc2hvdWxkR3JvdXApIHtcbiAgICBpZiAodGhpcy5zdHVkaW9TdGF0ZV8uc2VsZWN0ZWRMYXllcnMubGVuZ3RoKSB7XG4gICAgICAvLyBzb3J0IHNlbGVjdGVkIGxheWVycyBieSBvcmRlciB0aGV5IGFwcGVhciBpbiB0cmVlXG4gICAgICBsZXQgdGVtcFNlbExheWVycyA9IHRoaXMuc3R1ZGlvU3RhdGVfLnNlbGVjdGVkTGF5ZXJzLnNsaWNlKCk7XG4gICAgICBsZXQgc2VsTGF5ZXJPcmRlcnMgPSB7fTtcbiAgICAgIGxldCBuID0gMDtcbiAgICAgIHRoaXMuc3R1ZGlvU3RhdGVfLmFydHdvcmsud2FsayhsYXllciA9PiB7XG4gICAgICAgIGlmICh0ZW1wU2VsTGF5ZXJzLmluZGV4T2YobGF5ZXIpID49IDApIHtcbiAgICAgICAgICBzZWxMYXllck9yZGVyc1tsYXllci5pZF0gPSBuO1xuICAgICAgICAgICsrbjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0ZW1wU2VsTGF5ZXJzLnNvcnQoKGEsIGIpID0+IHNlbExheWVyT3JkZXJzW2EuaWRdIC0gc2VsTGF5ZXJPcmRlcnNbYi5pZF0pO1xuXG4gICAgICAvLyBlaXRoZXIgZ3JvdXAgb3IgdW5ncm91cCBzZWxlY3Rpb25cbiAgICAgIGlmIChzaG91bGRHcm91cCkge1xuICAgICAgICAvLyBncm91cCBzZWxlY3RlZCBsYXllcnNcblxuICAgICAgICAvLyByZW1vdmUgYW55IGxheWVycyB0aGF0IGFyZSBkZXNjZW5kYW50cyBvZiBvdGhlciBzZWxlY3RlZCBsYXllcnMsXG4gICAgICAgIC8vIGFuZCByZW1vdmUgdGhlIGFydHdvcmsgaXRzZWxmIGlmIHNlbGVjdGVkXG4gICAgICAgIHRlbXBTZWxMYXllcnMgPSB0ZW1wU2VsTGF5ZXJzLmZpbHRlcihsYXllciA9PiB7XG4gICAgICAgICAgaWYgKGxheWVyIGluc3RhbmNlb2YgQXJ0d29yaykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBwID0gbGF5ZXIucGFyZW50O1xuICAgICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICBpZiAodGVtcFNlbExheWVycy5pbmRleE9mKHApID49IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcCA9IHAucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCF0ZW1wU2VsTGF5ZXJzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmQgZGVzdGluYXRpb24gcGFyZW50IGFuZCBpbnNlcnRpb24gcG9pbnRcbiAgICAgICAgbGV0IGZpcnN0U2VsZWN0ZWRMYXllclBhcmVudCA9IHRlbXBTZWxMYXllcnNbMF0ucGFyZW50O1xuICAgICAgICBsZXQgZmlyc3RTZWxlY3RlZExheWVySW5kZXhJblBhcmVudFxuICAgICAgICAgICAgPSBmaXJzdFNlbGVjdGVkTGF5ZXJQYXJlbnQubGF5ZXJzLmluZGV4T2YodGVtcFNlbExheWVyc1swXSk7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGFsbCBzZWxlY3RlZCBpdGVtcyBmcm9tIHRoZWlyIHBhcmVudHMgYW5kXG4gICAgICAgIC8vIG1vdmUgdGhlbSBpbnRvIGEgbmV3IHBhcmVudFxuICAgICAgICBsZXQgbmV3R3JvdXAgPSBuZXcgTGF5ZXJHcm91cCh7XG4gICAgICAgICAgaWQ6IHRoaXMuc3R1ZGlvU3RhdGVfLmdldFVuaXF1ZUxheWVySWQoJ2dyb3VwJyksXG4gICAgICAgICAgbGF5ZXJzOiB0ZW1wU2VsTGF5ZXJzXG4gICAgICAgIH0pO1xuICAgICAgICB0ZW1wU2VsTGF5ZXJzLmZvckVhY2gobGF5ZXIgPT5cbiAgICAgICAgICAgIGxheWVyLnBhcmVudC5sYXllcnMuc3BsaWNlKGxheWVyLnBhcmVudC5sYXllcnMuaW5kZXhPZihsYXllciksIDEpKTtcbiAgICAgICAgbmV3R3JvdXAucGFyZW50ID0gZmlyc3RTZWxlY3RlZExheWVyUGFyZW50O1xuICAgICAgICBmaXJzdFNlbGVjdGVkTGF5ZXJQYXJlbnQubGF5ZXJzLnNwbGljZShmaXJzdFNlbGVjdGVkTGF5ZXJJbmRleEluUGFyZW50LCAwLCBuZXdHcm91cCk7XG5cbiAgICAgICAgdGhpcy5zdHVkaW9TdGF0ZV8uYXJ0d29ya0NoYW5nZWQoKTtcbiAgICAgICAgdGhpcy5zdHVkaW9TdGF0ZV8uYW5pbUNoYW5nZWQoKTtcbiAgICAgICAgdGhpcy5zdHVkaW9TdGF0ZV8uc2VsZWN0aW9uID0gW25ld0dyb3VwXTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdW5ncm91cCBzZWxlY3RlZCBsYXllciBncm91cHNcbiAgICAgICAgbGV0IG5ld1NlbGVjdGVkTGF5ZXJzID0gW107XG4gICAgICAgIHRlbXBTZWxMYXllcnNcbiAgICAgICAgICAgIC5maWx0ZXIobGF5ZXIgPT4gbGF5ZXIgaW5zdGFuY2VvZiBMYXllckdyb3VwICYmICEobGF5ZXIgaW5zdGFuY2VvZiBBcnR3b3JrKSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGxheWVyR3JvdXAgPT4ge1xuICAgICAgICAgICAgICAvLyBtb3ZlIGNoaWxkcmVuIGludG8gcGFyZW50XG4gICAgICAgICAgICAgIGxldCBwYXJlbnQgPSBsYXllckdyb3VwLnBhcmVudDtcbiAgICAgICAgICAgICAgbGV0IGluZGV4SW5QYXJlbnQgPSBNYXRoLm1heCgwLCBwYXJlbnQubGF5ZXJzLmluZGV4T2YobGF5ZXJHcm91cCkpO1xuICAgICAgICAgICAgICBwYXJlbnQubGF5ZXJzLnNwbGljZShpbmRleEluUGFyZW50LCAwLCAuLi5sYXllckdyb3VwLmxheWVycyk7XG4gICAgICAgICAgICAgIG5ld1NlbGVjdGVkTGF5ZXJzLnNwbGljZSgwLCAwLCAuLi5sYXllckdyb3VwLmxheWVycyk7XG4gICAgICAgICAgICAgIGxheWVyR3JvdXAubGF5ZXJzLmZvckVhY2gobGF5ZXIgPT4gbGF5ZXIucGFyZW50ID0gcGFyZW50KTtcbiAgICAgICAgICAgICAgbGF5ZXJHcm91cC5sYXllcnMgPSBbXTtcblxuICAgICAgICAgICAgICAvLyBkZWxldGUgdGhlIHBhcmVudFxuICAgICAgICAgICAgICB0aGlzLnN0dWRpb1N0YXRlXy5kZWxldGVMYXllcnMobGF5ZXJHcm91cCk7XG5cbiAgICAgICAgICAgICAgdGhpcy5zdHVkaW9TdGF0ZV8uYXJ0d29ya0NoYW5nZWQoKTtcbiAgICAgICAgICAgICAgdGhpcy5zdHVkaW9TdGF0ZV8uYW5pbUNoYW5nZWQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0dWRpb1N0YXRlXy5zZWxlY3Rpb24gPSBuZXdTZWxlY3RlZExheWVycztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBncm91cFNlbGVjdGVkTGF5ZXJzXygpIHtcbiAgICB0aGlzLmdyb3VwT3JVbmdyb3VwU2VsZWN0ZWRMYXllcnNfKHRydWUpO1xuICB9XG5cbiAgdW5ncm91cFNlbGVjdGVkTGF5ZXJzXygpIHtcbiAgICB0aGlzLmdyb3VwT3JVbmdyb3VwU2VsZWN0ZWRMYXllcnNfKGZhbHNlKTtcbiAgfVxufVxuXG5cbmFuZ3VsYXIubW9kdWxlKCdBVkRTdHVkaW8nKS5jb250cm9sbGVyKCdTdHVkaW9DdHJsJywgU3R1ZGlvQ3RybCk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtkZWZhdWx0IGFzIHppcH0gZnJvbSAnemlwanMtYnJvd3NlcmlmeSc7XG5cbmltcG9ydCB7QXJ0d29yaywgQW5pbWF0aW9uLCBBbmltYXRpb25CbG9jaywgQmFzZUxheWVyfSBmcm9tICdtb2RlbCc7XG5pbXBvcnQge0FuaW1hdGlvblJlbmRlcmVyfSBmcm9tICdBbmltYXRpb25SZW5kZXJlcic7XG5pbXBvcnQge0F2ZFNlcmlhbGl6ZXJ9IGZyb20gJ0F2ZFNlcmlhbGl6ZXInO1xuaW1wb3J0IHtNb2RlbFV0aWx9IGZyb20gJ01vZGVsVXRpbCc7XG5cblxuY29uc3QgQ0hBTkdFU19UQUcgPSAnJCRzdHVkaW9TdGF0ZTo6Q0hBTkdFUyc7XG5cbmNvbnN0IE1BWF9VTkRPX1NMT1RTID0gMTA7XG5jb25zdCBVTkRPX0RFQk9VTkNFX01TID0gMTAwMDtcblxuXG5jb25zdCBCTEFOS19BUlRXT1JLID0ge1xuICBpZDogbmV3IEFydHdvcmsoKS50eXBlSWRQcmVmaXgsXG4gIHdpZHRoOiAyNCxcbiAgaGVpZ2h0OiAyNCxcbiAgbGF5ZXJzOiBbXG4gIF1cbn07XG5cblxuY29uc3QgQkxBTktfQU5JTUFUSU9OID0ge1xuICBpZDogbmV3IEFuaW1hdGlvbigpLnR5cGVJZFByZWZpeCxcbiAgZHVyYXRpb246IDMwMCxcbn07XG5cblxuY2xhc3MgU3R1ZGlvU3RhdGVTZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IoJHJvb3RTY29wZSwgJHRpbWVvdXQpIHtcbiAgICB0aGlzLnJvb3RTY29wZV8gPSAkcm9vdFNjb3BlO1xuICAgIHRoaXMudGltZW91dF8gPSAkdGltZW91dDtcbiAgICB0aGlzLnJlYnVpbGRSZW5kZXJlcl8oKTtcbiAgfVxuXG4gIGxvYWQob2JqKSB7XG4gICAgdGhpcy5hcnR3b3JrXyA9IG9iai5hcnR3b3JrO1xuICAgIHRoaXMuYW5pbWF0aW9uc18gPSBvYmouYW5pbWF0aW9ucyB8fCBbbmV3IEFuaW1hdGlvbihCTEFOS19BTklNQVRJT04pXTtcblxuICAgIHRoaXMudW5kb1N0YXRlc18gPSBbXTtcbiAgICB0aGlzLmN1cnJlbnRVbmRvU3RhdGVfID0gLTE7XG4gICAgdGhpcy5kZWJvdW5jZWRTYXZlVW5kb1Byb21pc2VfID0gbnVsbDtcblxuICAgIHRoaXMuYWN0aXZlVGltZV8gPSAwO1xuICAgIHRoaXMucGxheWluZ18gPSBmYWxzZTtcbiAgICB0aGlzLnNlbGVjdGlvbl8gPSBudWxsO1xuXG4gICAgdGhpcy5hY3RpdmVBbmltYXRpb25fID0gdGhpcy5hbmltYXRpb25zXy5sZW5ndGggPyB0aGlzLmFuaW1hdGlvbnNfWzBdIDogbnVsbDtcblxuICAgIHRoaXMucmVidWlsZFJlbmRlcmVyXygpO1xuXG4gICAgdGhpcy5icm9hZGNhc3RDaGFuZ2VzXyh7XG4gICAgICBhcnR3b3JrOiB0cnVlLFxuICAgICAgYW5pbWF0aW9uczogdHJ1ZSxcbiAgICAgIHNlbGVjdGlvbjogdHJ1ZSxcbiAgICAgIGFjdGl2ZVRpbWU6IHRydWUsXG4gICAgICBwbGF5aW5nOiB0cnVlLFxuICAgICAgaXNSZXNldDogdHJ1ZVxuICAgIH0pO1xuXG4gICAgdGhpcy5kaXJ0eV8gPSBmYWxzZTtcbiAgICB0aGlzLnNhdmVVbmRvU3RhdGVfKCk7XG4gIH1cblxuICBnZXQgcGxheWJhY2tTcGVlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF5YmFja1NwZWVkXyB8fCAxO1xuICB9XG5cbiAgc2V0IHBsYXliYWNrU3BlZWQoc3BlZWQpIHtcbiAgICB0aGlzLnBsYXliYWNrU3BlZWRfID0gc3BlZWQ7XG4gIH1cblxuICBnZXQgcGxheWluZygpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF5aW5nXztcbiAgfVxuXG4gIHNldCBwbGF5aW5nKHBsYXlpbmcpIHtcbiAgICB0aGlzLnBsYXlpbmdfID0gcGxheWluZztcbiAgICB0aGlzLmJyb2FkY2FzdENoYW5nZXNfKHtwbGF5aW5nOiB0cnVlfSk7XG4gIH1cblxuICBnZXQgYXJ0d29yaygpIHtcbiAgICAvLyBpZiAodGhpcy5jdXJyZW50VW5kb1N0YXRlXyA+PSAwKSB7XG4gICAgLy8gICByZXR1cm4gdGhpcy51bmRvU3RhdGVzX1t0aGlzLmN1cnJlbnRVbmRvU3RhdGVfXS5hcnR3b3JrO1xuICAgIC8vIH1cblxuICAgIHJldHVybiB0aGlzLmFydHdvcmtfO1xuICB9XG5cbiAgc2V0IGFydHdvcmsoYXJ0d29yaykge1xuICAgIHRoaXMuYXJ0d29ya18gPSBhcnR3b3JrO1xuICAgIHRoaXMuYXJ0d29ya0NoYW5nZWQoe25vVW5kbzp0cnVlfSk7XG4gIH1cblxuICBnZXQgYW5pbWF0aW9ucygpIHtcbiAgICAvLyBpZiAodGhpcy5jdXJyZW50VW5kb1N0YXRlXyA+PSAwKSB7XG4gICAgLy8gICByZXR1cm4gdGhpcy51bmRvU3RhdGVzX1t0aGlzLmN1cnJlbnRVbmRvU3RhdGVfXS5hbmltYXRpb25zO1xuICAgIC8vIH1cblxuICAgIHJldHVybiAodGhpcy5hbmltYXRpb25zXyA9IHRoaXMuYW5pbWF0aW9uc18gfHwgW10pO1xuICB9XG5cbiAgc2V0IGFuaW1hdGlvbnMoYW5pbWF0aW9ucykge1xuICAgIHRoaXMuYW5pbWF0aW9uc18gPSBhbmltYXRpb25zO1xuICAgIGlmIChhbmltYXRpb25zLmluZGV4T2YodGhpcy5hY3RpdmVBbmltYXRpb24pIDwgMCkge1xuICAgICAgdGhpcy5hY3RpdmVBbmltYXRpb24gPSBhbmltYXRpb25zWzBdO1xuICAgIH1cbiAgICB0aGlzLmFuaW1DaGFuZ2VkKCk7XG4gIH1cblxuICBhbmltQ2hhbmdlZChvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmRpcnR5XyA9IHRydWU7XG4gICAgdGhpcy5yZWJ1aWxkUmVuZGVyZXJfKCk7XG4gICAgdGhpcy5icm9hZGNhc3RDaGFuZ2VzXyh7YW5pbWF0aW9uczogdHJ1ZX0pO1xuICAgIGlmICghb3B0aW9ucy5ub1VuZG8pIHtcbiAgICAgIHRoaXMuc2F2ZVVuZG9TdGF0ZV8oe2RlYm91bmNlOnRydWV9KTtcbiAgICB9XG4gIH1cblxuICBhcnR3b3JrQ2hhbmdlZChvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmRpcnR5XyA9IHRydWU7XG4gICAgdGhpcy5yZWJ1aWxkUmVuZGVyZXJfKCk7XG4gICAgdGhpcy5icm9hZGNhc3RDaGFuZ2VzXyh7YXJ0d29yazogdHJ1ZX0pO1xuICAgIGlmICghb3B0aW9ucy5ub1VuZG8pIHtcbiAgICAgIHRoaXMuc2F2ZVVuZG9TdGF0ZV8oe2RlYm91bmNlOnRydWV9KTtcbiAgICB9XG4gIH1cblxuICBzYXZlVW5kb1N0YXRlXyhvcHRpb25zID0ge30pIHtcbiAgICAvLyBpZiB0aGVyZSdzIGEgcGVuZGluZyBkZWJvdW5jZSwgZGVmZXIgaXRcbiAgICBpZiAodGhpcy5kZWJvdW5jZWRTYXZlVW5kb1Byb21pc2VfKSB7XG4gICAgICB0aGlzLnRpbWVvdXRfLmNhbmNlbCh0aGlzLmRlYm91bmNlZFNhdmVVbmRvUHJvbWlzZV8pO1xuICAgICAgdGhpcy51bmRvU3RhdGVzXy5zaGlmdCgpO1xuICAgIH1cblxuICAgIC8vIHN0ZXAgMTogc3RhZ2UgYSBuZXcgc2xvdCBmb3IgdGhlIHVuZG8gc3RhdGVcbiAgICBpZiAodGhpcy5jdXJyZW50VW5kb1N0YXRlXyA+IDApIHtcbiAgICAgIC8vIGN1cnJlbnRseSBpbiBhbiB1bmRvIHN0YXRlLCBibG93IGF3YXkgYWxsIHVuZG8gc3RhdGVzIGFmdGVyIHRoaXMgb25lXG4gICAgICB0aGlzLnVuZG9TdGF0ZXNfLnNwbGljZSgwLCB0aGlzLmN1cnJlbnRVbmRvU3RhdGVfKTtcbiAgICB9XG5cbiAgICB0aGlzLnVuZG9TdGF0ZXNfLnVuc2hpZnQobnVsbCk7XG4gICAgdGhpcy5jdXJyZW50VW5kb1N0YXRlXyA9IDA7XG5cbiAgICAvLyBjYXAgdGhlIG1heCBudW1iZXIgb2YgdW5kbyBzdGF0ZXNcbiAgICB0aGlzLnVuZG9TdGF0ZXNfLnNwbGljZShNQVhfVU5ET19TTE9UUywgdGhpcy51bmRvU3RhdGVzXy5sZW5ndGggLSBNQVhfVU5ET19TTE9UUyk7XG5cbiAgICAvLyBzdGVwIDI6IGVpdGhlciBjb21taXQgdGhlIGN1cnJlbnQgc3RhdGUgcmlnaHQgYXdheSwgb3IgZGVib3VuY2VcbiAgICAvLyAoY29tbWl0IHRoZSBjdXJyZW50IHN0YXRlIGFmdGVyIE4gbWlsbGlzZWMgb2YgaW5hY3Rpdml0eSlcbiAgICBpZiAob3B0aW9ucy5kZWJvdW5jZSkge1xuICAgICAgdGhpcy5kZWJvdW5jZWRTYXZlVW5kb1Byb21pc2VfID0gdGhpcy50aW1lb3V0XyhcbiAgICAgICAgICAoKSA9PiB0aGlzLmNvbW1pdFVuZG9TdGF0ZVRvVG9wU2xvdF8oKSwgVU5ET19ERUJPVU5DRV9NUyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29tbWl0VW5kb1N0YXRlVG9Ub3BTbG90XygpO1xuICAgIH1cbiAgfVxuXG4gIGNvbW1pdFVuZG9TdGF0ZVRvVG9wU2xvdF8oKSB7XG4gICAgdGhpcy51bmRvU3RhdGVzX1swXSA9IHtcbiAgICAgIGFydHdvcms6IG5ldyBBcnR3b3JrKHRoaXMuYXJ0d29ya18pLFxuICAgICAgYW5pbWF0aW9uczogKHRoaXMuYW5pbWF0aW9uc18gfHwgW10pLm1hcChhbmltID0+IG5ldyBBbmltYXRpb24oYW5pbSkpLFxuICAgICAgYWN0aXZlQW5pbWF0aW9uSW5kZXg6ICh0aGlzLmFuaW1hdGlvbnNfIHx8IFtdKS5pbmRleE9mKHRoaXMuYWN0aXZlQW5pbWF0aW9uXylcbiAgICB9O1xuICAgIHRoaXMuZGVib3VuY2VkU2F2ZVVuZG9Qcm9taXNlXyA9IG51bGw7XG4gIH1cblxuICByZWFsaXplVW5kb1N0YXRlXygpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLnVuZG9TdGF0ZXNfW3RoaXMuY3VycmVudFVuZG9TdGF0ZV9dO1xuICAgIHRoaXMuYXJ0d29ya18gPSBuZXcgQXJ0d29yayhzdGF0ZS5hcnR3b3JrKTtcbiAgICB0aGlzLmFuaW1hdGlvbnNfID0gc3RhdGUuYW5pbWF0aW9ucy5tYXAoYW5pbSA9PiBuZXcgQW5pbWF0aW9uKGFuaW0pKTtcbiAgICB0aGlzLmFjdGl2ZUFuaW1hdGlvbl8gPSAodGhpcy5hbmltYXRpb25zXy5sZW5ndGggPiAwICYmIHN0YXRlLmFjdGl2ZUFuaW1hdGlvbkluZGV4ID49IDApXG4gICAgICAgID8gdGhpcy5hbmltYXRpb25zX1tzdGF0ZS5hY3RpdmVBbmltYXRpb25JbmRleF1cbiAgICAgICAgOiBudWxsO1xuICAgIHRoaXMuc2VsZWN0aW9uID0gW107XG4gICAgdGhpcy5hcnR3b3JrQ2hhbmdlZCh7bm9VbmRvOnRydWV9KTtcbiAgICB0aGlzLmFuaW1DaGFuZ2VkKHtub1VuZG86dHJ1ZX0pO1xuICB9XG5cbiAgdHJ5VW5kbygpIHtcbiAgICAvLyBpZiB0aGVyZSdzIGEgZGVib3VuY2VkIGNvbW1pdCBvZiB1bmRvIHN0YXRlLCBjb21taXQgaXQgbm93XG4gICAgaWYgKHRoaXMuZGVib3VuY2VkU2F2ZVVuZG9Qcm9taXNlXykge1xuICAgICAgdGhpcy50aW1lb3V0Xy5jYW5jZWwodGhpcy5kZWJvdW5jZWRTYXZlVW5kb1Byb21pc2VfKTtcbiAgICAgIHRoaXMuY29tbWl0VW5kb1N0YXRlVG9Ub3BTbG90XygpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmN1cnJlbnRVbmRvU3RhdGVfIDwgdGhpcy51bmRvU3RhdGVzXy5sZW5ndGggLSAxKSB7XG4gICAgICArK3RoaXMuY3VycmVudFVuZG9TdGF0ZV87XG4gICAgICB0aGlzLnJlYWxpemVVbmRvU3RhdGVfKCk7XG4gICAgfVxuICB9XG5cbiAgdHJ5UmVkbygpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50VW5kb1N0YXRlXyA+IDApIHtcbiAgICAgIC0tdGhpcy5jdXJyZW50VW5kb1N0YXRlXztcbiAgICAgIHRoaXMucmVhbGl6ZVVuZG9TdGF0ZV8oKTtcbiAgICB9XG4gIH1cblxuICBnZXQgZGlydHkoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5kaXJ0eV87XG4gIH1cblxuICBzZXQgZGlydHkoZGlydHkpIHtcbiAgICB0aGlzLmRpcnR5XyA9IGRpcnR5O1xuICB9XG5cbiAgZ2V0IGFuaW1hdGlvblJlbmRlcmVyKCkge1xuICAgIHJldHVybiB0aGlzLmFuaW1hdGlvblJlbmRlcmVyXztcbiAgfVxuXG4gIGdldCBhY3RpdmVBbmltYXRpb24oKSB7XG4gICAgLy8gaWYgKHRoaXMuY3VycmVudFVuZG9TdGF0ZV8gPj0gMCkge1xuICAgIC8vICAgbGV0IGN1cnJlbnRVbmRvU3RhdGUgPSB0aGlzLnVuZG9TdGF0ZXNfW3RoaXMuY3VycmVudFVuZG9TdGF0ZV9dO1xuICAgIC8vICAgcmV0dXJuIGN1cnJlbnRVbmRvU3RhdGUuYW5pbWF0aW9uc1tjdXJyZW50VW5kb1N0YXRlLmFjdGl2ZUFuaW1hdGlvbkluZGV4XTtcbiAgICAvLyB9XG5cbiAgICByZXR1cm4gdGhpcy5hY3RpdmVBbmltYXRpb25fIHx8ICh0aGlzLmFuaW1hdGlvbnMubGVuZ3RoICYmIHRoaXMuYW5pbWF0aW9uc1swXSk7XG4gIH1cblxuICBzZXQgYWN0aXZlQW5pbWF0aW9uKGFjdGl2ZUFuaW1hdGlvbikge1xuICAgIGlmICh0aGlzLmFjdGl2ZUFuaW1hdGlvbl8gPT09IGFjdGl2ZUFuaW1hdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYWN0aXZlQW5pbWF0aW9uXyA9IGFjdGl2ZUFuaW1hdGlvbjtcbiAgICB0aGlzLnJlYnVpbGRSZW5kZXJlcl8oKTtcbiAgICB0aGlzLmJyb2FkY2FzdENoYW5nZXNfKHthY3RpdmVBbmltYXRpb246IHRydWV9KTtcbiAgfVxuXG4gIHJlYnVpbGRSZW5kZXJlcl8oKSB7XG4gICAgdGhpcy5hbmltYXRpb25SZW5kZXJlcl8gPSBudWxsO1xuICAgIGlmICh0aGlzLmFjdGl2ZUFuaW1hdGlvbikge1xuICAgICAgdGhpcy5hbmltYXRpb25SZW5kZXJlcl8gPSBuZXcgQW5pbWF0aW9uUmVuZGVyZXIoXG4gICAgICAgICAgdGhpcy5hcnR3b3JrLFxuICAgICAgICAgIHRoaXMuYWN0aXZlQW5pbWF0aW9uKTtcbiAgICAgIHRoaXMuYW5pbWF0aW9uUmVuZGVyZXJfLnNldEFuaW1hdGlvblRpbWUodGhpcy5hY3RpdmVUaW1lXyk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGFjdGl2ZVRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlVGltZV8gfHwgMDtcbiAgfVxuXG4gIHNldCBhY3RpdmVUaW1lKGFjdGl2ZVRpbWUpIHtcbiAgICB0aGlzLmFjdGl2ZVRpbWVfID0gYWN0aXZlVGltZTtcbiAgICBpZiAodGhpcy5hbmltYXRpb25SZW5kZXJlcl8pIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uUmVuZGVyZXJfLnNldEFuaW1hdGlvblRpbWUoYWN0aXZlVGltZSk7XG4gICAgfVxuICAgIHRoaXMuYnJvYWRjYXN0Q2hhbmdlc18oe2FjdGl2ZVRpbWU6IHRydWV9KTtcbiAgfVxuXG4gIGdldFNlbGVjdGlvbkJ5VHlwZV8odHlwZSkge1xuICAgIHJldHVybiAodGhpcy5zZWxlY3Rpb25fICYmIHRoaXMuc2VsZWN0aW9uXy5sZW5ndGggJiYgdGhpcy5zZWxlY3Rpb25fWzBdIGluc3RhbmNlb2YgdHlwZSlcbiAgICAgICAgPyB0aGlzLnNlbGVjdGlvbl8gOiBbXTtcbiAgfVxuXG4gIGdldCBzZWxlY3RlZExheWVycygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTZWxlY3Rpb25CeVR5cGVfKEJhc2VMYXllcik7XG4gIH1cblxuICBnZXQgc2VsZWN0ZWRBbmltYXRpb25CbG9ja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2VsZWN0aW9uQnlUeXBlXyhBbmltYXRpb25CbG9jayk7XG4gIH1cblxuICBnZXQgc2VsZWN0ZWRBbmltYXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmdldFNlbGVjdGlvbkJ5VHlwZV8oQW5pbWF0aW9uKTtcbiAgfVxuXG4gIGdldCBmaXJzdFNlbGVjdGVkSXRlbSgpIHtcbiAgICByZXR1cm4gKCh0aGlzLnNlbGVjdGlvbl8gfHwgW10pLmxlbmd0aCA+IDApID8gdGhpcy5zZWxlY3Rpb25fWzBdIDogbnVsbDtcbiAgfVxuXG4gIGdldCBpc011bHRpcGxlU2VsZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbl8gPyAhISh0aGlzLnNlbGVjdGlvbl8ubGVuZ3RoID4gMSkgOiBmYWxzZTtcbiAgfVxuXG4gIGdldCBzZWxlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uXyB8fCBbXTtcbiAgfVxuXG4gIHNldCBzZWxlY3Rpb24oc2VsZWN0aW9uKSB7XG4gICAgdGhpcy5zZWxlY3Rpb25fID0gdGhpcy5zZWxlY3Rpb25fIHx8IFtdO1xuICAgIHRoaXMuc2VsZWN0aW9uXy5mb3JFYWNoKGl0ZW0gPT4gZGVsZXRlIGl0ZW0uc2VsZWN0ZWRfKTtcbiAgICB0aGlzLnNlbGVjdGlvbl8gPSBzZWxlY3Rpb24gPyBzZWxlY3Rpb24uc2xpY2UoKSA6IFtdO1xuICAgIHRoaXMuc2VsZWN0aW9uXy5mb3JFYWNoKGl0ZW0gPT4gaXRlbS5zZWxlY3RlZF8gPSB0cnVlKTtcbiAgICB0aGlzLmJyb2FkY2FzdENoYW5nZXNfKHtzZWxlY3Rpb246IHRydWV9KTtcbiAgfVxuXG4gIGFyZUl0ZW1zTXVsdGlzZWxlY3RDb21wYXRpYmxlXyhpdGVtMSwgaXRlbTIpIHtcbiAgICByZXR1cm4gISEoIWl0ZW0xIHx8ICFpdGVtMlxuICAgICAgICB8fCBpdGVtMS5jb25zdHJ1Y3RvciA9PT0gaXRlbTIuY29uc3RydWN0b3JcbiAgICAgICAgfHwgaXRlbTEgaW5zdGFuY2VvZiBCYXNlTGF5ZXIgJiYgaXRlbTIgaW5zdGFuY2VvZiBCYXNlTGF5ZXIpO1xuICB9XG5cbiAgc2VsZWN0SXRlbShpdGVtKSB7XG4gICAgdGhpcy50b2dnbGVTZWxlY3RlZChpdGVtLCB0cnVlKTtcbiAgfVxuXG4gIGRlc2VsZWN0SXRlbShpdGVtKSB7XG4gICAgdGhpcy50b2dnbGVTZWxlY3RlZChpdGVtLCBmYWxzZSk7XG4gIH1cblxuICB0b2dnbGVTZWxlY3RlZChpdGVtLCBzZWxlY3QpIHtcbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHNlbGVjdCA9ICFpdGVtLnNlbGVjdGVkXztcbiAgICB9XG5cbiAgICBpZiAoISFpdGVtLnNlbGVjdGVkXyA9PSBzZWxlY3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNlbGVjdGlvbl8gPSB0aGlzLnNlbGVjdGlvbl8gfHwgW107XG5cbiAgICBpZiAoc2VsZWN0KSB7XG4gICAgICAvLyBlbnN1cmUgb25seSBvbmUgdHlwZSBvZiB0aGluZyBpcyBzZWxlY3RlZFxuICAgICAgaWYgKHRoaXMuYXJlSXRlbXNNdWx0aXNlbGVjdENvbXBhdGlibGVfKHRoaXMuZmlyc3RTZWxlY3RlZEl0ZW0sIGl0ZW0pKSB7XG4gICAgICAgIC8vIGFkZCB0aGlzIGl0ZW0gdG8gdGhlIGV4aXN0aW5nIHNlbGVjdGlvblxuICAgICAgICB0aGlzLnNlbGVjdGlvbl8ucHVzaChpdGVtKTtcbiAgICAgICAgaXRlbS5zZWxlY3RlZF8gPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVzZXQgdGhlIHNlbGVjdGlvblxuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IFtpdGVtXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc2ltcGx5IHRvZ2dsZSB0aGlzIGl0ZW0gYmVpbmcgc2VsZWN0ZWRcbiAgICAgIGxldCBpbmRleCA9IHRoaXMuc2VsZWN0aW9uXy5pbmRleE9mKGl0ZW0pO1xuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25fLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGRlbGV0ZSBpdGVtLnNlbGVjdGVkXztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmJyb2FkY2FzdENoYW5nZXNfKHtzZWxlY3Rpb246IHRydWV9KTtcbiAgfVxuXG4gIGRlbGV0ZUxheWVycyhsYXllcnNUb0RlbGV0ZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShsYXllcnNUb0RlbGV0ZSkpIHtcbiAgICAgIGxheWVyc1RvRGVsZXRlID0gW2xheWVyc1RvRGVsZXRlXTtcbiAgICB9XG5cbiAgICBsZXQgZGVsZXRlQW5pbWF0aW9uc0ZvckxheWVyXyA9IGxheWVyID0+IHtcbiAgICAgIGxheWVyLndhbGsobGF5ZXIgPT4ge1xuICAgICAgICB0aGlzLmFuaW1hdGlvbnMuZm9yRWFjaChhbmltYXRpb24gPT4ge1xuICAgICAgICAgIGFuaW1hdGlvbi5ibG9ja3MgPSBhbmltYXRpb24uYmxvY2tzLmZpbHRlcihibG9jayA9PiBibG9jay5sYXllcklkICE9IGxheWVyLmlkKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgbGV0IHZpc2l0XyA9IGxheWVyR3JvdXAgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IGxheWVyR3JvdXAubGF5ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGxldCBsYXllciA9IGxheWVyR3JvdXAubGF5ZXJzW2ldO1xuICAgICAgICBpZiAobGF5ZXJzVG9EZWxldGUuaW5kZXhPZihsYXllcikgPj0gMCkge1xuICAgICAgICAgIGRlbGV0ZUFuaW1hdGlvbnNGb3JMYXllcl8obGF5ZXIpO1xuICAgICAgICAgIGxheWVyR3JvdXAubGF5ZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXllci5sYXllcnMpIHtcbiAgICAgICAgICB2aXNpdF8obGF5ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZpc2l0Xyh0aGlzLmFydHdvcmspO1xuICAgIHRoaXMuYXJ0d29ya0NoYW5nZWQoKTtcbiAgICB0aGlzLmFuaW1DaGFuZ2VkKCk7XG4gIH1cblxuICB1cGRhdGVMYXllcklkKGxheWVyLCBuZXdJZCkge1xuICAgIGxldCBvbGRJZCA9IGxheWVyLmlkO1xuICAgIGlmIChvbGRJZCA9PSBuZXdJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYW5pbWF0aW9ucy5mb3JFYWNoKGFuaW1hdGlvbiA9PiBhbmltYXRpb24uYmxvY2tzLmZvckVhY2goYmxvY2sgPT4ge1xuICAgICAgaWYgKGJsb2NrLmxheWVySWQgPT0gb2xkSWQpIHtcbiAgICAgICAgYmxvY2subGF5ZXJJZCA9IG5ld0lkO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBsYXllci5pZCA9IG5ld0lkO1xuXG4gICAgdGhpcy5hcnR3b3JrQ2hhbmdlZCgpO1xuICAgIHRoaXMuYW5pbUNoYW5nZWQoKTtcbiAgfVxuXG4gIGdldFVuaXF1ZUFuaW1hdGlvbklkKHByZWZpeCwgdGFyZ2V0QW5pbWF0aW9uID0gbnVsbCkge1xuICAgIHJldHVybiBNb2RlbFV0aWwuZ2V0VW5pcXVlSWQoe1xuICAgICAgcHJlZml4OiBwcmVmaXggfHwgJ2FuaW0nLFxuICAgICAgb2JqZWN0QnlJZDogaWQgPT4gdGhpcy5hbmltYXRpb25zLnJlZHVjZSgoYSwgYikgPT4gYSB8fCAoYi5pZCA9PSBpZCksIGZhbHNlKSxcbiAgICAgIHNraXBPYmplY3Q6IHRhcmdldEFuaW1hdGlvblxuICAgIH0pO1xuICB9XG5cbiAgZ2V0VW5pcXVlTGF5ZXJJZChwcmVmaXgsIHRhcmdldExheWVyID0gbnVsbCkge1xuICAgIHJldHVybiBNb2RlbFV0aWwuZ2V0VW5pcXVlSWQoe1xuICAgICAgcHJlZml4OiBwcmVmaXggfHwgKHRhcmdldExheWVyID8gdGFyZ2V0TGF5ZXIudHlwZUlkUHJlZml4IDogJ2xheWVyJyksXG4gICAgICBvYmplY3RCeUlkOiBpZCA9PiB0aGlzLmFydHdvcmsuZmluZExheWVyQnlJZChpZCksXG4gICAgICBza2lwT2JqZWN0OiB0YXJnZXRMYXllclxuICAgIH0pO1xuICB9XG5cbiAgYnJvYWRjYXN0Q2hhbmdlc18oY2hhbmdlcykge1xuICAgIC8vIHRvZG86IGRlYm91bmNlXG4gICAgdGhpcy5yb290U2NvcGVfLiRlbWl0KENIQU5HRVNfVEFHLCBjaGFuZ2VzKTtcbiAgfVxuXG4gIG9uQ2hhbmdlKGZuLCAkc2NvcGUpIHtcbiAgICBsZXQgd2F0Y2hlciA9IHRoaXMucm9vdFNjb3BlXy4kb24oQ0hBTkdFU19UQUcsIGZ1bmN0aW9uKCkge1xuICAgICAgLy8gd2luZG93LnNldFRpbWVvdXQoKCkgPT4gJHNjb3BlLiRhcHBseSgoKSA9PiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSwgMCk7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgKCkgPT4gd2F0Y2hlcigpKTtcbiAgICByZXR1cm4gd2F0Y2hlcjtcbiAgfVxuXG4gIGRvd25sb2FkRmlsZV8oY29udGVudCwgZmlsZW5hbWUpIHtcbiAgICBsZXQgYW5jaG9yID0gJCgnPGE+JykuaGlkZSgpLmFwcGVuZFRvKGRvY3VtZW50LmJvZHkpO1xuICAgIGxldCBibG9iID0gY29udGVudDtcbiAgICBpZiAoIShjb250ZW50IGluc3RhbmNlb2YgQmxvYikpIHtcbiAgICAgIGJsb2IgPSBuZXcgQmxvYihbY29udGVudF0sIHt0eXBlOiAnb2N0ZXQvc3RyZWFtJ30pO1xuICAgIH1cbiAgICBsZXQgdXJsID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgYW5jaG9yLmF0dHIoe1xuICAgICAgaHJlZjogdXJsLFxuICAgICAgZG93bmxvYWQ6IGZpbGVuYW1lXG4gICAgfSk7XG4gICAgYW5jaG9yLmdldCgwKS5jbGljaygpO1xuICAgIHdpbmRvdy5VUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG4gIH1cblxuICBhZGRMYXllcnMobGF5ZXJzKSB7XG4gICAgKGxheWVycyB8fCBbXSkuZm9yRWFjaChsYXllciA9PiB7XG4gICAgICBsYXllci5wYXJlbnQgPSB0aGlzLmFydHdvcms7XG4gICAgICBsYXllci53YWxrKGxheWVyID0+IHtcbiAgICAgICAgbGF5ZXIuaWQgPSB0aGlzLmdldFVuaXF1ZUxheWVySWQobGF5ZXIuaWQsIGxheWVyKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5hcnR3b3JrLmxheWVycy5wdXNoKGxheWVyKTtcbiAgICB9KTtcbiAgICB0aGlzLmFydHdvcmtDaGFuZ2VkKCk7XG4gIH1cblxuICBzd2FwTGF5ZXIobGF5ZXIsIHdpdGhMYXllcikge1xuICAgIGxldCBwYXJlbnQgPSBsYXllci5wYXJlbnQ7XG4gICAgbGV0IGluZGV4SW5QYXJlbnQgPSBwYXJlbnQubGF5ZXJzLmluZGV4T2YobGF5ZXIpO1xuICAgIHdpdGhMYXllci5wYXJlbnQgPSBsYXllci5wYXJlbnQ7XG4gICAgcGFyZW50LmxheWVycy5zcGxpY2UoaW5kZXhJblBhcmVudCwgMSwgd2l0aExheWVyKTtcbiAgICBsZXQgaW5kZXhJblNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uLmluZGV4T2YobGF5ZXIpO1xuICAgIGlmIChpbmRleEluU2VsZWN0aW9uID49IDApIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uLnNwbGljZShpbmRleEluU2VsZWN0aW9uLCAxLCB3aXRoTGF5ZXIpO1xuICAgIH1cbiAgICAvLyBUT0RPOiBwcmVzZXJ2ZSBzdGlsbC12YWxpZCBhbmltYXRpb25zXG4gICAgdGhpcy5hbmltYXRpb25zLmZvckVhY2goYW5pbWF0aW9uID0+IHtcbiAgICAgIGFuaW1hdGlvbi5ibG9ja3MgPSBhbmltYXRpb24uYmxvY2tzLmZpbHRlcihibG9jayA9PiBibG9jay5sYXllcklkICE9IGxheWVyLmlkKTtcbiAgICB9KTtcbiAgICB0aGlzLmFydHdvcmtDaGFuZ2VkKCk7XG4gIH1cblxuICBuZXcoKSB7XG4gICAgdGhpcy5sb2FkKHtcbiAgICAgIGFydHdvcms6IG5ldyBBcnR3b3JrKEJMQU5LX0FSVFdPUkspLFxuICAgICAgYW5pbWF0aW9uczogW25ldyBBbmltYXRpb24oQkxBTktfQU5JTUFUSU9OKV1cbiAgICB9KTtcbiAgfVxuXG4gIHNhdmVUb0ZpbGUoKSB7XG4gICAgbGV0IGpzb25TdHIgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBhcnR3b3JrOiB0aGlzLmFydHdvcmsudG9KU09OKCksXG4gICAgICBhbmltYXRpb25zOiB0aGlzLmFuaW1hdGlvbnMubWFwKGFuaW0gPT4gYW5pbS50b0pTT04oKSlcbiAgICB9LCBudWxsLCAyKTtcbiAgICB0aGlzLmRvd25sb2FkRmlsZV8oanNvblN0ciwgYCR7dGhpcy5hcnR3b3JrLmlkfS5pY29uYW5pbWApO1xuICAgIHRoaXMuZGlydHlfID0gZmFsc2U7XG4gIH1cblxuICBleHBvcnRWZWN0b3JEcmF3YWJsZSgpIHtcbiAgICBsZXQgeG1sU3RyID0gQXZkU2VyaWFsaXplci5hcnR3b3JrVG9WZWN0b3JEcmF3YWJsZVhtbFN0cmluZyh0aGlzLmFydHdvcmspO1xuICAgIHRoaXMuZG93bmxvYWRGaWxlXyh4bWxTdHIsIGAke3RoaXMuYXJ0d29yay5pZH0ueG1sYCk7XG4gIH1cblxuICBleHBvcnRBVkRzKCkge1xuICAgIGlmICh0aGlzLmFuaW1hdGlvbnMubGVuZ3RoKSB7XG4gICAgICBsZXQgZXhwb3J0ZWRBbmltYXRpb25zID0gdGhpcy5hbmltYXRpb25zLm1hcChhbmltYXRpb24gPT4gKHtcbiAgICAgICAgYW5pbWF0aW9uLFxuICAgICAgICBmaWxlbmFtZTogYGF2ZF8ke3RoaXMuYXJ0d29yay5pZH1fJHthbmltYXRpb24uaWR9LnhtbGAsXG4gICAgICAgIHhtbFN0cjogQXZkU2VyaWFsaXplci5hcnR3b3JrQW5pbWF0aW9uVG9BdmRYbWxTdHJpbmcodGhpcy5hcnR3b3JrLCBhbmltYXRpb24pXG4gICAgICB9KSk7XG5cbiAgICAgIGlmIChleHBvcnRlZEFuaW1hdGlvbnMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgLy8gZG93bmxvYWQgYSBzaW5nbGUgWE1MXG4gICAgICAgIHRoaXMuZG93bmxvYWRGaWxlXyhleHBvcnRlZEFuaW1hdGlvbnNbMF0ueG1sU3RyLCBleHBvcnRlZEFuaW1hdGlvbnNbMF0uZmlsZW5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZG93bmxvYWQgYSBaSVBcbiAgICAgICAgemlwLmNyZWF0ZVdyaXRlcihuZXcgemlwLkJsb2JXcml0ZXIoKSwgd3JpdGVyID0+IHtcbiAgICAgICAgICBsZXQgaSA9IC0xO1xuICAgICAgICAgIGxldCBuZXh0XyA9ICgpID0+IHtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIGlmIChpID49IGV4cG9ydGVkQW5pbWF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8gY2xvc2VcbiAgICAgICAgICAgICAgd3JpdGVyLmNsb3NlKGJsb2IgPT4gdGhpcy5kb3dubG9hZEZpbGVfKGJsb2IsIGBhdmRfJHt0aGlzLmFydHdvcmsuaWR9LnppcGApKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGFkZCBuZXh0IGZpbGVcbiAgICAgICAgICAgICAgbGV0IGV4cG9ydGVkQW5pbWF0aW9uID0gZXhwb3J0ZWRBbmltYXRpb25zW2ldO1xuICAgICAgICAgICAgICB3cml0ZXIuYWRkKFxuICAgICAgICAgICAgICAgICAgZXhwb3J0ZWRBbmltYXRpb24uZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgICBuZXcgemlwLlRleHRSZWFkZXIoZXhwb3J0ZWRBbmltYXRpb24ueG1sU3RyKSxcbiAgICAgICAgICAgICAgICAgIG5leHRfKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIG5leHRfKCk7XG4gICAgICAgIH0sIGVycm9yID0+IGNvbnNvbGUuZXJyb3IoZXJyb3IpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG5hbmd1bGFyLm1vZHVsZSgnQVZEU3R1ZGlvJykuc2VydmljZSgnU3R1ZGlvU3RhdGVTZXJ2aWNlJywgU3R1ZGlvU3RhdGVTZXJ2aWNlKTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge0FydHdvcmssIEFuaW1hdGlvbn0gZnJvbSAnbW9kZWwnO1xuaW1wb3J0IHtNb2RlbFV0aWx9IGZyb20gJ01vZGVsVXRpbCc7XG5cblxuY29uc3QgREVGQVVMVF9MQVlFUl9QUk9QRVJUWV9TVEFURSA9IHtcbiAgYWN0aXZlQmxvY2s6IG51bGwsXG4gIGludGVycG9sYXRlZFZhbHVlOiBmYWxzZVxufTtcblxuXG5leHBvcnQgY2xhc3MgQW5pbWF0aW9uUmVuZGVyZXIge1xuICBjb25zdHJ1Y3RvcihhcnR3b3JrLCBhbmltYXRpb24pIHtcbiAgICB0aGlzLm9yaWdpbmFsQXJ0d29yayA9IGFydHdvcms7XG4gICAgdGhpcy5hbmltYXRpb24gPSBhbmltYXRpb247XG4gICAgdGhpcy5yZW5kZXJlZEFydHdvcmsgPSBuZXcgQXJ0d29yayhhcnR3b3JrLCB7bGlua1NlbGVjdGVkU3RhdGU6IHRydWV9KTtcbiAgICB0aGlzLmFuaW1EYXRhQnlMYXllciA9IE1vZGVsVXRpbC5nZXRPcmRlcmVkQW5pbWF0aW9uQmxvY2tzQnlMYXllcklkQW5kUHJvcGVydHkoYW5pbWF0aW9uKTtcblxuICAgIE9iamVjdC5rZXlzKHRoaXMuYW5pbURhdGFCeUxheWVyKS5mb3JFYWNoKGxheWVySWQgPT4ge1xuICAgICAgdGhpcy5hbmltRGF0YUJ5TGF5ZXJbbGF5ZXJJZF0gPSB7XG4gICAgICAgIG9yaWdpbmFsTGF5ZXI6IHRoaXMub3JpZ2luYWxBcnR3b3JrLmZpbmRMYXllckJ5SWQobGF5ZXJJZCksXG4gICAgICAgIHJlbmRlcmVkTGF5ZXI6IHRoaXMucmVuZGVyZWRBcnR3b3JrLmZpbmRMYXllckJ5SWQobGF5ZXJJZCksXG4gICAgICAgIG9yZGVyZWRCbG9ja3M6IHRoaXMuYW5pbURhdGFCeUxheWVyW2xheWVySWRdXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgdGhpcy5zZXRBbmltYXRpb25UaW1lKDApO1xuICB9XG5cbiAgc2V0QW5pbWF0aW9uVGltZSh0aW1lKSB7XG4gICAgZm9yIChsZXQgbGF5ZXJJZCBpbiB0aGlzLmFuaW1EYXRhQnlMYXllcikge1xuICAgICAgbGV0IGFuaW1EYXRhID0gdGhpcy5hbmltRGF0YUJ5TGF5ZXJbbGF5ZXJJZF07XG4gICAgICBhbmltRGF0YS5yZW5kZXJlZExheWVyLl9hciA9IGFuaW1EYXRhLnJlbmRlcmVkTGF5ZXIuX2FyIHx8IHt9O1xuXG4gICAgICBmb3IgKGxldCBwcm9wZXJ0eU5hbWUgaW4gYW5pbURhdGEub3JkZXJlZEJsb2Nrcykge1xuICAgICAgICBsZXQgYmxvY2tzID0gYW5pbURhdGEub3JkZXJlZEJsb2Nrc1twcm9wZXJ0eU5hbWVdO1xuICAgICAgICBsZXQgX2FyID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9MQVlFUl9QUk9QRVJUWV9TVEFURSk7XG5cbiAgICAgICAgLy8gY29tcHV0ZSByZW5kZXJlZCB2YWx1ZSBhdCBnaXZlbiB0aW1lXG4gICAgICAgIGxldCBwcm9wZXJ0eSA9IGFuaW1EYXRhLm9yaWdpbmFsTGF5ZXIuYW5pbWF0YWJsZVByb3BlcnRpZXNbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgbGV0IHZhbHVlID0gYW5pbURhdGEub3JpZ2luYWxMYXllcltwcm9wZXJ0eU5hbWVdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2Nrcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGxldCBibG9jayA9IGJsb2Nrc1tpXTtcbiAgICAgICAgICBpZiAodGltZSA8IGJsb2NrLnN0YXJ0VGltZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aW1lIDwgYmxvY2suZW5kVGltZSkge1xuICAgICAgICAgICAgbGV0IGZyb21WYWx1ZSA9ICgnZnJvbVZhbHVlJyBpbiBibG9jaykgPyBibG9jay5mcm9tVmFsdWUgOiB2YWx1ZTtcbiAgICAgICAgICAgIGxldCBmID0gKHRpbWUgLSBibG9jay5zdGFydFRpbWUpIC8gKGJsb2NrLmVuZFRpbWUgLSBibG9jay5zdGFydFRpbWUpO1xuICAgICAgICAgICAgZiA9IGJsb2NrLmludGVycG9sYXRvci5pbnRlcnBvbGF0ZShmKTtcbiAgICAgICAgICAgIHZhbHVlID0gcHJvcGVydHkuaW50ZXJwb2xhdGVWYWx1ZShmcm9tVmFsdWUsIGJsb2NrLnRvVmFsdWUsIGYpO1xuICAgICAgICAgICAgX2FyLmFjdGl2ZUJsb2NrID0gYmxvY2s7XG4gICAgICAgICAgICBfYXIuaW50ZXJwb2xhdGVkVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFsdWUgPSBibG9jay50b1ZhbHVlO1xuICAgICAgICAgIF9hci5hY3RpdmVCbG9jayA9IGJsb2NrO1xuICAgICAgICB9XG5cbiAgICAgICAgYW5pbURhdGEucmVuZGVyZWRMYXllcltwcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG5cbiAgICAgICAgLy8gY2FjaGVkIGRhdGFcbiAgICAgICAgYW5pbURhdGEucmVuZGVyZWRMYXllci5fYXJbcHJvcGVydHlOYW1lXSA9IGFuaW1EYXRhLnJlbmRlcmVkTGF5ZXIuX2FyW3Byb3BlcnR5TmFtZV0gfHwge307XG4gICAgICAgIGFuaW1EYXRhLnJlbmRlcmVkTGF5ZXIuX2FyW3Byb3BlcnR5TmFtZV0gPSBfYXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hbmltVGltZSA9IHRpbWU7XG4gIH1cblxuICBnZXRMYXllclByb3BlcnR5VmFsdWUobGF5ZXJJZCwgcHJvcGVydHlOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZWRBcnR3b3JrLmZpbmRMYXllckJ5SWQobGF5ZXJJZClbcHJvcGVydHlOYW1lXTtcbiAgfVxuXG4gIGdldExheWVyUHJvcGVydHlTdGF0ZShsYXllcklkLCBwcm9wZXJ0eU5hbWUpIHtcbiAgICBsZXQgbGF5ZXJBbmltRGF0YSA9IHRoaXMuYW5pbURhdGFCeUxheWVyW2xheWVySWRdO1xuICAgIHJldHVybiBsYXllckFuaW1EYXRhXG4gICAgICAgID8gbGF5ZXJBbmltRGF0YS5yZW5kZXJlZExheWVyLl9hcltwcm9wZXJ0eU5hbWVdIHx8IHt9XG4gICAgICAgIDogT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9MQVlFUl9QUk9QRVJUWV9TVEFURSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeG1sc2VyaWFsaXplciBmcm9tICd4bWxzZXJpYWxpemVyJztcblxuaW1wb3J0IHtBcnR3b3JrLCBQYXRoTGF5ZXIsIExheWVyR3JvdXAsIE1hc2tMYXllciwgRGVmYXVsdFZhbHVlc30gZnJvbSAnLi9tb2RlbCc7XG5cbmNvbnN0IFhNTE5TX05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvJztcbmNvbnN0IEFORFJPSURfTlMgPSAnaHR0cDovL3NjaGVtYXMuYW5kcm9pZC5jb20vYXBrL3Jlcy9hbmRyb2lkJztcbmNvbnN0IEFBUFRfTlMgPSAnaHR0cDovL3NjaGVtYXMuYW5kcm9pZC5jb20vYWFwdCc7XG5cblxubGV0IGNvbmRpdGlvbmFsQXR0cl8gPSAobm9kZSwgYXR0ciwgdmFsdWUsIHNraXBWYWx1ZSkgPT4ge1xuICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZFxuICAgICAgJiYgdmFsdWUgIT09IG51bGxcbiAgICAgICYmIChza2lwVmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSAhPT0gc2tpcFZhbHVlKSkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlTlMoQU5EUk9JRF9OUywgYXR0ciwgdmFsdWUpO1xuICB9XG59O1xuXG5cbmxldCBzZXJpYWxpemVYbWxOb2RlXyA9IHhtbE5vZGUgPT4ge1xuICBsZXQgeG1sU3RyID0geG1sc2VyaWFsaXplci5zZXJpYWxpemVUb1N0cmluZyh4bWxOb2RlLCB7aW5kZW50OjQsIG11bHRpQXR0cmlidXRlSW5kZW50OjR9KTtcbiAgcmV0dXJuIHhtbFN0cjsgLy9uZXcgWE1MU2VyaWFsaXplcigpLnNlcmlhbGl6ZVRvU3RyaW5nKHhtbE5vZGUpO1xuICAvLyByZXR1cm4gdmtiZWF1dGlmeS54bWwoeG1sU3RyLCA0KTtcbn07XG5cblxuZXhwb3J0IGNvbnN0IEF2ZFNlcmlhbGl6ZXIgPSB7XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgYW4gQXJ0d29yayB0byBhIHZlY3RvciBkcmF3YWJsZSBYTUwgZmlsZS5cbiAgICovXG4gIGFydHdvcmtUb1ZlY3RvckRyYXdhYmxlWG1sU3RyaW5nKGFydHdvcmspIHtcbiAgICBsZXQgeG1sRG9jID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlRG9jdW1lbnQobnVsbCwgJ3ZlY3RvcicpO1xuICAgIGxldCByb290Tm9kZSA9IHhtbERvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgQXZkU2VyaWFsaXplci5hcnR3b3JrVG9YbWxOb2RlXyhhcnR3b3JrLCByb290Tm9kZSwgeG1sRG9jKTtcbiAgICByZXR1cm4gc2VyaWFsaXplWG1sTm9kZV8ocm9vdE5vZGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIGEgZ2l2ZW4gQXJ0d29yayBhbmQgQW5pbWF0aW9uIHRvIGFuIGFuaW1hdGVkdmVjdG9yIGRyYXdhYmxlIFhNTCBmaWxlLlxuICAgKi9cbiAgYXJ0d29ya0FuaW1hdGlvblRvQXZkWG1sU3RyaW5nKGFydHdvcmssIGFuaW1hdGlvbikge1xuICAgIGxldCB4bWxEb2MgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVEb2N1bWVudChudWxsLCAnYW5pbWF0ZWQtdmVjdG9yJyk7XG4gICAgbGV0IHJvb3ROb2RlID0geG1sRG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICByb290Tm9kZS5zZXRBdHRyaWJ1dGVOUyhYTUxOU19OUywgJ3htbG5zOmFuZHJvaWQnLCBBTkRST0lEX05TKTtcbiAgICByb290Tm9kZS5zZXRBdHRyaWJ1dGVOUyhYTUxOU19OUywgJ3htbG5zOmFhcHQnLCBBQVBUX05TKTtcblxuICAgIC8vIGNyZWF0ZSBkcmF3YWJsZSBub2RlIGNvbnRhaW5pbmcgdGhlIGFydHdvcmtcbiAgICBsZXQgYXJ0d29ya0NvbnRhaW5lck5vZGUgPSB4bWxEb2MuY3JlYXRlRWxlbWVudE5TKEFBUFRfTlMsICdhYXB0OmF0dHInKTtcbiAgICBhcnR3b3JrQ29udGFpbmVyTm9kZS5zZXRBdHRyaWJ1dGUoJ25hbWUnLCAnYW5kcm9pZDpkcmF3YWJsZScpO1xuICAgIHJvb3ROb2RlLmFwcGVuZENoaWxkKGFydHdvcmtDb250YWluZXJOb2RlKTtcblxuICAgIGxldCBhcnR3b3JrTm9kZSA9IHhtbERvYy5jcmVhdGVFbGVtZW50KCd2ZWN0b3InKTtcbiAgICBBdmRTZXJpYWxpemVyLmFydHdvcmtUb1htbE5vZGVfKGFydHdvcmssIGFydHdvcmtOb2RlLCB4bWxEb2MpO1xuICAgIGFydHdvcmtDb250YWluZXJOb2RlLmFwcGVuZENoaWxkKGFydHdvcmtOb2RlKTtcblxuICAgIC8vIGNyZWF0ZSBhbmltYXRpb24gbm9kZXMgKG9uZSBwZXIgbGF5ZXIpXG4gICAgbGV0IGFuaW1CbG9ja3NCeUxheWVyID0ge307XG4gICAgYW5pbWF0aW9uLmJsb2Nrcy5mb3JFYWNoKGJsb2NrID0+IHtcbiAgICAgIGFuaW1CbG9ja3NCeUxheWVyW2Jsb2NrLmxheWVySWRdID0gYW5pbUJsb2Nrc0J5TGF5ZXJbYmxvY2subGF5ZXJJZF0gfHwgW107XG4gICAgICBhbmltQmxvY2tzQnlMYXllcltibG9jay5sYXllcklkXS5wdXNoKGJsb2NrKTtcbiAgICB9KTtcblxuICAgIGZvciAobGV0IGxheWVySWQgaW4gYW5pbUJsb2Nrc0J5TGF5ZXIpIHtcbiAgICAgIGxldCB0YXJnZXROb2RlID0geG1sRG9jLmNyZWF0ZUVsZW1lbnQoJ3RhcmdldCcpO1xuICAgICAgdGFyZ2V0Tm9kZS5zZXRBdHRyaWJ1dGVOUyhBTkRST0lEX05TLCAnYW5kcm9pZDpuYW1lJywgbGF5ZXJJZCk7XG4gICAgICByb290Tm9kZS5hcHBlbmRDaGlsZCh0YXJnZXROb2RlKTtcblxuICAgICAgbGV0IGFuaW1hdGlvbk5vZGUgPSB4bWxEb2MuY3JlYXRlRWxlbWVudE5TKEFBUFRfTlMsICdhYXB0OmF0dHInKTtcbiAgICAgIGFuaW1hdGlvbk5vZGUuc2V0QXR0cmlidXRlKCduYW1lJywgJ2FuZHJvaWQ6YW5pbWF0aW9uJyk7XG4gICAgICB0YXJnZXROb2RlLmFwcGVuZENoaWxkKGFuaW1hdGlvbk5vZGUpO1xuXG4gICAgICBsZXQgYmxvY2tzRm9yTGF5ZXIgPSBhbmltQmxvY2tzQnlMYXllcltsYXllcklkXTtcbiAgICAgIGxldCBibG9ja0NvbnRhaW5lck5vZGUgPSBhbmltYXRpb25Ob2RlO1xuICAgICAgbGV0IG11bHRpQmxvY2sgPSBmYWxzZTtcbiAgICAgIGlmIChibG9ja3NGb3JMYXllci5sZW5ndGggPiAxKSB7XG4gICAgICAgIG11bHRpQmxvY2sgPSB0cnVlO1xuXG4gICAgICAgIC8vIDxzZXQ+IGZvciBtdWx0aXBsZSBwcm9wZXJ0eSBhbmltYXRpb25zIG9uIGEgc2luZ2xlIGxheWVyXG4gICAgICAgIGJsb2NrQ29udGFpbmVyTm9kZSA9IHhtbERvYy5jcmVhdGVFbGVtZW50KCdzZXQnKTtcbiAgICAgICAgYmxvY2tDb250YWluZXJOb2RlLnNldEF0dHJpYnV0ZU5TKFhNTE5TX05TLCAneG1sbnM6YW5kcm9pZCcsIEFORFJPSURfTlMpO1xuICAgICAgICBhbmltYXRpb25Ob2RlLmFwcGVuZENoaWxkKGJsb2NrQ29udGFpbmVyTm9kZSk7XG4gICAgICB9XG5cbiAgICAgIGxldCBsYXllciA9IGFydHdvcmsuZmluZExheWVyQnlJZChsYXllcklkKTtcbiAgICAgIGxldCBhbmltYXRhYmxlUHJvcGVydGllcyA9IGxheWVyLmFuaW1hdGFibGVQcm9wZXJ0aWVzO1xuXG4gICAgICBibG9ja3NGb3JMYXllci5mb3JFYWNoKGJsb2NrID0+IHtcbiAgICAgICAgbGV0IGJsb2NrTm9kZSA9IHhtbERvYy5jcmVhdGVFbGVtZW50KCdvYmplY3RBbmltYXRvcicpO1xuICAgICAgICBpZiAoIW11bHRpQmxvY2spIHtcbiAgICAgICAgICBibG9ja05vZGUuc2V0QXR0cmlidXRlTlMoWE1MTlNfTlMsICd4bWxuczphbmRyb2lkJywgQU5EUk9JRF9OUyk7XG4gICAgICAgIH1cbiAgICAgICAgYmxvY2tOb2RlLnNldEF0dHJpYnV0ZU5TKEFORFJPSURfTlMsICdhbmRyb2lkOnByb3BlcnR5TmFtZScsIGJsb2NrLnByb3BlcnR5TmFtZSk7XG4gICAgICAgIGNvbmRpdGlvbmFsQXR0cl8oYmxvY2tOb2RlLCAnYW5kcm9pZDpzdGFydE9mZnNldCcsIGJsb2NrLnN0YXJ0VGltZSwgMCk7XG4gICAgICAgIGNvbmRpdGlvbmFsQXR0cl8oYmxvY2tOb2RlLCAnYW5kcm9pZDpkdXJhdGlvbicsIGJsb2NrLmVuZFRpbWUgLSBibG9jay5zdGFydFRpbWUpO1xuICAgICAgICBjb25kaXRpb25hbEF0dHJfKGJsb2NrTm9kZSwgJ2FuZHJvaWQ6dmFsdWVGcm9tJywgYmxvY2suZnJvbVZhbHVlKTtcbiAgICAgICAgY29uZGl0aW9uYWxBdHRyXyhibG9ja05vZGUsICdhbmRyb2lkOnZhbHVlVG8nLCBibG9jay50b1ZhbHVlKTtcbiAgICAgICAgY29uZGl0aW9uYWxBdHRyXyhibG9ja05vZGUsICdhbmRyb2lkOnZhbHVlVHlwZScsXG4gICAgICAgICAgICBhbmltYXRhYmxlUHJvcGVydGllc1tibG9jay5wcm9wZXJ0eU5hbWVdLmFuaW1hdG9yVmFsdWVUeXBlKTtcbiAgICAgICAgY29uZGl0aW9uYWxBdHRyXyhibG9ja05vZGUsICdhbmRyb2lkOmludGVycG9sYXRvcicsIGJsb2NrLmludGVycG9sYXRvci5hbmRyb2lkUmVmKTtcbiAgICAgICAgYmxvY2tDb250YWluZXJOb2RlLmFwcGVuZENoaWxkKGJsb2NrTm9kZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VyaWFsaXplWG1sTm9kZV8ocm9vdE5vZGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBIZWxwZXIgbWV0aG9kIHRoYXQgc2VyaWFsaXplcyBhbiBBcnR3b3JrIHRvIGEgZGVzdGluYXRpb25Ob2RlIGluIGFuIHhtbERvYy5cbiAgICogVGhlIGRlc3RpbmF0aW9uTm9kZSBzaG91bGQgYmUgYSA8dmVjdG9yPiBub2RlLlxuICAgKi9cbiAgYXJ0d29ya1RvWG1sTm9kZV8oYXJ0d29yaywgZGVzdGluYXRpb25Ob2RlLCB4bWxEb2MpIHtcbiAgICBkZXN0aW5hdGlvbk5vZGUuc2V0QXR0cmlidXRlTlMoWE1MTlNfTlMsICd4bWxuczphbmRyb2lkJywgQU5EUk9JRF9OUyk7XG4gICAgZGVzdGluYXRpb25Ob2RlLnNldEF0dHJpYnV0ZU5TKEFORFJPSURfTlMsICdhbmRyb2lkOndpZHRoJywgYCR7YXJ0d29yay53aWR0aH1kcGApO1xuICAgIGRlc3RpbmF0aW9uTm9kZS5zZXRBdHRyaWJ1dGVOUyhBTkRST0lEX05TLCAnYW5kcm9pZDpoZWlnaHQnLCBgJHthcnR3b3JrLmhlaWdodH1kcGApO1xuICAgIGRlc3RpbmF0aW9uTm9kZS5zZXRBdHRyaWJ1dGVOUyhBTkRST0lEX05TLCAnYW5kcm9pZDp2aWV3cG9ydFdpZHRoJywgYCR7YXJ0d29yay53aWR0aH1gKTtcbiAgICBkZXN0aW5hdGlvbk5vZGUuc2V0QXR0cmlidXRlTlMoQU5EUk9JRF9OUywgJ2FuZHJvaWQ6dmlld3BvcnRIZWlnaHQnLCBgJHthcnR3b3JrLmhlaWdodH1gKTtcbiAgICBjb25kaXRpb25hbEF0dHJfKGRlc3RpbmF0aW9uTm9kZSwgJ2FuZHJvaWQ6YWxwaGEnLCBhcnR3b3JrLmFscGhhLCAxKTtcblxuICAgIGFydHdvcmsud2FsaygobGF5ZXIsIHBhcmVudE5vZGUpID0+IHtcbiAgICAgIGlmIChsYXllciBpbnN0YW5jZW9mIEFydHdvcmspIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudE5vZGU7XG5cbiAgICAgIH0gZWxzZSBpZiAobGF5ZXIgaW5zdGFuY2VvZiBQYXRoTGF5ZXIpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB4bWxEb2MuY3JlYXRlRWxlbWVudCgncGF0aCcpO1xuICAgICAgICBjb25kaXRpb25hbEF0dHJfKG5vZGUsICdhbmRyb2lkOm5hbWUnLCBsYXllci5pZCk7XG4gICAgICAgIGNvbmRpdGlvbmFsQXR0cl8obm9kZSwgJ2FuZHJvaWQ6cGF0aERhdGEnLCBsYXllci5wYXRoRGF0YS5wYXRoU3RyaW5nKTtcbiAgICAgICAgY29uZGl0aW9uYWxBdHRyXyhub2RlLCAnYW5kcm9pZDpmaWxsQ29sb3InLCBsYXllci5maWxsQ29sb3IsICcnKTtcbiAgICAgICAgY29uZGl0aW9uYWxBdHRyXyhub2RlLCAnYW5kcm9pZDpmaWxsQWxwaGEnLCBsYXllci5maWxsQWxwaGEsIDEpO1xuICAgICAgICBjb25kaXRpb25hbEF0dHJfKG5vZGUsICdhbmRyb2lkOnN0cm9rZUNvbG9yJywgbGF5ZXIuc3Ryb2tlQ29sb3IsICcnKTtcbiAgICAgICAgY29uZGl0aW9uYWxBdHRyXyhub2RlLCAnYW5kcm9pZDpzdHJva2VBbHBoYScsIGxheWVyLnN0cm9rZUFscGhhLCAxKTtcbiAgICAgICAgY29uZGl0aW9uYWxBdHRyXyhub2RlLCAnYW5kcm9pZDpzdHJva2VXaWR0aCcsIGxheWVyLnN0cm9rZVdpZHRoLCAwKTtcbiAgICAgICAgY29uZGl0aW9uYWxBdHRyXyhub2RlLCAnYW5kcm9pZDp0cmltUGF0aFN0YXJ0JywgbGF5ZXIudHJpbVBhdGhTdGFydCwgMCk7XG4gICAgICAgIGNvbmRpdGlvbmFsQXR0cl8obm9kZSwgJ2FuZHJvaWQ6dHJpbVBhdGhFbmQnLCBsYXllci50cmltUGF0aEVuZCwgMSk7XG4gICAgICAgIGNvbmRpdGlvbmFsQXR0cl8obm9kZSwgJ2FuZHJvaWQ6dHJpbVBhdGhPZmZzZXQnLCBsYXllci50cmltUGF0aE9mZnNldCwgMCk7XG4gICAgICAgIGNvbmRpdGlvbmFsQXR0cl8obm9kZSwgJ2FuZHJvaWQ6c3Ryb2tlTGluZUNhcCcsIGxheWVyLnN0cm9rZUxpbmVjYXAsIERlZmF1bHRWYWx1ZXMuTElORUNBUCk7XG4gICAgICAgIGNvbmRpdGlvbmFsQXR0cl8obm9kZSwgJ2FuZHJvaWQ6c3Ryb2tlTGluZUpvaW4nLCBsYXllci5zdHJva2VMaW5lam9pbixcbiAgICAgICAgICAgIERlZmF1bHRWYWx1ZXMuTElORUpPSU4pO1xuICAgICAgICBjb25kaXRpb25hbEF0dHJfKG5vZGUsICdhbmRyb2lkOnN0cm9rZU1pdGVyTGltaXQnLCBsYXllci5zdHJva2VNaXRlckxpbWl0LFxuICAgICAgICAgICAgRGVmYXVsdFZhbHVlcy5NSVRFUl9MSU1JVCk7XG4gICAgICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIHJldHVybiBwYXJlbnROb2RlO1xuXG4gICAgICB9IGVsc2UgaWYgKGxheWVyIGluc3RhbmNlb2YgTWFza0xheWVyKSB7XG4gICAgICAgIGxldCBub2RlID0geG1sRG9jLmNyZWF0ZUVsZW1lbnQoJ2NsaXAtcGF0aCcpO1xuICAgICAgICBjb25kaXRpb25hbEF0dHJfKG5vZGUsICdhbmRyb2lkOm5hbWUnLCBsYXllci5pZCk7XG4gICAgICAgIGNvbmRpdGlvbmFsQXR0cl8obm9kZSwgJ2FuZHJvaWQ6cGF0aERhdGEnLCBsYXllci5wYXRoRGF0YS5wYXRoU3RyaW5nKTtcbiAgICAgICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgcmV0dXJuIHBhcmVudE5vZGU7XG5cbiAgICAgIH0gZWxzZSBpZiAobGF5ZXIgaW5zdGFuY2VvZiBMYXllckdyb3VwKSB7XG4gICAgICAgIGxldCBub2RlID0geG1sRG9jLmNyZWF0ZUVsZW1lbnQoJ2dyb3VwJyk7XG4gICAgICAgIGNvbmRpdGlvbmFsQXR0cl8obm9kZSwgJ2FuZHJvaWQ6bmFtZScsIGxheWVyLmlkKTtcbiAgICAgICAgY29uZGl0aW9uYWxBdHRyXyhub2RlLCAnYW5kcm9pZDpwaXZvdFgnLCBsYXllci5waXZvdFgsIDApO1xuICAgICAgICBjb25kaXRpb25hbEF0dHJfKG5vZGUsICdhbmRyb2lkOnBpdm90WScsIGxheWVyLnBpdm90WSwgMCk7XG4gICAgICAgIGNvbmRpdGlvbmFsQXR0cl8obm9kZSwgJ2FuZHJvaWQ6dHJhbnNsYXRlWCcsIGxheWVyLnRyYW5zbGF0ZVgsIDApO1xuICAgICAgICBjb25kaXRpb25hbEF0dHJfKG5vZGUsICdhbmRyb2lkOnRyYW5zbGF0ZVknLCBsYXllci50cmFuc2xhdGVZLCAwKTtcbiAgICAgICAgY29uZGl0aW9uYWxBdHRyXyhub2RlLCAnYW5kcm9pZDpzY2FsZVgnLCBsYXllci5zY2FsZVgsIDEpO1xuICAgICAgICBjb25kaXRpb25hbEF0dHJfKG5vZGUsICdhbmRyb2lkOnNjYWxlWScsIGxheWVyLnNjYWxlWSwgMSk7XG4gICAgICAgIGNvbmRpdGlvbmFsQXR0cl8obm9kZSwgJ2FuZHJvaWQ6cm90YXRpb24nLCBsYXllci5yb3RhdGlvbiwgMCk7XG4gICAgICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgIH0sIGRlc3RpbmF0aW9uTm9kZSk7XG4gIH0sXG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7ZGVmYXVsdCBhcyB0aW55Y29sb3J9IGZyb20gJ3Rpbnljb2xvcjInO1xuXG5jb25zdCBCUklHSFRORVNTX1RIUkVTSE9MRCA9IDEzMDsgLy8gZm9yIGlzQ29sb3JEYXJrXG5cblxuZXhwb3J0IGNvbnN0IENvbG9yVXRpbCA9IHtcbiAgcGFyc2VBbmRyb2lkQ29sb3IodmFsKSB7XG4gICAgdmFsID0gKHZhbCB8fCAnJykucmVwbGFjZSgvXlxccyojP3xcXHMqJC9nLCAnJyk7XG4gICAgbGV0IGRpY3QgPSB7YToyNTV9O1xuXG4gICAgaWYgKHZhbC5sZW5ndGggPT0gMykge1xuICAgICAgZGljdC5yID0gcGFyc2VJbnQodmFsLnN1YnN0cmluZygwLCAxKSwgMTYpICogMTc7XG4gICAgICBkaWN0LmcgPSBwYXJzZUludCh2YWwuc3Vic3RyaW5nKDEsIDIpLCAxNikgKiAxNztcbiAgICAgIGRpY3QuYiA9IHBhcnNlSW50KHZhbC5zdWJzdHJpbmcoMiwgMyksIDE2KSAqIDE3O1xuICAgIH0gZWxzZSBpZiAodmFsLmxlbmd0aCA9PSA0KSB7XG4gICAgICBkaWN0LmEgPSBwYXJzZUludCh2YWwuc3Vic3RyaW5nKDAsIDEpLCAxNikgKiAxNztcbiAgICAgIGRpY3QuciA9IHBhcnNlSW50KHZhbC5zdWJzdHJpbmcoMSwgMiksIDE2KSAqIDE3O1xuICAgICAgZGljdC5nID0gcGFyc2VJbnQodmFsLnN1YnN0cmluZygyLCAzKSwgMTYpICogMTc7XG4gICAgICBkaWN0LmIgPSBwYXJzZUludCh2YWwuc3Vic3RyaW5nKDMsIDQpLCAxNikgKiAxNztcbiAgICB9IGVsc2UgaWYgKHZhbC5sZW5ndGggPT0gNikge1xuICAgICAgZGljdC5yID0gcGFyc2VJbnQodmFsLnN1YnN0cmluZygwLCAyKSwgMTYpO1xuICAgICAgZGljdC5nID0gcGFyc2VJbnQodmFsLnN1YnN0cmluZygyLCA0KSwgMTYpO1xuICAgICAgZGljdC5iID0gcGFyc2VJbnQodmFsLnN1YnN0cmluZyg0LCA2KSwgMTYpO1xuICAgIH0gZWxzZSBpZiAodmFsLmxlbmd0aCA9PSA4KSB7XG4gICAgICBkaWN0LmEgPSBwYXJzZUludCh2YWwuc3Vic3RyaW5nKDAsIDIpLCAxNik7XG4gICAgICBkaWN0LnIgPSBwYXJzZUludCh2YWwuc3Vic3RyaW5nKDIsIDQpLCAxNik7XG4gICAgICBkaWN0LmcgPSBwYXJzZUludCh2YWwuc3Vic3RyaW5nKDQsIDYpLCAxNik7XG4gICAgICBkaWN0LmIgPSBwYXJzZUludCh2YWwuc3Vic3RyaW5nKDYsIDgpLCAxNik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiAoaXNOYU4oZGljdC5yKSB8fCBpc05hTihkaWN0LmcpIHx8IGlzTmFOKGRpY3QuYikgfHwgaXNOYU4oZGljdC5hKSlcbiAgICAgICAgPyBudWxsXG4gICAgICAgIDogZGljdDtcbiAgfSxcblxuICB0b0FuZHJvaWRTdHJpbmcoZGljdCkge1xuICAgIGxldCBzdHIgPSAnIyc7XG4gICAgaWYgKGRpY3QuYSAhPSAyNTUpIHtcbiAgICAgIHN0ciArPSAoKGRpY3QuYSA8IDE2KSA/ICcwJyA6ICcnKSArIGRpY3QuYS50b1N0cmluZygxNik7XG4gICAgfVxuXG4gICAgc3RyICs9ICgoZGljdC5yIDwgMTYpID8gJzAnIDogJycpICsgZGljdC5yLnRvU3RyaW5nKDE2KVxuICAgICAgICArICgoZGljdC5nIDwgMTYpID8gJzAnIDogJycpICsgZGljdC5nLnRvU3RyaW5nKDE2KVxuICAgICAgICArICgoZGljdC5iIDwgMTYpID8gJzAnIDogJycpICsgZGljdC5iLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gc3RyO1xuICB9LFxuXG4gIHN2Z1RvQW5kcm9pZENvbG9yKGNvbG9yKSB7XG4gICAgaWYgKGNvbG9yID09ICdub25lJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbG9yID0gdGlueWNvbG9yKGNvbG9yKTtcbiAgICBsZXQgY29sb3JIZXggPSBjb2xvci50b0hleCgpO1xuICAgIGxldCBhbHBoYUhleCA9IGNvbG9yLnRvSGV4OCgpLnN1YnN0cig2KTtcbiAgICByZXR1cm4gJyMnICsgKGFscGhhSGV4ICE9ICdmZicgPyBhbHBoYUhleCA6ICcnKSArIGNvbG9ySGV4O1xuICB9LFxuXG4gIGFuZHJvaWRUb0Nzc0NvbG9yKGFuZHJvaWRDb2xvciwgbXVsdEFscGhhKSB7XG4gICAgbXVsdEFscGhhID0gKG11bHRBbHBoYSA9PT0gdW5kZWZpbmVkKSA/IDEgOiBtdWx0QWxwaGE7XG4gICAgaWYgKCFhbmRyb2lkQ29sb3IpIHtcbiAgICAgIHJldHVybiAndHJhbnNwYXJlbnQnO1xuICAgIH1cblxuICAgIGxldCBkID0gQ29sb3JVdGlsLnBhcnNlQW5kcm9pZENvbG9yKGFuZHJvaWRDb2xvcik7XG4gICAgcmV0dXJuIGByZ2JhKCR7ZC5yfSwke2QuZ30sJHtkLmJ9LCR7KGQuYSAqIG11bHRBbHBoYSAvIDI1NSkudG9GaXhlZCgyKX0pYDtcbiAgfSxcblxuICBpc0FuZHJvaWRDb2xvckRhcmsoYW5kcm9pZENvbG9yKSB7XG4gICAgaWYgKCFhbmRyb2lkQ29sb3IpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgZCA9IENvbG9yVXRpbC5wYXJzZUFuZHJvaWRDb2xvcihhbmRyb2lkQ29sb3IpO1xuICAgIHJldHVybiAoKDMwICogZC5yICsgNTkgKiBkLmcgKyAxMSAqIGQuYikgLyAxMDApIDw9IEJSSUdIVE5FU1NfVEhSRVNIT0xEO1xuICB9XG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmNvbnN0IERSQUdfU0xPUCA9IDQ7IC8vIHBpeGVsc1xuXG5cbmV4cG9ydCBjbGFzcyBEcmFnSGVscGVyIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgdGhpcy5kaXJlY3Rpb25fID0gb3B0cy5kaXJlY3Rpb24gfHwgJ2JvdGgnO1xuICAgIHRoaXMuZG93blhfID0gb3B0cy5kb3duRXZlbnQuY2xpZW50WDtcbiAgICB0aGlzLmRvd25ZXyA9IG9wdHMuZG93bkV2ZW50LmNsaWVudFk7XG4gICAgdGhpcy5za2lwU2xvcENoZWNrXyA9ICEhb3B0cy5za2lwU2xvcENoZWNrO1xuXG4gICAgdGhpcy5vbkJlZ2luRHJhZ18gPSBvcHRzLm9uQmVnaW5EcmFnIHx8ICgoKSA9PiB7fSk7XG4gICAgdGhpcy5vbkRyYWdfID0gb3B0cy5vbkRyYWcgfHwgKCgpID0+IHt9KTtcbiAgICB0aGlzLm9uRHJvcF8gPSBvcHRzLm9uRHJvcCB8fCAoKCkgPT4ge30pO1xuXG4gICAgdGhpcy5kcmFnZ2luZ18gPSBmYWxzZTtcbiAgICB0aGlzLmRyYWdnaW5nU2NyaW1fID0gbnVsbDtcblxuICAgIHRoaXMuZHJhZ2dpbmdDdXJzb3IgPSBvcHRzLmRyYWdnaW5nQ3Vyc29yIHx8ICdncmFiYmluZyc7XG5cbiAgICBsZXQgbW91c2VNb3ZlSGFuZGxlcl8gPSBldmVudCA9PiB7XG4gICAgICBpZiAoIXRoaXMuZHJhZ2dpbmdfICYmIHRoaXMuc2hvdWxkQmVnaW5EcmFnZ2luZ18oZXZlbnQpKSB7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmdfID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kcmFnZ2luZ1NjcmltXyA9IHRoaXMuYnVpbGREcmFnZ2luZ1NjcmltXygpLmFwcGVuZFRvKGRvY3VtZW50LmJvZHkpO1xuICAgICAgICB0aGlzLmRyYWdnaW5nQ3Vyc29yID0gdGhpcy5kcmFnZ2luZ0N1cnNvcl87XG4gICAgICAgIHRoaXMub25CZWdpbkRyYWdfKGV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZHJhZ2dpbmdfKSB7XG4gICAgICAgIHRoaXMub25EcmFnXyhldmVudCwge1xuICAgICAgICAgIHg6IGV2ZW50LmNsaWVudFggLSB0aGlzLmRvd25YXyxcbiAgICAgICAgICB5OiBldmVudC5jbGllbnRZIC0gdGhpcy5kb3duWV9cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxldCBtb3VzZVVwSGFuZGxlcl8gPSBldmVudCA9PiB7XG4gICAgICAkKHdpbmRvdylcbiAgICAgICAgICAub2ZmKCdtb3VzZW1vdmUnLCBtb3VzZU1vdmVIYW5kbGVyXylcbiAgICAgICAgICAub2ZmKCdtb3VzZXVwJywgbW91c2VVcEhhbmRsZXJfKTtcbiAgICAgIGlmICh0aGlzLmRyYWdnaW5nXykge1xuICAgICAgICB0aGlzLm9uRHJhZ18oZXZlbnQsIHtcbiAgICAgICAgICB4OiBldmVudC5jbGllbnRYIC0gdGhpcy5kb3duWF8sXG4gICAgICAgICAgeTogZXZlbnQuY2xpZW50WSAtIHRoaXMuZG93bllfXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMub25Ecm9wXygpO1xuXG4gICAgICAgIHRoaXMuZHJhZ2dpbmdTY3JpbV8ucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmdTY3JpbV8gPSBudWxsO1xuICAgICAgICB0aGlzLmRyYWdnaW5nXyA9IGZhbHNlO1xuXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcblxuICAgICQod2luZG93KVxuICAgICAgICAub24oJ21vdXNlbW92ZScsIG1vdXNlTW92ZUhhbmRsZXJfKVxuICAgICAgICAub24oJ21vdXNldXAnLCBtb3VzZVVwSGFuZGxlcl8pO1xuICB9XG5cbiAgc2hvdWxkQmVnaW5EcmFnZ2luZ18obW91c2VNb3ZlRXZlbnQpIHtcbiAgICBpZiAodGhpcy5za2lwU2xvcENoZWNrXykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgbGV0IGJlZ2luID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuZGlyZWN0aW9uXyA9PSAnYm90aCcgfHwgdGhpcy5kaXJlY3Rpb25fID09ICdob3Jpem9udGFsJykge1xuICAgICAgYmVnaW4gPSBiZWdpbiB8fCAoTWF0aC5hYnMobW91c2VNb3ZlRXZlbnQuY2xpZW50WCAtIHRoaXMuZG93blhfKSA+IERSQUdfU0xPUCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmRpcmVjdGlvbl8gPT0gJ2JvdGgnIHx8IHRoaXMuZGlyZWN0aW9uXyA9PSAndmVydGljYWwnKSB7XG4gICAgICBiZWdpbiA9IGJlZ2luIHx8IChNYXRoLmFicyhtb3VzZU1vdmVFdmVudC5jbGllbnRZIC0gdGhpcy5kb3duWV8pID4gRFJBR19TTE9QKTtcbiAgICB9XG4gICAgcmV0dXJuIGJlZ2luO1xuICB9XG5cbiAgc2V0IGRyYWdnaW5nQ3Vyc29yKGN1cnNvcikge1xuICAgIGlmIChjdXJzb3IgPT0gJ2dyYWJiaW5nJykge1xuICAgICAgY3Vyc29yID0gYC13ZWJraXQtJHtjdXJzb3J9YDtcbiAgICB9XG5cbiAgICB0aGlzLmRyYWdnaW5nQ3Vyc29yXyA9IGN1cnNvcjtcbiAgICBpZiAodGhpcy5kcmFnZ2luZ1NjcmltXykge1xuICAgICAgdGhpcy5kcmFnZ2luZ1NjcmltXy5jc3Moe2N1cnNvcn0pO1xuICAgIH1cbiAgfVxuXG4gIGJ1aWxkRHJhZ2dpbmdTY3JpbV8oKSB7XG4gICAgcmV0dXJuICQoJzxkaXY+JylcbiAgICAgICAgLmNzcyh7XG4gICAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAgIHpJbmRleDogOTk5OVxuICAgICAgICB9KTtcbiAgfVxuXG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLy8gQmFzZWQgb24gaHR0cDovL3d3dy5iYWNrYWxsZXljb2Rlci5jb20vMjAxMy8wMy8xOC9jcm9zcy1icm93c2VyLWV2ZW50LWJhc2VkLWVsZW1lbnQtcmVzaXplLWRldGVjdGlvbi9cblxuZXhwb3J0IGNsYXNzIEVsZW1lbnRSZXNpemVXYXRjaGVyIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLmVsZW1lbnRfID0gJChlbGVtZW50KTtcblxuICAgIC8vIGNyZWF0ZSByZXNpemUgbGlzdGVuZXJcbiAgICBsZXQgcmFmSGFuZGxlO1xuXG4gICAgdGhpcy5vblJlc2l6ZV8gPSBldmVudCA9PiB7XG4gICAgICB2YXIgZWwgPSBldmVudC50YXJnZXQgfHwgZXZlbnQuc3JjRWxlbWVudDtcbiAgICAgIGlmIChyYWZIYW5kbGUpIHtcbiAgICAgICAgZWwuY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSGFuZGxlKTtcbiAgICAgIH1cblxuICAgICAgcmFmSGFuZGxlID0gZWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IGxpc3RlbmVyKCkpO1xuICAgIH07XG5cbiAgICAvLyBhZGQgbGlzdGVuZXJcbiAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVsZW1lbnRfLmdldCgwKSkucG9zaXRpb24gPT0gJ3N0YXRpYycpIHtcbiAgICAgIHRoaXMuZWxlbWVudF8uY3NzKHtwb3NpdGlvbjogJ3JlbGF0aXZlJ30pO1xuICAgIH1cblxuICAgIHRoaXMucHJveHlFbGVtZW50XyA9ICQoJzxvYmplY3Q+JylcbiAgICAgICAgLmNzcyh7XG4gICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICAgICAgekluZGV4OiAtMVxuICAgICAgICB9KVxuICAgICAgICAuYXR0cigndHlwZScsICd0ZXh0L2h0bWwnKVxuICAgICAgICAuYXR0cignZGF0YScsICdhYm91dDpibGFuaycpXG4gICAgICAgIC5vbignbG9hZCcsICgpID0+IHtcbiAgICAgICAgICB0aGlzLnByb3h5RGVmYXVsdFZpZXdfID0gdGhpcy5wcm94eUVsZW1lbnRfLmdldCgwKS5jb250ZW50RG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgICAgICAgdGhpcy5wcm94eURlZmF1bHRWaWV3Xy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLm9uUmVzaXplXyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5hcHBlbmRUbyh0aGlzLmVsZW1lbnRfKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMucHJveHlEZWZhdWx0Vmlld18pIHtcbiAgICAgIHRoaXMucHJveHlEZWZhdWx0Vmlld18ucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5vblJlc2l6ZV8pO1xuICAgIH1cblxuICAgIHRoaXMucHJveHlFbGVtZW50Xy5yZW1vdmUoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBjb25zdCBNYXRoVXRpbCA9IHtcbiAgcHJvZ3Jlc3ModmFsLCBtaW4sIG1heCkge1xuICAgIHJldHVybiBNYXRoVXRpbC5jb25zdHJhaW4oKHZhbCAtIG1pbikgLyAobWF4IC0gbWluKSwgMCwgMSk7XG4gIH0sXG5cbiAgY29uc3RyYWluKHZhbCwgbWluLCBtYXgpIHtcbiAgICBpZiAodmFsIDwgbWluKSB7XG4gICAgICByZXR1cm4gbWluO1xuICAgIH0gZWxzZSBpZiAodmFsID4gbWF4KSB7XG4gICAgICByZXR1cm4gbWF4O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgfSxcblxuICBpbnRlcnBvbGF0ZShzdGFydCwgZW5kLCBmKSB7XG4gICAgcmV0dXJuIHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIGY7XG4gIH0sXG5cbiAgZGlzdCh4MSwgeTEsIHgyLCB5Mikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coeTIgLSB5MSwgMikgKyBNYXRoLnBvdyh4MiAtIHgxLCAyKSk7XG4gIH0sXG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBjb25zdCBNb2RlbFV0aWwgPSB7XG4gIGdldE9yZGVyZWRBbmltYXRpb25CbG9ja3NCeUxheWVySWRBbmRQcm9wZXJ0eShhbmltYXRpb24pIHtcbiAgICBsZXQgYW5pbWF0aW9uQmxvY2tzQnlMYXllcklkID0ge307XG5cbiAgICBhbmltYXRpb24uYmxvY2tzLmZvckVhY2goYmxvY2sgPT4ge1xuICAgICAgbGV0IGJsb2Nrc0J5UHJvcGVydHkgPSBhbmltYXRpb25CbG9ja3NCeUxheWVySWRbYmxvY2subGF5ZXJJZF07XG4gICAgICBpZiAoIWJsb2Nrc0J5UHJvcGVydHkpIHtcbiAgICAgICAgYmxvY2tzQnlQcm9wZXJ0eSA9IHt9O1xuICAgICAgICBhbmltYXRpb25CbG9ja3NCeUxheWVySWRbYmxvY2subGF5ZXJJZF0gPSBibG9ja3NCeVByb3BlcnR5O1xuICAgICAgfVxuXG4gICAgICBibG9ja3NCeVByb3BlcnR5W2Jsb2NrLnByb3BlcnR5TmFtZV0gPSBibG9ja3NCeVByb3BlcnR5W2Jsb2NrLnByb3BlcnR5TmFtZV0gfHwgW107XG4gICAgICBibG9ja3NCeVByb3BlcnR5W2Jsb2NrLnByb3BlcnR5TmFtZV0ucHVzaChibG9jayk7XG4gICAgfSk7XG5cbiAgICBmb3IgKGxldCBsYXllcklkIGluIGFuaW1hdGlvbkJsb2Nrc0J5TGF5ZXJJZCkge1xuICAgICAgbGV0IGJsb2Nrc0J5UHJvcGVydHkgPSBhbmltYXRpb25CbG9ja3NCeUxheWVySWRbbGF5ZXJJZF07XG4gICAgICBmb3IgKGxldCBwcm9wZXJ0eU5hbWUgaW4gYmxvY2tzQnlQcm9wZXJ0eSkge1xuICAgICAgICBibG9ja3NCeVByb3BlcnR5W3Byb3BlcnR5TmFtZV0uc29ydCgoYSwgYikgPT4gYS5zdGFydFRpbWUgLSBiLnN0YXJ0VGltZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuaW1hdGlvbkJsb2Nrc0J5TGF5ZXJJZDtcbiAgfSxcblxuICBnZXRVbmlxdWVJZChvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgb3B0cy5wcmVmaXggPSBvcHRzLnByZWZpeCB8fCAnJztcbiAgICBvcHRzLm9iamVjdEJ5SWQgPSBvcHRzLm9iamVjdEJ5SWQgfHwgKCgpID0+IG51bGwpO1xuICAgIG9wdHMudGFyZ2V0T2JqZWN0ID0gb3B0cy50YXJnZXRPYmplY3QgfHwgbnVsbDtcblxuICAgIGxldCBuID0gMDtcbiAgICBsZXQgaWRfID0gKCkgPT4gb3B0cy5wcmVmaXggKyAobiA/IGBfJHtufWAgOiAnJyk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGxldCBvID0gb3B0cy5vYmplY3RCeUlkKGlkXygpKTtcbiAgICAgIGlmICghbyB8fCBvID09IG9wdHMudGFyZ2V0T2JqZWN0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICArK247XG4gICAgfVxuXG4gICAgcmV0dXJuIGlkXygpO1xuICB9XG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmNvbnN0IElERU5USVRZX1RSQU5TRk9STV9NQVRSSVggPSBbMSwgMCwgMCwgMSwgMCwgMF07XG5cbmV4cG9ydCBjb25zdCBSZW5kZXJVdGlsID0ge1xuICB0cmFuc2Zvcm1NYXRyaXhGb3JMYXllcihsYXllcikge1xuICAgIGxldCBjb3NSID0gTWF0aC5jb3MobGF5ZXIucm90YXRpb24gKiBNYXRoLlBJIC8gMTgwKTtcbiAgICBsZXQgc2luUiA9IE1hdGguc2luKGxheWVyLnJvdGF0aW9uICogTWF0aC5QSSAvIDE4MCk7XG5cbiAgICAvLyBmaXJzdCBuZWdhdGl2ZSBwaXZvdCwgdGhlbiBzY2FsZSwgcm90YXRlLCB0cmFuc2xhdGUsIGFuZCBwaXZvdFxuICAgIC8vIG5vdGVzOlxuICAgIC8vIHRyYW5zbGF0ZTogWzEsIDAsIDAsIDEsIHgsIHldXG4gICAgLy8gc2NhbGU6IFtzeCwgMCwgMCwgc3ksIDAsIDBdXG4gICAgLy8gcm90YXRlOiBbY29zLCBzaW4sIC1zaW4sIGNvcywgMCwgMF1cblxuICAgIHJldHVybiBbXG4gICAgICBjb3NSICogbGF5ZXIuc2NhbGVYLFxuICAgICAgc2luUiAqIGxheWVyLnNjYWxlWCxcbiAgICAgIC1zaW5SICogbGF5ZXIuc2NhbGVZLFxuICAgICAgY29zUiAqIGxheWVyLnNjYWxlWSxcbiAgICAgIChsYXllci5waXZvdFggKyBsYXllci50cmFuc2xhdGVYKVxuICAgICAgICAgIC0gY29zUiAqIGxheWVyLnNjYWxlWCAqIGxheWVyLnBpdm90WFxuICAgICAgICAgICsgc2luUiAqIGxheWVyLnNjYWxlWSAqIGxheWVyLnBpdm90WSxcbiAgICAgIChsYXllci5waXZvdFkgKyBsYXllci50cmFuc2xhdGVZKVxuICAgICAgICAgIC0gY29zUiAqIGxheWVyLnNjYWxlWSAqIGxheWVyLnBpdm90WVxuICAgICAgICAgIC0gc2luUiAqIGxheWVyLnNjYWxlWCAqIGxheWVyLnBpdm90WFxuICAgIF07XG4gIH0sXG5cbiAgZmxhdHRlblRyYW5zZm9ybXModHJhbnNmb3Jtcykge1xuICAgIHJldHVybiAodHJhbnNmb3JtcyB8fCBbXSkucmVkdWNlKFxuICAgICAgICAobSwgdHJhbnNmb3JtKSA9PiB0cmFuc2Zvcm1NYXRyaXhfKHRyYW5zZm9ybSwgbSksXG4gICAgICAgIElERU5USVRZX1RSQU5TRk9STV9NQVRSSVgpO1xuICB9LFxuXG4gIHRyYW5zZm9ybVBvaW50KG1hdHJpY2VzLCBwKSB7XG4gICAgaWYgKCFtYXRyaWNlcyB8fCAhbWF0cmljZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdHJpY2VzLnJlZHVjZSgocCwgbSkgPT4gKHtcbiAgICAgIC8vIFthIGMgZV0gICBbcC54XVxuICAgICAgLy8gW2IgZCBmXSAqIFtwLnldXG4gICAgICAvLyBbMCAwIDFdICAgWyAxIF1cbiAgICAgIHg6IG1bMF0gKiBwLnggKyBtWzJdICogcC55ICsgbVs0XSxcbiAgICAgIHk6IG1bMV0gKiBwLnggKyBtWzNdICogcC55ICsgbVs1XVxuICAgIH0pLCBwKTtcbiAgfSxcblxuICBjb21wdXRlU3Ryb2tlV2lkdGhNdWx0aXBsaWVyKHRyYW5zZm9ybU1hdHJpeCkge1xuICAgIC8vIGZyb20gZ2V0TWF0cml4U2NhbGUgaW5cbiAgICAvLyBodHRwczovL2FuZHJvaWQuZ29vZ2xlc291cmNlLmNvbS9wbGF0Zm9ybS9mcmFtZXdvcmtzL2Jhc2UvKy9tYXN0ZXIvbGlicy9od3VpL1ZlY3RvckRyYXdhYmxlLmNwcFxuXG4gICAgLy8gR2l2ZW4gdW5pdCB2ZWN0b3JzIEEgPSAoMCwgMSkgYW5kIEIgPSAoMSwgMCkuXG4gICAgLy8gQWZ0ZXIgbWF0cml4IG1hcHBpbmcsIHdlIGdvdCBBJyBhbmQgQicuIExldCB0aGV0YSA9IHRoZSBhbmdlbCBiL3QgQScgYW5kIEInLlxuICAgIC8vIFRoZXJlZm9yZSwgdGhlIGZpbmFsIHNjYWxlIHdlIHdhbnQgaXMgbWluKHxBJ3wgKiBzaW4odGhldGEpLCB8Qid8ICogc2luKHRoZXRhKSksXG4gICAgLy8gd2hpY2ggaXMgKHxBJ3wgKiB8Qid8ICogc2luKHRoZXRhKSkgLyBtYXggKHxBJ3wsIHxCJ3wpO1xuICAgIC8vIElmICBtYXggKHxBJ3wsIHxCJ3wpID0gMCwgdGhhdCBtZWFucyBlaXRoZXIgeCBvciB5IGhhcyBhIHNjYWxlIG9mIDAuXG4gICAgLy9cbiAgICAvLyBGb3Igbm9uLXNrZXcgY2FzZSwgd2hpY2ggaXMgbW9zdCBvZiB0aGUgY2FzZXMsIG1hdHJpeCBzY2FsZSBpcyBjb21wdXRpbmcgZXhhY3RseSB0aGVcbiAgICAvLyBzY2FsZSBvbiB4IGFuZCB5IGF4aXMsIGFuZCB0YWtlIHRoZSBtaW5pbWFsIG9mIHRoZXNlIHR3by5cbiAgICAvLyBGb3Igc2tldyBjYXNlLCBhbiB1bml0IHNxdWFyZSB3aWxsIG1hcHBlZCB0byBhIHBhcmFsbGVsb2dyYW0uIEFuZCB0aGlzIGZ1bmN0aW9uIHdpbGxcbiAgICAvLyByZXR1cm4gdGhlIG1pbmltYWwgaGVpZ2h0IG9mIHRoZSAyIGJhc2VzLlxuXG4gICAgLy8gZmlyc3QgcmVtb3ZlIHRyYW5zbGF0ZSBlbGVtZW50cyBmcm9tIG1hdHJpeFxuICAgIHRyYW5zZm9ybU1hdHJpeFs0XSA9IHRyYW5zZm9ybU1hdHJpeFs1XSA9IDA7XG5cbiAgICBsZXQgdmVjQSA9IFJlbmRlclV0aWwudHJhbnNmb3JtUG9pbnQoW3RyYW5zZm9ybU1hdHJpeF0sIHt4OjAsIHk6MX0pO1xuICAgIGxldCB2ZWNCID0gUmVuZGVyVXRpbC50cmFuc2Zvcm1Qb2ludChbdHJhbnNmb3JtTWF0cml4XSwge3g6MSwgeTowfSk7XG4gICAgbGV0IHNjYWxlWCA9IE1hdGguaHlwb3QodmVjQS54LCB2ZWNBLnkpO1xuICAgIGxldCBzY2FsZVkgPSBNYXRoLmh5cG90KHZlY0IueCwgdmVjQi55KTtcbiAgICBsZXQgY3Jvc3NQcm9kdWN0ID0gdmVjQS55ICogdmVjQi54IC0gdmVjQS54ICogdmVjQi55OyAvLyB2ZWN0b3IgY3Jvc3MgcHJvZHVjdFxuICAgIGxldCBtYXhTY2FsZSA9IE1hdGgubWF4KHNjYWxlWCwgc2NhbGVZKTtcbiAgICBsZXQgbWF0cml4U2NhbGUgPSAwO1xuICAgIGlmIChtYXhTY2FsZSA+IDApIHtcbiAgICAgIG1hdHJpeFNjYWxlID0gTWF0aC5hYnMoY3Jvc3NQcm9kdWN0KSAvIG1heFNjYWxlO1xuICAgIH1cbiAgICByZXR1cm4gbWF0cml4U2NhbGU7XG4gIH1cbn07XG5cblxuLy8gZm9ybXVsYSBnZW5lcmF0ZWQgdy8gd29sZnJhbSBhbHBoYVxuLy8gcmV0dXJucyB0aGUgcHJvZHVjdCBvZiAyRCB0cmFuc2Zvcm1hdGlvbiBtYXRyaWNlcyBzIGFuZCB0XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdHJpeF8ocywgdCkge1xuICByZXR1cm4gW3RbMF0gKiBzWzBdICsgdFsxXSAqIHNbMl0sXG4gICAgICAgICAgdFswXSAqIHNbMV0gKyB0WzFdICogc1szXSxcbiAgICAgICAgICBzWzBdICogdFsyXSArIHNbMl0gKiB0WzNdLFxuICAgICAgICAgIHNbMV0gKiB0WzJdICsgdFszXSAqIHNbM10sXG4gICAgICAgICAgc1swXSAqIHRbNF0gKyBzWzRdICsgc1syXSAqIHRbNV0sXG4gICAgICAgICAgc1sxXSAqIHRbNF0gKyBzWzNdICogdFs1XSArIHNbNV1dO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7QXJ0d29yaywgRGVmYXVsdFZhbHVlc30gZnJvbSAnLi9tb2RlbCc7XG5pbXBvcnQge0lkUHJvcGVydHl9IGZyb20gJy4vbW9kZWwvcHJvcGVydGllcyc7XG5pbXBvcnQge0NvbG9yVXRpbH0gZnJvbSAnLi9Db2xvclV0aWwnO1xuaW1wb3J0IHtTdmdQYXRoRGF0YX0gZnJvbSAnLi9TdmdQYXRoRGF0YSc7XG5pbXBvcnQge01vZGVsVXRpbH0gZnJvbSAnLi9Nb2RlbFV0aWwnO1xuXG5cbmV4cG9ydCBjb25zdCBTdmdMb2FkZXIgPSB7XG4gIGxvYWRBcnR3b3JrRnJvbVN2Z1N0cmluZyhzdmdTdHJpbmcpIHtcbiAgICBsZXQgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgIGxldCBkb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHN2Z1N0cmluZywgJ2ltYWdlL3N2Zyt4bWwnKTtcblxuICAgIGxldCB1c2VkSWRzID0ge307XG5cbiAgICBsZXQgbm9kZVRvTGF5ZXJEYXRhXyA9IChub2RlLCBjb250ZXh0KSA9PiB7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IE5vZGUuVEVYVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT0gTm9kZS5DT01NRU5UX05PREUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGxldCBtYWtlRmluYWxOb2RlSWRfID0gdHlwZUlkUHJlZml4ID0+IHtcbiAgICAgICAgbGV0IGZpbmFsSWQgPSBNb2RlbFV0aWwuZ2V0VW5pcXVlSWQoe1xuICAgICAgICAgIHByZWZpeDogSWRQcm9wZXJ0eS5zYW5pdGl6ZShub2RlLmlkIHx8IHR5cGVJZFByZWZpeCksXG4gICAgICAgICAgb2JqZWN0QnlJZDogaWQgPT4gdXNlZElkc1tpZF0sXG4gICAgICAgIH0pO1xuICAgICAgICB1c2VkSWRzW2ZpbmFsSWRdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZpbmFsSWQ7XG4gICAgICB9O1xuXG4gICAgICBsZXQgbGF5ZXJEYXRhID0ge307XG5cbiAgICAgIGxldCBzaW1wbGVBdHRyXyA9IChub2RlQXR0ciwgY29udGV4dEF0dHIpID0+IHtcbiAgICAgICAgaWYgKG5vZGUuYXR0cmlidXRlc1tub2RlQXR0cl0pIHtcbiAgICAgICAgICBjb250ZXh0W2NvbnRleHRBdHRyXSA9IG5vZGUuYXR0cmlidXRlc1tub2RlQXR0cl0udmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIHNldCBhdHRyaWJ1dGVzXG4gICAgICBzaW1wbGVBdHRyXygnc3Ryb2tlJywgJ3N0cm9rZUNvbG9yJyk7XG4gICAgICBzaW1wbGVBdHRyXygnc3Ryb2tlLXdpZHRoJywgJ3N0cm9rZVdpZHRoJyk7XG4gICAgICBzaW1wbGVBdHRyXygnc3Ryb2tlLWxpbmVjYXAnLCAnc3Ryb2tlTGluZWNhcCcpO1xuICAgICAgc2ltcGxlQXR0cl8oJ3N0cm9rZS1saW5lam9pbicsICdzdHJva2VMaW5lam9pbicpO1xuICAgICAgc2ltcGxlQXR0cl8oJ3N0cm9rZS1taXRlcmxpbWl0JywgJ3N0cm9rZU1pdGVyTGltaXQnKTtcbiAgICAgIHNpbXBsZUF0dHJfKCdzdHJva2Utb3BhY2l0eScsICdzdHJva2VBbHBoYScpO1xuICAgICAgc2ltcGxlQXR0cl8oJ2ZpbGwnLCAnZmlsbENvbG9yJyk7XG4gICAgICBzaW1wbGVBdHRyXygnZmlsbC1vcGFjaXR5JywgJ2ZpbGxBbHBoYScpO1xuXG4gICAgICAvLyBhZGQgdHJhbnNmb3Jtc1xuXG4gICAgICBpZiAobm9kZS50cmFuc2Zvcm0pIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybXMgPSBBcnJheS5mcm9tKG5vZGUudHJhbnNmb3JtLmJhc2VWYWwpO1xuICAgICAgICB0cmFuc2Zvcm1zLnJldmVyc2UoKTtcbiAgICAgICAgY29udGV4dC50cmFuc2Zvcm1zID0gY29udGV4dC50cmFuc2Zvcm1zID8gY29udGV4dC50cmFuc2Zvcm1zLnNsaWNlKCkgOiBbXTtcbiAgICAgICAgY29udGV4dC50cmFuc2Zvcm1zLnNwbGljZSgwLCAwLCAuLi50cmFuc2Zvcm1zKTtcbiAgICAgIH1cblxuICAgICAgLy8gc2VlIGlmIHRoaXMgaXMgYSBwYXRoXG4gICAgICBsZXQgcGF0aDtcbiAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgU1ZHUGF0aEVsZW1lbnQpIHtcbiAgICAgICAgcGF0aCA9IG5vZGUuYXR0cmlidXRlcy5kLnZhbHVlO1xuXG4gICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBTVkdSZWN0RWxlbWVudCkge1xuICAgICAgICBsZXQgbCA9IGxlbmd0aFB4Xyhub2RlLngpLFxuICAgICAgICAgICAgdCA9IGxlbmd0aFB4Xyhub2RlLnkpLFxuICAgICAgICAgICAgciA9IGwgKyBsZW5ndGhQeF8obm9kZS53aWR0aCksXG4gICAgICAgICAgICBiID0gdCArIGxlbmd0aFB4Xyhub2RlLmhlaWdodCk7XG4gICAgICAgIC8vIFRPRE86IGhhbmRsZSBjb3JuZXIgcmFkaWlcbiAgICAgICAgcGF0aCA9IGBNICR7bH0sJHt0fSAke3J9LCR7dH0gJHtyfSwke2J9ICR7bH0sJHtifSBaYDtcblxuICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgU1ZHTGluZUVsZW1lbnQpIHtcbiAgICAgICAgbGV0IHgxID0gbGVuZ3RoUHhfKG5vZGUueDEpLFxuICAgICAgICAgICAgeTEgPSBsZW5ndGhQeF8obm9kZS55MSksXG4gICAgICAgICAgICB4MiA9IGxlbmd0aFB4Xyhub2RlLngyKSxcbiAgICAgICAgICAgIHkyID0gbGVuZ3RoUHhfKG5vZGUueTIpO1xuICAgICAgICBwYXRoID0gYE0gJHt4MX0sJHt5MX0gJHt4Mn0sJHt5Mn0gWmA7XG5cbiAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFNWR1BvbHlnb25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBTVkdQb2x5bGluZUVsZW1lbnQpIHtcbiAgICAgICAgcGF0aCA9ICdNICcgKyBBcnJheS5mcm9tKG5vZGUucG9pbnRzKS5tYXAocHQgPT4gcHQueCArJywnICsgcHQueSkuam9pbignICcpO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFNWR1BvbHlnb25FbGVtZW50KSB7XG4gICAgICAgICAgcGF0aCArPSAnIFonO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFNWR0NpcmNsZUVsZW1lbnQpIHtcbiAgICAgICAgbGV0IGN4ID0gbGVuZ3RoUHhfKG5vZGUuY3gpLFxuICAgICAgICAgICAgY3kgPSBsZW5ndGhQeF8obm9kZS5jeSksXG4gICAgICAgICAgICByID0gbGVuZ3RoUHhfKG5vZGUucik7XG4gICAgICAgIHBhdGggPSBgTSAke2N4fSwke2N5LXJ9IEEgJHtyfSAke3J9IDAgMSAwICR7Y3h9LCR7Y3krcn0gQSAke3J9ICR7cn0gMCAxIDAgJHtjeH0sJHtjeS1yfSBaYDtcblxuICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgU1ZHRWxsaXBzZUVsZW1lbnQpIHtcbiAgICAgICAgbGV0IGN4ID0gbGVuZ3RoUHhfKG5vZGUuY3gpLFxuICAgICAgICAgICAgY3kgPSBsZW5ndGhQeF8obm9kZS5jeSksXG4gICAgICAgICAgICByeCA9IGxlbmd0aFB4Xyhub2RlLnJ4KSxcbiAgICAgICAgICAgIHJ5ID0gbGVuZ3RoUHhfKG5vZGUucnkpO1xuICAgICAgICBwYXRoID0gYE0gJHtjeH0sJHtjeS1yeX0gQSAke3J4fSAke3J5fSAwIDEgMCAke2N4fSwke2N5K3J5fSBgICtcbiAgICAgICAgICAgICAgIGBBICR7cnh9ICR7cnl9IDAgMSAwICR7Y3h9LCR7Y3ktcnl9IFpgO1xuICAgICAgfVxuXG4gICAgICBpZiAocGF0aCkge1xuICAgICAgICAvLyB0cmFuc2Zvcm0gYWxsIHBvaW50c1xuICAgICAgICBpZiAoY29udGV4dC50cmFuc2Zvcm1zICYmIGNvbnRleHQudHJhbnNmb3Jtcy5sZW5ndGgpIHtcbiAgICAgICAgICBsZXQgcGF0aERhdGEgPSBuZXcgU3ZnUGF0aERhdGEocGF0aCk7XG4gICAgICAgICAgcGF0aERhdGEudHJhbnNmb3JtKGNvbnRleHQudHJhbnNmb3Jtcyk7XG4gICAgICAgICAgcGF0aCA9IHBhdGhEYXRhLnBhdGhTdHJpbmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgYSBwYXRoIGxheWVyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGxheWVyRGF0YSwge1xuICAgICAgICAgIGlkOiBtYWtlRmluYWxOb2RlSWRfKCdwYXRoJyksXG4gICAgICAgICAgcGF0aERhdGE6IHBhdGgsXG4gICAgICAgICAgZmlsbENvbG9yOiAoJ2ZpbGxDb2xvcicgaW4gY29udGV4dCkgPyBDb2xvclV0aWwuc3ZnVG9BbmRyb2lkQ29sb3IoY29udGV4dC5maWxsQ29sb3IpIDogXCIjZmYwMDAwMDBcIixcbiAgICAgICAgICBmaWxsQWxwaGE6ICgnZmlsbEFscGhhJyBpbiBjb250ZXh0KSA/IGNvbnRleHQuZmlsbEFscGhhIDogMSxcbiAgICAgICAgICBzdHJva2VDb2xvcjogKCdzdHJva2VDb2xvcicgaW4gY29udGV4dCkgPyBDb2xvclV0aWwuc3ZnVG9BbmRyb2lkQ29sb3IoY29udGV4dC5zdHJva2VDb2xvcikgOiBudWxsLFxuICAgICAgICAgIHN0cm9rZUFscGhhOiAoJ3N0cm9rZUFscGhhJyBpbiBjb250ZXh0KSA/IGNvbnRleHQuc3Ryb2tlQWxwaGEgOiAxLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiAoJ3N0cm9rZVdpZHRoJyBpbiBjb250ZXh0KSA/IGNvbnRleHQuc3Ryb2tlV2lkdGggOiAxLFxuICAgICAgICAgIHN0cm9rZUxpbmVjYXA6IGNvbnRleHQuc3Ryb2tlTGluZWNhcCB8fCBEZWZhdWx0VmFsdWVzLkxJTkVDQVAsXG4gICAgICAgICAgc3Ryb2tlTGluZWpvaW46IGNvbnRleHQuc3Ryb2tlTGluZWpvaW4gfHwgRGVmYXVsdFZhbHVlcy5MSU5FSk9JTixcbiAgICAgICAgICBzdHJva2VNaXRlckxpbWl0OiAoJ3N0cm9rZU1pdGVyTGltaXQnIGluIGNvbnRleHQpID8gY29udGV4dC5zdHJva2VNaXRlckxpbWl0IDogRGVmYXVsdFZhbHVlcy5NSVRFUl9MSU1JVCxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIGxldCBsYXllcnMgPSBBcnJheS5mcm9tKG5vZGUuY2hpbGROb2RlcylcbiAgICAgICAgICAgIC5tYXAoY2hpbGQgPT4gbm9kZVRvTGF5ZXJEYXRhXyhjaGlsZCwgT2JqZWN0LmFzc2lnbih7fSwgY29udGV4dCkpKVxuICAgICAgICAgICAgLmZpbHRlcihsYXllciA9PiAhIWxheWVyKTtcbiAgICAgICAgaWYgKGxheWVycyAmJiBsYXllcnMubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gY3JlYXRlIGEgZ3JvdXAgKHRoZXJlIGFyZSB2YWxpZCBjaGlsZHJlbilcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihsYXllckRhdGEsIHtcbiAgICAgICAgICAgIGlkOiBtYWtlRmluYWxOb2RlSWRfKCdncm91cCcpLFxuICAgICAgICAgICAgdHlwZTogJ2dyb3VwJyxcbiAgICAgICAgICAgIGxheWVyczogbGF5ZXJzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGV0IGRvY0VsQ29udGV4dCA9IHt9O1xuICAgIGxldCB3aWR0aCA9IGxlbmd0aFB4Xyhkb2MuZG9jdW1lbnRFbGVtZW50LndpZHRoKTtcbiAgICBsZXQgaGVpZ2h0ID0gbGVuZ3RoUHhfKGRvYy5kb2N1bWVudEVsZW1lbnQuaGVpZ2h0KTtcblxuICAgIGlmIChkb2MuZG9jdW1lbnRFbGVtZW50LnZpZXdCb3gpIHtcbiAgICAgIHdpZHRoID0gZG9jLmRvY3VtZW50RWxlbWVudC52aWV3Qm94LmJhc2VWYWwud2lkdGg7XG4gICAgICBoZWlnaHQgPSBkb2MuZG9jdW1lbnRFbGVtZW50LnZpZXdCb3guYmFzZVZhbC5oZWlnaHQ7XG5cbiAgICAgIC8vIGZha2UgYSB0cmFuc2xhdGUgdHJhbnNmb3JtIGZvciB0aGUgdmlld2JveFxuICAgICAgZG9jRWxDb250ZXh0LnRyYW5zZm9ybXMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBtYXRyaXg6IHtcbiAgICAgICAgICAgIGE6IDEsXG4gICAgICAgICAgICBiOiAwLFxuICAgICAgICAgICAgYzogMCxcbiAgICAgICAgICAgIGQ6IDEsXG4gICAgICAgICAgICBlOiAtZG9jLmRvY3VtZW50RWxlbWVudC52aWV3Qm94LmJhc2VWYWwueCxcbiAgICAgICAgICAgIGY6IC1kb2MuZG9jdW1lbnRFbGVtZW50LnZpZXdCb3guYmFzZVZhbC55XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH1cblxuICAgIGxldCByb290TGF5ZXIgPSBub2RlVG9MYXllckRhdGFfKGRvYy5kb2N1bWVudEVsZW1lbnQsIGRvY0VsQ29udGV4dCk7XG5cbiAgICBsZXQgYXJ0d29yayA9IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgbGF5ZXJzOiAocm9vdExheWVyID8gcm9vdExheWVyLmxheWVycyA6IG51bGwpIHx8IFtdLFxuICAgICAgYWxwaGE6IGRvYy5kb2N1bWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdvcGFjaXR5JykgfHwgMSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIG5ldyBBcnR3b3JrKGFydHdvcmspO1xuICB9XG59O1xuXG5cbmZ1bmN0aW9uIGxlbmd0aFB4XyhzdmdMZW5ndGgpIHtcbiAgaWYgKHN2Z0xlbmd0aC5iYXNlVmFsKSB7XG4gICAgc3ZnTGVuZ3RoID0gc3ZnTGVuZ3RoLmJhc2VWYWw7XG4gIH1cbiAgc3ZnTGVuZ3RoLmNvbnZlcnRUb1NwZWNpZmllZFVuaXRzKFNWR0xlbmd0aC5TVkdfTEVOR1RIVFlQRV9QWCk7XG4gIHJldHVybiBzdmdMZW5ndGgudmFsdWVJblNwZWNpZmllZFVuaXRzO1xufVxuXG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtkZWZhdWx0IGFzIEJlemllcn0gZnJvbSAnYmV6aWVyLWpzJztcbmltcG9ydCB7TWF0aFV0aWx9IGZyb20gJy4vTWF0aFV0aWwnO1xuXG5leHBvcnQgY2xhc3MgU3ZnUGF0aERhdGEge1xuICBjb25zdHJ1Y3RvcihvYmopIHtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5ib3VuZHMgPSBudWxsO1xuICAgIHRoaXMuc3ViUGF0aHMgPSBbXTtcblxuICAgIGlmIChvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqID09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMucGF0aFN0cmluZyA9IG9iajtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIHRoaXMuY29tbWFuZHMgPSBvYmo7XG4gICAgICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFN2Z1BhdGhEYXRhKSB7XG4gICAgICAgIHRoaXMucGF0aFN0cmluZyA9IG9iai5wYXRoU3RyaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldCBwYXRoU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmluZ18gfHwgJyc7XG4gIH1cblxuICBzZXQgcGF0aFN0cmluZyh2YWx1ZSkge1xuICAgIHRoaXMuc3RyaW5nXyA9IHZhbHVlO1xuICAgIGxldCBjb21tYW5kcyA9IHBhcnNlQ29tbWFuZHNfKHZhbHVlKTtcbiAgICB0aGlzLmNvbW1hbmRzXyA9IGNvbW1hbmRzO1xuICAgIGxldCB7bGVuZ3RoLCBib3VuZHMsIHN1YlBhdGhzfSA9IG1ha2VQYXRoQ29tcHV0YXRpb25zXyh0aGlzLmNvbW1hbmRzXyk7XG4gICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgdGhpcy5ib3VuZHMgPSBib3VuZHM7XG4gICAgdGhpcy5zdWJQYXRocyA9IHN1YlBhdGhzO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0aFN0cmluZztcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5wYXRoU3RyaW5nO1xuICB9XG5cbiAgZXhlY3V0ZShjdHgpIHtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgdGhpcy5jb21tYW5kc18uZm9yRWFjaCgoe2NvbW1hbmQsIGFyZ3N9KSA9PiB7XG4gICAgICBpZiAoY29tbWFuZCA9PSAnX19hcmNfXycpIHtcbiAgICAgICAgZXhlY3V0ZUFyY18oY3R4LCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eFtjb21tYW5kXSguLi5hcmdzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIGV4ZWN1dGVzIHRoZSBwYXRoLCBwb3NzaWJseSB0cmltbWluZyBpdFxuICAvLyAoaWYgYWN0dWFsbHkgdHJpbW1pbmcsIGRyYXdzIG9ubHkgdXNpbmcgYmV6aWVycylcbiAgZXhlY3V0ZVRyaW1tZWQoY3R4LCBzdGFydCA9IDAsIGVuZCA9IDEsIG9mZnNldCA9IDAsIGJlZ2luUGF0aCA9IHRydWUpIHtcbiAgICBpZiAoc3RhcnQgPT09IGVuZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IDEgJiYgb2Zmc2V0ID09PSAwKSB7XG4gICAgICB0aGlzLmV4ZWN1dGUoY3R4KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzdGFydCArPSBvZmZzZXQ7XG4gICAgaWYgKHN0YXJ0ID4gMSkge1xuICAgICAgc3RhcnQgPSAoc3RhcnQgJSAxICsgMSkgJSAxOyAvLyBkb3VibGUgbW9kdWxvIHRvIHN0YXkgcG9zaXRpdmVcbiAgICB9XG4gICAgZW5kICs9IG9mZnNldDtcbiAgICBpZiAoZW5kID4gMSkge1xuICAgICAgZW5kID0gKGVuZCAlIDEgKyAxKSAlIDE7XG4gICAgfVxuXG4gICAgaWYgKGJlZ2luUGF0aCkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgLy8gd3JhcCBhcm91bmRcbiAgICAgIHRoaXMuZXhlY3V0ZVRyaW1tZWQoY3R4LCAwLCBlbmQsIDAsIGZhbHNlKTtcbiAgICAgIHRoaXMuZXhlY3V0ZVRyaW1tZWQoY3R4LCBzdGFydCwgMSwgMCwgZmFsc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHN0YXJ0IGd1YXJhbnRlZWQgdG8gYmUgYmVmb3JlIGVuZFxuXG4gICAgaWYgKCF0aGlzLnN1YlBhdGhzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE5PVEU6IGRvbid0IHN1cHBvcnQgdHJpbW1pbmcgbXVsdGlwbGUgc3VicGF0aHMgdG8gbWF0Y2ggYW5kcm9pZCBiZWhhdmlvclxuICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvYW5kcm9pZC9pc3N1ZXMvZGV0YWlsP2lkPTE3MjU0N1xuICAgIGxldCBmaXJzdFN1YlBhdGggPSB0aGlzLnN1YlBhdGhzWzBdO1xuICAgIGxldCBsZW5ndGggPSBmaXJzdFN1YlBhdGgucmVkdWNlKChsLCBzdWJQYXRoKSA9PiBsICsgc3ViUGF0aC5sZW5ndGgsIDApO1xuICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY29tcHV0ZSB0aGUgc3RyaW5nIG9mIGJlemllcnMgKHBvc3NpYmx5IHNwbGl0KSB0aGF0IG1ha2UgdXAgdGhlXG4gICAgLy8gcGF0aCBmcm9tIHN0YXJ0IHRvIGVuZFxuICAgIGxldCBiZXppZXJzID0gW107XG4gICAgbGV0IGxlbmd0aENvdmVyZWQgPSAwO1xuICAgIGxldCBzdGFydGVkID0gZmFsc2U7XG4gICAgbGV0IGVuZGVkID0gZmFsc2U7XG4gICAgZmlyc3RTdWJQYXRoLmZvckVhY2goc2VnbWVudCA9PiB7XG4gICAgICBsZXQgc2VnU3RhcnQgPSBsZW5ndGhDb3ZlcmVkIC8gbGVuZ3RoO1xuICAgICAgbGV0IHNlZ0VuZCA9IChzZWdtZW50Lmxlbmd0aCArIGxlbmd0aENvdmVyZWQpIC8gbGVuZ3RoO1xuICAgICAgaWYgKCFzdGFydGVkKSB7XG4gICAgICAgIGlmIChzdGFydCA8IHNlZ0VuZCkge1xuICAgICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgIGxldCBzcGxpdFN0YXJ0ID0gTWF0aFV0aWwucHJvZ3Jlc3Moc3RhcnQsIHNlZ1N0YXJ0LCBzZWdFbmQpO1xuICAgICAgICAgIGlmIChlbmQgPCBzZWdFbmQpIHtcbiAgICAgICAgICAgIGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBzcGxpdEVuZCA9IE1hdGhVdGlsLnByb2dyZXNzKGVuZCwgc2VnU3RhcnQsIHNlZ0VuZCk7XG4gICAgICAgICAgICBiZXppZXJzLnB1c2goc2VnbWVudC5iZXppZXIuc3BsaXQoXG4gICAgICAgICAgICAgICAgdEZvckJlemllckRpc3RhbmNlXyhzZWdtZW50LCBzcGxpdFN0YXJ0KSxcbiAgICAgICAgICAgICAgICB0Rm9yQmV6aWVyRGlzdGFuY2VfKHNlZ21lbnQsIHNwbGl0RW5kKSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiZXppZXJzLnB1c2goc2VnbWVudC5iZXppZXIuc3BsaXQoXG4gICAgICAgICAgICAgICAgdEZvckJlemllckRpc3RhbmNlXyhzZWdtZW50LCBzcGxpdFN0YXJ0KSkucmlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghZW5kZWQpIHtcbiAgICAgICAgaWYgKGVuZCA8IHNlZ0VuZCkge1xuICAgICAgICAgIGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICBsZXQgc3BsaXRFbmQgPSBNYXRoVXRpbC5wcm9ncmVzcyhlbmQsIHNlZ1N0YXJ0LCBzZWdFbmQpO1xuICAgICAgICAgIGJlemllcnMucHVzaChzZWdtZW50LmJlemllci5zcGxpdChcbiAgICAgICAgICAgICAgdEZvckJlemllckRpc3RhbmNlXyhzZWdtZW50LCBzcGxpdEVuZCkpLmxlZnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJlemllcnMucHVzaChzZWdtZW50LmJlemllcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxlbmd0aENvdmVyZWQgKz0gc2VnbWVudC5sZW5ndGg7XG4gICAgfSk7XG5cbiAgICAvLyBkcmF3IHRoZSBiZXppZXJzIGp1c3QgY29tcHV0ZWRcbiAgICBpZiAoYmV6aWVycy5sZW5ndGgpIHtcbiAgICAgIGN0eC5tb3ZlVG8oYmV6aWVyc1swXS5wb2ludHNbMF0ueCwgYmV6aWVyc1swXS5wb2ludHNbMF0ueSk7XG4gICAgICBiZXppZXJzLmZvckVhY2goYmV6ID0+IHtcbiAgICAgICAgaWYgKGJlei5wb2ludHMubGVuZ3RoID09IDQpIHtcbiAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgICAgYmV6LnBvaW50c1sxXS54LCBiZXoucG9pbnRzWzFdLnksXG4gICAgICAgICAgICAgIGJlei5wb2ludHNbMl0ueCwgYmV6LnBvaW50c1syXS55LFxuICAgICAgICAgICAgICBiZXoucG9pbnRzWzNdLngsIGJlei5wb2ludHNbM10ueSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYmV6LnBvaW50cy5sZW5ndGggPT0gMykge1xuICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgICAgICBiZXoucG9pbnRzWzFdLngsIGJlei5wb2ludHNbMV0ueSxcbiAgICAgICAgICAgICAgYmV6LnBvaW50c1syXS54LCBiZXoucG9pbnRzWzJdLnkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBoaXRUZXN0U3Ryb2tlKHBvaW50LCBwb2ludFRyYW5zZm9ybWVyRm4sIHN0cm9rZVdpZHRoKSB7XG4gICAgLy8gSWYgdGhlIHNob3J0ZXN0IGRpc3RhbmNlIGZyb20gdGhlIHBvaW50IHRvIHRoZSBwYXRoIGlzIGxlc3MgdGhhbiBoYWxmXG4gICAgLy8gdGhlIHN0cm9rZSB3aWR0aCwgdGhlbiBzZWxlY3QgdGhlIHBhdGguXG4gICAgcmV0dXJuIHRoaXMuc3ViUGF0aHNcbiAgICAgICAgLnJlZHVjZSgoYWxsLCBzdWJQYXRoKSA9PiBhbGwuY29uY2F0KHN1YlBhdGgpLCBbXSlcbiAgICAgICAgLm1hcChzZWdtZW50ID0+IHNlZ21lbnQuYmV6aWVyKVxuICAgICAgICAubWFwKGJleiA9PiBuZXcgQmV6aWVyKGJlei5wb2ludHMubWFwKHAgPT4gcG9pbnRUcmFuc2Zvcm1lckZuKHApKSkpXG4gICAgICAgIC5tYXAoYmV6ID0+IGJlei5wcm9qZWN0KHBvaW50KSlcbiAgICAgICAgLnJlZHVjZSgocHJvaiwgbWluKSA9PiBwcm9qLmQgPCBtaW4uZCA/IHByb2ogOiBtaW4pLmQgPD0gKHN0cm9rZVdpZHRoIC8gMik7XG4gIH1cblxuICBoaXRUZXN0RmlsbChwb2ludCwgcG9pbnRUcmFuc2Zvcm1lckZuKSB7XG4gICAgLy8gV2UgdXNlIHRoZSAnZXZlbi1vZGQgcnVsZScgdG8gZGV0ZXJtaW5lIGlmIHRoZSBmaWxsZWQgcGF0aCBpcyBzZWxlY3RlZC5cbiAgICAvLyBXZSBjcmVhdGUgYSBsaW5lIGZyb20gdGhlIG1vdXNlIHBvaW50IHRvIGEgcG9pbnQgd2Uga25vdyB0aGF0IGlzIG5vdFxuICAgIC8vIGluc2lkZSB0aGUgcGF0aCAoaW4gdGhpcyBjYXNlLCB3ZSB1c2UgYSBjb29yZGluYXRlIG91dHNpZGUgdGhlIHBhdGgnc1xuICAgIC8vIGJvdW5kZWQgYm94KS4gVGhlIHBhdGggc2hvdWxkIGJlIHNlbGVjdGVkIGlmIGFuZCBvbmx5IGlmIHRoZSBudW1iZXIgb2YgPVxuICAgIC8vIGludGVyc2VjdGlvbnMgYmV0d2VlbiB0aGUgbGluZSBhbmQgdGhlIHBhdGggaXMgb2RkLlxuICAgIGxldCBsaW5lID0ge1xuICAgICAgcDE6IHBvaW50LFxuICAgICAgcDI6IHtcbiAgICAgICAgeDogdGhpcy5ib3VuZHMuciArIDEsXG4gICAgICAgIHk6IHRoaXMuYm91bmRzLmIgKyAxLFxuICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLnN1YlBhdGhzXG4gICAgICAgIC5yZWR1Y2UoKGFsbCwgc3ViUGF0aCkgPT4gYWxsLmNvbmNhdChzdWJQYXRoKSwgW10pXG4gICAgICAgIC5tYXAoc2VnbWVudCA9PiBzZWdtZW50LmJlemllcilcbiAgICAgICAgLm1hcChiZXogPT4gbmV3IEJlemllcihiZXoucG9pbnRzLm1hcChwID0+IHBvaW50VHJhbnNmb3JtZXJGbihwKSkpKVxuICAgICAgICAubWFwKGJleiA9PiBiZXouaW50ZXJzZWN0cyhsaW5lKS5sZW5ndGgpXG4gICAgICAgIC5yZWR1Y2UoKGwsIHN1bSkgPT4gc3VtICsgbCkgJSAyICE9IDA7XG4gIH1cblxuICBnZXQgY29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tbWFuZHNfO1xuICB9XG5cbiAgc2V0IGNvbW1hbmRzKHZhbHVlKSB7XG4gICAgdGhpcy5jb21tYW5kc18gPSAodmFsdWUgPyB2YWx1ZS5zbGljZSgpIDogW10pO1xuICAgIHRoaXMuc3RyaW5nXyA9IGNvbW1hbmRzVG9TdHJpbmdfKHRoaXMuY29tbWFuZHNfKTtcbiAgICBsZXQge2xlbmd0aCwgYm91bmRzLCBzdWJQYXRoc30gPSBtYWtlUGF0aENvbXB1dGF0aW9uc18odGhpcy5jb21tYW5kc18pO1xuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIHRoaXMuYm91bmRzID0gYm91bmRzO1xuICAgIHRoaXMuc3ViUGF0aHMgPSBzdWJQYXRocztcbiAgfVxuXG4gIHRyYW5zZm9ybSh0cmFuc2Zvcm1zKSB7XG4gICAgdGhpcy5jb21tYW5kc18uZm9yRWFjaCgoeyBjb21tYW5kLCBhcmdzIH0pID0+IHtcbiAgICAgIGlmIChjb21tYW5kID09ICdfX2FyY19fJykge1xuICAgICAgICBjb25zdCBzdGFydCA9IHRyYW5zZm9ybVBvaW50Xyh7IHg6YXJnc1swXSwgeTphcmdzWzFdIH0sIHRyYW5zZm9ybXMpO1xuICAgICAgICBhcmdzWzBdID0gc3RhcnQueDtcbiAgICAgICAgYXJnc1sxXSA9IHN0YXJ0Lnk7XG4gICAgICAgIGNvbnN0IGFyYyA9IHRyYW5zZm9ybUFyY18oe1xuICAgICAgICAgIHJ4OiBhcmdzWzJdLFxuICAgICAgICAgIHJ5OiBhcmdzWzNdLFxuICAgICAgICAgIHhBeGlzUm90YXRpb246IGFyZ3NbNF0sXG4gICAgICAgICAgbGFyZ2VBcmNGbGFnOiBhcmdzWzVdLFxuICAgICAgICAgIHN3ZWVwRmxhZzogYXJnc1s2XSxcbiAgICAgICAgICBlbmRYOiBhcmdzWzddLFxuICAgICAgICAgIGVuZFk6IGFyZ3NbOF0sXG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zZm9ybXMpO1xuICAgICAgICBhcmdzWzJdID0gYXJjLnJ4O1xuICAgICAgICBhcmdzWzNdID0gYXJjLnJ5O1xuICAgICAgICBhcmdzWzRdID0gYXJjLnhBeGlzUm90YXRpb247XG4gICAgICAgIGFyZ3NbNV0gPSBhcmMubGFyZ2VBcmNGbGFnO1xuICAgICAgICBhcmdzWzZdID0gYXJjLnN3ZWVwRmxhZztcbiAgICAgICAgYXJnc1s3XSA9IGFyYy5lbmRYO1xuICAgICAgICBhcmdzWzhdID0gYXJjLmVuZFk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZCA9IHRyYW5zZm9ybVBvaW50Xyh7IHg6IGFyZ3NbaV0sIHk6IGFyZ3NbaSArIDFdIH0sIHRyYW5zZm9ybXMpO1xuICAgICAgICBhcmdzW2ldID0gdHJhbnNmb3JtZWQueDtcbiAgICAgICAgYXJnc1tpICsgMV0gPSB0cmFuc2Zvcm1lZC55O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5zdHJpbmdfID0gY29tbWFuZHNUb1N0cmluZ18odGhpcy5jb21tYW5kc18pO1xuICAgIGxldCB7IGxlbmd0aCwgYm91bmRzLCBzdWJQYXRocyB9ID0gbWFrZVBhdGhDb21wdXRhdGlvbnNfKHRoaXMuY29tbWFuZHNfKTtcbiAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICB0aGlzLmJvdW5kcyA9IGJvdW5kcztcbiAgICB0aGlzLnN1YlBhdGhzID0gc3ViUGF0aHM7XG4gIH1cblxuXG4gIHN0YXRpYyBpbnRlcnBvbGF0ZShzdGFydCwgZW5kLCBmKSB7XG4gICAgaWYgKCFlbmQgfHwgIXN0YXJ0IHx8ICFlbmQuY29tbWFuZHMgfHwgIXN0YXJ0LmNvbW1hbmRzXG4gICAgICAgIHx8IGVuZC5jb21tYW5kcy5sZW5ndGggIT0gc3RhcnQuY29tbWFuZHMubGVuZ3RoKSB7XG4gICAgICAvLyBUT0RPOiBzaG93IGEgd2FybmluZ1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGxldCBpbnRlcnBvbGF0ZWRDb21tYW5kcyA9IFtdO1xuXG4gICAgbGV0IGksIGo7XG4gICAgZm9yIChpID0gMDsgaSA8IHN0YXJ0LmNvbW1hbmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgc2kgPSBzdGFydC5jb21tYW5kc1tpXSwgZWkgPSBlbmQuY29tbWFuZHNbaV07XG4gICAgICBpZiAoIWVpLmFyZ3MgfHwgIXNpLmFyZ3MgfHwgZWkuYXJncy5sZW5ndGggIT0gc2kuYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdJbmNvbXBhdGlibGUgcGF0aCBpbnRlcnBvbGF0aW9uJyk7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgbGV0IGludGVycG9sYXRlZEFyZ3MgPSBbXTtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBzaS5hcmdzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGludGVycG9sYXRlZEFyZ3MucHVzaChzaW1wbGVJbnRlcnBvbGF0ZV8oc2kuYXJnc1tqXSwgZWkuYXJnc1tqXSwgZikpO1xuICAgICAgfVxuXG4gICAgICBpbnRlcnBvbGF0ZWRDb21tYW5kcy5wdXNoKHtcbiAgICAgICAgY29tbWFuZDogc2kuY29tbWFuZCxcbiAgICAgICAgYXJnczogaW50ZXJwb2xhdGVkQXJnc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBTdmdQYXRoRGF0YShpbnRlcnBvbGF0ZWRDb21tYW5kcyk7XG4gIH1cbn1cblxuXG5sZXQgc2ltcGxlSW50ZXJwb2xhdGVfID0gKHN0YXJ0LCBlbmQsIGYpID0+IHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIGY7XG5cblxuY29uc3QgVE9LRU5fQUJTT0xVVEVfQ09NTUFORCA9IDE7XG5jb25zdCBUT0tFTl9SRUxBVElWRV9DT01NQU5EID0gMjtcbmNvbnN0IFRPS0VOX1ZBTFVFID0gMztcbmNvbnN0IFRPS0VOX0VPRiA9IDQ7XG5cblxuZnVuY3Rpb24gcGFyc2VDb21tYW5kc18ocGF0aFN0cmluZykge1xuICBsZXQgY29tbWFuZHMgPSBbXTtcbiAgbGV0IHB1c2hDb21tYW5kQ29tcGxleF8gPSAoY29tbWFuZCwgLi4uYXJncykgPT4gY29tbWFuZHMucHVzaCh7Y29tbWFuZCwgYXJnc30pO1xuICBsZXQgcHVzaENvbW1hbmRQb2ludHNfID0gKGNvbW1hbmQsIC4uLnBvaW50cykgPT4gY29tbWFuZHMucHVzaCh7XG4gICAgICBjb21tYW5kLCBhcmdzOiBwb2ludHMucmVkdWNlKChhcnIsIHBvaW50KSA9PiBhcnIuY29uY2F0KHBvaW50LngsIHBvaW50LnkpLCBbXSl9KTtcblxuICBsZXQgY3VycmVudFBvaW50ID0ge3g6TmFOLCB5Ok5hTn07XG4gIGxldCBjdXJyZW50Q29udHJvbFBvaW50ID0gbnVsbDsgLy8gdXNlZCBmb3IgUyBhbmQgVCBjb21tYW5kc1xuICBsZXQgaW5kZXggPSAwO1xuICBsZXQgbGVuZ3RoID0gcGF0aFN0cmluZy5sZW5ndGg7XG5cbiAgbGV0IHRlbXBQb2ludDEgPSB7eDowLCB5OjB9O1xuICBsZXQgdGVtcFBvaW50MiA9IHt4OjAsIHk6MH07XG4gIGxldCB0ZW1wUG9pbnQzID0ge3g6MCwgeTowfTtcblxuICBsZXQgZmlyc3RNb3ZlID0gdHJ1ZTtcbiAgbGV0IGN1cnJlbnRUb2tlbjtcblxuICBsZXQgYWR2YW5jZVRvTmV4dFRva2VuXyA9ICgpID0+IHtcbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGxldCBjID0gcGF0aFN0cmluZy5jaGFyQXQoaW5kZXgpO1xuICAgICAgaWYgKCdhJyA8PSBjICYmIGMgPD0gJ3onKSB7XG4gICAgICAgIHJldHVybiAoY3VycmVudFRva2VuID0gVE9LRU5fUkVMQVRJVkVfQ09NTUFORCk7XG4gICAgICB9IGVsc2UgaWYgKCdBJyA8PSBjICYmIGMgPD0gJ1onKSB7XG4gICAgICAgIHJldHVybiAoY3VycmVudFRva2VuID0gVE9LRU5fQUJTT0xVVEVfQ09NTUFORCk7XG4gICAgICB9IGVsc2UgaWYgKCgnMCcgPD0gYyAmJiBjIDw9ICc5JykgfHwgYyA9PSAnLicgfHwgYyA9PSAnLScpIHtcbiAgICAgICAgcmV0dXJuIChjdXJyZW50VG9rZW4gPSBUT0tFTl9WQUxVRSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNraXAgdW5yZWNvZ25pemVkIGNoYXJhY3RlclxuICAgICAgKytpbmRleDtcbiAgICB9XG5cbiAgICByZXR1cm4gKGN1cnJlbnRUb2tlbiA9IFRPS0VOX0VPRik7XG4gIH07XG5cbiAgbGV0IGNvbnN1bWVDb21tYW5kXyA9ICgpID0+IHtcbiAgICBhZHZhbmNlVG9OZXh0VG9rZW5fKCk7XG4gICAgaWYgKGN1cnJlbnRUb2tlbiAhPT0gVE9LRU5fUkVMQVRJVkVfQ09NTUFORCAmJiBjdXJyZW50VG9rZW4gIT09IFRPS0VOX0FCU09MVVRFX0NPTU1BTkQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgY29tbWFuZCcpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoU3RyaW5nLmNoYXJBdChpbmRleCsrKTtcbiAgfTtcblxuICBsZXQgY29uc3VtZVBvaW50XyA9IChvdXQsIHJlbGF0aXZlKSA9PiB7XG4gICAgb3V0LnggPSBjb25zdW1lVmFsdWVfKCk7XG4gICAgb3V0LnkgPSBjb25zdW1lVmFsdWVfKCk7XG4gICAgaWYgKHJlbGF0aXZlKSB7XG4gICAgICBvdXQueCArPSBjdXJyZW50UG9pbnQueDtcbiAgICAgIG91dC55ICs9IGN1cnJlbnRQb2ludC55O1xuICAgIH1cbiAgfTtcblxuICBsZXQgY29uc3VtZVZhbHVlXyA9ICgpID0+IHtcbiAgICBhZHZhbmNlVG9OZXh0VG9rZW5fKCk7XG4gICAgaWYgKGN1cnJlbnRUb2tlbiAhPT0gVE9LRU5fVkFMVUUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdmFsdWUnKTtcbiAgICB9XG5cbiAgICBsZXQgc3RhcnQgPSB0cnVlO1xuICAgIGxldCBzZWVuRG90ID0gZmFsc2U7XG4gICAgbGV0IHRlbXBJbmRleCA9IGluZGV4O1xuICAgIHdoaWxlICh0ZW1wSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGxldCBjID0gcGF0aFN0cmluZy5jaGFyQXQodGVtcEluZGV4KTtcblxuICAgICAgaWYgKCEoJzAnIDw9IGMgJiYgYyA8PSAnOScpICYmIChjICE9ICcuJyB8fCBzZWVuRG90KSAmJiAoYyAhPSAnLScgfHwgIXN0YXJ0KSAmJiBjICE9ICdlJykge1xuICAgICAgICAvLyBlbmQgb2YgdmFsdWVcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChjID09ICcuJykge1xuICAgICAgICBzZWVuRG90ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgc3RhcnQgPSBmYWxzZTtcbiAgICAgIGlmIChjID09ICdlJykge1xuICAgICAgICBzdGFydCA9IHRydWU7XG4gICAgICB9XG4gICAgICArK3RlbXBJbmRleDtcbiAgICB9XG5cbiAgICBpZiAodGVtcEluZGV4ID09IGluZGV4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgbGV0IHN0ciA9IHBhdGhTdHJpbmcuc3Vic3RyaW5nKGluZGV4LCB0ZW1wSW5kZXgpO1xuICAgIGluZGV4ID0gdGVtcEluZGV4O1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHN0cik7XG4gIH07XG5cbiAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgbGV0IGNvbW1hbmQgPSBjb25zdW1lQ29tbWFuZF8oKTtcbiAgICBsZXQgcmVsYXRpdmUgPSAoY3VycmVudFRva2VuID09PSBUT0tFTl9SRUxBVElWRV9DT01NQU5EKTtcblxuICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgY2FzZSAnTSc6XG4gICAgICBjYXNlICdtJzoge1xuICAgICAgICAvLyBtb3ZlIGNvbW1hbmRcbiAgICAgICAgbGV0IGZpcnN0UG9pbnQgPSB0cnVlO1xuICAgICAgICB3aGlsZSAoYWR2YW5jZVRvTmV4dFRva2VuXygpID09PSBUT0tFTl9WQUxVRSkge1xuICAgICAgICAgIGNvbnN1bWVQb2ludF8odGVtcFBvaW50MSwgcmVsYXRpdmUgJiYgIWlzTmFOKGN1cnJlbnRQb2ludC54KSk7XG4gICAgICAgICAgaWYgKGZpcnN0UG9pbnQpIHtcbiAgICAgICAgICAgIHB1c2hDb21tYW5kUG9pbnRzXygnbW92ZVRvJywgdGVtcFBvaW50MSk7XG4gICAgICAgICAgICBmaXJzdFBvaW50ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZmlyc3RNb3ZlKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRQb2ludCA9IE9iamVjdC5hc3NpZ24oe30sIHRlbXBQb2ludDEpO1xuICAgICAgICAgICAgICBmaXJzdE1vdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHVzaENvbW1hbmRQb2ludHNfKCdsaW5lVG8nLCB0ZW1wUG9pbnQxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50Q29udHJvbFBvaW50ID0gbnVsbDtcbiAgICAgICAgY3VycmVudFBvaW50ID0gT2JqZWN0LmFzc2lnbih7fSwgdGVtcFBvaW50MSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjYXNlICdDJzpcbiAgICAgIGNhc2UgJ2MnOiB7XG4gICAgICAgIC8vIGN1YmljIGN1cnZlIGNvbW1hbmRcbiAgICAgICAgaWYgKGlzTmFOKGN1cnJlbnRQb2ludC54KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVsYXRpdmUgY29tbWFuZHMgcmVxdWlyZSBjdXJyZW50IHBvaW50Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoYWR2YW5jZVRvTmV4dFRva2VuXygpID09PSBUT0tFTl9WQUxVRSkge1xuICAgICAgICAgIGNvbnN1bWVQb2ludF8odGVtcFBvaW50MSwgcmVsYXRpdmUpO1xuICAgICAgICAgIGNvbnN1bWVQb2ludF8odGVtcFBvaW50MiwgcmVsYXRpdmUpO1xuICAgICAgICAgIGNvbnN1bWVQb2ludF8odGVtcFBvaW50MywgcmVsYXRpdmUpO1xuICAgICAgICAgIHB1c2hDb21tYW5kUG9pbnRzXygnYmV6aWVyQ3VydmVUbycsIHRlbXBQb2ludDEsIHRlbXBQb2ludDIsIHRlbXBQb2ludDMpO1xuXG4gICAgICAgICAgY3VycmVudENvbnRyb2xQb2ludCA9IE9iamVjdC5hc3NpZ24oe30sIHRlbXBQb2ludDIpO1xuICAgICAgICAgIGN1cnJlbnRQb2ludCA9IE9iamVjdC5hc3NpZ24oe30sIHRlbXBQb2ludDMpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgJ1MnOlxuICAgICAgY2FzZSAncyc6IHtcbiAgICAgICAgLy8gY3ViaWMgY3VydmUgY29tbWFuZCAoc3RyaW5nIG9mIGN1cnZlcylcbiAgICAgICAgaWYgKGlzTmFOKGN1cnJlbnRQb2ludC54KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVsYXRpdmUgY29tbWFuZHMgcmVxdWlyZSBjdXJyZW50IHBvaW50Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoYWR2YW5jZVRvTmV4dFRva2VuXygpID09PSBUT0tFTl9WQUxVRSkge1xuICAgICAgICAgIGNvbnN1bWVQb2ludF8odGVtcFBvaW50MSwgcmVsYXRpdmUpO1xuICAgICAgICAgIGNvbnN1bWVQb2ludF8odGVtcFBvaW50MiwgcmVsYXRpdmUpO1xuICAgICAgICAgIGlmIChjdXJyZW50Q29udHJvbFBvaW50KSB7XG4gICAgICAgICAgICB0ZW1wUG9pbnQzLnggPSBjdXJyZW50UG9pbnQueCArIChjdXJyZW50UG9pbnQueCAtIGN1cnJlbnRDb250cm9sUG9pbnQueCk7XG4gICAgICAgICAgICB0ZW1wUG9pbnQzLnkgPSBjdXJyZW50UG9pbnQueSArIChjdXJyZW50UG9pbnQueSAtIGN1cnJlbnRDb250cm9sUG9pbnQueSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGVtcFBvaW50MywgdGVtcFBvaW50MSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHB1c2hDb21tYW5kUG9pbnRzXygnYmV6aWVyQ3VydmVUbycsIHRlbXBQb2ludDMsIHRlbXBQb2ludDEsIHRlbXBQb2ludDIpO1xuXG4gICAgICAgICAgY3VycmVudENvbnRyb2xQb2ludCA9IE9iamVjdC5hc3NpZ24oe30sIHRlbXBQb2ludDEpO1xuICAgICAgICAgIGN1cnJlbnRQb2ludCA9IE9iamVjdC5hc3NpZ24oe30sIHRlbXBQb2ludDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgJ1EnOlxuICAgICAgY2FzZSAncSc6IHtcbiAgICAgICAgLy8gcXVhZHJhdGljIGN1cnZlIGNvbW1hbmRcbiAgICAgICAgaWYgKGlzTmFOKGN1cnJlbnRQb2ludC54KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVsYXRpdmUgY29tbWFuZHMgcmVxdWlyZSBjdXJyZW50IHBvaW50Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoYWR2YW5jZVRvTmV4dFRva2VuXygpID09PSBUT0tFTl9WQUxVRSkge1xuICAgICAgICAgIGNvbnN1bWVQb2ludF8odGVtcFBvaW50MSwgcmVsYXRpdmUpO1xuICAgICAgICAgIGNvbnN1bWVQb2ludF8odGVtcFBvaW50MiwgcmVsYXRpdmUpO1xuICAgICAgICAgIHB1c2hDb21tYW5kUG9pbnRzXygncXVhZHJhdGljQ3VydmVUbycsIHRlbXBQb2ludDEsIHRlbXBQb2ludDIpO1xuXG4gICAgICAgICAgY3VycmVudENvbnRyb2xQb2ludCA9IE9iamVjdC5hc3NpZ24oe30sIHRlbXBQb2ludDEpO1xuICAgICAgICAgIGN1cnJlbnRQb2ludCA9IE9iamVjdC5hc3NpZ24oe30sIHRlbXBQb2ludDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgJ1QnOlxuICAgICAgY2FzZSAndCc6IHtcbiAgICAgICAgLy8gcXVhZHJhdGljIGN1cnZlIGNvbW1hbmQgKHN0cmluZyBvZiBjdXJ2ZXMpXG4gICAgICAgIGlmIChpc05hTihjdXJyZW50UG9pbnQueCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbGF0aXZlIGNvbW1hbmRzIHJlcXVpcmUgY3VycmVudCBwb2ludCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGFkdmFuY2VUb05leHRUb2tlbl8oKSA9PT0gVE9LRU5fVkFMVUUpIHtcbiAgICAgICAgICBjb25zdW1lUG9pbnRfKHRlbXBQb2ludDEsIHJlbGF0aXZlKTtcbiAgICAgICAgICBpZiAoY3VycmVudENvbnRyb2xQb2ludCkge1xuICAgICAgICAgICAgdGVtcFBvaW50Mi54ID0gY3VycmVudFBvaW50LnggKyAoY3VycmVudFBvaW50LnggLSBjdXJyZW50Q29udHJvbFBvaW50LngpO1xuICAgICAgICAgICAgdGVtcFBvaW50Mi55ID0gY3VycmVudFBvaW50LnkgKyAoY3VycmVudFBvaW50LnkgLSBjdXJyZW50Q29udHJvbFBvaW50LnkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRlbXBQb2ludDIsIHRlbXBQb2ludDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwdXNoQ29tbWFuZFBvaW50c18oJ3F1YWRyYXRpY0N1cnZlVG8nLCB0ZW1wUG9pbnQyLCB0ZW1wUG9pbnQxKTtcblxuICAgICAgICAgIGN1cnJlbnRDb250cm9sUG9pbnQgPSBPYmplY3QuYXNzaWduKHt9LCB0ZW1wUG9pbnQyKTtcbiAgICAgICAgICBjdXJyZW50UG9pbnQgPSBPYmplY3QuYXNzaWduKHt9LCB0ZW1wUG9pbnQxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjYXNlICdMJzpcbiAgICAgIGNhc2UgJ2wnOiB7XG4gICAgICAgIC8vIGxpbmUgY29tbWFuZFxuICAgICAgICBpZiAoaXNOYU4oY3VycmVudFBvaW50LngpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWxhdGl2ZSBjb21tYW5kcyByZXF1aXJlIGN1cnJlbnQgcG9pbnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChhZHZhbmNlVG9OZXh0VG9rZW5fKCkgPT09IFRPS0VOX1ZBTFVFKSB7XG4gICAgICAgICAgY29uc3VtZVBvaW50Xyh0ZW1wUG9pbnQxLCByZWxhdGl2ZSk7XG4gICAgICAgICAgcHVzaENvbW1hbmRQb2ludHNfKCdsaW5lVG8nLCB0ZW1wUG9pbnQxKTtcblxuICAgICAgICAgIGN1cnJlbnRDb250cm9sUG9pbnQgPSBudWxsO1xuICAgICAgICAgIGN1cnJlbnRQb2ludCA9IE9iamVjdC5hc3NpZ24oe30sIHRlbXBQb2ludDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgJ0gnOlxuICAgICAgY2FzZSAnaCc6IHtcbiAgICAgICAgLy8gaG9yaXpvbnRhbCBsaW5lIGNvbW1hbmRcbiAgICAgICAgaWYgKGlzTmFOKGN1cnJlbnRQb2ludC54KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVsYXRpdmUgY29tbWFuZHMgcmVxdWlyZSBjdXJyZW50IHBvaW50Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoYWR2YW5jZVRvTmV4dFRva2VuXygpID09PSBUT0tFTl9WQUxVRSkge1xuICAgICAgICAgIHRlbXBQb2ludDEueCA9IGNvbnN1bWVWYWx1ZV8oKTtcbiAgICAgICAgICB0ZW1wUG9pbnQxLnkgPSBjdXJyZW50UG9pbnQueTtcbiAgICAgICAgICBpZiAocmVsYXRpdmUpIHtcbiAgICAgICAgICAgIHRlbXBQb2ludDEueCArPSBjdXJyZW50UG9pbnQueDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwdXNoQ29tbWFuZFBvaW50c18oJ2xpbmVUbycsIHRlbXBQb2ludDEpO1xuXG4gICAgICAgICAgY3VycmVudENvbnRyb2xQb2ludCA9IG51bGw7XG4gICAgICAgICAgY3VycmVudFBvaW50ID0gT2JqZWN0LmFzc2lnbih7fSwgdGVtcFBvaW50MSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgJ0EnOlxuICAgICAgY2FzZSAnYSc6IHtcbiAgICAgICAgLy8gYXJjIGNvbW1hbmRcbiAgICAgICAgaWYgKGlzTmFOKGN1cnJlbnRQb2ludC54KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVsYXRpdmUgY29tbWFuZHMgcmVxdWlyZSBjdXJyZW50IHBvaW50Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoYWR2YW5jZVRvTmV4dFRva2VuXygpID09PSBUT0tFTl9WQUxVRSkge1xuICAgICAgICAgIGxldCByeCA9IGNvbnN1bWVWYWx1ZV8oKTtcbiAgICAgICAgICBsZXQgcnkgPSBjb25zdW1lVmFsdWVfKCk7XG4gICAgICAgICAgbGV0IHhBeGlzUm90YXRpb24gPSBjb25zdW1lVmFsdWVfKCk7XG4gICAgICAgICAgbGV0IGxhcmdlQXJjRmxhZyA9IGNvbnN1bWVWYWx1ZV8oKTtcbiAgICAgICAgICBsZXQgc3dlZXBGbGFnID0gY29uc3VtZVZhbHVlXygpO1xuICAgICAgICAgIGNvbnN1bWVQb2ludF8odGVtcFBvaW50MSwgcmVsYXRpdmUpO1xuXG4gICAgICAgICAgcHVzaENvbW1hbmRDb21wbGV4XygnX19hcmNfXycsXG4gICAgICAgICAgICAgIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSxcbiAgICAgICAgICAgICAgcngsIHJ5LFxuICAgICAgICAgICAgICB4QXhpc1JvdGF0aW9uLCBsYXJnZUFyY0ZsYWcsIHN3ZWVwRmxhZyxcbiAgICAgICAgICAgICAgdGVtcFBvaW50MS54LCB0ZW1wUG9pbnQxLnkpO1xuXG4gICAgICAgICAgLy8gcHAuYWRkTWFya2VyQW5nbGUoaGFsZldheSwgYWggLSBkaXIgKiBNYXRoLlBJIC8gMik7XG4gICAgICAgICAgLy8gcHAuYWRkTWFya2VyQW5nbGUodGVtcFBvaW50MSwgYWggLSBkaXIgKiBNYXRoLlBJKTtcblxuICAgICAgICAgIGN1cnJlbnRDb250cm9sUG9pbnQgPSBudWxsO1xuICAgICAgICAgIGN1cnJlbnRQb2ludCA9IE9iamVjdC5hc3NpZ24oe30sIHRlbXBQb2ludDEpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjYXNlICdWJzpcbiAgICAgIGNhc2UgJ3YnOiB7XG4gICAgICAgIC8vIHZlcnRpY2FsIGxpbmUgY29tbWFuZFxuICAgICAgICBpZiAoaXNOYU4oY3VycmVudFBvaW50LngpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWxhdGl2ZSBjb21tYW5kcyByZXF1aXJlIGN1cnJlbnQgcG9pbnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChhZHZhbmNlVG9OZXh0VG9rZW5fKCkgPT09IFRPS0VOX1ZBTFVFKSB7XG4gICAgICAgICAgdGVtcFBvaW50MS55ID0gY29uc3VtZVZhbHVlXygpO1xuICAgICAgICAgIHRlbXBQb2ludDEueCA9IGN1cnJlbnRQb2ludC54O1xuICAgICAgICAgIGlmIChyZWxhdGl2ZSkge1xuICAgICAgICAgICAgdGVtcFBvaW50MS55ICs9IGN1cnJlbnRQb2ludC55O1xuICAgICAgICAgIH1cbiAgICAgICAgICBwdXNoQ29tbWFuZFBvaW50c18oJ2xpbmVUbycsIHRlbXBQb2ludDEpO1xuXG4gICAgICAgICAgY3VycmVudENvbnRyb2xQb2ludCA9IG51bGw7XG4gICAgICAgICAgY3VycmVudFBvaW50ID0gT2JqZWN0LmFzc2lnbih7fSwgdGVtcFBvaW50MSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgJ1onOlxuICAgICAgY2FzZSAneic6IHtcbiAgICAgICAgLy8gY2xvc2UgY29tbWFuZFxuICAgICAgICBwdXNoQ29tbWFuZFBvaW50c18oJ2Nsb3NlUGF0aCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29tbWFuZHM7XG59XG5cblxuZnVuY3Rpb24gY29tbWFuZHNUb1N0cmluZ18oY29tbWFuZHMpIHtcbiAgbGV0IHRva2VucyA9IFtdO1xuICBjb21tYW5kcy5mb3JFYWNoKCh7Y29tbWFuZCwgYXJnc30pID0+IHtcbiAgICBpZiAoY29tbWFuZCA9PSAnX19hcmNfXycpIHtcbiAgICAgIHRva2Vucy5wdXNoKCdBJyk7XG4gICAgICB0b2tlbnMuc3BsaWNlKHRva2Vucy5sZW5ndGgsIDAsIGFyZ3Muc2xpY2UoMikpOyAvLyBza2lwIGZpcnN0IHR3byBhcmMgYXJnc1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgY2FzZSAnbW92ZVRvJzogdG9rZW5zLnB1c2goJ00nKTsgYnJlYWs7XG4gICAgICBjYXNlICdsaW5lVG8nOiB0b2tlbnMucHVzaCgnTCcpOyBicmVhaztcbiAgICAgIGNhc2UgJ2JlemllckN1cnZlVG8nOiB0b2tlbnMucHVzaCgnQycpOyBicmVhaztcbiAgICAgIGNhc2UgJ3F1YWRyYXRpY0N1cnZlVG8nOiB0b2tlbnMucHVzaCgnUScpOyBicmVhaztcbiAgICAgIGNhc2UgJ2Nsb3NlUGF0aCc6IHRva2Vucy5wdXNoKCdaJyk7IGJyZWFrO1xuICAgIH1cblxuICAgIHRva2Vucy5zcGxpY2UodG9rZW5zLmxlbmd0aCwgMCwgLi4uYXJncy5tYXAoYXJnID0+IE51bWJlcihhcmcudG9GaXhlZCgzKSkudG9TdHJpbmcoKSkpO1xuICB9KTtcblxuICByZXR1cm4gdG9rZW5zLmpvaW4oJyAnKTtcbn1cblxuXG5mdW5jdGlvbiBleGVjdXRlQXJjXyhjdHgsIGFyY0FyZ3MpIHtcbiAgbGV0IFtjdXJyZW50UG9pbnRYLCBjdXJyZW50UG9pbnRZLFxuICAgICAgIHJ4LCByeSwgeEF4aXNSb3RhdGlvbixcbiAgICAgICBsYXJnZUFyY0ZsYWcsIHN3ZWVwRmxhZyxcbiAgICAgICB0ZW1wUG9pbnQxWCwgdGVtcFBvaW50MVldID0gYXJjQXJncztcblxuICBpZiAoY3VycmVudFBvaW50WCA9PSB0ZW1wUG9pbnQxWCAmJiBjdXJyZW50UG9pbnRZID09IHRlbXBQb2ludDFZKSB7XG4gICAgLy8gZGVnZW5lcmF0ZSB0byBwb2ludFxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChyeCA9PSAwIHx8IHJ5ID09IDApIHtcbiAgICAvLyBkZWdlbmVyYXRlIHRvIGxpbmVcbiAgICBjdHgubGluZVRvKHRlbXBQb2ludDFYLCB0ZW1wUG9pbnQxWSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IGJlemllckNvb3JkcyA9IGFyY1RvQmV6aWVyc18oY3VycmVudFBvaW50WCwgY3VycmVudFBvaW50WSxcbiAgICAgIHJ4LCByeSwgeEF4aXNSb3RhdGlvbixcbiAgICAgIGxhcmdlQXJjRmxhZywgc3dlZXBGbGFnLFxuICAgICAgdGVtcFBvaW50MVgsIHRlbXBQb2ludDFZKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJlemllckNvb3Jkcy5sZW5ndGg7IGkgKz0gOCkge1xuICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGJlemllckNvb3Jkc1tpICsgMl0sIGJlemllckNvb3Jkc1tpICsgM10sXG4gICAgICAgIGJlemllckNvb3Jkc1tpICsgNF0sIGJlemllckNvb3Jkc1tpICsgNV0sXG4gICAgICAgIGJlemllckNvb3Jkc1tpICsgNl0sIGJlemllckNvb3Jkc1tpICsgN10pO1xuICB9XG59XG5cbi8vIG1hcHMgYSBkaXN0YW5jZSBhbG9uZyB0aGUgY3VydmUgdG8gdGhlIGJlemllciBwYXJhbWV0ZXIgc3BhY2UgKHQpXG5mdW5jdGlvbiB0Rm9yQmV6aWVyRGlzdGFuY2VfKHtsdXQsIGxlbmd0aH0sIGYpIHtcbiAgbGV0IHRhcmdldERpc3QgPSBmICogbGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGx1dC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBsZXQgcDEgPSBsdXRbaV07XG4gICAgbGV0IHAyID0gbHV0W2kgKyAxXTtcbiAgICBsZXQgZGlzdCA9IE1hdGhVdGlsLmRpc3QocDEueCwgcDEueSwgcDIueCwgcDIueSk7XG4gICAgaWYgKCFkaXN0KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0RGlzdCA8PSBkaXN0KSB7XG4gICAgICBmID0gdGFyZ2V0RGlzdCAvIGRpc3Q7XG4gICAgICByZXR1cm4gKGkgKyBmKSAvIChsdXQubGVuZ3RoIC0gMSk7XG4gICAgfVxuXG4gICAgdGFyZ2V0RGlzdCAtPSBkaXN0O1xuICB9XG5cbiAgcmV0dXJuIDE7XG59XG5cblxuZnVuY3Rpb24gbWFrZVBhdGhDb21wdXRhdGlvbnNfKGNvbW1hbmRzKSB7XG4gIGxldCBsZW5ndGggPSAwO1xuICBsZXQgYm91bmRzID0ge2w6IEluZmluaXR5LCB0OiBJbmZpbml0eSwgcjogLUluZmluaXR5LCBiOiAtSW5maW5pdHl9O1xuICBsZXQgY3VycmVudFN1YlBhdGggPSBudWxsO1xuICBsZXQgc3ViUGF0aHMgPSBbXTtcblxuICBsZXQgcHVzaEJlemllcl8gPSBiZXppZXIgPT4ge1xuICAgIGN1cnJlbnRTdWJQYXRoLnB1c2goe1xuICAgICAgYmV6aWVyLFxuICAgICAgbHV0OiBiZXppZXIuZ2V0TFVUKDEwMCksXG4gICAgICBsZW5ndGg6IGJlemllci5sZW5ndGgoKSxcbiAgICB9KTtcbiAgfTtcblxuICBsZXQgZXhwYW5kQm91bmRzXyA9ICh4LCB5KSA9PiB7XG4gICAgYm91bmRzLmwgPSBNYXRoLm1pbih4LCBib3VuZHMubCk7XG4gICAgYm91bmRzLnQgPSBNYXRoLm1pbih5LCBib3VuZHMudCk7XG4gICAgYm91bmRzLnIgPSBNYXRoLm1heCh4LCBib3VuZHMucik7XG4gICAgYm91bmRzLmIgPSBNYXRoLm1heCh5LCBib3VuZHMuYik7XG4gIH07XG5cbiAgbGV0IGV4cGFuZEJvdW5kc1RvQmV6aWVyXyA9IGJleiA9PiB7XG4gICAgbGV0IGJib3ggPSBiZXouYmJveCgpO1xuICAgIGV4cGFuZEJvdW5kc18oYmJveC54Lm1pbiwgYmJveC55Lm1pbik7XG4gICAgZXhwYW5kQm91bmRzXyhiYm94LngubWF4LCBiYm94LnkubWluKTtcbiAgICBleHBhbmRCb3VuZHNfKGJib3gueC5taW4sIGJib3gueS5tYXgpO1xuICAgIGV4cGFuZEJvdW5kc18oYmJveC54Lm1heCwgYmJveC55Lm1heCk7XG4gIH07XG5cbiAgbGV0IGxhc3RNb3ZlUG9pbnQgPSBudWxsO1xuICBsZXQgY3VycmVudFBvaW50ID0ge3g6IDAsIHk6IDB9O1xuXG4gIGNvbW1hbmRzLmZvckVhY2goKHtjb21tYW5kLCBhcmdzfSkgPT4ge1xuICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgY2FzZSAnbW92ZVRvJzoge1xuICAgICAgICAvLyBzdGFydCBuZXcgc3ViLXBhdGhcbiAgICAgICAgY3VycmVudFN1YlBhdGggPSBbXTtcbiAgICAgICAgc3ViUGF0aHMucHVzaChjdXJyZW50U3ViUGF0aCk7XG4gICAgICAgIGxhc3RNb3ZlUG9pbnQgPSB7eDphcmdzWzBdLCB5OmFyZ3NbMV19O1xuICAgICAgICBjdXJyZW50UG9pbnQueCA9IGFyZ3NbMF07XG4gICAgICAgIGN1cnJlbnRQb2ludC55ID0gYXJnc1sxXTtcbiAgICAgICAgZXhwYW5kQm91bmRzXyhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgJ2xpbmVUbyc6IHtcbiAgICAgICAgbGVuZ3RoICs9IE1hdGhVdGlsLmRpc3QoYXJnc1swXSwgYXJnc1sxXSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICAgICAgcHVzaEJlemllcl8obmV3IEJlemllcihcbiAgICAgICAgICAgIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSxcbiAgICAgICAgICAgIGFyZ3NbMF0sIGFyZ3NbMV0sXG4gICAgICAgICAgICBhcmdzWzBdLCBhcmdzWzFdKSk7XG4gICAgICAgIGN1cnJlbnRQb2ludC54ID0gYXJnc1swXTtcbiAgICAgICAgY3VycmVudFBvaW50LnkgPSBhcmdzWzFdO1xuICAgICAgICBleHBhbmRCb3VuZHNfKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2FzZSAnY2xvc2VQYXRoJzoge1xuICAgICAgICBpZiAobGFzdE1vdmVQb2ludCkge1xuICAgICAgICAgIGxlbmd0aCArPSBNYXRoVXRpbC5kaXN0KGxhc3RNb3ZlUG9pbnQueCwgbGFzdE1vdmVQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuICAgICAgICAgIHB1c2hCZXppZXJfKG5ldyBCZXppZXIoXG4gICAgICAgICAgICAgIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSxcbiAgICAgICAgICAgICAgbGFzdE1vdmVQb2ludC54LCBsYXN0TW92ZVBvaW50LnksXG4gICAgICAgICAgICAgIGxhc3RNb3ZlUG9pbnQueCwgbGFzdE1vdmVQb2ludC55KSk7XG4gICAgICAgICAgY3VycmVudFBvaW50LnggPSBsYXN0TW92ZVBvaW50Lng7XG4gICAgICAgICAgY3VycmVudFBvaW50LnkgPSBsYXN0TW92ZVBvaW50Lnk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgJ2JlemllckN1cnZlVG8nOiB7XG4gICAgICAgIGxldCBiZXogPSBuZXcgQmV6aWVyKGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSwgYXJnc1swXSwgYXJnc1sxXSxcbiAgICAgICAgICAgIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0sIGFyZ3NbNV0pO1xuICAgICAgICBsZW5ndGggKz0gYmV6Lmxlbmd0aCgpO1xuICAgICAgICBjdXJyZW50UG9pbnQueCA9IGFyZ3NbNF07XG4gICAgICAgIGN1cnJlbnRQb2ludC55ID0gYXJnc1s1XTtcbiAgICAgICAgcHVzaEJlemllcl8oYmV6KTtcbiAgICAgICAgZXhwYW5kQm91bmRzVG9CZXppZXJfKGJleik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjYXNlICdxdWFkcmF0aWNDdXJ2ZVRvJzoge1xuICAgICAgICBsZXQgYmV6ID0gbmV3IEJlemllcihjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnksIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgICBsZW5ndGggKz0gYmV6Lmxlbmd0aCgpO1xuICAgICAgICBjdXJyZW50UG9pbnQueCA9IGFyZ3NbMl07XG4gICAgICAgIGN1cnJlbnRQb2ludC55ID0gYXJnc1szXTtcbiAgICAgICAgcHVzaEJlemllcl8oYmV6KTtcbiAgICAgICAgZXhwYW5kQm91bmRzVG9CZXppZXJfKGJleik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjYXNlICdfX2FyY19fJzoge1xuICAgICAgICBsZXQgW2N1cnJlbnRQb2ludFgsIGN1cnJlbnRQb2ludFksXG4gICAgICAgICAgICAgcngsIHJ5LCB4QXhpc1JvdGF0aW9uLFxuICAgICAgICAgICAgIGxhcmdlQXJjRmxhZywgc3dlZXBGbGFnLFxuICAgICAgICAgICAgIHRlbXBQb2ludDFYLCB0ZW1wUG9pbnQxWV0gPSBhcmdzO1xuXG4gICAgICAgIGlmIChjdXJyZW50UG9pbnRYID09IHRlbXBQb2ludDFYICYmIGN1cnJlbnRQb2ludFkgPT0gdGVtcFBvaW50MVkpIHtcbiAgICAgICAgICAvLyBkZWdlbmVyYXRlIHRvIHBvaW50ICgwIGxlbmd0aClcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyeCA9PSAwIHx8IHJ5ID09IDApIHtcbiAgICAgICAgICAvLyBkZWdlbmVyYXRlIHRvIGxpbmVcbiAgICAgICAgICBsZW5ndGggKz0gTWF0aFV0aWwuZGlzdChjdXJyZW50UG9pbnRYLCBjdXJyZW50UG9pbnRZLCB0ZW1wUG9pbnQxWCwgdGVtcFBvaW50MVkpO1xuICAgICAgICAgIGV4cGFuZEJvdW5kc18odGVtcFBvaW50MVgsIHRlbXBQb2ludDFZKTtcbiAgICAgICAgICBjdXJyZW50UG9pbnQueCA9IHRlbXBQb2ludDFYO1xuICAgICAgICAgIGN1cnJlbnRQb2ludC55ID0gdGVtcFBvaW50MVk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGJlemllckNvb3JkcyA9IGFyY1RvQmV6aWVyc18oY3VycmVudFBvaW50WCwgY3VycmVudFBvaW50WSxcbiAgICAgICAgICAgIHJ4LCByeSwgeEF4aXNSb3RhdGlvbixcbiAgICAgICAgICAgIGxhcmdlQXJjRmxhZywgc3dlZXBGbGFnLFxuICAgICAgICAgICAgdGVtcFBvaW50MVgsIHRlbXBQb2ludDFZKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJlemllckNvb3Jkcy5sZW5ndGg7IGkgKz0gOCkge1xuICAgICAgICAgIGxldCBiZXogPSBuZXcgQmV6aWVyKGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSxcbiAgICAgICAgICAgICAgYmV6aWVyQ29vcmRzW2kgKyAyXSwgYmV6aWVyQ29vcmRzW2kgKyAzXSxcbiAgICAgICAgICAgICAgYmV6aWVyQ29vcmRzW2kgKyA0XSwgYmV6aWVyQ29vcmRzW2kgKyA1XSxcbiAgICAgICAgICAgICAgYmV6aWVyQ29vcmRzW2kgKyA2XSwgYmV6aWVyQ29vcmRzW2kgKyA3XSk7XG4gICAgICAgICAgbGVuZ3RoICs9IGJlei5sZW5ndGgoKTtcbiAgICAgICAgICBjdXJyZW50UG9pbnQueCA9IGJlemllckNvb3Jkc1tpICsgNl07XG4gICAgICAgICAgY3VycmVudFBvaW50LnkgPSBiZXppZXJDb29yZHNbaSArIDddO1xuICAgICAgICAgIGV4cGFuZEJvdW5kc1RvQmV6aWVyXyhiZXopO1xuICAgICAgICAgIHB1c2hCZXppZXJfKGJleik7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBvaW50LnggPSB0ZW1wUG9pbnQxWDtcbiAgICAgICAgY3VycmVudFBvaW50LnkgPSB0ZW1wUG9pbnQxWTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4ge2xlbmd0aCwgYm91bmRzLCBzdWJQYXRoc307XG59XG5cblxuLy8gQmFzZWQgb24gY29kZSBmcm9tIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL2FyY2hpdmUvcC9hbmRyb2lkc3ZnXG5mdW5jdGlvbiBhcmNUb0JlemllcnNfKHhmLCB5ZiwgcngsIHJ5LCB4QXhpc1JvdGF0aW9uLCBsYXJnZUFyY0ZsYWcsIHN3ZWVwRmxhZywgeHQsIHl0KSB7XG4gIC8vIFNpZ24gb2YgdGhlIHJhZGlpIGlzIGlnbm9yZWQgKGJlaGF2aW91ciBzcGVjaWZpZWQgYnkgdGhlIHNwZWMpXG4gIHJ4ID0gTWF0aC5hYnMocngpO1xuICByeSA9IE1hdGguYWJzKHJ5KTtcblxuICBsZXQgcm90YXRlID0geEF4aXNSb3RhdGlvbiAqIE1hdGguUEkgLyAxODA7XG4gIGxldCBjb3NBbmdsZSA9IE1hdGguY29zKHJvdGF0ZSk7XG4gIGxldCBzaW5BbmdsZSA9IE1hdGguc2luKHJvdGF0ZSk7XG5cbiAgLy8gV2Ugc2ltcGxpZnkgdGhlIGNhbGN1bGF0aW9ucyBieSB0cmFuc2Zvcm1pbmcgdGhlIGFyYyBzbyB0aGF0IHRoZSBvcmlnaW4gaXMgYXQgdGhlXG4gIC8vIG1pZHBvaW50IGNhbGN1bGF0ZWQgYWJvdmUgZm9sbG93ZWQgYnkgYSByb3RhdGlvbiB0byBsaW5lIHVwIHRoZSBjb29yZGluYXRlIGF4ZXNcbiAgLy8gd2l0aCB0aGUgYXhlcyBvZiB0aGUgZWxsaXBzZS5cblxuICAvLyBDb21wdXRlIHRoZSBtaWRwb2ludCBvZiB0aGUgbGluZSBiZXR3ZWVuIHRoZSBjdXJyZW50IGFuZCB0aGUgZW5kIHBvaW50XG4gIGxldCBkeDIgPSAoeGYgLSB4dCkgLyAyO1xuICBsZXQgZHkyID0gKHlmIC0geXQpIC8gMjtcblxuICAvLyBTdGVwIDEgOiBDb21wdXRlICh4MScsIHkxJykgLSB0aGUgdHJhbnNmb3JtZWQgc3RhcnQgcG9pbnRcbiAgbGV0IHgxID0gKGNvc0FuZ2xlICogZHgyICsgc2luQW5nbGUgKiBkeTIpO1xuICBsZXQgeTEgPSAoLXNpbkFuZ2xlICogZHgyICsgY29zQW5nbGUgKiBkeTIpO1xuXG4gIGxldCByeF9zcSA9IHJ4ICogcng7XG4gIGxldCByeV9zcSA9IHJ5ICogcnk7XG4gIGxldCB4MV9zcSA9IHgxICogeDE7XG4gIGxldCB5MV9zcSA9IHkxICogeTE7XG5cbiAgLy8gQ2hlY2sgdGhhdCByYWRpaSBhcmUgbGFyZ2UgZW5vdWdoLlxuICAvLyBJZiB0aGV5IGFyZSBub3QsIHRoZSBzcGVjIHNheXMgdG8gc2NhbGUgdGhlbSB1cCBzbyB0aGV5IGFyZS5cbiAgLy8gVGhpcyBpcyB0byBjb21wZW5zYXRlIGZvciBwb3RlbnRpYWwgcm91bmRpbmcgZXJyb3JzL2RpZmZlcmVuY2VzIGJldHdlZW4gU1ZHIGltcGxlbWVudGF0aW9ucy5cbiAgbGV0IHJhZGlpQ2hlY2sgPSB4MV9zcSAvIHJ4X3NxICsgeTFfc3EgLyByeV9zcTtcbiAgaWYgKHJhZGlpQ2hlY2sgPiAxKSB7XG4gICAgcnggPSBNYXRoLnNxcnQocmFkaWlDaGVjaykgKiByeDtcbiAgICByeSA9IE1hdGguc3FydChyYWRpaUNoZWNrKSAqIHJ5O1xuICAgIHJ4X3NxID0gcnggKiByeDtcbiAgICByeV9zcSA9IHJ5ICogcnk7XG4gIH1cblxuICAvLyBTdGVwIDIgOiBDb21wdXRlIChjeDEsIGN5MSkgLSB0aGUgdHJhbnNmb3JtZWQgY2VudHJlIHBvaW50XG4gIGxldCBzaWduID0gKGxhcmdlQXJjRmxhZyA9PSBzd2VlcEZsYWcpID8gLTEgOiAxO1xuICBsZXQgc3EgPSAoKHJ4X3NxICogcnlfc3EpIC0gKHJ4X3NxICogeTFfc3EpIC0gKHJ5X3NxICogeDFfc3EpKSAvICgocnhfc3EgKiB5MV9zcSkgKyAocnlfc3EgKiB4MV9zcSkpO1xuICBzcSA9IChzcSA8IDApID8gMCA6IHNxO1xuICBsZXQgY29lZiA9IChzaWduICogTWF0aC5zcXJ0KHNxKSk7XG4gIGxldCBjeDEgPSBjb2VmICogKChyeCAqIHkxKSAvIHJ5KTtcbiAgbGV0IGN5MSA9IGNvZWYgKiAtKChyeSAqIHgxKSAvIHJ4KTtcblxuICAvLyBTdGVwIDMgOiBDb21wdXRlIChjeCwgY3kpIGZyb20gKGN4MSwgY3kxKVxuICBsZXQgc3gyID0gKHhmICsgeHQpIC8gMjtcbiAgbGV0IHN5MiA9ICh5ZiArIHl0KSAvIDI7XG4gIGxldCBjeCA9IHN4MiArIChjb3NBbmdsZSAqIGN4MSAtIHNpbkFuZ2xlICogY3kxKTtcbiAgbGV0IGN5ID0gc3kyICsgKHNpbkFuZ2xlICogY3gxICsgY29zQW5nbGUgKiBjeTEpO1xuXG4gIC8vIFN0ZXAgNCA6IENvbXB1dGUgdGhlIGFuZ2xlU3RhcnQgKGFuZ2xlMSkgYW5kIHRoZSBhbmdsZUV4dGVudCAoZGFuZ2xlKVxuICBsZXQgdXggPSAoeDEgLSBjeDEpIC8gcng7XG4gIGxldCB1eSA9ICh5MSAtIGN5MSkgLyByeTtcbiAgbGV0IHZ4ID0gKC14MSAtIGN4MSkgLyByeDtcbiAgbGV0IHZ5ID0gKC15MSAtIGN5MSkgLyByeTtcbiAgbGV0IHAsIG47XG5cbiAgLy8gQ29tcHV0ZSB0aGUgYW5nbGUgc3RhcnRcbiAgbiA9IE1hdGguc3FydCgodXggKiB1eCkgKyAodXkgKiB1eSkpO1xuICBwID0gdXg7IC8vICgxICogdXgpICsgKDAgKiB1eSlcbiAgc2lnbiA9ICh1eSA8IDApID8gLTEgOiAxO1xuICBsZXQgYW5nbGVTdGFydCA9IChzaWduICogTWF0aC5hY29zKHAgLyBuKSkgKiAxODAgLyBNYXRoLlBJO1xuXG4gIC8vIENvbXB1dGUgdGhlIGFuZ2xlIGV4dGVudFxuICBuID0gTWF0aC5zcXJ0KCh1eCAqIHV4ICsgdXkgKiB1eSkgKiAodnggKiB2eCArIHZ5ICogdnkpKTtcbiAgcCA9IHV4ICogdnggKyB1eSAqIHZ5O1xuICBzaWduID0gKHV4ICogdnkgLSB1eSAqIHZ4IDwgMCkgPyAtMSA6IDE7XG4gIGxldCBhbmdsZUV4dGVudCA9IChzaWduICogTWF0aC5hY29zKHAgLyBuKSkgKiAxODAgLyBNYXRoLlBJO1xuICBpZiAoIXN3ZWVwRmxhZyAmJiBhbmdsZUV4dGVudCA+IDApIHtcbiAgICBhbmdsZUV4dGVudCAtPSAzNjA7XG4gIH0gZWxzZSBpZiAoc3dlZXBGbGFnICYmIGFuZ2xlRXh0ZW50IDwgMCkge1xuICAgIGFuZ2xlRXh0ZW50ICs9IDM2MDtcbiAgfVxuXG4gIGFuZ2xlRXh0ZW50ICU9IDM2MDtcbiAgYW5nbGVTdGFydCAlPSAzNjA7XG5cbiAgLy8gTWFueSBlbGxpcHRpY2FsIGFyYyBpbXBsZW1lbnRhdGlvbnMgaW5jbHVkaW5nIHRoZSBKYXZhMkQgYW5kIEFuZHJvaWQgb25lcywgb25seVxuICAvLyBzdXBwb3J0IGFyY3MgdGhhdCBhcmUgYXhpcyBhbGlnbmVkLiAgVGhlcmVmb3JlIHdlIG5lZWQgdG8gc3Vic3RpdHV0ZSB0aGUgYXJjXG4gIC8vIHdpdGggYmV6aWVyIGN1cnZlcy4gIFRoZSBmb2xsb3dpbmcgbWV0aG9kIGNhbGwgd2lsbCBnZW5lcmF0ZSB0aGUgYmV6aWVycyBmb3JcbiAgLy8gYSB1bml0IGNpcmNsZSB0aGF0IGNvdmVycyB0aGUgYXJjIGFuZ2xlcyB3ZSB3YW50LlxuICBsZXQgYmV6aWVyQ29vcmRzID0gdW5pdENpcmNsZUFyY1RvQmV6aWVyc18oYW5nbGVTdGFydCwgYW5nbGVFeHRlbnQpO1xuXG4gIC8vIENhbGN1bGF0ZSBhIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCB0aGF0IHdpbGwgbW92ZSBhbmQgc2NhbGUgdGhlc2UgYmV6aWVyIHBvaW50cyB0byB0aGUgY29ycmVjdCBsb2NhdGlvbi5cbiAgLy8gdHJhbnNsYXRlKGN4LCBjeSkgLS0+IHJvdGF0ZShyb3RhdGUpIC0tPiBzY2FsZShyeCwgcnkpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmV6aWVyQ29vcmRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgLy8gZG90IHByb2R1Y3RcbiAgICBsZXQgeCA9IGJlemllckNvb3Jkc1tpXTtcbiAgICBsZXQgeSA9IGJlemllckNvb3Jkc1tpICsgMV07XG4gICAgYmV6aWVyQ29vcmRzW2ldID1cbiAgICAgICAgY29zQW5nbGUgKiByeCAqIHggK1xuICAgICAgICAtc2luQW5nbGUgKiByeSAqIHkgK1xuICAgICAgICBjeDtcblxuICAgIGJlemllckNvb3Jkc1tpICsgMV0gPVxuICAgICAgICBzaW5BbmdsZSAqIHJ4ICogeCArXG4gICAgICAgIGNvc0FuZ2xlICogcnkgKiB5ICtcbiAgICAgICAgY3k7XG4gIH1cblxuICAvLyBUaGUgbGFzdCBwb2ludCBpbiB0aGUgYmV6aWVyIHNldCBzaG91bGQgbWF0Y2ggZXhhY3RseSB0aGUgbGFzdCBjb29yZCBwYWlyIGluIHRoZSBhcmMgKGllOiB4LHkpLiBCdXRcbiAgLy8gY29uc2lkZXJpbmcgYWxsIHRoZSBtYXRoZW1hdGljYWwgbWFuaXB1bGF0aW9uIHdlIGhhdmUgYmVlbiBkb2luZywgaXQgaXMgYm91bmQgdG8gYmUgb2ZmIGJ5IGEgdGlueVxuICAvLyBmcmFjdGlvbi4gRXhwZXJpbWVudHMgc2hvdyB0aGF0IGl0IGNhbiBiZSB1cCB0byBhcm91bmQgMC4wMDAwMi4gIFNvIHdoeSBkb24ndCB3ZSBqdXN0IHNldCBpdCB0b1xuICAvLyBleGFjdGx5IHdoYXQgaXQgb3VnaHQgdG8gYmUuXG4gIGJlemllckNvb3Jkc1tiZXppZXJDb29yZHMubGVuZ3RoIC0gMl0gPSB4dDtcbiAgYmV6aWVyQ29vcmRzW2JlemllckNvb3Jkcy5sZW5ndGggLSAxXSA9IHl0O1xuICByZXR1cm4gYmV6aWVyQ29vcmRzO1xufVxuXG5cbi8qXG4qIEdlbmVyYXRlIHRoZSBjb250cm9sIHBvaW50cyBhbmQgZW5kcG9pbnRzIGZvciBhIHNldCBvZiBiZXppZXIgY3VydmVzIHRoYXQgbWF0Y2hcbiogYSBjaXJjdWxhciBhcmMgc3RhcnRpbmcgZnJvbSBhbmdsZSAnYW5nbGVTdGFydCcgYW5kIHN3ZWVwIHRoZSBhbmdsZSAnYW5nbGVFeHRlbnQnLlxuKiBUaGUgY2lyY2xlIHRoZSBhcmMgZm9sbG93cyB3aWxsIGJlIGNlbnRyZWQgb24gKDAsMCkgYW5kIGhhdmUgYSByYWRpdXMgb2YgMS4wLlxuKlxuKiBFYWNoIGJlemllciBjYW4gY292ZXIgbm8gbW9yZSB0aGFuIDkwIGRlZ3JlZXMsIHNvIHRoZSBhcmMgd2lsbCBiZSBkaXZpZGVkIGV2ZW5seVxuKiBpbnRvIGEgbWF4aW11bSBvZiBmb3VyIGN1cnZlcy5cbipcbiogVGhlIHJlc3VsdGluZyBjb250cm9sIHBvaW50cyB3aWxsIGxhdGVyIGJlIHNjYWxlZCBhbmQgcm90YXRlZCB0byBtYXRjaCB0aGUgZmluYWxcbiogYXJjIHJlcXVpcmVkLlxuKlxuKiBUaGUgcmV0dXJuZWQgYXJyYXkgaGFzIHRoZSBmb3JtYXQgW3gwLHkwLCB4MSx5MSwuLi5dLlxuKi9cbmZ1bmN0aW9uIHVuaXRDaXJjbGVBcmNUb0JlemllcnNfKGFuZ2xlU3RhcnQsIGFuZ2xlRXh0ZW50KSB7XG4gIGxldCBudW1TZWdtZW50cyA9IE1hdGguY2VpbChNYXRoLmFicyhhbmdsZUV4dGVudCkgLyA5MCk7XG5cbiAgYW5nbGVTdGFydCA9IGFuZ2xlU3RhcnQgKiBNYXRoLlBJIC8gMTgwO1xuICBhbmdsZUV4dGVudCA9IGFuZ2xlRXh0ZW50ICogTWF0aC5QSSAvIDE4MDtcblxuICBsZXQgYW5nbGVJbmNyZW1lbnQgPSBhbmdsZUV4dGVudCAvIG51bVNlZ21lbnRzO1xuXG4gIC8vIFRoZSBsZW5ndGggb2YgZWFjaCBjb250cm9sIHBvaW50IHZlY3RvciBpcyBnaXZlbiBieSB0aGUgZm9sbG93aW5nIGZvcm11bGEuXG4gIGxldCBjb250cm9sTGVuZ3RoID0gNCAvIDMgKiBNYXRoLnNpbihhbmdsZUluY3JlbWVudCAvIDIpIC8gKDEgKyBNYXRoLmNvcyhhbmdsZUluY3JlbWVudCAvIDIpKTtcblxuICBsZXQgY29vcmRzID0gbmV3IEFycmF5KG51bVNlZ21lbnRzICogOCk7XG4gIGxldCBwb3MgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKykge1xuICAgIGxldCBhbmdsZSA9IGFuZ2xlU3RhcnQgKyBpICogYW5nbGVJbmNyZW1lbnQ7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGNvbnRyb2wgdmVjdG9yIGF0IHRoaXMgYW5nbGVcbiAgICBsZXQgZHggPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgbGV0IGR5ID0gTWF0aC5zaW4oYW5nbGUpO1xuXG4gICAgLy8gRmlyc3QgcG9pbnRcbiAgICBjb29yZHNbcG9zKytdID0gZHg7XG4gICAgY29vcmRzW3BvcysrXSA9IGR5O1xuXG4gICAgLy8gRmlyc3QgY29udHJvbCBwb2ludFxuICAgIGNvb3Jkc1twb3MrK10gPSAoZHggLSBjb250cm9sTGVuZ3RoICogZHkpO1xuICAgIGNvb3Jkc1twb3MrK10gPSAoZHkgKyBjb250cm9sTGVuZ3RoICogZHgpO1xuXG4gICAgLy8gU2Vjb25kIGNvbnRyb2wgcG9pbnRcbiAgICBhbmdsZSArPSBhbmdsZUluY3JlbWVudDtcbiAgICBkeCA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICBkeSA9IE1hdGguc2luKGFuZ2xlKTtcblxuICAgIGNvb3Jkc1twb3MrK10gPSAoZHggKyBjb250cm9sTGVuZ3RoICogZHkpO1xuICAgIGNvb3Jkc1twb3MrK10gPSAoZHkgLSBjb250cm9sTGVuZ3RoICogZHgpO1xuXG4gICAgLy8gRW5kcG9pbnQgb2YgYmV6aWVyXG4gICAgY29vcmRzW3BvcysrXSA9IGR4O1xuICAgIGNvb3Jkc1twb3MrK10gPSBkeTtcbiAgfVxuXG4gIHJldHVybiBjb29yZHM7XG59XG5cblxuLy8gVE9ETzogcmVmYWN0b3IgaW50byBhIE1hdHJpeFV0aWxcbmZ1bmN0aW9uIHRyYW5zZm9ybVBvaW50XyhwLCB0cmFuc2Zvcm1NYXRyaWNpZXMpIHtcbiAgcmV0dXJuIHRyYW5zZm9ybU1hdHJpY2llcy5yZWR1Y2UoKHAsIHRyYW5zZm9ybSkgPT4ge1xuICAgIGNvbnN0IG0gPSB0cmFuc2Zvcm0ubWF0cml4O1xuICAgIHJldHVybiB7XG4gICAgICAvLyBkb3QgcHJvZHVjdFxuICAgICAgeDogbS5hICogcC54ICsgbS5jICogcC55ICsgbS5lICogMSxcbiAgICAgIHk6IG0uYiAqIHAueCArIG0uZCAqIHAueSArIG0uZiAqIDEsXG4gICAgfTtcbiAgfSwgcCk7XG59XG5cbi8vIENvZGUgYWRhcHRlZCBmcm9tIGhlcmU6XG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9hbGV4amxvY2t3b29kL2MwMzcxNDA4Nzk4MDZmYjRkOTgyMGI3ZTcwMTk1NDk0I2ZpbGUtZmxhdHRlbi1qcy1MNDQxLUw1NDdcbmZ1bmN0aW9uIHRyYW5zZm9ybUFyY18oaW5pdGlhbEFyYywgdHJhbnNmb3JtTWF0cmljaWVzKSB7XG4gIGNvbnN0IGlzTmVhclplcm8gPSBuID0+IE1hdGguYWJzKG4pIDwgMC4wMDAwMDAwMDAwMDAwMDAxO1xuICByZXR1cm4gdHJhbnNmb3JtTWF0cmljaWVzLnJlZHVjZSgoYXJjLCB0cmFuc2Zvcm0pID0+IHtcbiAgICBsZXQge3J4LCByeSwgeEF4aXNSb3RhdGlvbiwgbGFyZ2VBcmNGbGFnLCBzd2VlcEZsYWcsIGVuZFgsIGVuZFl9ID0gYXJjO1xuXG4gICAgeEF4aXNSb3RhdGlvbiA9IHhBeGlzUm90YXRpb24gKiBNYXRoLlBJIC8gMTgwO1xuXG4gICAgY29uc3QgcyA9IHBhcnNlRmxvYXQoTWF0aC5zaW4oeEF4aXNSb3RhdGlvbikpO1xuICAgIGNvbnN0IGMgPSBwYXJzZUZsb2F0KE1hdGguY29zKHhBeGlzUm90YXRpb24pKTtcblxuICAgIC8vIE1hdHJpeCByZXByZXNlbnRhdGlvbiBvZiB0cmFuc2Zvcm1lZCBlbGxpcHNlLlxuICAgIGxldCBtID0gW107XG5cbiAgICAvLyBCdWlsZCBlbGxpcHNlIHJlcHJlc2VudGF0aW9uIG1hdHJpeCAodW5pdCBjaXJjbGUgdHJhbnNmb3JtYXRpb24pLlxuICAgIC8vIFRoZSAyeDIgbWF0cml4IG11bHRpcGxpY2F0aW9uIHdpdGggdGhlIHVwcGVyIDJ4MiBvZiBhX21hdCBpcyBpbmxpbmVkLlxuICAgIGNvbnN0IG1hdHJpeCA9IHRyYW5zZm9ybS5tYXRyaXg7XG4gICAgbVswXSA9IG1hdHJpeC5hICogK3J4ICogYyArIG1hdHJpeC5jICogcnggKiBzO1xuICAgIG1bMV0gPSBtYXRyaXguYiAqICtyeCAqIGMgKyBtYXRyaXguZCAqIHJ4ICogcztcbiAgICBtWzJdID0gbWF0cml4LmEgKiAtcnkgKiBzICsgbWF0cml4LmMgKiByeSAqIGM7XG4gICAgbVszXSA9IG1hdHJpeC5iICogLXJ5ICogcyArIG1hdHJpeC5kICogcnkgKiBjO1xuXG4gICAgLy8gVG8gaW1wbGljdCBlcXVhdGlvbiAoY2VudGVyZWQpLlxuICAgIGNvbnN0IEEgPSAobVswXSAqIG1bMF0pICsgKG1bMl0gKiBtWzJdKTtcbiAgICBjb25zdCBDID0gKG1bMV0gKiBtWzFdKSArIChtWzNdICogbVszXSk7XG4gICAgY29uc3QgQiA9IChtWzBdICogbVsxXSArIG1bMl0gKiBtWzNdKSAqIDIuMDtcblxuICAgIC8vIFByZWNhbGN1bGF0ZSBkaXN0YW5jZSBBIHRvIEMuXG4gICAgY29uc3QgYWMgPSBBIC0gQztcblxuICAgIC8vIENvbnZlcnQgaW1wbGljaXQgZXF1YXRpb24gdG8gYW5nbGUgYW5kIGhhbGZheGlzLlxuICAgIGxldCBBMiwgQzI7XG4gICAgaWYgKGlzTmVhclplcm8oQikpIHtcbiAgICAgIHhBeGlzUm90YXRpb24gPSAwO1xuICAgICAgQTIgPSBBO1xuICAgICAgQzIgPSBDO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNOZWFyWmVybyhhYykpIHtcbiAgICAgICAgQTIgPSBBICsgQiAqIDAuNTtcbiAgICAgICAgQzIgPSBBIC0gQiAqIDAuNTtcbiAgICAgICAgeEF4aXNSb3RhdGlvbiA9IE1hdGguUEkgLyA0LjA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBQcmVjYWxjdWxhdGUgcmFkaWNhbC5cbiAgICAgICAgbGV0IEsgPSAxICsgQiAqIEIgLyAoYWMgKiBhYyk7XG5cbiAgICAgICAgLy8gQ2xhbXAgKHByZWNpc2lvbiBpc3N1ZXMgbWlnaHQgbmVlZCB0aGlzLi4uIG5vdCBsaWtlbHksIGJ1dCBiZXR0ZXIgc2FmZSB0aGFuIHNvcnJ5KS5cbiAgICAgICAgSyA9IEsgPCAwID8gMCA6IE1hdGguc3FydChLKTtcblxuICAgICAgICBBMiA9IDAuNSAqIChBICsgQyArIEsgKiBhYyk7XG4gICAgICAgIEMyID0gMC41ICogKEEgKyBDIC0gSyAqIGFjKTtcbiAgICAgICAgeEF4aXNSb3RhdGlvbiA9IDAuNSAqIE1hdGguYXRhbjIoQiwgYWMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoaXMgY2FuIGdldCBzbGlnaHRseSBiZWxvdyB6ZXJvIGR1ZSB0byByb3VuZGluZyBpc3N1ZXMuXG4gICAgLy8gSXQncyBzYWZlIHRvIGNsYW1wIHRvIHplcm8gaW4gdGhpcyBjYXNlICh0aGlzIHlpZWxkcyBhIHplcm8gbGVuZ3RoIGhhbGZheGlzKS5cbiAgICBBMiA9IEEyIDwgMCA/IDAgOiBNYXRoLnNxcnQoQTIpO1xuICAgIEMyID0gQzIgPCAwID8gMCA6IE1hdGguc3FydChDMik7XG5cbiAgICAvLyBOb3cgQTIgYW5kIEMyIGFyZSBoYWxmLWF4aXMuXG4gICAgaWYgKGFjIDw9IDApIHtcbiAgICAgIHJ5ID0gQTI7XG4gICAgICByeCA9IEMyO1xuICAgIH0gZWxzZSB7XG4gICAgICByeSA9IEMyO1xuICAgICAgcnggPSBBMjtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4IGNvbnRhaW4gYSBtaXJyb3ItY29tcG9uZW50XG4gICAgLy8gd2luZGluZyBvcmRlciBvZiB0aGUgZWxsaXNlIG5lZWRzIHRvIGJlIGNoYW5nZWQuXG4gICAgaWYgKChtYXRyaXguYSAqIG1hdHJpeC5kKSAtIChtYXRyaXguYiAqIG1hdHJpeC5jKSA8IDApIHtcbiAgICAgIHN3ZWVwRmxhZyA9IHN3ZWVwRmxhZyA/IDAgOiAxO1xuICAgIH1cblxuICAgIC8vIEZpbmFsbHksIHRyYW5zZm9ybSBhcmMgZW5kcG9pbnQuIFRoaXMgdGFrZXMgY2FyZSBhYm91dCB0aGVcbiAgICAvLyB0cmFuc2xhdGlvbmFsIHBhcnQgd2hpY2ggd2UgaWdub3JlZCBhdCB0aGUgd2hvbGUgbWF0aC1zaG93ZG93biBhYm92ZS5cbiAgICBjb25zdCBlbmQgPSB0cmFuc2Zvcm1Qb2ludF8oeyB4OiBlbmRYLCB5OiBlbmRZIH0sIFt0cmFuc2Zvcm1dKTtcblxuICAgIHhBeGlzUm90YXRpb24gPSB4QXhpc1JvdGF0aW9uICogMTgwIC8gTWF0aC5QSTtcblxuICAgIHJldHVybiB7XG4gICAgICByeCxcbiAgICAgIHJ5LFxuICAgICAgeEF4aXNSb3RhdGlvbixcbiAgICAgIGxhcmdlQXJjRmxhZyxcbiAgICAgIHN3ZWVwRmxhZyxcbiAgICAgIGVuZFg6IGVuZC54LFxuICAgICAgZW5kWTogZW5kLnksXG4gICAgfTtcbiAgfSwgaW5pdGlhbEFyYyk7XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGNvbnN0IFVpVXRpbCA9IHtcbiAgd2FpdEZvckVsZW1lbnRXaWR0aF8oZWwsIHRpbWVvdXQgPSAxMDAwKSB7XG4gICAgbGV0IHN0YXJ0ID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuICAgIGxldCAkZWwgPSAkKGVsKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IHRyeVJlc29sdmVfID0gKCkgPT4ge1xuICAgICAgICBpZiAoTnVtYmVyKG5ldyBEYXRlKCkpIC0gc3RhcnQgPiB0aW1lb3V0KSB7XG4gICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHdpZHRoID0gJGVsLndpZHRoKCk7XG4gICAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICAgIHJlc29sdmUod2lkdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdHJ5UmVzb2x2ZV8oKSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRyeVJlc29sdmVfKCk7XG4gICAgfSk7XG4gIH1cbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtBcnR3b3JrLCBEZWZhdWx0VmFsdWVzfSBmcm9tICcuL21vZGVsJztcbmltcG9ydCB7SWRQcm9wZXJ0eX0gZnJvbSAnLi9tb2RlbC9wcm9wZXJ0aWVzJztcbmltcG9ydCB7TW9kZWxVdGlsfSBmcm9tICcuL01vZGVsVXRpbCc7XG5cblxuZXhwb3J0IGNvbnN0IFZlY3RvckRyYXdhYmxlTG9hZGVyID0ge1xuICBsb2FkQXJ0d29ya0Zyb21YbWxTdHJpbmcoeG1sU3RyaW5nKSB7XG4gICAgbGV0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICBsZXQgZG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh4bWxTdHJpbmcsICdhcHBsaWNhdGlvbi94bWwnKTtcblxuICAgIGxldCB1c2VkSWRzID0ge307XG5cbiAgICBsZXQgbm9kZVRvTGF5ZXJEYXRhXyA9IChub2RlKSA9PiB7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSBOb2RlLlRFWFRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09IE5vZGUuQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBsZXQgbWFrZUZpbmFsTm9kZUlkXyA9IChub2RlLCB0eXBlSWRQcmVmaXgpID0+IHtcbiAgICAgICAgbGV0IG5hbWUgPSBub2RlLmdldEF0dHJpYnV0ZSgnYW5kcm9pZDpuYW1lJyk7XG4gICAgICAgIGxldCBmaW5hbElkID0gTW9kZWxVdGlsLmdldFVuaXF1ZUlkKHtcbiAgICAgICAgICAgIHByZWZpeDogSWRQcm9wZXJ0eS5zYW5pdGl6ZShuYW1lIHx8IHR5cGVJZFByZWZpeCksXG4gICAgICAgICAgICBvYmplY3RCeUlkOiBpZCA9PiB1c2VkSWRzW2lkXSxcbiAgICAgICAgfSk7XG4gICAgICAgIHVzZWRJZHNbZmluYWxJZF0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmluYWxJZDtcbiAgICAgIH07XG5cbiAgICAgIGxldCBsYXllckRhdGEgPSB7fTtcblxuICAgICAgaWYgKG5vZGUudGFnTmFtZSA9PT0gJ3BhdGgnKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGxheWVyRGF0YSwge1xuICAgICAgICAgICAgaWQ6IG1ha2VGaW5hbE5vZGVJZF8obm9kZSwgJ3BhdGgnKSxcbiAgICAgICAgICAgIHBhdGhEYXRhOiBub2RlLmdldEF0dHJpYnV0ZSgnYW5kcm9pZDpwYXRoRGF0YScpIHx8IG51bGwsXG4gICAgICAgICAgICBmaWxsQ29sb3I6IG5vZGUuZ2V0QXR0cmlidXRlKCdhbmRyb2lkOmZpbGxDb2xvcicpIHx8IG51bGwsXG4gICAgICAgICAgICBmaWxsQWxwaGE6IG5vZGUuZ2V0QXR0cmlidXRlKCdhbmRyb2lkOmZpbGxBbHBoYScpIHx8IDEsXG4gICAgICAgICAgICBzdHJva2VDb2xvcjogbm9kZS5nZXRBdHRyaWJ1dGUoJ2FuZHJvaWQ6c3Ryb2tlQ29sb3InKSB8fCBudWxsLFxuICAgICAgICAgICAgc3Ryb2tlQWxwaGE6IG5vZGUuZ2V0QXR0cmlidXRlKCdhbmRyb2lkOnN0cm9rZUFscGhhJykgfHwgMSxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBub2RlLmdldEF0dHJpYnV0ZSgnYW5kcm9pZDpzdHJva2VXaWR0aCcpIHx8IDAsXG4gICAgICAgICAgICBzdHJva2VMaW5lY2FwOiBub2RlLmdldEF0dHJpYnV0ZSgnYW5kcm9pZDpzdHJva2VMaW5lQ2FwJykgfHwgRGVmYXVsdFZhbHVlcy5MSU5FQ0FQLFxuICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW46IG5vZGUuZ2V0QXR0cmlidXRlKCdhbmRyb2lkOnN0cm9rZUxpbmVKb2luJykgfHwgRGVmYXVsdFZhbHVlcy5MSU5FSk9JTixcbiAgICAgICAgICAgIHN0cm9rZU1pdGVyTGltaXQ6XG4gICAgICAgICAgICAgICAgbm9kZS5nZXRBdHRyaWJ1dGUoJ2FuZHJvaWQ6c3Ryb2tlTWl0ZXJMaW1pdCcpIHx8IERlZmF1bHRWYWx1ZXMuTUlURVJfTElNSVQsXG4gICAgICAgICAgICB0cmltUGF0aFN0YXJ0OiBub2RlLmdldEF0dHJpYnV0ZSgnYW5kcm9pZDp0cmltUGF0aFN0YXJ0JykgfHwgMCxcbiAgICAgICAgICAgIHRyaW1QYXRoRW5kOiBub2RlLmdldEF0dHJpYnV0ZSgnYW5kcm9pZDp0cmltUGF0aEVuZCcpIHx8IDEsXG4gICAgICAgICAgICB0cmltUGF0aE9mZnNldDogbm9kZS5nZXRBdHRyaWJ1dGUoJ2FuZHJvaWQ6dHJpbVBhdGhPZmZzZXQnKSB8fCAwLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IGxheWVycyA9IEFycmF5LmZyb20obm9kZS5jaGlsZE5vZGVzKVxuICAgICAgICAgICAgLm1hcChjaGlsZCA9PiBub2RlVG9MYXllckRhdGFfKGNoaWxkKSlcbiAgICAgICAgICAgIC5maWx0ZXIobGF5ZXIgPT4gISFsYXllcik7XG4gICAgICAgIGlmIChsYXllcnMgJiYgbGF5ZXJzLmxlbmd0aCkge1xuICAgICAgICAgIC8vIGNyZWF0ZSBhIGdyb3VwICh0aGVyZSBhcmUgdmFsaWQgY2hpbGRyZW4pXG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obGF5ZXJEYXRhLCB7XG4gICAgICAgICAgICAgIGlkOiBtYWtlRmluYWxOb2RlSWRfKG5vZGUsICdncm91cCcpLFxuICAgICAgICAgICAgICB0eXBlOiAnZ3JvdXAnLFxuICAgICAgICAgICAgICByb3RhdGlvbjogbm9kZS5nZXRBdHRyaWJ1dGUoJ2FuZHJvaWQ6cm90YXRpb24nKSB8fCAwLFxuICAgICAgICAgICAgICBzY2FsZVg6IG5vZGUuZ2V0QXR0cmlidXRlKCdhbmRyb2lkOnNjYWxlWCcpIHx8IDEsXG4gICAgICAgICAgICAgIHNjYWxlWTogbm9kZS5nZXRBdHRyaWJ1dGUoJ2FuZHJvaWQ6c2NhbGVZJykgfHwgMSxcbiAgICAgICAgICAgICAgcGl2b3RYOiBub2RlLmdldEF0dHJpYnV0ZSgnYW5kcm9pZDpwaXZvdFgnKSB8fCAwLFxuICAgICAgICAgICAgICBwaXZvdFk6IG5vZGUuZ2V0QXR0cmlidXRlKCdhbmRyb2lkOnBpdm90WScpIHx8IDAsXG4gICAgICAgICAgICAgIHRyYW5zbGF0ZVg6IG5vZGUuZ2V0QXR0cmlidXRlKCdhbmRyb2lkOnRyYW5zbGF0ZVgnKSB8fCAwLFxuICAgICAgICAgICAgICB0cmFuc2xhdGVZOiBub2RlLmdldEF0dHJpYnV0ZSgnYW5kcm9pZDp0cmFuc2xhdGVZJykgfHwgMCxcbiAgICAgICAgICAgICAgbGF5ZXJzLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxldCByb290TGF5ZXIgPSBub2RlVG9MYXllckRhdGFfKGRvYy5kb2N1bWVudEVsZW1lbnQpO1xuICAgIGxldCBpZCA9IElkUHJvcGVydHkuc2FuaXRpemUoZG9jLmRvY3VtZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FuZHJvaWQ6bmFtZScpIHx8ICd2ZWN0b3InKTtcbiAgICB1c2VkSWRzW2lkXSA9IHRydWU7XG4gICAgbGV0IHdpZHRoID0gZG9jLmRvY3VtZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FuZHJvaWQ6dmlld3BvcnRXaWR0aCcpO1xuICAgIGxldCBoZWlnaHQgPSBkb2MuZG9jdW1lbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnYW5kcm9pZDp2aWV3cG9ydEhlaWdodCcpO1xuICAgIGxldCBhbHBoYSA9IGRvYy5kb2N1bWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdhbmRyb2lkOmFscGhhJykgfHwgMTtcbiAgICBsZXQgYXJ0d29yayA9IHtcbiAgICAgICAgaWQsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGxheWVyczogKHJvb3RMYXllciA/IHJvb3RMYXllci5sYXllcnMgOiBudWxsKSB8fCBbXSxcbiAgICAgICAgYWxwaGEsXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IEFydHdvcmsoYXJ0d29yayk7XG4gIH1cbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuYW5ndWxhci5tb2R1bGUoJ0FWRFN0dWRpbycsIFsnbmdNYXRlcmlhbCcsICduZ1JvdXRlJ10pXG4gICAgLmNvbmZpZyhyZXF1aXJlKCcuL21hdGVyaWFsdGhlbWUnKSlcbiAgICAuY29uZmlnKHJlcXVpcmUoJy4vaWNvbnMnKSlcbiAgICAuY29uZmlnKHJlcXVpcmUoJy4vcm91dGVzJykucm91dGVDb25maWcpO1xuXG4vLyBjb3JlIGFwcFxuYW5ndWxhci5tb2R1bGUoJ0FWRFN0dWRpbycpLmNvbnRyb2xsZXIoJ0FwcEN0cmwnLCBjbGFzcyBBcHBDdHJsIHtcbiAgY29uc3RydWN0b3IoJHNjb3BlKSB7fVxufSk7XG5cbi8vIGFsbCBjb21wb25lbnRzXG5yZXF1aXJlKCcuLi9jb21wb25lbnRzLyoqLyouanMnLCB7bW9kZTogJ2V4cGFuZCd9KTtcblxuLy8gYWxsIHBhZ2VzXG5yZXF1aXJlKCcuLi9wYWdlcy8qKi8qLmpzJywge21vZGU6ICdleHBhbmQnfSk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigkbWRJY29uUHJvdmlkZXIpIHtcbiAgJG1kSWNvblByb3ZpZGVyLmljb25TZXQoJ2F2ZHN0dWRpbycsICdpbWFnZXMvaWNvbnMuc3ZnJyk7XG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oJG1kVGhlbWluZ1Byb3ZpZGVyKSB7XG4gICRtZFRoZW1pbmdQcm92aWRlci50aGVtZSgnZGVmYXVsdCcpXG4gICAgICAucHJpbWFyeVBhbGV0dGUoJ2JsdWUnKVxuICAgICAgLmFjY2VudFBhbGV0dGUoJ2JsdWUnKTtcbiAgJG1kVGhlbWluZ1Byb3ZpZGVyLnRoZW1lKCdkYXJrJylcbiAgICAgIC5wcmltYXJ5UGFsZXR0ZSgnYmx1ZScpXG4gICAgICAuYWNjZW50UGFsZXR0ZSgnYmx1ZScpXG4gICAgICAuZGFyaygpO1xuICAkbWRUaGVtaW5nUHJvdmlkZXIuc2V0RGVmYXVsdFRoZW1lKCdkZWZhdWx0Jyk7XG59OyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1Byb3BlcnR5LCBJZFByb3BlcnR5LCBOdW1iZXJQcm9wZXJ0eX0gZnJvbSAnLi9wcm9wZXJ0aWVzJztcblxuaW1wb3J0IHtBbmltYXRpb25CbG9ja30gZnJvbSAnLi9BbmltYXRpb25CbG9jayc7XG5cbi8qKlxuICogQW4gYW5pbWF0aW9uIHJlcHJlc2VudHMgYSBjb2xsZWN0aW9uIG9mIGxheWVyIHByb3BlcnR5IHR3ZWVucyBmb3IgYSBnaXZlbiBhcnR3b3JrLlxuICovXG5AUHJvcGVydHkucmVnaXN0ZXIoW1xuICBuZXcgSWRQcm9wZXJ0eSgnaWQnKSxcbiAgbmV3IE51bWJlclByb3BlcnR5KCdkdXJhdGlvbicsIHttaW46MTAwLCBtYXg6NjAwMDB9KSxcbl0pXG5leHBvcnQgY2xhc3MgQW5pbWF0aW9uIHtcbiAgY29uc3RydWN0b3Iob2JqID0ge30pIHtcbiAgICB0aGlzLmlkID0gb2JqLmlkIHx8IG51bGw7XG4gICAgdGhpcy5ibG9ja3MgPSAob2JqLmJsb2NrcyB8fCBbXSkubWFwKG9iaiA9PiBuZXcgQW5pbWF0aW9uQmxvY2sob2JqKSk7XG4gICAgdGhpcy5kdXJhdGlvbiA9IG9iai5kdXJhdGlvbiB8fCAxMDA7XG4gIH1cblxuICBnZXQgYmxvY2tzKCkge1xuICAgIHJldHVybiB0aGlzLmJsb2Nrc18gfHwgW107XG4gIH1cblxuICBzZXQgYmxvY2tzKGJsb2Nrcykge1xuICAgIHRoaXMuYmxvY2tzXyA9IGJsb2NrcztcbiAgICB0aGlzLmJsb2Nrc18uZm9yRWFjaChibG9jayA9PiBibG9jay5wYXJlbnQgPSB0aGlzKTtcbiAgfVxuXG4gIGdldCB0eXBlU3RyaW5nKCkge1xuICAgIHJldHVybiAnYW5pbWF0aW9uJztcbiAgfVxuXG4gIGdldCB0eXBlSWRQcmVmaXgoKSB7XG4gICAgcmV0dXJuICdhbmltJztcbiAgfVxuXG4gIGdldCB0eXBlSWNvbigpIHtcbiAgICByZXR1cm4gJ2FuaW1hdGlvbic7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICBibG9ja3M6IHRoaXMuYmxvY2tzLm1hcChibG9jayA9PiBibG9jay50b0pTT04oKSlcbiAgICB9O1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtkZWZhdWx0IGFzIGJlemllckVhc2luZ30gZnJvbSAnYmV6aWVyLWVhc2luZyc7XG5cbmltcG9ydCB7U3ZnUGF0aERhdGF9IGZyb20gJy4uL1N2Z1BhdGhEYXRhJztcbmltcG9ydCB7UHJvcGVydHksIFN0dWJQcm9wZXJ0eSwgTnVtYmVyUHJvcGVydHksIEVudW1Qcm9wZXJ0eX0gZnJvbSAnLi9wcm9wZXJ0aWVzJztcblxuY29uc3QgRkFTVF9PVVRfU0xPV19JTl9FQVNJTkcgPSBiZXppZXJFYXNpbmcoLjQsIDAsIC4yLCAxKTtcbmNvbnN0IEZBU1RfT1VUX0xJTkVBUl9JTl9FQVNJTkcgPSBiZXppZXJFYXNpbmcoLjQsIDAsIDEsIDEpO1xuY29uc3QgTElORUFSX09VVF9TTE9XX0lOX0VBU0lORyA9IGJlemllckVhc2luZygwLCAwLCAuMiwgMSk7XG5cbmNvbnN0IEVOVU1fSU5URVJQT0xBVE9SX09QVElPTlMgPSBbXG4gIHtcbiAgICB2YWx1ZTogJ0FDQ0VMRVJBVEVfREVDRUxFUkFURScsXG4gICAgbGFiZWw6ICdBY2NlbGVyYXRlL2RlY2VsZXJhdGUnLFxuICAgIGFuZHJvaWRSZWY6ICdAYW5kcm9pZDphbmltL2FjY2VsZXJhdGVfZGVjZWxlcmF0ZV9pbnRlcnBvbGF0b3InLFxuICAgIGludGVycG9sYXRlOiBmID0+IE1hdGguY29zKChmICsgMSkgKiBNYXRoLlBJKSAvIDIuMCArIDAuNSxcbiAgfSxcbiAge1xuICAgIHZhbHVlOiAnQUNDRUxFUkFURScsXG4gICAgbGFiZWw6ICdBY2NlbGVyYXRlJyxcbiAgICBhbmRyb2lkUmVmOiAnQGFuZHJvaWQ6YW5pbS9hY2NlbGVyYXRlX2ludGVycG9sYXRvcicsXG4gICAgaW50ZXJwb2xhdGU6IGYgPT4gZiAqIGYsXG4gIH0sXG4gIHtcbiAgICB2YWx1ZTogJ0RFQ0VMRVJBVEUnLFxuICAgIGxhYmVsOiAnRGVjZWxlcmF0ZScsXG4gICAgYW5kcm9pZFJlZjogJ0BhbmRyb2lkOmFuaW0vZGVjZWxlcmF0ZV9pbnRlcnBvbGF0b3InLFxuICAgIGludGVycG9sYXRlOiBmID0+ICgxIC0gKDEgLSBmKSAqICgxIC0gZikpLFxuICB9LFxuICB7XG4gICAgdmFsdWU6ICdBTlRJQ0lQQVRFJyxcbiAgICBsYWJlbDogJ0FudGljaXBhdGUnLFxuICAgIGFuZHJvaWRSZWY6ICdAYW5kcm9pZDphbmltL2FudGljaXBhdGVfaW50ZXJwb2xhdG9yJyxcbiAgICBpbnRlcnBvbGF0ZTogZiA9PiBmICogZiAqICgoMiArIDEpICogZiAtIDIpLFxuICB9LFxuICB7XG4gICAgdmFsdWU6ICdMSU5FQVInLFxuICAgIGxhYmVsOiAnTGluZWFyJyxcbiAgICBhbmRyb2lkUmVmOiAnQGFuZHJvaWQ6YW5pbS9saW5lYXJfaW50ZXJwb2xhdG9yJyxcbiAgICBpbnRlcnBvbGF0ZTogZiA9PiBmLFxuICB9LFxuICB7XG4gICAgdmFsdWU6ICdPVkVSU0hPT1QnLFxuICAgIGxhYmVsOiAnT3ZlcnNob290JyxcbiAgICBhbmRyb2lkUmVmOiAnQGFuZHJvaWQ6YW5pbS9vdmVyc2hvb3RfaW50ZXJwb2xhdG9yJyxcbiAgICBpbnRlcnBvbGF0ZTogZiA9PiAoZiAtIDEpICogKGYgLSAxKSAqICgoMiArIDEpICogKGYgLSAxKSArIDIpICsgMVxuICB9LFxuICB7XG4gICAgdmFsdWU6ICdGQVNUX09VVF9TTE9XX0lOJyxcbiAgICBsYWJlbDogJ0Zhc3Qgb3V0LCBzbG93IGluJyxcbiAgICBhbmRyb2lkUmVmOiAnQGFuZHJvaWQ6aW50ZXJwb2xhdG9yL2Zhc3Rfb3V0X3Nsb3dfaW4nLFxuICAgIGludGVycG9sYXRlOiBmID0+IEZBU1RfT1VUX1NMT1dfSU5fRUFTSU5HKGYpXG4gIH0sXG4gIHtcbiAgICB2YWx1ZTogJ0ZBU1RfT1VUX0xJTkVBUl9JTicsXG4gICAgbGFiZWw6ICdGYXN0IG91dCwgbGluZWFyIGluJyxcbiAgICBhbmRyb2lkUmVmOiAnQGFuZHJvaWQ6aW50ZXJwb2xhdG9yL2Zhc3Rfb3V0X2xpbmVhcl9pbicsXG4gICAgaW50ZXJwb2xhdGU6IGYgPT4gRkFTVF9PVVRfTElORUFSX0lOX0VBU0lORyhmKVxuICB9LFxuICB7XG4gICAgdmFsdWU6ICdMSU5FQVJfT1VUX1NMT1dfSU4nLFxuICAgIGxhYmVsOiAnTGluZWFyIG91dCwgc2xvdyBpbicsXG4gICAgYW5kcm9pZFJlZjogJ0BhbmRyb2lkOmludGVycG9sYXRvci9saW5lYXJfb3V0X3Nsb3dfaW4nLFxuICAgIGludGVycG9sYXRlOiBmID0+IExJTkVBUl9PVVRfU0xPV19JTl9FQVNJTkcoZilcbiAgfSxcbiAgLy9CT1VOQ0U6IGh0dHBzOi8vYW5kcm9pZC5nb29nbGVzb3VyY2UuY29tL3BsYXRmb3JtL2ZyYW1ld29ya3MvYmFzZS8rL3JlZnMvaGVhZHMvbWFzdGVyL2NvcmUvamF2YS9hbmRyb2lkL3ZpZXcvYW5pbWF0aW9uL0JvdW5jZUludGVycG9sYXRvci5qYXZhXG4gIC8vQU5USUNJUEFURV9PVkVSU0hPT1Q6IGh0dHBzOi8vYW5kcm9pZC5nb29nbGVzb3VyY2UuY29tL3BsYXRmb3JtL2ZyYW1ld29ya3MvYmFzZS8rL3JlZnMvaGVhZHMvbWFzdGVyL2NvcmUvamF2YS9hbmRyb2lkL3ZpZXcvYW5pbWF0aW9uL0FudGljaXBhdGVPdmVyc2hvb3RJbnRlcnBvbGF0b3IuamF2YVxuICAvL1BBVEg6IGh0dHBzOi8vYW5kcm9pZC5nb29nbGVzb3VyY2UuY29tL3BsYXRmb3JtL2ZyYW1ld29ya3MvYmFzZS8rL3JlZnMvaGVhZHMvbWFzdGVyL2NvcmUvamF2YS9hbmRyb2lkL3ZpZXcvYW5pbWF0aW9uL1BhdGhJbnRlcnBvbGF0b3IuamF2YVxuXTtcblxuLyoqXG4gKiBBbiBhbmltYXRpb24gYmxvY2sgaXMgYW4gaW5kaXZpZHVhbCBsYXllciBwcm9wZXJ0eSB0d2VlbiAocHJvcGVydHkgYW5pbWF0aW9uKS5cbiAqL1xuQFByb3BlcnR5LnJlZ2lzdGVyKFtcbiAgbmV3IFN0dWJQcm9wZXJ0eSgnZnJvbVZhbHVlJyksXG4gIG5ldyBTdHViUHJvcGVydHkoJ3RvVmFsdWUnKSxcbiAgbmV3IE51bWJlclByb3BlcnR5KCdzdGFydFRpbWUnLCB7bWluOjAsIGludGVnZXI6dHJ1ZX0pLFxuICBuZXcgTnVtYmVyUHJvcGVydHkoJ2VuZFRpbWUnLCB7bWluOjAsIGludGVnZXI6dHJ1ZX0pLFxuICBuZXcgRW51bVByb3BlcnR5KCdpbnRlcnBvbGF0b3InLCBFTlVNX0lOVEVSUE9MQVRPUl9PUFRJT05TLCB7c3RvcmVFbnRpcmVPcHRpb246dHJ1ZX0pLFxuXSlcbmV4cG9ydCBjbGFzcyBBbmltYXRpb25CbG9jayB7XG4gIGNvbnN0cnVjdG9yKG9iaiA9IHt9KSB7XG4gICAgdGhpcy5sYXllcklkID0gb2JqLmxheWVySWQgfHwgbnVsbDtcbiAgICB0aGlzLnByb3BlcnR5TmFtZSA9IG9iai5wcm9wZXJ0eU5hbWUgfHwgbnVsbDtcbiAgICBsZXQgaXNQYXRoRGF0YSA9ICh0aGlzLnByb3BlcnR5TmFtZSA9PSAncGF0aERhdGEnKTtcbiAgICBpZiAoJ2Zyb21WYWx1ZScgaW4gb2JqKSB7XG4gICAgICB0aGlzLmZyb21WYWx1ZSA9IGlzUGF0aERhdGEgPyBuZXcgU3ZnUGF0aERhdGEob2JqLmZyb21WYWx1ZSkgOiBvYmouZnJvbVZhbHVlO1xuICAgIH1cbiAgICB0aGlzLnRvVmFsdWUgPSBpc1BhdGhEYXRhID8gbmV3IFN2Z1BhdGhEYXRhKG9iai50b1ZhbHVlKSA6IG9iai50b1ZhbHVlO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gb2JqLnN0YXJ0VGltZSB8fCAwO1xuICAgIHRoaXMuZW5kVGltZSA9IG9iai5lbmRUaW1lIHx8IDA7XG4gICAgaWYgKHRoaXMuc3RhcnRUaW1lID4gdGhpcy5lbmRUaW1lKSB7XG4gICAgICBsZXQgdG1wID0gdGhpcy5lbmRUaW1lO1xuICAgICAgdGhpcy5lbmRUaW1lID0gdGhpcy5zdGFydFRpbWU7XG4gICAgICB0aGlzLnN0YXJ0VGltZSA9IHRtcDtcbiAgICB9XG4gICAgdGhpcy5pbnRlcnBvbGF0b3IgPSBvYmouaW50ZXJwb2xhdG9yIHx8ICdBQ0NFTEVSQVRFX0RFQ0VMRVJBVEUnO1xuICB9XG5cbiAgZ2V0IHR5cGVTdHJpbmcoKSB7XG4gICAgcmV0dXJuICdibG9jayc7XG4gIH1cblxuICBnZXQgdHlwZUlkUHJlZml4KCkge1xuICAgIHJldHVybiAnYmxvY2snO1xuICB9XG5cbiAgZ2V0IHR5cGVJY29uKCkge1xuICAgIHJldHVybiAnYW5pbWF0aW9uX2Jsb2NrJztcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGF5ZXJJZDogdGhpcy5sYXllcklkLFxuICAgICAgcHJvcGVydHlOYW1lOiB0aGlzLnByb3BlcnR5TmFtZSxcbiAgICAgIGZyb21WYWx1ZTogdmFsdWVUb0pzb25fKHRoaXMuZnJvbVZhbHVlKSxcbiAgICAgIHRvVmFsdWU6IHZhbHVlVG9Kc29uXyh0aGlzLnRvVmFsdWUpLFxuICAgICAgc3RhcnRUaW1lOiB0aGlzLnN0YXJ0VGltZSxcbiAgICAgIGVuZFRpbWU6IHRoaXMuZW5kVGltZSxcbiAgICAgIGludGVycG9sYXRvcjogdGhpcy5pbnRlcnBvbGF0b3IudmFsdWUsXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWx1ZVRvSnNvbl8odmFsKSB7XG4gIGlmICh0eXBlb2YgdmFsID09ICdvYmplY3QnICYmICd0b0pTT04nIGluIHZhbCkge1xuICAgIHJldHVybiB2YWwudG9KU09OKCk7XG4gIH1cblxuICByZXR1cm4gdmFsO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7UHJvcGVydHksIElkUHJvcGVydHksIENvbG9yUHJvcGVydHksIE51bWJlclByb3BlcnR5LCBGcmFjdGlvblByb3BlcnR5fSBmcm9tICcuL3Byb3BlcnRpZXMnO1xuaW1wb3J0IHtCYXNlTGF5ZXJ9IGZyb20gJy4vQmFzZUxheWVyJztcbmltcG9ydCB7TGF5ZXJHcm91cH0gZnJvbSAnLi9MYXllckdyb3VwJztcblxuLyoqXG4gKiBBbiBhcnR3b3JrIGlzIHRoZSByb290IGxheWVyIGdyb3VwIGZvciBhIHZlY3RvciwgZGVmaW5lZCBtb3N0bHkgYnlcbiAqIGEgd2lkdGgsIGhlaWdodCwgYW5kIGl0cyBjaGlsZHJlbi5cbiAqL1xuQFByb3BlcnR5LnJlZ2lzdGVyKFtcbiAgbmV3IElkUHJvcGVydHkoJ2lkJyksXG4gIG5ldyBDb2xvclByb3BlcnR5KCdjYW52YXNDb2xvcicpLFxuICBuZXcgTnVtYmVyUHJvcGVydHkoJ3dpZHRoJywge21pbjo0LCBtYXg6MTAyNCwgaW50ZWdlcjp0cnVlfSksXG4gIG5ldyBOdW1iZXJQcm9wZXJ0eSgnaGVpZ2h0Jywge21pbjo0LCBtYXg6MTAyNCwgaW50ZWdlcjp0cnVlfSksXG4gIG5ldyBGcmFjdGlvblByb3BlcnR5KCdhbHBoYScsIHthbmltYXRhYmxlOiB0cnVlfSksXG5dLCB7cmVzZXQ6dHJ1ZX0pXG5leHBvcnQgY2xhc3MgQXJ0d29yayBleHRlbmRzIExheWVyR3JvdXAge1xuICBjb25zdHJ1Y3RvcihvYmogPSB7fSwgb3B0cyA9IHt9KSB7XG4gICAgc3VwZXIob2JqLCBvcHRzKTtcbiAgICB0aGlzLmlkID0gdGhpcy5pZCB8fCB0aGlzLnR5cGVJZFByZWZpeDtcbiAgICB0aGlzLmNhbnZhc0NvbG9yID0gb2JqLmZpbGxDb2xvciB8fCBudWxsO1xuICAgIHRoaXMud2lkdGggPSBvYmoud2lkdGggfHwgMTAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gb2JqLmhlaWdodCB8fCAxMDA7XG4gICAgdGhpcy5hbHBoYSA9IG9iai5hbHBoYSB8fCAxO1xuICB9XG5cbiAgY29tcHV0ZUJvdW5kcygpIHtcbiAgICByZXR1cm4geyBsOiAwLCB0OiAwLCByOiB0aGlzLndpZHRoLCBiOiB0aGlzLmhlaWdodCB9O1xuICB9XG5cbiAgZ2V0IHR5cGVTdHJpbmcoKSB7XG4gICAgcmV0dXJuICdhcnR3b3JrJztcbiAgfVxuXG4gIGdldCB0eXBlSWRQcmVmaXgoKSB7XG4gICAgcmV0dXJuICd2ZWN0b3InO1xuICB9XG5cbiAgZ2V0IHR5cGVJY29uKCkge1xuICAgIHJldHVybiAnYXJ0d29yayc7XG4gIH1cblxuICBmaW5kTGF5ZXJCeUlkKGlkKSB7XG4gICAgaWYgKHRoaXMuaWQgPT09IGlkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmZpbmRMYXllckJ5SWQoaWQpO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIGNhbnZhc0NvbG9yOiB0aGlzLmNhbnZhc0NvbG9yLFxuICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgYWxwaGE6IHRoaXMuYWxwaGEsXG4gICAgICBsYXllcnM6IHRoaXMubGF5ZXJzLm1hcChsYXllciA9PiBsYXllci50b0pTT04oKSlcbiAgICB9O1xuICB9XG59XG5cbkJhc2VMYXllci5MQVlFUl9DTEFTU0VTX0JZX1RZUEVbJ2FydHdvcmsnXSA9IEFydHdvcms7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtQcm9wZXJ0eSwgSWRQcm9wZXJ0eX0gZnJvbSAnLi9wcm9wZXJ0aWVzJztcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBhbnkgbm9kZSBpbiB0aGUgdHJlZSwgaW5jbHVkaW5nIHBhdGggbGF5ZXJzLCBsYXllciBncm91cHMsIGFuZCBhcnR3b3Jrcy5cbiAqL1xuQFByb3BlcnR5LnJlZ2lzdGVyKFtcbiAgbmV3IElkUHJvcGVydHkoJ2lkJylcbl0pXG5leHBvcnQgY2xhc3MgQmFzZUxheWVyIHtcbiAgY29uc3RydWN0b3Iob2JqID0ge30sIG9wdHMgPSB7fSkge1xuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB0aGlzLmlkID0gb2JqLmlkIHx8IG51bGw7XG4gICAgaWYgKG9wdHMgJiYgb3B0cy5saW5rU2VsZWN0ZWRTdGF0ZSkge1xuICAgICAgdGhpcy5zZWxlY3RlZFN0YXRlTGlua2VkT2JqXyA9IG9iajtcbiAgICB9XG5cbiAgICAvLyBtZXRhXG4gICAgdGhpcy52aXNpYmxlID0gKCd2aXNpYmxlJyBpbiBvYmopID8gb2JqLnZpc2libGUgOiB0cnVlO1xuICAgIHRoaXMuZXhwYW5kZWQgPSB0cnVlO1xuICB9XG5cbiAgZ2V0IHNlbGVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdGVkU3RhdGVMaW5rZWRPYmpfXG4gICAgICAgID8gdGhpcy5zZWxlY3RlZFN0YXRlTGlua2VkT2JqXy5zZWxlY3RlZF9cbiAgICAgICAgOiB0aGlzLnNlbGVjdGVkXztcbiAgfVxuXG4gIGNvbXB1dGVCb3VuZHMoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnZXRTaWJsaW5nXyhvZmZzKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCB8fCAhdGhpcy5wYXJlbnQubGF5ZXJzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgaW5kZXggPSB0aGlzLnBhcmVudC5sYXllcnMuaW5kZXhPZih0aGlzKTtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpbmRleCArPSBvZmZzO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5wYXJlbnQubGF5ZXJzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGFyZW50LmxheWVyc1tpbmRleF07XG4gIH1cblxuICBnZXQgcHJldmlvdXNTaWJsaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmdldFNpYmxpbmdfKC0xKTtcbiAgfVxuXG4gIGdldCBuZXh0U2libGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTaWJsaW5nXygxKTtcbiAgfVxuXG4gIHJlbW92ZSgpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50IHx8ICF0aGlzLnBhcmVudC5sYXllcnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgaW5kZXggPSB0aGlzLnBhcmVudC5sYXllcnMuaW5kZXhPZih0aGlzKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdGhpcy5wYXJlbnQubGF5ZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuXG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICB9XG5cbiAgd2FsayhmbiwgY29udGV4dCkge1xuICAgIGxldCB2aXNpdF8gPSAobGF5ZXIsIGNvbnRleHQpID0+IHtcbiAgICAgIGxldCBjaGlsZENvbnRleHQgPSBmbihsYXllciwgY29udGV4dCk7XG4gICAgICBpZiAobGF5ZXIubGF5ZXJzKSB7XG4gICAgICAgIHdhbGtMYXllckdyb3VwXyhsYXllciwgY2hpbGRDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGV0IHdhbGtMYXllckdyb3VwXyA9IChsYXllckdyb3VwLCBjb250ZXh0KSA9PiB7XG4gICAgICBsYXllckdyb3VwLmxheWVycy5mb3JFYWNoKGxheWVyID0+IHZpc2l0XyhsYXllciwgY29udGV4dCkpO1xuICAgIH07XG5cbiAgICB2aXNpdF8odGhpcywgY29udGV4dCk7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgdHlwZTogdGhpcy50eXBlU3RyaW5nLFxuICAgICAgdmlzaWJsZTogdGhpcy52aXNpYmxlLFxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgbG9hZChvYmogPSB7fSwgb3B0cykge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBCYXNlTGF5ZXIpIHtcbiAgICAgIHJldHVybiBuZXcgb2JqLmNvbnN0cnVjdG9yKG9iaiwgb3B0cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBCYXNlTGF5ZXIuTEFZRVJfQ0xBU1NFU19CWV9UWVBFW29iai50eXBlIHx8ICdwYXRoJ10ob2JqLCBvcHRzKTtcbiAgfVxufVxuXG4vLyBmaWxsZWQgaW4gYnkgZGVyaXZlZCBjbGFzc2VzXG5CYXNlTGF5ZXIuTEFZRVJfQ0xBU1NFU19CWV9UWVBFID0ge307XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtQcm9wZXJ0eSwgTnVtYmVyUHJvcGVydHl9IGZyb20gJy4vcHJvcGVydGllcyc7XG5pbXBvcnQge0Jhc2VMYXllcn0gZnJvbSAnLi9CYXNlTGF5ZXInO1xuXG4vKipcbiAqIEEgZ3JvdXAgKCdmb2xkZXInKSBjb250YWluaW5nIG90aGVyIGxheWVycy5cbiAqL1xuQFByb3BlcnR5LnJlZ2lzdGVyKFtcbiAgbmV3IE51bWJlclByb3BlcnR5KCdyb3RhdGlvbicsIHthbmltYXRhYmxlOiB0cnVlfSksXG4gIG5ldyBOdW1iZXJQcm9wZXJ0eSgnc2NhbGVYJywge2FuaW1hdGFibGU6IHRydWV9KSxcbiAgbmV3IE51bWJlclByb3BlcnR5KCdzY2FsZVknLCB7YW5pbWF0YWJsZTogdHJ1ZX0pLFxuICBuZXcgTnVtYmVyUHJvcGVydHkoJ3Bpdm90WCcsIHthbmltYXRhYmxlOiB0cnVlfSksXG4gIG5ldyBOdW1iZXJQcm9wZXJ0eSgncGl2b3RZJywge2FuaW1hdGFibGU6IHRydWV9KSxcbiAgbmV3IE51bWJlclByb3BlcnR5KCd0cmFuc2xhdGVYJywge2FuaW1hdGFibGU6IHRydWV9KSxcbiAgbmV3IE51bWJlclByb3BlcnR5KCd0cmFuc2xhdGVZJywge2FuaW1hdGFibGU6IHRydWV9KSxcbl0pXG5leHBvcnQgY2xhc3MgTGF5ZXJHcm91cCBleHRlbmRzIEJhc2VMYXllciB7XG4gIGNvbnN0cnVjdG9yKG9iaiA9IHt9LCBvcHRzID0ge30pIHtcbiAgICBzdXBlcihvYmosIG9wdHMpO1xuICAgIHRoaXMubGF5ZXJzID0gKG9iai5sYXllcnMgfHwgW10pLm1hcChvYmogPT4gQmFzZUxheWVyLmxvYWQob2JqLCBvcHRzKSk7XG4gICAgdGhpcy5yb3RhdGlvbiA9IG9iai5yb3RhdGlvbiB8fCAwO1xuICAgIHRoaXMuc2NhbGVYID0gKCdzY2FsZVgnIGluIG9iaikgPyBvYmouc2NhbGVYIDogMTtcbiAgICB0aGlzLnNjYWxlWSA9ICgnc2NhbGVZJyBpbiBvYmopID8gb2JqLnNjYWxlWSA6IDE7XG4gICAgdGhpcy5waXZvdFggPSBvYmoucGl2b3RYIHx8IDA7XG4gICAgdGhpcy5waXZvdFkgPSBvYmoucGl2b3RZIHx8IDA7XG4gICAgdGhpcy50cmFuc2xhdGVYID0gb2JqLnRyYW5zbGF0ZVggfHwgMDtcbiAgICB0aGlzLnRyYW5zbGF0ZVkgPSBvYmoudHJhbnNsYXRlWSB8fCAwO1xuXG4gICAgLy8gbWV0YVxuICAgIHRoaXMuZXhwYW5kZWQgPSAoJ2V4cGFuZGVkJyBpbiBvYmopID8gb2JqLmV4cGFuZGVkIDogdHJ1ZTtcbiAgfVxuXG4gIGNvbXB1dGVCb3VuZHMoKSB7XG4gICAgbGV0IGJvdW5kcyA9IG51bGw7XG4gICAgdGhpcy5sYXllcnMuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICBsZXQgY2hpbGRCb3VuZHMgPSBjaGlsZC5jb21wdXRlQm91bmRzKCk7XG4gICAgICBpZiAoIWNoaWxkQm91bmRzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFib3VuZHMpIHtcbiAgICAgICAgYm91bmRzID0gT2JqZWN0LmFzc2lnbih7fSwgY2hpbGRCb3VuZHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYm91bmRzLmwgPSBNYXRoLm1pbihjaGlsZEJvdW5kcy5sLCBib3VuZHMubCk7XG4gICAgICAgIGJvdW5kcy50ID0gTWF0aC5taW4oY2hpbGRCb3VuZHMudCwgYm91bmRzLnQpO1xuICAgICAgICBib3VuZHMuciA9IE1hdGgubWF4KGNoaWxkQm91bmRzLnIsIGJvdW5kcy5yKTtcbiAgICAgICAgYm91bmRzLmIgPSBNYXRoLm1heChjaGlsZEJvdW5kcy5iLCBib3VuZHMuYik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGJvdW5kcztcbiAgfVxuXG4gIGdldCBsYXllcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMubGF5ZXJzXyB8fCBbXTtcbiAgfVxuXG4gIHNldCBsYXllcnMobGF5ZXJzKSB7XG4gICAgdGhpcy5sYXllcnNfID0gbGF5ZXJzO1xuICAgIHRoaXMubGF5ZXJzXy5mb3JFYWNoKGxheWVyID0+IGxheWVyLnBhcmVudCA9IHRoaXMpO1xuICB9XG5cbiAgZ2V0IHR5cGVTdHJpbmcoKSB7XG4gICAgcmV0dXJuICdncm91cCc7XG4gIH1cblxuICBnZXQgdHlwZUlkUHJlZml4KCkge1xuICAgIHJldHVybiAnZ3JvdXAnO1xuICB9XG5cbiAgZ2V0IHR5cGVJY29uKCkge1xuICAgIHJldHVybiAnbGF5ZXJfZ3JvdXAnO1xuICB9XG5cbiAgZmluZExheWVyQnlJZChpZCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBsYXllciA9IHRoaXMubGF5ZXJzW2ldO1xuICAgICAgaWYgKGxheWVyLmlkID09PSBpZCkge1xuICAgICAgICByZXR1cm4gbGF5ZXI7XG4gICAgICB9IGVsc2UgaWYgKGxheWVyLmZpbmRMYXllckJ5SWQpIHtcbiAgICAgICAgbGF5ZXIgPSBsYXllci5maW5kTGF5ZXJCeUlkKGlkKTtcbiAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgcmV0dXJuIGxheWVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oc3VwZXIudG9KU09OKCksIHtcbiAgICAgIHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLFxuICAgICAgc2NhbGVYOiB0aGlzLnNjYWxlWCxcbiAgICAgIHNjYWxlWTogdGhpcy5zY2FsZVksXG4gICAgICBwaXZvdFg6IHRoaXMucGl2b3RYLFxuICAgICAgcGl2b3RZOiB0aGlzLnBpdm90WSxcbiAgICAgIHRyYW5zbGF0ZVg6IHRoaXMudHJhbnNsYXRlWCxcbiAgICAgIHRyYW5zbGF0ZVk6IHRoaXMudHJhbnNsYXRlWSxcbiAgICAgIGxheWVyczogdGhpcy5sYXllcnMubWFwKGxheWVyID0+IGxheWVyLnRvSlNPTigpKSxcbiAgICAgIGV4cGFuZGVkOiB0aGlzLmV4cGFuZGVkLFxuICAgIH0pO1xuICB9XG59XG5cbkJhc2VMYXllci5MQVlFUl9DTEFTU0VTX0JZX1RZUEVbJ2dyb3VwJ10gPSBMYXllckdyb3VwO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7UHJvcGVydHksIFBhdGhEYXRhUHJvcGVydHl9IGZyb20gJy4vcHJvcGVydGllcyc7XG5pbXBvcnQge0Jhc2VMYXllcn0gZnJvbSAnLi9CYXNlTGF5ZXInO1xuXG4vKipcbiAqIEEgbWFzayBsYXllciAobWFzayBkZWZpbmVkIGJ5IGEgcGF0aCkgdGhhdCBjbGlwcy9tYXNrcyBsYXllcnMgdGhhdCBmb2xsb3cgaXRcbiAqIHdpdGhpbiBpdHMgbGF5ZXIgZ3JvdXAuXG4gKi9cbkBQcm9wZXJ0eS5yZWdpc3RlcihbXG4gIG5ldyBQYXRoRGF0YVByb3BlcnR5KCdwYXRoRGF0YScsIHthbmltYXRhYmxlOiB0cnVlfSksXG5dKVxuZXhwb3J0IGNsYXNzIE1hc2tMYXllciBleHRlbmRzIEJhc2VMYXllciB7XG4gIGNvbnN0cnVjdG9yKG9iaiA9IHt9LCBvcHRzID0ge30pIHtcbiAgICBzdXBlcihvYmosIG9wdHMpO1xuICAgIHRoaXMucGF0aERhdGEgPSBvYmoucGF0aERhdGEgfHwgJyc7XG4gIH1cblxuICBjb21wdXRlQm91bmRzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCAodGhpcy5wYXRoRGF0YSAmJiB0aGlzLnBhdGhEYXRhLmJvdW5kcykgPyB0aGlzLnBhdGhEYXRhLmJvdW5kcyA6IG51bGwpO1xuICB9XG5cbiAgZ2V0IHR5cGVTdHJpbmcoKSB7XG4gICAgcmV0dXJuICdtYXNrJztcbiAgfVxuXG4gIGdldCB0eXBlSWRQcmVmaXgoKSB7XG4gICAgcmV0dXJuICdtYXNrJztcbiAgfVxuXG4gIGdldCB0eXBlSWNvbigpIHtcbiAgICByZXR1cm4gJ21hc2tfbGF5ZXInO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHN1cGVyLnRvSlNPTigpLCB7XG4gICAgICBwYXRoRGF0YTogdGhpcy5wYXRoRGF0YS5wYXRoU3RyaW5nXG4gICAgfSk7XG4gIH1cbn1cblxuQmFzZUxheWVyLkxBWUVSX0NMQVNTRVNfQllfVFlQRVsnbWFzayddID0gTWFza0xheWVyO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7UHJvcGVydHksIFBhdGhEYXRhUHJvcGVydHksIE51bWJlclByb3BlcnR5LCBDb2xvclByb3BlcnR5LFxuICAgICAgICBGcmFjdGlvblByb3BlcnR5LCBFbnVtUHJvcGVydHl9IGZyb20gJy4vcHJvcGVydGllcyc7XG5pbXBvcnQge0Jhc2VMYXllcn0gZnJvbSAnLi9CYXNlTGF5ZXInO1xuXG5leHBvcnQgY29uc3QgRGVmYXVsdFZhbHVlcyA9IHtcbiAgTElORUNBUDogJ2J1dHQnLFxuICBMSU5FSk9JTjogJ21pdGVyJyxcbiAgTUlURVJfTElNSVQ6IDQsXG59O1xuXG5jb25zdCBFTlVNX0xJTkVDQVBfT1BUSU9OUyA9IFtcbiAge3ZhbHVlOiAnYnV0dCcsIGxhYmVsOiAnQnV0dCd9LFxuICB7dmFsdWU6ICdzcXVhcmUnLCBsYWJlbDogJ1NxdWFyZSd9LFxuICB7dmFsdWU6ICdyb3VuZCcsIGxhYmVsOiAnUm91bmQnfSxcbl07XG5cbmNvbnN0IEVOVU1fTElORUpPSU5fT1BUSU9OUyA9IFtcbiAge3ZhbHVlOiAnbWl0ZXInLCBsYWJlbDogJ01pdGVyJ30sXG4gIHt2YWx1ZTogJ3JvdW5kJywgbGFiZWw6ICdSb3VuZCd9LFxuICB7dmFsdWU6ICdiZXZlbCcsIGxhYmVsOiAnQmV2ZWwnfSxcbl07XG5cbi8qKlxuICogQSBwYXRoIGxheWVyLCB3aGljaCBpcyB0aGUgbWFpbiBidWlsZGluZyBibG9jayBmb3IgdmlzaWJsZSBjb250ZW50IGluIGEgdmVjdG9yXG4gKiBhcnR3b3JrLlxuICovXG5AUHJvcGVydHkucmVnaXN0ZXIoW1xuICBuZXcgUGF0aERhdGFQcm9wZXJ0eSgncGF0aERhdGEnLCB7YW5pbWF0YWJsZTogdHJ1ZX0pLFxuICBuZXcgQ29sb3JQcm9wZXJ0eSgnZmlsbENvbG9yJywge2FuaW1hdGFibGU6IHRydWV9KSxcbiAgbmV3IEZyYWN0aW9uUHJvcGVydHkoJ2ZpbGxBbHBoYScsIHthbmltYXRhYmxlOiB0cnVlfSksXG4gIG5ldyBDb2xvclByb3BlcnR5KCdzdHJva2VDb2xvcicsIHthbmltYXRhYmxlOiB0cnVlfSksXG4gIG5ldyBGcmFjdGlvblByb3BlcnR5KCdzdHJva2VBbHBoYScsIHthbmltYXRhYmxlOiB0cnVlfSksXG4gIG5ldyBOdW1iZXJQcm9wZXJ0eSgnc3Ryb2tlV2lkdGgnLCB7bWluOjAsIGFuaW1hdGFibGU6IHRydWV9KSxcbiAgbmV3IEVudW1Qcm9wZXJ0eSgnc3Ryb2tlTGluZWNhcCcsIEVOVU1fTElORUNBUF9PUFRJT05TKSxcbiAgbmV3IEVudW1Qcm9wZXJ0eSgnc3Ryb2tlTGluZWpvaW4nLCBFTlVNX0xJTkVKT0lOX09QVElPTlMpLFxuICBuZXcgTnVtYmVyUHJvcGVydHkoJ3N0cm9rZU1pdGVyTGltaXQnLCB7bWluOjF9KSxcbiAgbmV3IEZyYWN0aW9uUHJvcGVydHkoJ3RyaW1QYXRoU3RhcnQnLCB7YW5pbWF0YWJsZTogdHJ1ZX0pLFxuICBuZXcgRnJhY3Rpb25Qcm9wZXJ0eSgndHJpbVBhdGhFbmQnLCB7YW5pbWF0YWJsZTogdHJ1ZX0pLFxuICBuZXcgRnJhY3Rpb25Qcm9wZXJ0eSgndHJpbVBhdGhPZmZzZXQnLCB7YW5pbWF0YWJsZTogdHJ1ZX0pLFxuXSlcbmV4cG9ydCBjbGFzcyBQYXRoTGF5ZXIgZXh0ZW5kcyBCYXNlTGF5ZXIge1xuICBjb25zdHJ1Y3RvcihvYmogPSB7fSwgb3B0cyA9IHt9KSB7XG4gICAgc3VwZXIob2JqLCBvcHRzKTtcbiAgICB0aGlzLnBhdGhEYXRhID0gb2JqLnBhdGhEYXRhIHx8ICcnO1xuICAgIHRoaXMuZmlsbENvbG9yID0gb2JqLmZpbGxDb2xvciB8fCBudWxsO1xuICAgIHRoaXMuZmlsbEFscGhhID0gKCdmaWxsQWxwaGEnIGluIG9iaikgPyBvYmouZmlsbEFscGhhIDogMTtcbiAgICB0aGlzLnN0cm9rZUNvbG9yID0gb2JqLnN0cm9rZUNvbG9yIHx8ICcnO1xuICAgIHRoaXMuc3Ryb2tlQWxwaGEgPSAoJ3N0cm9rZUFscGhhJyBpbiBvYmopID8gb2JqLnN0cm9rZUFscGhhIDogMTtcbiAgICB0aGlzLnN0cm9rZVdpZHRoID0gb2JqLnN0cm9rZVdpZHRoIHx8IDA7XG4gICAgdGhpcy5zdHJva2VMaW5lY2FwID0gb2JqLnN0cm9rZUxpbmVjYXAgfHwgRGVmYXVsdFZhbHVlcy5MSU5FQ0FQO1xuICAgIHRoaXMuc3Ryb2tlTGluZWpvaW4gPSBvYmouc3Ryb2tlTGluZWpvaW4gfHwgRGVmYXVsdFZhbHVlcy5MSU5FSk9JTjtcbiAgICB0aGlzLnN0cm9rZU1pdGVyTGltaXQgPSBvYmouc3Ryb2tlTWl0ZXJMaW1pdCB8fCBEZWZhdWx0VmFsdWVzLk1JVEVSX0xJTUlUO1xuICAgIHRoaXMudHJpbVBhdGhTdGFydCA9IG9iai50cmltUGF0aFN0YXJ0IHx8IDA7XG4gICAgdGhpcy50cmltUGF0aEVuZCA9ICgndHJpbVBhdGhFbmQnIGluIG9iaiAmJiB0eXBlb2Ygb2JqLnRyaW1QYXRoRW5kID09ICdudW1iZXInKVxuICAgICAgICA/IG9iai50cmltUGF0aEVuZCA6IDE7XG4gICAgdGhpcy50cmltUGF0aE9mZnNldCA9IG9iai50cmltUGF0aE9mZnNldCB8fCAwO1xuICB9XG5cbiAgY29tcHV0ZUJvdW5kcygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgKHRoaXMucGF0aERhdGEgJiYgdGhpcy5wYXRoRGF0YS5ib3VuZHMpID8gdGhpcy5wYXRoRGF0YS5ib3VuZHMgOiBudWxsKTtcbiAgfVxuXG4gIGdldCB0eXBlU3RyaW5nKCkge1xuICAgIHJldHVybiAncGF0aCc7XG4gIH1cblxuICBnZXQgdHlwZUlkUHJlZml4KCkge1xuICAgIHJldHVybiAncGF0aCc7XG4gIH1cblxuICBnZXQgdHlwZUljb24oKSB7XG4gICAgcmV0dXJuICdwYXRoX2xheWVyJztcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihzdXBlci50b0pTT04oKSwge1xuICAgICAgcGF0aERhdGE6IHRoaXMucGF0aERhdGEucGF0aFN0cmluZyxcbiAgICAgIGZpbGxDb2xvcjogdGhpcy5maWxsQ29sb3IsXG4gICAgICBmaWxsQWxwaGE6IHRoaXMuZmlsbEFscGhhLFxuICAgICAgc3Ryb2tlQ29sb3I6IHRoaXMuc3Ryb2tlQ29sb3IsXG4gICAgICBzdHJva2VBbHBoYTogdGhpcy5zdHJva2VBbHBoYSxcbiAgICAgIHN0cm9rZVdpZHRoOiB0aGlzLnN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlTGluZWNhcDogdGhpcy5zdHJva2VMaW5lY2FwLFxuICAgICAgc3Ryb2tlTGluZWpvaW46IHRoaXMuc3Ryb2tlTGluZWpvaW4sXG4gICAgICBzdHJva2VNaXRlckxpbWl0OiB0aGlzLnN0cm9rZU1pdGVyTGltaXQsXG4gICAgICB0cmltUGF0aFN0YXJ0OiB0aGlzLnRyaW1QYXRoU3RhcnQsXG4gICAgICB0cmltUGF0aEVuZDogdGhpcy50cmltUGF0aEVuZCxcbiAgICAgIHRyaW1QYXRoT2Zmc2V0OiB0aGlzLnRyaW1QYXRoT2Zmc2V0XG4gICAgfSk7XG4gIH1cbn1cblxuQmFzZUxheWVyLkxBWUVSX0NMQVNTRVNfQllfVFlQRVsncGF0aCddID0gUGF0aExheWVyO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCB7QW5pbWF0aW9ufSBmcm9tICcuL0FuaW1hdGlvbic7XG5leHBvcnQge0FuaW1hdGlvbkJsb2NrfSBmcm9tICcuL0FuaW1hdGlvbkJsb2NrJztcbmV4cG9ydCB7QXJ0d29ya30gZnJvbSAnLi9BcnR3b3JrJztcbmV4cG9ydCB7QmFzZUxheWVyfSBmcm9tICcuL0Jhc2VMYXllcic7XG5leHBvcnQge0xheWVyR3JvdXB9IGZyb20gJy4vTGF5ZXJHcm91cCc7XG5leHBvcnQge01hc2tMYXllcn0gZnJvbSAnLi9NYXNrTGF5ZXInO1xuZXhwb3J0IHtQYXRoTGF5ZXIsIERlZmF1bHRWYWx1ZXN9IGZyb20gJy4vUGF0aExheWVyJztcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge0NvbG9yVXRpbH0gZnJvbSAnQ29sb3JVdGlsJztcbmltcG9ydCB7TWF0aFV0aWx9IGZyb20gJ01hdGhVdGlsJztcblxuaW1wb3J0IHtQcm9wZXJ0eX0gZnJvbSAnLi9Qcm9wZXJ0eSc7XG5cbmV4cG9ydCBjbGFzcyBDb2xvclByb3BlcnR5IGV4dGVuZHMgUHJvcGVydHkge1xuICBpbnRlcnBvbGF0ZVZhbHVlKHN0YXJ0LCBlbmQsIGYpIHtcbiAgICBzdGFydCA9IENvbG9yVXRpbC5wYXJzZUFuZHJvaWRDb2xvcihzdGFydCk7XG4gICAgZW5kID0gQ29sb3JVdGlsLnBhcnNlQW5kcm9pZENvbG9yKGVuZCk7XG4gICAgcmV0dXJuIENvbG9yVXRpbC50b0FuZHJvaWRTdHJpbmcoe1xuICAgICAgcjogTWF0aFV0aWwuY29uc3RyYWluKE1hdGgucm91bmQoUHJvcGVydHkuc2ltcGxlSW50ZXJwb2xhdGUoc3RhcnQuciwgZW5kLnIsIGYpKSwgMCwgMjU1KSxcbiAgICAgIGc6IE1hdGhVdGlsLmNvbnN0cmFpbihNYXRoLnJvdW5kKFByb3BlcnR5LnNpbXBsZUludGVycG9sYXRlKHN0YXJ0LmcsIGVuZC5nLCBmKSksIDAsIDI1NSksXG4gICAgICBiOiBNYXRoVXRpbC5jb25zdHJhaW4oTWF0aC5yb3VuZChQcm9wZXJ0eS5zaW1wbGVJbnRlcnBvbGF0ZShzdGFydC5iLCBlbmQuYiwgZikpLCAwLCAyNTUpLFxuICAgICAgYTogTWF0aFV0aWwuY29uc3RyYWluKE1hdGgucm91bmQoUHJvcGVydHkuc2ltcGxlSW50ZXJwb2xhdGUoc3RhcnQuYSwgZW5kLmEsIGYpKSwgMCwgMjU1KVxuICAgIH0pO1xuICB9XG5cbiAgdHJ5U2V0RWRpdGVkVmFsdWUob2JqLCBwcm9wZXJ0eU5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgb2JqW3Byb3BlcnR5TmFtZV0gPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBwcm9jZXNzZWRWYWx1ZSA9IENvbG9yVXRpbC5wYXJzZUFuZHJvaWRDb2xvcih2YWx1ZSk7XG4gICAgaWYgKCFwcm9jZXNzZWRWYWx1ZSkge1xuICAgICAgcHJvY2Vzc2VkVmFsdWUgPSBDb2xvclV0aWwucGFyc2VBbmRyb2lkQ29sb3IoQ29sb3JVdGlsLnN2Z1RvQW5kcm9pZENvbG9yKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgb2JqW3Byb3BlcnR5TmFtZV0gPSBDb2xvclV0aWwudG9BbmRyb2lkU3RyaW5nKHByb2Nlc3NlZFZhbHVlKTtcbiAgfVxuXG4gIGdldCBhbmltYXRvclZhbHVlVHlwZSgpIHtcbiAgICByZXR1cm4gJ2NvbG9yVHlwZSc7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1Byb3BlcnR5fSBmcm9tICcuL1Byb3BlcnR5JztcblxuZXhwb3J0IGNsYXNzIEVudW1Qcm9wZXJ0eSBleHRlbmRzIFByb3BlcnR5IHtcbiAgY29uc3RydWN0b3IobmFtZSwgb3B0aW9ucywgY29uZmlnID0ge30pIHtcbiAgICBzdXBlcihuYW1lLCBjb25maWcpO1xuICAgIHRoaXMub3B0aW9uc0J5VmFsdWVfID0ge307XG4gICAgdGhpcy5vcHRpb25zXyA9IChvcHRpb25zIHx8IFtdKS5tYXAob3B0aW9uID0+IHtcbiAgICAgIGxldCBuZXdPcHRpb24gPSB7fTtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICBuZXdPcHRpb24gPSB7XG4gICAgICAgICAgdmFsdWU6IG9wdGlvbixcbiAgICAgICAgICBsYWJlbDogb3B0aW9uXG4gICAgICAgIH07XG4gICAgICAgIG9wdGlvbiA9IG5ld09wdGlvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKCEoJ2xhYmVsJyBpbiBvcHRpb24pKSB7XG4gICAgICAgIG9wdGlvbi5sYWJlbCA9IG9wdGlvbi52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vcHRpb25zQnlWYWx1ZV9bb3B0aW9uLnZhbHVlXSA9IG9wdGlvbjtcbiAgICAgIHJldHVybiBvcHRpb247XG4gICAgfSk7XG5cbiAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgaWYgKGNvbmZpZy5zdG9yZUVudGlyZU9wdGlvbikge1xuICAgICAgdGhpcy5zdG9yZUVudGlyZU9wdGlvbiA9IGNvbmZpZy5zdG9yZUVudGlyZU9wdGlvbjtcbiAgICB9XG4gIH1cblxuICBnZXR0ZXJfKG9iaiwgcHJvcGVydHlOYW1lLCB2YWx1ZSkge1xuICAgIGxldCBiYWNraW5nUHJvcGVydHlOYW1lID0gYCR7cHJvcGVydHlOYW1lfV9gO1xuICAgIHJldHVybiBvYmpbYmFja2luZ1Byb3BlcnR5TmFtZV07XG4gIH1cblxuICBzZXR0ZXJfKG9iaiwgcHJvcGVydHlOYW1lLCB2YWx1ZSkge1xuICAgIGxldCBiYWNraW5nUHJvcGVydHlOYW1lID0gYCR7cHJvcGVydHlOYW1lfV9gO1xuXG4gICAgb2JqW2JhY2tpbmdQcm9wZXJ0eU5hbWVdID0gdGhpcy5zdG9yZUVudGlyZU9wdGlvblxuICAgICAgICA/IHRoaXMuZ2V0T3B0aW9uRm9yVmFsdWVfKHZhbHVlKVxuICAgICAgICA6IHRoaXMuZ2V0T3B0aW9uRm9yVmFsdWVfKHZhbHVlKS52YWx1ZTtcbiAgfVxuXG4gIGdldE9wdGlvbkZvclZhbHVlXyh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zQnlWYWx1ZV9bdmFsdWVdO1xuICAgIH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGlzcGxheVZhbHVlRm9yVmFsdWUodmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uRm9yVmFsdWVfKHZhbHVlKS5sYWJlbDtcbiAgfVxuXG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnNfO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtOdW1iZXJQcm9wZXJ0eX0gZnJvbSAnLi9OdW1iZXJQcm9wZXJ0eSc7XG5cbmV4cG9ydCBjbGFzcyBGcmFjdGlvblByb3BlcnR5IGV4dGVuZHMgTnVtYmVyUHJvcGVydHkge1xuICBjb25zdHJ1Y3RvcihuYW1lLCBjb25maWcgPSB7fSkge1xuICAgIGNvbmZpZy5taW4gPSAwO1xuICAgIGNvbmZpZy5tYXggPSAxO1xuICAgIHN1cGVyKG5hbWUsIGNvbmZpZyk7XG4gIH1cblxuICBnZXQgYW5pbWF0b3JWYWx1ZVR5cGUoKSB7XG4gICAgcmV0dXJuICdmbG9hdFR5cGUnO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtQcm9wZXJ0eX0gZnJvbSAnLi9Qcm9wZXJ0eSc7XG5cbmV4cG9ydCBjbGFzcyBJZFByb3BlcnR5IGV4dGVuZHMgUHJvcGVydHkge1xuICB0cnlTZXRFZGl0ZWRWYWx1ZShvYmosIHByb3BlcnR5TmFtZSwgdmFsdWUpIHtcbiAgICBvYmpbcHJvcGVydHlOYW1lXSA9IElkUHJvcGVydHkuc2FuaXRpemUodmFsdWUpO1xuICB9XG5cbiAgc3RhdGljIHNhbml0aXplKHZhbHVlKSB7XG4gICAgdmFsdWUgPSAodmFsdWUgfHwgJycpXG4gICAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgICAgIC5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbiAgICAgICAgLnJlcGxhY2UoL1tcXHMtXSsvZywgJ18nKVxuICAgICAgICAucmVwbGFjZSgvW15cXHdfXSsvZywgJycpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7UHJvcGVydHl9IGZyb20gJy4vUHJvcGVydHknO1xuXG5leHBvcnQgY2xhc3MgTnVtYmVyUHJvcGVydHkgZXh0ZW5kcyBQcm9wZXJ0eSB7XG4gIGNvbnN0cnVjdG9yKG5hbWUsIGNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIobmFtZSwgY29uZmlnKTtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgfVxuXG4gIHRyeVNldEVkaXRlZFZhbHVlKG9iaiwgcHJvcGVydHlOYW1lLCB2YWx1ZSkge1xuICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICAgIGlmICgnbWluJyBpbiB0aGlzLmNvbmZpZykge1xuICAgICAgICB2YWx1ZSA9IE1hdGgubWF4KHRoaXMuY29uZmlnLm1pbiwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKCdtYXgnIGluIHRoaXMuY29uZmlnKSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5taW4odGhpcy5jb25maWcubWF4LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb25maWcuaW50ZWdlcikge1xuICAgICAgICB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpO1xuICAgICAgfVxuICAgICAgb2JqW3Byb3BlcnR5TmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBkaXNwbGF5VmFsdWVGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gKE51bWJlci5pc0ludGVnZXIodmFsdWUpXG4gICAgICAgICAgICA/IHZhbHVlLnRvU3RyaW5nKClcbiAgICAgICAgICAgIDogTnVtYmVyKHZhbHVlLnRvRml4ZWQoMykpLnRvU3RyaW5nKCkpXG4gICAgICAgICAgLnJlcGxhY2UoLy0vZywgJ1xcdTIyMTInKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgc2V0dGVyXyhvYmosIHByb3BlcnR5TmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICBpZiAoJ21pbicgaW4gdGhpcy5jb25maWcpIHtcbiAgICAgICAgICB2YWx1ZSA9IE1hdGgubWF4KHRoaXMuY29uZmlnLm1pbiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnbWF4JyBpbiB0aGlzLmNvbmZpZykge1xuICAgICAgICAgIHZhbHVlID0gTWF0aC5taW4odGhpcy5jb25maWcubWF4LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmludGVnZXIpIHtcbiAgICAgICAgICB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGJhY2tpbmdQcm9wZXJ0eU5hbWUgPSBgJHtwcm9wZXJ0eU5hbWV9X2A7XG4gICAgb2JqW2JhY2tpbmdQcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG4gIH1cblxuICBpbnRlcnBvbGF0ZVZhbHVlKHN0YXJ0LCBlbmQsIGYpIHtcbiAgICByZXR1cm4gUHJvcGVydHkuc2ltcGxlSW50ZXJwb2xhdGUoc3RhcnQsIGVuZCwgZik7XG4gIH1cblxuICBnZXQgYW5pbWF0b3JWYWx1ZVR5cGUoKSB7XG4gICAgcmV0dXJuICdmbG9hdFR5cGUnO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtTdmdQYXRoRGF0YX0gZnJvbSAnU3ZnUGF0aERhdGEnO1xuXG5pbXBvcnQge1Byb3BlcnR5fSBmcm9tICcuL1Byb3BlcnR5JztcblxuZXhwb3J0IGNsYXNzIFBhdGhEYXRhUHJvcGVydHkgZXh0ZW5kcyBQcm9wZXJ0eSB7XG4gIGludGVycG9sYXRlVmFsdWUoc3RhcnQsIGVuZCwgZikge1xuICAgIHJldHVybiBTdmdQYXRoRGF0YS5pbnRlcnBvbGF0ZShzdGFydCwgZW5kLCBmKTtcbiAgfVxuXG4gIGRpc3BsYXlWYWx1ZUZvclZhbHVlKHZhbCkge1xuICAgIHJldHVybiB2YWwucGF0aFN0cmluZztcbiAgfVxuXG4gIGdldEVkaXRhYmxlVmFsdWUob2JqLCBwcm9wZXJ0eU5hbWUpIHtcbiAgICByZXR1cm4gb2JqW3Byb3BlcnR5TmFtZV0gPyBvYmpbcHJvcGVydHlOYW1lXS5wYXRoU3RyaW5nIDogJyc7XG4gIH1cblxuICB0cnlTZXRFZGl0ZWRWYWx1ZShvYmosIHByb3BlcnR5TmFtZSwgc3RyaW5nVmFsdWUpIHtcbiAgICBvYmpbcHJvcGVydHlOYW1lXSA9IG5ldyBTdmdQYXRoRGF0YShzdHJpbmdWYWx1ZSk7XG4gIH1cblxuICBnZXR0ZXJfKG9iaiwgcHJvcGVydHlOYW1lKSB7XG4gICAgbGV0IGJhY2tpbmdQcm9wZXJ0eU5hbWUgPSBgJHtwcm9wZXJ0eU5hbWV9X2A7XG4gICAgcmV0dXJuIG9ialtiYWNraW5nUHJvcGVydHlOYW1lXTtcbiAgfVxuXG4gIHNldHRlcl8ob2JqLCBwcm9wZXJ0eU5hbWUsIHZhbHVlKSB7XG4gICAgbGV0IGJhY2tpbmdQcm9wZXJ0eU5hbWUgPSBgJHtwcm9wZXJ0eU5hbWV9X2A7XG4gICAgbGV0IHBhdGhEYXRhO1xuICAgIGlmICghdmFsdWUgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdmdQYXRoRGF0YSkge1xuICAgICAgcGF0aERhdGEgPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aERhdGEgPSBuZXcgU3ZnUGF0aERhdGEodmFsdWUpO1xuICAgIH1cblxuICAgIG9ialtiYWNraW5nUHJvcGVydHlOYW1lXSA9IHBhdGhEYXRhO1xuICB9XG5cbiAgY2xvbmVWYWx1ZSh2YWwpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh2YWwpKTtcbiAgfVxuXG4gIGdldCBhbmltYXRvclZhbHVlVHlwZSgpIHtcbiAgICByZXR1cm4gJ3BhdGhUeXBlJztcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBjbGFzcyBQcm9wZXJ0eSB7XG4gIGNvbnN0cnVjdG9yKG5hbWUsIGNvbmZpZyA9IHt9KSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLmFuaW1hdGFibGUgPSBjb25maWcuYW5pbWF0YWJsZTtcbiAgICB0aGlzLmluc3BlY3RhYmxlID0gY29uZmlnLmluc3BlY3RhYmxlO1xuICB9XG5cbiAgaW50ZXJwb2xhdGVWYWx1ZShzdGFydCwgZW5kLCBmKSB7XG4gICAgcmV0dXJuIHN0YXJ0O1xuICB9XG5cbiAgZ2V0RWRpdGFibGVWYWx1ZShvYmosIHByb3BlcnR5TmFtZSkge1xuICAgIHJldHVybiBvYmpbcHJvcGVydHlOYW1lXTtcbiAgfVxuXG4gIHRyeVNldEVkaXRlZFZhbHVlKG9iaiwgcHJvcGVydHlOYW1lLCB2YWx1ZSkge1xuICAgIG9ialtwcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG4gIH1cblxuICBnZXR0ZXJfKG9iaiwgcHJvcGVydHlOYW1lLCB2YWx1ZSkge1xuICAgIGxldCBiYWNraW5nUHJvcGVydHlOYW1lID0gYCR7cHJvcGVydHlOYW1lfV9gO1xuICAgIHJldHVybiBvYmpbYmFja2luZ1Byb3BlcnR5TmFtZV07XG4gIH1cblxuICBzZXR0ZXJfKG9iaiwgcHJvcGVydHlOYW1lLCB2YWx1ZSkge1xuICAgIGxldCBiYWNraW5nUHJvcGVydHlOYW1lID0gYCR7cHJvcGVydHlOYW1lfV9gO1xuICAgIG9ialtiYWNraW5nUHJvcGVydHlOYW1lXSA9IHZhbHVlO1xuICB9XG5cbiAgZGlzcGxheVZhbHVlRm9yVmFsdWUodmFsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGNsb25lVmFsdWUodmFsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIHN0YXRpYyBzaW1wbGVJbnRlcnBvbGF0ZShzdGFydCwgZW5kLCBmKSB7XG4gICAgcmV0dXJuIHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIGY7XG4gIH1cblxuICBzdGF0aWMgcmVnaXN0ZXIocHJvcHMsIHtyZXNldCA9IGZhbHNlfSA9IHt9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNscykge1xuICAgICAgcHJvcHMuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgICAgaWYgKCEocHJvcCBpbnN0YW5jZW9mIFN0dWJQcm9wZXJ0eSkpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xzLnByb3RvdHlwZSwgcHJvcC5uYW1lLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9wLmdldHRlcl8odGhpcywgcHJvcC5uYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgcHJvcC5zZXR0ZXJfKHRoaXMsIHByb3AubmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgbGV0IGFuaW1hdGFibGVQcm9wZXJ0aWVzID0ge307XG4gICAgICBsZXQgaW5zcGVjdGFibGVQcm9wZXJ0aWVzID0ge307XG5cbiAgICAgIGlmICghcmVzZXQpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhbmltYXRhYmxlUHJvcGVydGllcywgY2xzLnByb3RvdHlwZS5hbmltYXRhYmxlUHJvcGVydGllcyk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oaW5zcGVjdGFibGVQcm9wZXJ0aWVzLCBjbHMucHJvdG90eXBlLmluc3BlY3RhYmxlUHJvcGVydGllcyk7XG4gICAgICB9XG5cbiAgICAgIHByb3BzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgIGlmIChwcm9wLmFuaW1hdGFibGUpIHtcbiAgICAgICAgICBhbmltYXRhYmxlUHJvcGVydGllc1twcm9wLm5hbWVdID0gcHJvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcHJvcC5pbnNwZWN0YWJsZSkge1xuICAgICAgICAgIGluc3BlY3RhYmxlUHJvcGVydGllc1twcm9wLm5hbWVdID0gcHJvcDtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbHMucHJvdG90eXBlLCAnYW5pbWF0YWJsZVByb3BlcnRpZXMnLCB7XG4gICAgICAgIGdldDogKCkgPT4gT2JqZWN0LmFzc2lnbih7fSwgYW5pbWF0YWJsZVByb3BlcnRpZXMpXG4gICAgICB9KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNscy5wcm90b3R5cGUsICdpbnNwZWN0YWJsZVByb3BlcnRpZXMnLCB7XG4gICAgICAgIGdldDogKCkgPT4gT2JqZWN0LmFzc2lnbih7fSwgaW5zcGVjdGFibGVQcm9wZXJ0aWVzKVxuICAgICAgfSk7XG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgU3R1YlByb3BlcnR5IGV4dGVuZHMgUHJvcGVydHkge31cblxuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7UHJvcGVydHl9IGZyb20gJy4vUHJvcGVydHknO1xuXG5leHBvcnQgY2xhc3MgU3RyaW5nUHJvcGVydHkgZXh0ZW5kcyBQcm9wZXJ0eSB7XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IHtDb2xvclByb3BlcnR5fSBmcm9tICcuL0NvbG9yUHJvcGVydHknO1xuZXhwb3J0IHtFbnVtUHJvcGVydHl9IGZyb20gJy4vRW51bVByb3BlcnR5JztcbmV4cG9ydCB7RnJhY3Rpb25Qcm9wZXJ0eX0gZnJvbSAnLi9GcmFjdGlvblByb3BlcnR5JztcbmV4cG9ydCB7SWRQcm9wZXJ0eX0gZnJvbSAnLi9JZFByb3BlcnR5JztcbmV4cG9ydCB7TnVtYmVyUHJvcGVydHl9IGZyb20gJy4vTnVtYmVyUHJvcGVydHknO1xuZXhwb3J0IHtQYXRoRGF0YVByb3BlcnR5fSBmcm9tICcuL1BhdGhEYXRhUHJvcGVydHknO1xuZXhwb3J0IHtQcm9wZXJ0eSwgU3R1YlByb3BlcnR5fSBmcm9tICcuL1Byb3BlcnR5JztcbmV4cG9ydCB7U3RyaW5nUHJvcGVydHl9IGZyb20gJy4vU3RyaW5nUHJvcGVydHknO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbm1vZHVsZS5leHBvcnRzLnJvdXRlQ29uZmlnID0gZnVuY3Rpb24oJGxvY2F0aW9uUHJvdmlkZXIsICRyb3V0ZVByb3ZpZGVyKSB7XG4gICRsb2NhdGlvblByb3ZpZGVyLmh0bWw1TW9kZSh0cnVlKTtcblxuICAkcm91dGVQcm92aWRlclxuICAgICAgLm90aGVyd2lzZSh7XG4gICAgICAgIHRlbXBsYXRlVXJsOiAncGFnZXMvc3R1ZGlvL3N0dWRpby5odG1sJ1xuICAgICAgfSk7XG59O1xuXG5PYmplY3QuYXNzaWduKG1vZHVsZS5leHBvcnRzLCB7XG4gIHN0dWRpbzogKCkgPT4gYC9gXG59KTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vY2J1cmdtZXIveG1sc2VyaWFsaXplci9ibG9iL21hc3Rlci9saWIvc2VyaWFsaXplci5qc1xuLy8gT3RoZXIgb3B0aW9ucyBmb3IgcHJldHR5LXByaW50aW5nOlxuLy8gLSBodHRwczovL2dpdGh1Yi5jb20vdHJhdmlzbGVpdGhlYWQveG1sc2VyaWFsaXphdGlvbi1wb2x5ZmlsbFxuLy8gLSBodHRwczovL2dpdGh1Yi5jb20vcHJldHR5ZGlmZi9wcmV0dHlkaWZmL2Jsb2IvbWFzdGVyL2xpYi9tYXJrdXBwcmV0dHkuanNcbi8vIC0gaHR0cHM6Ly9naXRodWIuY29tL3ZraXJ5dWtoaW4vdmtCZWF1dGlmeVxuXG52YXIgcmVtb3ZlSW52YWxpZENoYXJhY3RlcnMgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICAgIC8vIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi94bWwvI05ULUNoYXIgZm9yIHZhbGlkIFhNTCAxLjAgY2hhcmFjdGVyc1xuICAgIHJldHVybiBjb250ZW50LnJlcGxhY2UoL1tcXHgwMC1cXHgwOFxceDBCXFx4MENcXHgwRS1cXHgxRl0vZywgJycpO1xufTtcblxudmFyIHNlcmlhbGl6ZUF0dHJpYnV0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gICAgICAgIC5yZXBsYWNlKC8mL2csICcmYW1wOycpXG4gICAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAgICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgICAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpXG4gICAgICAgIC5yZXBsYWNlKC8nL2csICcmYXBvczsnKTtcbn07XG5cbnZhciBzZXJpYWxpemVUZXh0Q29udGVudCA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgcmV0dXJuIGNvbnRlbnRcbiAgICAgICAgLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAgICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xufTtcblxudmFyIHNlcmlhbGl6ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgdmFyIHZhbHVlID0gYXR0ci52YWx1ZTtcblxuICAgIHJldHVybiBhdHRyLm5hbWUgKyAnPVwiJyArIHNlcmlhbGl6ZUF0dHJpYnV0ZVZhbHVlKHZhbHVlKSArICdcIic7XG59O1xuXG52YXIgZ2V0VGFnTmFtZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIHRhZ05hbWUgPSBub2RlLnRhZ05hbWU7XG5cbiAgICAvLyBBaWQgaW4gc2VyaWFsaXppbmcgb2Ygb3JpZ2luYWwgSFRNTCBkb2N1bWVudHNcbiAgICBpZiAobm9kZS5uYW1lc3BhY2VVUkkgPT09ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJykge1xuICAgICAgICB0YWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGFnTmFtZTtcbn07XG5cbnZhciBzZXJpYWxpemVOYW1lc3BhY2UgPSBmdW5jdGlvbiAobm9kZSwgb3B0aW9ucykge1xuICAgIHZhciBub2RlSGFzWG1sbnNBdHRyID0gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKG5vZGUuYXR0cmlidXRlcyB8fCBub2RlLmF0dHJzLCBmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgcmV0dXJuIGF0dHIubmFtZTtcbiAgICAgICAgfSlcbiAgICAgICAgLmluZGV4T2YoJ3htbG5zJykgPj0gMDtcbiAgICAvLyBTZXJpYWxpemUgdGhlIG5hbWVzcGFjZSBhcyBhbiB4bWxucyBhdHRyaWJ1dGUgd2hlbmV2ZXIgdGhlIGVsZW1lbnRcbiAgICAvLyBkb2Vzbid0IGFscmVhZHkgaGF2ZSBvbmUgYW5kIHRoZSBpbmhlcml0ZWQgbmFtZXNwYWNlIGRvZXMgbm90IG1hdGNoXG4gICAgLy8gdGhlIGVsZW1lbnQncyBuYW1lc3BhY2UuXG4gICAgaWYgKCFub2RlSGFzWG1sbnNBdHRyICYmIG5vZGUubmFtZXNwYWNlVVJJICYmXG4gICAgICAgIChvcHRpb25zLmlzUm9vdE5vZGUvKiB8fFxuICAgICAgICAgbm9kZS5uYW1lc3BhY2VVUkkgIT09IG5vZGUucGFyZW50Tm9kZS5uYW1lc3BhY2VVUkkqLykpIHtcbiAgICAgICAgIHJldHVybiAnIHhtbG5zPVwiJyArIG5vZGUubmFtZXNwYWNlVVJJICsgJ1wiJztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxufTtcblxudmFyIHNlcmlhbGl6ZUNoaWxkcmVuID0gZnVuY3Rpb24gKG5vZGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKG5vZGUuY2hpbGROb2RlcywgZnVuY3Rpb24gKGNoaWxkTm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZVRyZWVUb1hIVE1MKGNoaWxkTm9kZSwgb3B0aW9ucyk7XG4gICAgfSkuam9pbignJyk7XG59O1xuXG52YXIgc2VyaWFsaXplVGFnID0gZnVuY3Rpb24gKG5vZGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgb3V0cHV0ID0gJyc7XG4gICAgaWYgKG9wdGlvbnMuaW5kZW50ICYmIG9wdGlvbnMuX2luZGVudExldmVsKSB7XG4gICAgICAgIG91dHB1dCArPSBBcnJheShvcHRpb25zLl9pbmRlbnRMZXZlbCAqIG9wdGlvbnMuaW5kZW50ICsgMSkuam9pbignICcpO1xuICAgIH1cbiAgICBvdXRwdXQgKz0gJzwnICsgZ2V0VGFnTmFtZShub2RlKTtcbiAgICBvdXRwdXQgKz0gc2VyaWFsaXplTmFtZXNwYWNlKG5vZGUsIG9wdGlvbnMuaXNSb290Tm9kZSk7XG5cbiAgICB2YXIgYXR0cmlidXRlcyA9IG5vZGUuYXR0cmlidXRlcyB8fCBub2RlLmF0dHJzO1xuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoYXR0cmlidXRlcywgZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMubXVsdGlBdHRyaWJ1dGVJbmRlbnQgJiYgYXR0cmlidXRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBvdXRwdXQgKz0gJ1xcbic7XG4gICAgICAgICAgICBvdXRwdXQgKz0gQXJyYXkoKG9wdGlvbnMuX2luZGVudExldmVsIHx8IDApICogb3B0aW9ucy5pbmRlbnQgKyBvcHRpb25zLm11bHRpQXR0cmlidXRlSW5kZW50ICsgMSkuam9pbignICcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0ICs9ICcgJztcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQgKz0gc2VyaWFsaXplQXR0cmlidXRlKGF0dHIpO1xuICAgIH0pO1xuXG4gICAgaWYgKG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG91dHB1dCArPSAnPic7XG4gICAgICAgIGlmIChvcHRpb25zLmluZGVudCkge1xuICAgICAgICAgICAgb3V0cHV0ICs9ICdcXG4nO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMuaXNSb290Tm9kZSA9IGZhbHNlO1xuICAgICAgICBvcHRpb25zLl9pbmRlbnRMZXZlbCA9IChvcHRpb25zLl9pbmRlbnRMZXZlbCB8fCAwKSArIDE7XG4gICAgICAgIG91dHB1dCArPSBzZXJpYWxpemVDaGlsZHJlbihub2RlLCBvcHRpb25zKTtcbiAgICAgICAgLS1vcHRpb25zLl9pbmRlbnRMZXZlbDtcbiAgICAgICAgaWYgKG9wdGlvbnMuaW5kZW50ICYmIG9wdGlvbnMuX2luZGVudExldmVsKSB7XG4gICAgICAgICAgICBvdXRwdXQgKz0gQXJyYXkob3B0aW9ucy5faW5kZW50TGV2ZWwgKiBvcHRpb25zLmluZGVudCArIDEpLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQgKz0gJzwvJyArIGdldFRhZ05hbWUobm9kZSkgKyAnPic7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0ICs9ICcvPic7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmluZGVudCkge1xuICAgICAgICBvdXRwdXQgKz0gJ1xcbic7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG52YXIgc2VyaWFsaXplVGV4dCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIHRleHQgPSBub2RlLm5vZGVWYWx1ZSB8fCBub2RlLnZhbHVlIHx8ICcnO1xuICAgIHJldHVybiBzZXJpYWxpemVUZXh0Q29udGVudCh0ZXh0KTtcbn07XG5cbnZhciBzZXJpYWxpemVDb21tZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gJzwhLS0nICtcbiAgICAgICAgbm9kZS5kYXRhXG4gICAgICAgICAgICAucmVwbGFjZSgvLS9nLCAnJiM0NTsnKSArXG4gICAgICAgICctLT4nO1xufTtcblxudmFyIHNlcmlhbGl6ZUNEQVRBID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gJzwhW0NEQVRBWycgKyBub2RlLm5vZGVWYWx1ZSArICddXT4nO1xufTtcblxudmFyIG5vZGVUcmVlVG9YSFRNTCA9IGZ1bmN0aW9uIChub2RlLCBvcHRpb25zKSB7XG4gICAgaWYgKG5vZGUubm9kZU5hbWUgPT09ICcjZG9jdW1lbnQnIHx8XG4gICAgICAgIG5vZGUubm9kZU5hbWUgPT09ICcjZG9jdW1lbnQtZnJhZ21lbnQnKSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVDaGlsZHJlbihub2RlLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobm9kZS50YWdOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVGFnKG5vZGUsIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUubm9kZU5hbWUgPT09ICcjdGV4dCcpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUZXh0KG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUubm9kZU5hbWUgPT09ICcjY29tbWVudCcpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVDb21tZW50KG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUubm9kZU5hbWUgPT09ICcjY2RhdGEtc2VjdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVDREFUQShub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmV4cG9ydHMuc2VyaWFsaXplVG9TdHJpbmcgPSBmdW5jdGlvbiAobm9kZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMucm9vdE5vZGUgPSB0cnVlO1xuICAgIHJldHVybiByZW1vdmVJbnZhbGlkQ2hhcmFjdGVycyhub2RlVHJlZVRvWEhUTUwobm9kZSwgb3B0aW9ucykpO1xufTtcbiIsIi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dyZS9iZXppZXItZWFzaW5nXG4gKiBCZXppZXJFYXNpbmcgLSB1c2UgYmV6aWVyIGN1cnZlIGZvciB0cmFuc2l0aW9uIGVhc2luZyBmdW5jdGlvblxuICogYnkgR2HDq3RhbiBSZW5hdWRlYXUgMjAxNCAtIDIwMTUg4oCTIE1JVCBMaWNlbnNlXG4gKi9cblxuLy8gVGhlc2UgdmFsdWVzIGFyZSBlc3RhYmxpc2hlZCBieSBlbXBpcmljaXNtIHdpdGggdGVzdHMgKHRyYWRlb2ZmOiBwZXJmb3JtYW5jZSBWUyBwcmVjaXNpb24pXG52YXIgTkVXVE9OX0lURVJBVElPTlMgPSA0O1xudmFyIE5FV1RPTl9NSU5fU0xPUEUgPSAwLjAwMTtcbnZhciBTVUJESVZJU0lPTl9QUkVDSVNJT04gPSAwLjAwMDAwMDE7XG52YXIgU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMgPSAxMDtcblxudmFyIGtTcGxpbmVUYWJsZVNpemUgPSAxMTtcbnZhciBrU2FtcGxlU3RlcFNpemUgPSAxLjAgLyAoa1NwbGluZVRhYmxlU2l6ZSAtIDEuMCk7XG5cbnZhciBmbG9hdDMyQXJyYXlTdXBwb3J0ZWQgPSB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAnZnVuY3Rpb24nO1xuXG5mdW5jdGlvbiBBIChhQTEsIGFBMikgeyByZXR1cm4gMS4wIC0gMy4wICogYUEyICsgMy4wICogYUExOyB9XG5mdW5jdGlvbiBCIChhQTEsIGFBMikgeyByZXR1cm4gMy4wICogYUEyIC0gNi4wICogYUExOyB9XG5mdW5jdGlvbiBDIChhQTEpICAgICAgeyByZXR1cm4gMy4wICogYUExOyB9XG5cbi8vIFJldHVybnMgeCh0KSBnaXZlbiB0LCB4MSwgYW5kIHgyLCBvciB5KHQpIGdpdmVuIHQsIHkxLCBhbmQgeTIuXG5mdW5jdGlvbiBjYWxjQmV6aWVyIChhVCwgYUExLCBhQTIpIHsgcmV0dXJuICgoQShhQTEsIGFBMikgKiBhVCArIEIoYUExLCBhQTIpKSAqIGFUICsgQyhhQTEpKSAqIGFUOyB9XG5cbi8vIFJldHVybnMgZHgvZHQgZ2l2ZW4gdCwgeDEsIGFuZCB4Miwgb3IgZHkvZHQgZ2l2ZW4gdCwgeTEsIGFuZCB5Mi5cbmZ1bmN0aW9uIGdldFNsb3BlIChhVCwgYUExLCBhQTIpIHsgcmV0dXJuIDMuMCAqIEEoYUExLCBhQTIpICogYVQgKiBhVCArIDIuMCAqIEIoYUExLCBhQTIpICogYVQgKyBDKGFBMSk7IH1cblxuZnVuY3Rpb24gYmluYXJ5U3ViZGl2aWRlIChhWCwgYUEsIGFCLCBtWDEsIG1YMikge1xuICB2YXIgY3VycmVudFgsIGN1cnJlbnRULCBpID0gMDtcbiAgZG8ge1xuICAgIGN1cnJlbnRUID0gYUEgKyAoYUIgLSBhQSkgLyAyLjA7XG4gICAgY3VycmVudFggPSBjYWxjQmV6aWVyKGN1cnJlbnRULCBtWDEsIG1YMikgLSBhWDtcbiAgICBpZiAoY3VycmVudFggPiAwLjApIHtcbiAgICAgIGFCID0gY3VycmVudFQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFBID0gY3VycmVudFQ7XG4gICAgfVxuICB9IHdoaWxlIChNYXRoLmFicyhjdXJyZW50WCkgPiBTVUJESVZJU0lPTl9QUkVDSVNJT04gJiYgKytpIDwgU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMpO1xuICByZXR1cm4gY3VycmVudFQ7XG59XG5cbmZ1bmN0aW9uIG5ld3RvblJhcGhzb25JdGVyYXRlIChhWCwgYUd1ZXNzVCwgbVgxLCBtWDIpIHtcbiBmb3IgKHZhciBpID0gMDsgaSA8IE5FV1RPTl9JVEVSQVRJT05TOyArK2kpIHtcbiAgIHZhciBjdXJyZW50U2xvcGUgPSBnZXRTbG9wZShhR3Vlc3NULCBtWDEsIG1YMik7XG4gICBpZiAoY3VycmVudFNsb3BlID09PSAwLjApIHtcbiAgICAgcmV0dXJuIGFHdWVzc1Q7XG4gICB9XG4gICB2YXIgY3VycmVudFggPSBjYWxjQmV6aWVyKGFHdWVzc1QsIG1YMSwgbVgyKSAtIGFYO1xuICAgYUd1ZXNzVCAtPSBjdXJyZW50WCAvIGN1cnJlbnRTbG9wZTtcbiB9XG4gcmV0dXJuIGFHdWVzc1Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmV6aWVyIChtWDEsIG1ZMSwgbVgyLCBtWTIpIHtcbiAgaWYgKCEoMCA8PSBtWDEgJiYgbVgxIDw9IDEgJiYgMCA8PSBtWDIgJiYgbVgyIDw9IDEpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdiZXppZXIgeCB2YWx1ZXMgbXVzdCBiZSBpbiBbMCwgMV0gcmFuZ2UnKTtcbiAgfVxuXG4gIC8vIFByZWNvbXB1dGUgc2FtcGxlcyB0YWJsZVxuICB2YXIgc2FtcGxlVmFsdWVzID0gZmxvYXQzMkFycmF5U3VwcG9ydGVkID8gbmV3IEZsb2F0MzJBcnJheShrU3BsaW5lVGFibGVTaXplKSA6IG5ldyBBcnJheShrU3BsaW5lVGFibGVTaXplKTtcbiAgaWYgKG1YMSAhPT0gbVkxIHx8IG1YMiAhPT0gbVkyKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrU3BsaW5lVGFibGVTaXplOyArK2kpIHtcbiAgICAgIHNhbXBsZVZhbHVlc1tpXSA9IGNhbGNCZXppZXIoaSAqIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFRGb3JYIChhWCkge1xuICAgIHZhciBpbnRlcnZhbFN0YXJ0ID0gMC4wO1xuICAgIHZhciBjdXJyZW50U2FtcGxlID0gMTtcbiAgICB2YXIgbGFzdFNhbXBsZSA9IGtTcGxpbmVUYWJsZVNpemUgLSAxO1xuXG4gICAgZm9yICg7IGN1cnJlbnRTYW1wbGUgIT09IGxhc3RTYW1wbGUgJiYgc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdIDw9IGFYOyArK2N1cnJlbnRTYW1wbGUpIHtcbiAgICAgIGludGVydmFsU3RhcnQgKz0ga1NhbXBsZVN0ZXBTaXplO1xuICAgIH1cbiAgICAtLWN1cnJlbnRTYW1wbGU7XG5cbiAgICAvLyBJbnRlcnBvbGF0ZSB0byBwcm92aWRlIGFuIGluaXRpYWwgZ3Vlc3MgZm9yIHRcbiAgICB2YXIgZGlzdCA9IChhWCAtIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSkgLyAoc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGUgKyAxXSAtIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSk7XG4gICAgdmFyIGd1ZXNzRm9yVCA9IGludGVydmFsU3RhcnQgKyBkaXN0ICoga1NhbXBsZVN0ZXBTaXplO1xuXG4gICAgdmFyIGluaXRpYWxTbG9wZSA9IGdldFNsb3BlKGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuICAgIGlmIChpbml0aWFsU2xvcGUgPj0gTkVXVE9OX01JTl9TTE9QRSkge1xuICAgICAgcmV0dXJuIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBndWVzc0ZvclQsIG1YMSwgbVgyKTtcbiAgICB9IGVsc2UgaWYgKGluaXRpYWxTbG9wZSA9PT0gMC4wKSB7XG4gICAgICByZXR1cm4gZ3Vlc3NGb3JUO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYmluYXJ5U3ViZGl2aWRlKGFYLCBpbnRlcnZhbFN0YXJ0LCBpbnRlcnZhbFN0YXJ0ICsga1NhbXBsZVN0ZXBTaXplLCBtWDEsIG1YMik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIEJlemllckVhc2luZyAoeCkge1xuICAgIGlmIChtWDEgPT09IG1ZMSAmJiBtWDIgPT09IG1ZMikge1xuICAgICAgcmV0dXJuIHg7IC8vIGxpbmVhclxuICAgIH1cbiAgICAvLyBCZWNhdXNlIEphdmFTY3JpcHQgbnVtYmVyIGFyZSBpbXByZWNpc2UsIHdlIHNob3VsZCBndWFyYW50ZWUgdGhlIGV4dHJlbWVzIGFyZSByaWdodC5cbiAgICBpZiAoeCA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmICh4ID09PSAxKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGNCZXppZXIoZ2V0VEZvclgoeCksIG1ZMSwgbVkyKTtcbiAgfTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2JlemllcicpO1xuIiwiLyoqXG4gIEEgamF2YXNjcmlwdCBCZXppZXIgY3VydmUgbGlicmFyeSBieSBQb21heC5cblxuICBCYXNlZCBvbiBodHRwOi8vcG9tYXguZ2l0aHViLmlvL2JlemllcmluZm9cblxuICBUaGlzIGNvZGUgaXMgTUlUIGxpY2Vuc2VkLlxuKiovXG4oZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIC8vIG1hdGgtaW5saW5pbmcuXG4gIHZhciBhYnMgPSBNYXRoLmFicyxcbiAgICAgIG1pbiA9IE1hdGgubWluLFxuICAgICAgbWF4ID0gTWF0aC5tYXgsXG4gICAgICBhY29zID0gTWF0aC5hY29zLFxuICAgICAgc3FydCA9IE1hdGguc3FydCxcbiAgICAgIHBpID0gTWF0aC5QSSxcbiAgICAgIC8vIGEgemVybyBjb29yZGluYXRlLCB3aGljaCBpcyBzdXJwcmlzaW5nbHkgdXNlZnVsXG4gICAgICBaRVJPID0ge3g6MCx5OjAsejowfTtcblxuICAvLyBxdWl0ZSBuZWVkZWRcbiAgdmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscy5qcycpO1xuXG4gIC8vIG5vdCBxdWl0ZSBuZWVkZWQsIGJ1dCBldmVudHVhbGx5IHRoaXMnbGwgYmUgdXNlZnVsLi4uXG4gIHZhciBQb2x5QmV6aWVyID0gcmVxdWlyZSgnLi9wb2x5LWJlemllci5qcycpO1xuXG4gIC8qKlxuICAgKiBCZXppZXIgY3VydmUgY29uc3RydWN0b3IuIFRoZSBjb25zdHJ1Y3RvciBhcmd1bWVudCBjYW4gYmUgb25lIG9mIHRocmVlIHRoaW5nczpcbiAgICpcbiAgICogMS4gYXJyYXkvNCBvZiB7eDouLi4sIHk6Li4uLCB6Oi4uLn0sIHogb3B0aW9uYWxcbiAgICogMi4gbnVtZXJpY2FsIGFycmF5Lzggb3JkZXJlZCB4MSx5MSx4Mix5Mix4Myx5Myx4NCx5NFxuICAgKiAzLiBudW1lcmljYWwgYXJyYXkvMTIgb3JkZXJlZCB4MSx5MSx6MSx4Mix5Mix6Mix4Myx5Myx6Myx4NCx5NCx6NFxuICAgKlxuICAgKi9cbiAgdmFyIEJlemllciA9IGZ1bmN0aW9uKGNvb3Jkcykge1xuICAgIHZhciBhcmdzID0gKGNvb3JkcyAmJiBjb29yZHMuZm9yRWFjaCkgPyBjb29yZHMgOiBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgdmFyIGNvb3JkbGVuID0gZmFsc2U7XG4gICAgaWYodHlwZW9mIGFyZ3NbMF0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvb3JkbGVuID0gYXJncy5sZW5ndGg7XG4gICAgICB2YXIgbmV3YXJncyA9IFtdO1xuICAgICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIFsneCcsJ3knLCd6J10uZm9yRWFjaChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgaWYodHlwZW9mIHBvaW50W2RdICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBuZXdhcmdzLnB1c2gocG9pbnRbZF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGFyZ3MgPSBuZXdhcmdzO1xuICAgIH1cbiAgICB2YXIgaGlnaGVyID0gZmFsc2U7XG4gICAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICAgIGlmIChjb29yZGxlbikge1xuICAgICAgaWYoY29vcmRsZW4+NCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9ubHkgbmV3IEJlemllcihwb2ludFtdKSBpcyBhY2NlcHRlZCBmb3IgNHRoIGFuZCBoaWdoZXIgb3JkZXIgY3VydmVzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGhpZ2hlciA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKGxlbiE9PTYgJiYgbGVuIT09OCAmJiBsZW4hPT05ICYmIGxlbiE9PTEyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSBuZXcgQmV6aWVyKHBvaW50W10pIGlzIGFjY2VwdGVkIGZvciA0dGggYW5kIGhpZ2hlciBvcmRlciBjdXJ2ZXNcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIF8zZCA9ICghaGlnaGVyICYmIChsZW4gPT09IDkgfHwgbGVuID09PSAxMikpIHx8IChjb29yZHMgJiYgY29vcmRzWzBdICYmIHR5cGVvZiBjb29yZHNbMF0ueiAhPT0gXCJ1bmRlZmluZWRcIik7XG4gICAgdGhpcy5fM2QgPSBfM2Q7XG4gICAgdmFyIHBvaW50cyA9IFtdO1xuICAgIGZvcih2YXIgaWR4PTAsIHN0ZXA9KF8zZCA/IDMgOiAyKTsgaWR4PGxlbjsgaWR4Kz1zdGVwKSB7XG4gICAgICB2YXIgcG9pbnQgPSB7XG4gICAgICAgIHg6IGFyZ3NbaWR4XSxcbiAgICAgICAgeTogYXJnc1tpZHgrMV1cbiAgICAgIH07XG4gICAgICBpZihfM2QpIHsgcG9pbnQueiA9IGFyZ3NbaWR4KzJdIH07XG4gICAgICBwb2ludHMucHVzaChwb2ludCk7XG4gICAgfVxuICAgIHRoaXMub3JkZXIgPSBwb2ludHMubGVuZ3RoIC0gMTtcbiAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcbiAgICB2YXIgZGltcyA9IFsneCcsJ3knXTtcbiAgICBpZihfM2QpIGRpbXMucHVzaCgneicpO1xuICAgIHRoaXMuZGltcyA9IGRpbXM7XG4gICAgdGhpcy5kaW1sZW4gPSBkaW1zLmxlbmd0aDtcblxuICAgIChmdW5jdGlvbihjdXJ2ZSkge1xuICAgICAgdmFyIG9yZGVyID0gY3VydmUub3JkZXI7XG4gICAgICB2YXIgcG9pbnRzID0gY3VydmUucG9pbnRzO1xuICAgICAgdmFyIGEgPSB1dGlscy5hbGlnbihwb2ludHMsIHtwMTpwb2ludHNbMF0sIHAyOnBvaW50c1tvcmRlcl19KTtcbiAgICAgIGZvcih2YXIgaT0wOyBpPGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYoYWJzKGFbaV0ueSkgPiAwLjAwMDEpIHtcbiAgICAgICAgICBjdXJ2ZS5fbGluZWFyID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdXJ2ZS5fbGluZWFyID0gdHJ1ZTtcbiAgICB9KHRoaXMpKTtcblxuICAgIHRoaXMuX3QxID0gMDtcbiAgICB0aGlzLl90MiA9IDE7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfTtcblxuICBCZXppZXIuZnJvbVNWRyA9IGZ1bmN0aW9uKHN2Z1N0cmluZykge1xuICAgIHZhciBsaXN0ID0gc3ZnU3RyaW5nLm1hdGNoKC9bLStdP1xcZCpcXC4/XFxkKyg/OltlRV1bLStdP1xcZCspPy9nKS5tYXAocGFyc2VGbG9hdCk7XG4gICAgdmFyIHJlbGF0aXZlID0gL1tjcV0vLnRlc3Qoc3ZnU3RyaW5nKTtcbiAgICBpZighcmVsYXRpdmUpIHJldHVybiBuZXcgQmV6aWVyKGxpc3QpO1xuICAgIGxpc3QgPSBsaXN0Lm1hcChmdW5jdGlvbih2LGkpIHtcbiAgICAgIHJldHVybiBpIDwgMiA/IHYgOiB2ICsgbGlzdFtpICUgMl07XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBCZXppZXIobGlzdCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0QUJDKG4sUyxCLEUsdCkge1xuICAgIGlmKHR5cGVvZiB0ID09PSBcInVuZGVmaW5lZFwiKSB7IHQgPSAwLjU7IH1cbiAgICB2YXIgdSA9IHV0aWxzLnByb2plY3Rpb25yYXRpbyh0LG4pLFxuICAgICAgICB1bSA9IDEtdSxcbiAgICAgICAgQyA9IHtcbiAgICAgICAgICB4OiB1KlMueCArIHVtKkUueCxcbiAgICAgICAgICB5OiB1KlMueSArIHVtKkUueVxuICAgICAgICB9LFxuICAgICAgICBzID0gdXRpbHMuYWJjcmF0aW8odCxuKSxcbiAgICAgICAgQSA9IHtcbiAgICAgICAgICB4OiBCLnggKyAoQi54LUMueCkvcyxcbiAgICAgICAgICB5OiBCLnkgKyAoQi55LUMueSkvc1xuICAgICAgICB9O1xuICAgIHJldHVybiB7IEE6QSwgQjpCLCBDOkMgfTtcbiAgfVxuXG4gIEJlemllci5xdWFkcmF0aWNGcm9tUG9pbnRzID0gZnVuY3Rpb24ocDEscDIscDMsIHQpIHtcbiAgICBpZih0eXBlb2YgdCA9PT0gXCJ1bmRlZmluZWRcIikgeyB0ID0gMC41OyB9XG4gICAgLy8gc2hvcnRjdXRzLCBhbHRob3VnaCB0aGV5J3JlIHJlYWxseSBkdW1iXG4gICAgaWYodD09PTApIHsgcmV0dXJuIG5ldyBCZXppZXIocDIscDIscDMpOyB9XG4gICAgaWYodD09PTEpIHsgcmV0dXJuIG5ldyBCZXppZXIocDEscDIscDIpOyB9XG4gICAgLy8gcmVhbCBmaXR0aW5nLlxuICAgIHZhciBhYmMgPSBnZXRBQkMoMixwMSxwMixwMyx0KTtcbiAgICByZXR1cm4gbmV3IEJlemllcihwMSwgYWJjLkEsIHAzKTtcbiAgfTtcblxuICBCZXppZXIuY3ViaWNGcm9tUG9pbnRzID0gZnVuY3Rpb24oUyxCLEUsIHQsZDEpIHtcbiAgICBpZih0eXBlb2YgdCA9PT0gXCJ1bmRlZmluZWRcIikgeyB0ID0gMC41OyB9XG4gICAgdmFyIGFiYyA9IGdldEFCQygzLFMsQixFLHQpO1xuICAgIGlmKHR5cGVvZiBkMSA9PT0gXCJ1bmRlZmluZWRcIikgeyBkMSA9IHV0aWxzLmRpc3QoQixhYmMuQyk7IH1cbiAgICB2YXIgZDIgPSBkMSAqICgxLXQpL3Q7XG5cbiAgICB2YXIgc2VsZW4gPSB1dGlscy5kaXN0KFMsRSksXG4gICAgICAgIGx4ID0gKEUueC1TLngpL3NlbGVuLFxuICAgICAgICBseSA9IChFLnktUy55KS9zZWxlbixcbiAgICAgICAgYngxID0gZDEgKiBseCxcbiAgICAgICAgYnkxID0gZDEgKiBseSxcbiAgICAgICAgYngyID0gZDIgKiBseCxcbiAgICAgICAgYnkyID0gZDIgKiBseTtcbiAgICAvLyBkZXJpdmF0aW9uIG9mIG5ldyBodWxsIGNvb3JkaW5hdGVzXG4gICAgdmFyIGUxICA9IHsgeDogQi54IC0gYngxLCB5OiBCLnkgLSBieTEgfSxcbiAgICAgICAgZTIgID0geyB4OiBCLnggKyBieDIsIHk6IEIueSArIGJ5MiB9LFxuICAgICAgICBBID0gYWJjLkEsXG4gICAgICAgIHYxICA9IHsgeDogQS54ICsgKGUxLngtQS54KS8oMS10KSwgeTogQS55ICsgKGUxLnktQS55KS8oMS10KSB9LFxuICAgICAgICB2MiAgPSB7IHg6IEEueCArIChlMi54LUEueCkvKHQpLCB5OiBBLnkgKyAoZTIueS1BLnkpLyh0KSB9LFxuICAgICAgICBuYzEgPSB7IHg6IFMueCArICh2MS54LVMueCkvKHQpLCB5OiBTLnkgKyAodjEueS1TLnkpLyh0KSB9LFxuICAgICAgICBuYzIgPSB7IHg6IEUueCArICh2Mi54LUUueCkvKDEtdCksIHk6IEUueSArICh2Mi55LUUueSkvKDEtdCkgfTtcbiAgICAvLyAuLi5kb25lXG4gICAgcmV0dXJuIG5ldyBCZXppZXIoUyxuYzEsbmMyLEUpO1xuICB9O1xuXG4gIHZhciBnZXRVdGlscyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB1dGlscztcbiAgfTtcblxuICBCZXppZXIuZ2V0VXRpbHMgPSBnZXRVdGlscztcblxuICBCZXppZXIucHJvdG90eXBlID0ge1xuICAgIGdldFV0aWxzOiBnZXRVdGlscyxcbiAgICB2YWx1ZU9mOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gICAgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdXRpbHMucG9pbnRzVG9TdHJpbmcodGhpcy5wb2ludHMpO1xuICAgIH0sXG4gICAgdG9TVkc6IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gICAgICBpZih0aGlzLl8zZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIHAgPSB0aGlzLnBvaW50cyxcbiAgICAgICAgICB4ID0gcFswXS54LFxuICAgICAgICAgIHkgPSBwWzBdLnksXG4gICAgICAgICAgcyA9IFtcIk1cIiwgeCwgeSwgKHRoaXMub3JkZXI9PT0yID8gXCJRXCI6XCJDXCIpXTtcbiAgICAgIGZvcih2YXIgaT0xLCBsYXN0PXAubGVuZ3RoOyBpPGxhc3Q7IGkrKykge1xuICAgICAgICBzLnB1c2gocFtpXS54KTtcbiAgICAgICAgcy5wdXNoKHBbaV0ueSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcy5qb2luKFwiIFwiKTtcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBvbmUtdGltZSBjb21wdXRlIGRlcml2YXRpdmUgY29vcmRpbmF0ZXNcbiAgICAgIHRoaXMuZHBvaW50cyA9IFtdO1xuICAgICAgZm9yKHZhciBwPXRoaXMucG9pbnRzLCBkPXAubGVuZ3RoLCBjPWQtMTsgZD4xOyBkLS0sIGMtLSkge1xuICAgICAgICB2YXIgbGlzdCA9IFtdO1xuICAgICAgICBmb3IodmFyIGo9MCwgZHB0OyBqPGM7IGorKykge1xuICAgICAgICAgIGRwdCA9IHtcbiAgICAgICAgICAgIHg6IGMgKiAocFtqKzFdLnggLSBwW2pdLngpLFxuICAgICAgICAgICAgeTogYyAqIChwW2orMV0ueSAtIHBbal0ueSlcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmKHRoaXMuXzNkKSB7XG4gICAgICAgICAgICBkcHQueiA9IGMgKiAocFtqKzFdLnogLSBwW2pdLnopO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsaXN0LnB1c2goZHB0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRwb2ludHMucHVzaChsaXN0KTtcbiAgICAgICAgcCA9IGxpc3Q7XG4gICAgICB9O1xuICAgICAgdGhpcy5jb21wdXRlZGlyZWN0aW9uKCk7XG4gICAgfSxcbiAgICBjb21wdXRlZGlyZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICAgIHZhciBhbmdsZSA9IHV0aWxzLmFuZ2xlKHBvaW50c1swXSwgcG9pbnRzW3RoaXMub3JkZXJdLCBwb2ludHNbMV0pO1xuICAgICAgdGhpcy5jbG9ja3dpc2UgPSBhbmdsZSA+IDA7XG4gICAgfSxcbiAgICBsZW5ndGg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHV0aWxzLmxlbmd0aCh0aGlzLmRlcml2YXRpdmUuYmluZCh0aGlzKSk7XG4gICAgfSxcbiAgICBfbHV0OiBbXSxcbiAgICBnZXRMVVQ6IGZ1bmN0aW9uKHN0ZXBzKSB7XG4gICAgICBzdGVwcyA9IHN0ZXBzIHx8IDEwMDtcbiAgICAgIGlmICh0aGlzLl9sdXQubGVuZ3RoID09PSBzdGVwcykgeyByZXR1cm4gdGhpcy5fbHV0OyB9XG4gICAgICB0aGlzLl9sdXQgPSBbXTtcbiAgICAgIGZvcih2YXIgdD0wOyB0PD1zdGVwczsgdCsrKSB7XG4gICAgICAgIHRoaXMuX2x1dC5wdXNoKHRoaXMuY29tcHV0ZSh0L3N0ZXBzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fbHV0O1xuICAgIH0sXG4gICAgb246IGZ1bmN0aW9uKHBvaW50LCBlcnJvcikge1xuICAgICAgZXJyb3IgPSBlcnJvciB8fCA1O1xuICAgICAgdmFyIGx1dCA9IHRoaXMuZ2V0TFVUKCksIGhpdHMgPSBbXSwgYywgdD0wO1xuICAgICAgZm9yKHZhciBpPTA7IGk8bHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGMgPSBsdXRbaV07XG4gICAgICAgIGlmICh1dGlscy5kaXN0KGMscG9pbnQpIDwgZXJyb3IpIHtcbiAgICAgICAgICBoaXRzLnB1c2goYylcbiAgICAgICAgICB0ICs9IGkgLyBsdXQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZighaGl0cy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0IC89IGhpdHMubGVuZ3RoO1xuICAgIH0sXG4gICAgcHJvamVjdDogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgIC8vIHN0ZXAgMTogY29hcnNlIGNoZWNrXG4gICAgICB2YXIgTFVUID0gdGhpcy5nZXRMVVQoKSwgbCA9IExVVC5sZW5ndGgtMSxcbiAgICAgICAgICBjbG9zZXN0ID0gdXRpbHMuY2xvc2VzdChMVVQsIHBvaW50KSxcbiAgICAgICAgICBtZGlzdCA9IGNsb3Nlc3QubWRpc3QsXG4gICAgICAgICAgbXBvcyA9IGNsb3Nlc3QubXBvcztcbiAgICAgIGlmIChtcG9zPT09MCB8fCBtcG9zPT09bCkge1xuICAgICAgICB2YXIgdCA9IG1wb3MvbCwgcHQgPSB0aGlzLmNvbXB1dGUodCk7XG4gICAgICAgIHB0LnQgPSB0O1xuICAgICAgICBwdC5kID0gbWRpc3Q7XG4gICAgICAgIHJldHVybiBwdDtcbiAgICAgIH1cblxuICAgICAgLy8gc3RlcCAyOiBmaW5lIGNoZWNrXG4gICAgICB2YXIgZnQsIHQsIHAsIGQsXG4gICAgICAgICAgdDEgPSAobXBvcy0xKS9sLFxuICAgICAgICAgIHQyID0gKG1wb3MrMSkvbCxcbiAgICAgICAgICBzdGVwID0gMC4xL2w7XG4gICAgICBtZGlzdCArPSAxO1xuICAgICAgZm9yKHQ9dDEsZnQ9dDsgdDx0MitzdGVwOyB0Kz1zdGVwKSB7XG4gICAgICAgIHAgPSB0aGlzLmNvbXB1dGUodCk7XG4gICAgICAgIGQgPSB1dGlscy5kaXN0KHBvaW50LCBwKTtcbiAgICAgICAgaWYgKGQ8bWRpc3QpIHtcbiAgICAgICAgICBtZGlzdCA9IGQ7XG4gICAgICAgICAgZnQgPSB0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwID0gdGhpcy5jb21wdXRlKGZ0KTtcbiAgICAgIHAudCA9IGZ0O1xuICAgICAgcC5kID0gbWRpc3Q7XG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZSh0KTtcbiAgICB9LFxuICAgIHBvaW50OiBmdW5jdGlvbihpZHgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBvaW50c1tpZHhdO1xuICAgIH0sXG4gICAgY29tcHV0ZTogZnVuY3Rpb24odCkge1xuICAgICAgLy8gc2hvcnRjdXRzXG4gICAgICBpZih0PT09MCkgeyByZXR1cm4gdGhpcy5wb2ludHNbMF07IH1cbiAgICAgIGlmKHQ9PT0xKSB7IHJldHVybiB0aGlzLnBvaW50c1t0aGlzLm9yZGVyXTsgfVxuXG4gICAgICB2YXIgcCA9IHRoaXMucG9pbnRzO1xuICAgICAgdmFyIG10ID0gMS10O1xuXG4gICAgICAvLyBsaW5lYXI/XG4gICAgICBpZih0aGlzLm9yZGVyPT09MSkge1xuICAgICAgICByZXQgPSB7XG4gICAgICAgICAgeDogbXQqcFswXS54ICsgdCpwWzFdLngsXG4gICAgICAgICAgeTogbXQqcFswXS55ICsgdCpwWzFdLnlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuXzNkKSB7IHJldC56ID0gbXQqcFswXS56ICsgdCpwWzFdLno7IH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cblxuICAgICAgLy8gcXVhZHJhdGljL2N1YmljIGN1cnZlP1xuICAgICAgaWYodGhpcy5vcmRlcjw0KSB7XG4gICAgICAgIHZhciBtdDIgPSBtdCptdCxcbiAgICAgICAgICAgIHQyID0gdCp0LFxuICAgICAgICAgICAgYSxiLGMsZCA9IDA7XG4gICAgICAgIGlmKHRoaXMub3JkZXI9PT0yKSB7XG4gICAgICAgICAgcCA9IFtwWzBdLCBwWzFdLCBwWzJdLCBaRVJPXTtcbiAgICAgICAgICBhID0gbXQyO1xuICAgICAgICAgIGIgPSBtdCp0KjI7XG4gICAgICAgICAgYyA9IHQyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYodGhpcy5vcmRlcj09PTMpIHtcbiAgICAgICAgICBhID0gbXQyKm10O1xuICAgICAgICAgIGIgPSBtdDIqdCozO1xuICAgICAgICAgIGMgPSBtdCp0MiozO1xuICAgICAgICAgIGQgPSB0KnQyO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXQgPSB7XG4gICAgICAgICAgeDogYSpwWzBdLnggKyBiKnBbMV0ueCArIGMqcFsyXS54ICsgZCpwWzNdLngsXG4gICAgICAgICAgeTogYSpwWzBdLnkgKyBiKnBbMV0ueSArIGMqcFsyXS55ICsgZCpwWzNdLnlcbiAgICAgICAgfTtcbiAgICAgICAgaWYodGhpcy5fM2QpIHtcbiAgICAgICAgICByZXQueiA9IGEqcFswXS56ICsgYipwWzFdLnogKyBjKnBbMl0ueiArIGQqcFszXS56O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG5cbiAgICAgIC8vIGhpZ2hlciBvcmRlciBjdXJ2ZXM6IHVzZSBkZSBDYXN0ZWxqYXUncyBjb21wdXRhdGlvblxuICAgICAgdmFyIGRDcHRzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLnBvaW50cykpO1xuICAgICAgd2hpbGUoZENwdHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpPTA7IGk8ZENwdHMubGVuZ3RoLTE7IGkrKykge1xuICAgICAgICAgIGRDcHRzW2ldID0ge1xuICAgICAgICAgICAgeDogZENwdHNbaV0ueCArIChkQ3B0c1tpKzFdLnggLSBkQ3B0c1tpXS54KSAqIHQsXG4gICAgICAgICAgICB5OiBkQ3B0c1tpXS55ICsgKGRDcHRzW2krMV0ueSAtIGRDcHRzW2ldLnkpICogdFxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKHR5cGVvZiBkQ3B0c1tpXS56ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBkQ3B0c1tpXSA9IGRDcHRzW2ldLnogKyAoZENwdHNbaSsxXS56IC0gZENwdHNbaV0ueikgKiB0XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRDcHRzLnNwbGljZShkQ3B0cy5sZW5ndGgtMSwgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZENwdHNbMF07XG4gICAgfSxcbiAgICByYWlzZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcCA9IHRoaXMucG9pbnRzLCBucCA9IFtwWzBdXSwgaSwgaz1wLmxlbmd0aCwgcGksIHBpbTtcbiAgICAgIGZvciAodmFyIGk9MTsgaTxrOyBpKyspIHtcbiAgICAgICAgcGkgPSBwW2ldO1xuICAgICAgICBwaW0gPSBwW2ktMV07XG4gICAgICAgIG5wW2ldID0ge1xuICAgICAgICAgIHg6IChrLWkpL2sgKiBwaS54ICsgaS9rICogcGltLngsXG4gICAgICAgICAgeTogKGstaSkvayAqIHBpLnkgKyBpL2sgKiBwaW0ueVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgbnBba10gPSBwW2stMV07XG4gICAgICByZXR1cm4gbmV3IEJlemllcihucCk7XG4gICAgfSxcbiAgICBkZXJpdmF0aXZlOiBmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgbXQgPSAxLXQsXG4gICAgICAgICAgYSxiLGM9MCxcbiAgICAgICAgICBwID0gdGhpcy5kcG9pbnRzWzBdO1xuICAgICAgaWYodGhpcy5vcmRlcj09PTIpIHsgcCA9IFtwWzBdLCBwWzFdLCBaRVJPXTsgYSA9IG10OyBiID0gdDsgfVxuICAgICAgaWYodGhpcy5vcmRlcj09PTMpIHsgYSA9IG10Km10OyBiID0gbXQqdCoyOyBjID0gdCp0OyB9XG4gICAgICB2YXIgcmV0ID0ge1xuICAgICAgICB4OiBhKnBbMF0ueCArIGIqcFsxXS54ICsgYypwWzJdLngsXG4gICAgICAgIHk6IGEqcFswXS55ICsgYipwWzFdLnkgKyBjKnBbMl0ueVxuICAgICAgfTtcbiAgICAgIGlmKHRoaXMuXzNkKSB7XG4gICAgICAgIHJldC56ID0gYSpwWzBdLnogKyBiKnBbMV0ueiArIGMqcFsyXS56O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuICAgIGluZmxlY3Rpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB1dGlscy5pbmZsZWN0aW9ucyh0aGlzLnBvaW50cyk7XG4gICAgfSxcbiAgICBub3JtYWw6IGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl8zZCA/IHRoaXMuX19ub3JtYWwzKHQpIDogdGhpcy5fX25vcm1hbDIodCk7XG4gICAgfSxcbiAgICBfX25vcm1hbDI6IGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBkID0gdGhpcy5kZXJpdmF0aXZlKHQpO1xuICAgICAgdmFyIHEgPSBzcXJ0KGQueCpkLnggKyBkLnkqZC55KVxuICAgICAgcmV0dXJuIHsgeDogLWQueS9xLCB5OiBkLngvcSB9O1xuICAgIH0sXG4gICAgX19ub3JtYWwzOiBmdW5jdGlvbih0KSB7XG4gICAgICAvLyBzZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNTQ1MzE1OVxuICAgICAgdmFyIHIxID0gdGhpcy5kZXJpdmF0aXZlKHQpLFxuICAgICAgICAgIHIyID0gdGhpcy5kZXJpdmF0aXZlKHQrMC4wMSksXG4gICAgICAgICAgcTEgPSBzcXJ0KHIxLngqcjEueCArIHIxLnkqcjEueSArIHIxLnoqcjEueiksXG4gICAgICAgICAgcTIgPSBzcXJ0KHIyLngqcjIueCArIHIyLnkqcjIueSArIHIyLnoqcjIueik7XG4gICAgICByMS54IC89IHExOyByMS55IC89IHExOyByMS56IC89IHExO1xuICAgICAgcjIueCAvPSBxMjsgcjIueSAvPSBxMjsgcjIueiAvPSBxMjtcbiAgICAgIC8vIGNyb3NzIHByb2R1Y3RcbiAgICAgIHZhciBjID0ge1xuICAgICAgICB4OiByMi55KnIxLnogLSByMi56KnIxLnksXG4gICAgICAgIHk6IHIyLnoqcjEueCAtIHIyLngqcjEueixcbiAgICAgICAgejogcjIueCpyMS55IC0gcjIueSpyMS54XG4gICAgICB9O1xuICAgICAgdmFyIG0gPSBzcXJ0KGMueCpjLnggKyBjLnkqYy55ICsgYy56KmMueik7XG4gICAgICBjLnggLz0gbTsgYy55IC89IG07IGMueiAvPSBtO1xuICAgICAgLy8gcm90YXRpb24gbWF0cml4XG4gICAgICB2YXIgUiA9IFsgICBjLngqYy54LCAgIGMueCpjLnktYy56LCBjLngqYy56K2MueSxcbiAgICAgICAgICAgICAgICBjLngqYy55K2MueiwgICBjLnkqYy55LCAgIGMueSpjLnotYy54LFxuICAgICAgICAgICAgICAgIGMueCpjLnotYy55LCBjLnkqYy56K2MueCwgICBjLnoqYy56ICAgIF07XG4gICAgICAvLyBub3JtYWwgdmVjdG9yOlxuICAgICAgdmFyIG4gPSB7XG4gICAgICAgIHg6IFJbMF0gKiByMS54ICsgUlsxXSAqIHIxLnkgKyBSWzJdICogcjEueixcbiAgICAgICAgeTogUlszXSAqIHIxLnggKyBSWzRdICogcjEueSArIFJbNV0gKiByMS56LFxuICAgICAgICB6OiBSWzZdICogcjEueCArIFJbN10gKiByMS55ICsgUls4XSAqIHIxLnpcbiAgICAgIH07XG4gICAgICByZXR1cm4gbjtcbiAgICB9LFxuICAgIGh1bGw6IGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBwID0gdGhpcy5wb2ludHMsXG4gICAgICAgICAgX3AgPSBbXSxcbiAgICAgICAgICBwdCxcbiAgICAgICAgICBxID0gW10sXG4gICAgICAgICAgaWR4ID0gMCxcbiAgICAgICAgICBpPTAsXG4gICAgICAgICAgbD0wO1xuICAgICAgcVtpZHgrK10gPSBwWzBdO1xuICAgICAgcVtpZHgrK10gPSBwWzFdO1xuICAgICAgcVtpZHgrK10gPSBwWzJdO1xuICAgICAgaWYodGhpcy5vcmRlciA9PT0gMykgeyBxW2lkeCsrXSA9IHBbM107IH1cbiAgICAgIC8vIHdlIGxlcnAgYmV0d2VlbiBhbGwgcG9pbnRzIGF0IGVhY2ggaXRlcmF0aW9uLCB1bnRpbCB3ZSBoYXZlIDEgcG9pbnQgbGVmdC5cbiAgICAgIHdoaWxlKHAubGVuZ3RoPjEpIHtcbiAgICAgICAgX3AgPSBbXTtcbiAgICAgICAgZm9yKGk9MCwgbD1wLmxlbmd0aC0xOyBpPGw7IGkrKykge1xuICAgICAgICAgIHB0ID0gdXRpbHMubGVycCh0LHBbaV0scFtpKzFdKTtcbiAgICAgICAgICBxW2lkeCsrXSA9IHB0O1xuICAgICAgICAgIF9wLnB1c2gocHQpO1xuICAgICAgICB9XG4gICAgICAgIHAgPSBfcDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBxO1xuICAgIH0sXG4gICAgc3BsaXQ6IGZ1bmN0aW9uKHQxLCB0Mikge1xuICAgICAgLy8gc2hvcnRjdXRzXG4gICAgICBpZih0MT09PTAgJiYgISF0MikgeyByZXR1cm4gdGhpcy5zcGxpdCh0MikubGVmdDsgfVxuICAgICAgaWYodDI9PT0xKSB7IHJldHVybiB0aGlzLnNwbGl0KHQxKS5yaWdodDsgfVxuXG4gICAgICAvLyBubyBzaG9ydGN1dDogdXNlIFwiZGUgQ2FzdGVsamF1XCIgaXRlcmF0aW9uLlxuICAgICAgdmFyIHEgPSB0aGlzLmh1bGwodDEpO1xuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgbGVmdDogdGhpcy5vcmRlciA9PT0gMiA/IG5ldyBCZXppZXIoW3FbMF0scVszXSxxWzVdXSkgOiBuZXcgQmV6aWVyKFtxWzBdLHFbNF0scVs3XSxxWzldXSksXG4gICAgICAgIHJpZ2h0OiB0aGlzLm9yZGVyID09PSAyID8gbmV3IEJlemllcihbcVs1XSxxWzRdLHFbMl1dKSA6IG5ldyBCZXppZXIoW3FbOV0scVs4XSxxWzZdLHFbM11dKSxcbiAgICAgICAgc3BhbjogcVxuICAgICAgfTtcblxuICAgICAgLy8gbWFrZSBzdXJlIHdlIGJpbmQgX3QxL190MiBpbmZvcm1hdGlvbiFcbiAgICAgIHJlc3VsdC5sZWZ0Ll90MSAgPSB1dGlscy5tYXAoMCwgIDAsMSwgdGhpcy5fdDEsdGhpcy5fdDIpO1xuICAgICAgcmVzdWx0LmxlZnQuX3QyICA9IHV0aWxzLm1hcCh0MSwgMCwxLCB0aGlzLl90MSx0aGlzLl90Mik7XG4gICAgICByZXN1bHQucmlnaHQuX3QxID0gdXRpbHMubWFwKHQxLCAwLDEsIHRoaXMuX3QxLHRoaXMuX3QyKTtcbiAgICAgIHJlc3VsdC5yaWdodC5fdDIgPSB1dGlscy5tYXAoMSwgIDAsMSwgdGhpcy5fdDEsdGhpcy5fdDIpO1xuXG4gICAgICAvLyBpZiB3ZSBoYXZlIG5vIHQyLCB3ZSdyZSBkb25lXG4gICAgICBpZighdDIpIHsgcmV0dXJuIHJlc3VsdDsgfVxuXG4gICAgICAvLyBpZiB3ZSBoYXZlIGEgdDIsIHNwbGl0IGFnYWluOlxuICAgICAgdDIgPSB1dGlscy5tYXAodDIsdDEsMSwwLDEpO1xuICAgICAgdmFyIHN1YnNwbGl0ID0gcmVzdWx0LnJpZ2h0LnNwbGl0KHQyKTtcbiAgICAgIHJldHVybiBzdWJzcGxpdC5sZWZ0O1xuICAgIH0sXG4gICAgZXh0cmVtYTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGltcyA9IHRoaXMuZGltcyxcbiAgICAgICAgICByZXN1bHQ9e30sXG4gICAgICAgICAgcm9vdHM9W10sXG4gICAgICAgICAgcCwgbWZuO1xuICAgICAgZGltcy5mb3JFYWNoKGZ1bmN0aW9uKGRpbSkge1xuICAgICAgICBtZm4gPSBmdW5jdGlvbih2KSB7IHJldHVybiB2W2RpbV07IH07XG4gICAgICAgIHAgPSB0aGlzLmRwb2ludHNbMF0ubWFwKG1mbik7XG4gICAgICAgIHJlc3VsdFtkaW1dID0gdXRpbHMuZHJvb3RzKHApO1xuICAgICAgICBpZih0aGlzLm9yZGVyID09PSAzKSB7XG4gICAgICAgICAgcCA9IHRoaXMuZHBvaW50c1sxXS5tYXAobWZuKTtcbiAgICAgICAgICByZXN1bHRbZGltXSA9IHJlc3VsdFtkaW1dLmNvbmNhdCh1dGlscy5kcm9vdHMocCkpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtkaW1dID0gcmVzdWx0W2RpbV0uZmlsdGVyKGZ1bmN0aW9uKHQpIHsgcmV0dXJuICh0Pj0wICYmIHQ8PTEpOyB9KTtcbiAgICAgICAgcm9vdHMgPSByb290cy5jb25jYXQocmVzdWx0W2RpbV0uc29ydCgpKTtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICByb290cyA9IHJvb3RzLnNvcnQoKS5maWx0ZXIoZnVuY3Rpb24odixpZHgpIHsgcmV0dXJuIChyb290cy5pbmRleE9mKHYpID09PSBpZHgpOyB9KTtcbiAgICAgIHJlc3VsdC52YWx1ZXMgPSByb290cztcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICBiYm94OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBleHRyZW1hID0gdGhpcy5leHRyZW1hKCksIHJlc3VsdCA9IHt9O1xuICAgICAgdGhpcy5kaW1zLmZvckVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgICByZXN1bHRbZF0gPSB1dGlscy5nZXRtaW5tYXgodGhpcywgZCwgZXh0cmVtYVtkXSk7XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIG92ZXJsYXBzOiBmdW5jdGlvbihjdXJ2ZSkge1xuICAgICAgdmFyIGxiYm94ID0gdGhpcy5iYm94KCksXG4gICAgICAgICAgdGJib3ggPSBjdXJ2ZS5iYm94KCk7XG4gICAgICByZXR1cm4gdXRpbHMuYmJveG92ZXJsYXAobGJib3gsdGJib3gpO1xuICAgIH0sXG4gICAgb2Zmc2V0OiBmdW5jdGlvbih0LCBkKSB7XG4gICAgICBpZih0eXBlb2YgZCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB2YXIgYyA9IHRoaXMuZ2V0KHQpO1xuICAgICAgICB2YXIgbiA9IHRoaXMubm9ybWFsKHQpO1xuICAgICAgICB2YXIgcmV0ID0ge1xuICAgICAgICAgIGM6IGMsXG4gICAgICAgICAgbjogbixcbiAgICAgICAgICB4OiBjLnggKyBuLnggKiBkLFxuICAgICAgICAgIHk6IGMueSArIG4ueSAqIGRcbiAgICAgICAgfTtcbiAgICAgICAgaWYodGhpcy5fM2QpIHtcbiAgICAgICAgICByZXQueiA9IGMueiArIG4ueiAqIGQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgICBpZih0aGlzLl9saW5lYXIpIHtcbiAgICAgICAgdmFyIG52ID0gdGhpcy5ub3JtYWwoMCk7XG4gICAgICAgIHZhciBjb29yZHMgPSB0aGlzLnBvaW50cy5tYXAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgIHZhciByZXQgPSB7XG4gICAgICAgICAgICB4OiBwLnggKyB0ICogbnYueCxcbiAgICAgICAgICAgIHk6IHAueSArIHQgKiBudi55XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZihwLnogJiYgbi56KSB7IHJldC56ID0gcC56ICsgdCAqIG52Lno7IH1cbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFtuZXcgQmV6aWVyKGNvb3JkcyldO1xuICAgICAgfVxuICAgICAgdmFyIHJlZHVjZWQgPSB0aGlzLnJlZHVjZSgpO1xuICAgICAgcmV0dXJuIHJlZHVjZWQubWFwKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHMuc2NhbGUodCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHNpbXBsZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZih0aGlzLm9yZGVyPT09Mykge1xuICAgICAgICB2YXIgYTEgPSB1dGlscy5hbmdsZSh0aGlzLnBvaW50c1swXSwgdGhpcy5wb2ludHNbM10sIHRoaXMucG9pbnRzWzFdKTtcbiAgICAgICAgdmFyIGEyID0gdXRpbHMuYW5nbGUodGhpcy5wb2ludHNbMF0sIHRoaXMucG9pbnRzWzNdLCB0aGlzLnBvaW50c1syXSk7XG4gICAgICAgIGlmKGExPjAgJiYgYTI8MCB8fCBhMTwwICYmIGEyPjApIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBuMSA9IHRoaXMubm9ybWFsKDApO1xuICAgICAgdmFyIG4yID0gdGhpcy5ub3JtYWwoMSk7XG4gICAgICB2YXIgcyA9IG4xLngqbjIueCArIG4xLnkqbjIueTtcbiAgICAgIGlmKHRoaXMuXzNkKSB7IHMgKz0gbjEueipuMi56OyB9XG4gICAgICB2YXIgYW5nbGUgPSBhYnMoYWNvcyhzKSk7XG4gICAgICByZXR1cm4gYW5nbGUgPCBwaS8zO1xuICAgIH0sXG4gICAgcmVkdWNlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpLCB0MT0wLCB0Mj0wLCBzdGVwPTAuMDEsIHNlZ21lbnQsIHBhc3MxPVtdLCBwYXNzMj1bXTtcbiAgICAgIC8vIGZpcnN0IHBhc3M6IHNwbGl0IG9uIGV4dHJlbWFcbiAgICAgIHZhciBleHRyZW1hID0gdGhpcy5leHRyZW1hKCkudmFsdWVzO1xuICAgICAgaWYoZXh0cmVtYS5pbmRleE9mKDApPT09LTEpIHsgZXh0cmVtYSA9IFswXS5jb25jYXQoZXh0cmVtYSk7IH1cbiAgICAgIGlmKGV4dHJlbWEuaW5kZXhPZigxKT09PS0xKSB7IGV4dHJlbWEucHVzaCgxKTsgfVxuXG4gICAgICBmb3IodDE9ZXh0cmVtYVswXSwgaT0xOyBpPGV4dHJlbWEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdDIgPSBleHRyZW1hW2ldO1xuICAgICAgICBzZWdtZW50ID0gdGhpcy5zcGxpdCh0MSx0Mik7XG4gICAgICAgIHNlZ21lbnQuX3QxID0gdDE7XG4gICAgICAgIHNlZ21lbnQuX3QyID0gdDI7XG4gICAgICAgIHBhc3MxLnB1c2goc2VnbWVudCk7XG4gICAgICAgIHQxID0gdDI7XG4gICAgICB9XG5cbiAgICAgIC8vIHNlY29uZCBwYXNzOiBmdXJ0aGVyIHJlZHVjZSB0aGVzZSBzZWdtZW50cyB0byBzaW1wbGUgc2VnbWVudHNcbiAgICAgIHBhc3MxLmZvckVhY2goZnVuY3Rpb24ocDEpIHtcbiAgICAgICAgdDE9MDtcbiAgICAgICAgdDI9MDtcbiAgICAgICAgd2hpbGUodDIgPD0gMSkge1xuICAgICAgICAgIGZvcih0Mj10MStzdGVwOyB0Mjw9MStzdGVwOyB0Mis9c3RlcCkge1xuICAgICAgICAgICAgc2VnbWVudCA9IHAxLnNwbGl0KHQxLHQyKTtcbiAgICAgICAgICAgIGlmKCFzZWdtZW50LnNpbXBsZSgpKSB7XG4gICAgICAgICAgICAgIHQyIC09IHN0ZXA7XG4gICAgICAgICAgICAgIGlmKGFicyh0MS10Mik8c3RlcCkge1xuICAgICAgICAgICAgICAgIC8vIHdlIGNhbiBuZXZlciBmb3JtIGEgcmVkdWN0aW9uXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNlZ21lbnQgPSBwMS5zcGxpdCh0MSx0Mik7XG4gICAgICAgICAgICAgIHNlZ21lbnQuX3QxID0gdXRpbHMubWFwKHQxLDAsMSxwMS5fdDEscDEuX3QyKTtcbiAgICAgICAgICAgICAgc2VnbWVudC5fdDIgPSB1dGlscy5tYXAodDIsMCwxLHAxLl90MSxwMS5fdDIpO1xuICAgICAgICAgICAgICBwYXNzMi5wdXNoKHNlZ21lbnQpO1xuICAgICAgICAgICAgICB0MSA9IHQyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYodDE8MSkge1xuICAgICAgICAgIHNlZ21lbnQgPSBwMS5zcGxpdCh0MSwxKTtcbiAgICAgICAgICBzZWdtZW50Ll90MSA9IHV0aWxzLm1hcCh0MSwwLDEscDEuX3QxLHAxLl90Mik7XG4gICAgICAgICAgc2VnbWVudC5fdDIgPSBwMS5fdDI7XG4gICAgICAgICAgcGFzczIucHVzaChzZWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcGFzczI7XG4gICAgfSxcbiAgICBzY2FsZTogZnVuY3Rpb24oZCkge1xuICAgICAgdmFyIG9yZGVyID0gdGhpcy5vcmRlcjtcbiAgICAgIHZhciBkaXN0YW5jZUZuID0gZmFsc2VcbiAgICAgIGlmKHR5cGVvZiBkID09PSBcImZ1bmN0aW9uXCIpIHsgZGlzdGFuY2VGbiA9IGQ7IH1cbiAgICAgIGlmKGRpc3RhbmNlRm4gJiYgb3JkZXIgPT09IDIpIHsgcmV0dXJuIHRoaXMucmFpc2UoKS5zY2FsZShkaXN0YW5jZUZuKTsgfVxuXG4gICAgICAvLyBUT0RPOiBhZGQgc3BlY2lhbCBoYW5kbGluZyBmb3IgZGVnZW5lcmF0ZSAoPWxpbmVhcikgY3VydmVzLlxuICAgICAgdmFyIGNsb2Nrd2lzZSA9IHRoaXMuY2xvY2t3aXNlO1xuICAgICAgdmFyIHIxID0gZGlzdGFuY2VGbiA/IGRpc3RhbmNlRm4oMCkgOiBkO1xuICAgICAgdmFyIHIyID0gZGlzdGFuY2VGbiA/IGRpc3RhbmNlRm4oMSkgOiBkO1xuICAgICAgdmFyIHYgPSBbIHRoaXMub2Zmc2V0KDAsMTApLCB0aGlzLm9mZnNldCgxLDEwKSBdO1xuICAgICAgdmFyIG8gPSB1dGlscy5sbGk0KHZbMF0sIHZbMF0uYywgdlsxXSwgdlsxXS5jKTtcbiAgICAgIGlmKCFvKSB7IHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBzY2FsZSB0aGlzIGN1cnZlLiBUcnkgcmVkdWNpbmcgaXQgZmlyc3QuXCIpOyB9XG4gICAgICAvLyBtb3ZlIGFsbCBwb2ludHMgYnkgZGlzdGFuY2UgJ2QnIHdydCB0aGUgb3JpZ2luICdvJ1xuICAgICAgdmFyIHBvaW50cz10aGlzLnBvaW50cywgbnA9W107XG5cbiAgICAgIC8vIG1vdmUgZW5kIHBvaW50cyBieSBmaXhlZCBkaXN0YW5jZSBhbG9uZyBub3JtYWwuXG4gICAgICBbMCwxXS5mb3JFYWNoKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdmFyIHAgPSBucFt0Km9yZGVyXSA9IHV0aWxzLmNvcHkocG9pbnRzW3Qqb3JkZXJdKTtcbiAgICAgICAgcC54ICs9ICh0P3IyOnIxKSAqIHZbdF0ubi54O1xuICAgICAgICBwLnkgKz0gKHQ/cjI6cjEpICogdlt0XS5uLnk7XG4gICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICBpZiAoIWRpc3RhbmNlRm4pIHtcbiAgICAgICAgLy8gbW92ZSBjb250cm9sIHBvaW50cyB0byBsaWUgb24gdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgb2Zmc2V0XG4gICAgICAgIC8vIGRlcml2YXRpdmUgdmVjdG9yLCBhbmQgdGhlIG9yaWdpbi10aHJvdWdoLWNvbnRyb2wgdmVjdG9yXG4gICAgICAgIFswLDFdLmZvckVhY2goZnVuY3Rpb24odCkge1xuICAgICAgICAgIGlmKHRoaXMub3JkZXI9PT0yICYmICEhdCkgcmV0dXJuO1xuICAgICAgICAgIHZhciBwID0gbnBbdCpvcmRlcl07XG4gICAgICAgICAgdmFyIGQgPSB0aGlzLmRlcml2YXRpdmUodCk7XG4gICAgICAgICAgdmFyIHAyID0geyB4OiBwLnggKyBkLngsIHk6IHAueSArIGQueSB9O1xuICAgICAgICAgIG5wW3QrMV0gPSB1dGlscy5sbGk0KHAsIHAyLCBvLCBwb2ludHNbdCsxXSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIHJldHVybiBuZXcgQmV6aWVyKG5wKTtcbiAgICAgIH1cblxuICAgICAgLy8gbW92ZSBjb250cm9sIHBvaW50cyBieSBcImhvd2V2ZXIgbXVjaCBuZWNlc3NhcnkgdG9cbiAgICAgIC8vIGVuc3VyZSB0aGUgY29ycmVjdCB0YW5nZW50IHRvIGVuZHBvaW50XCIuXG4gICAgICBbMCwxXS5mb3JFYWNoKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgaWYodGhpcy5vcmRlcj09PTIgJiYgISF0KSByZXR1cm47XG4gICAgICAgIHZhciBwID0gcG9pbnRzW3QrMV07XG4gICAgICAgIHZhciBvdiA9IHtcbiAgICAgICAgICB4OiBwLnggLSBvLngsXG4gICAgICAgICAgeTogcC55IC0gby55XG4gICAgICAgIH07XG4gICAgICAgIHZhciByYyA9IGRpc3RhbmNlRm4gPyBkaXN0YW5jZUZuKCh0KzEpL29yZGVyKSA6IGQ7XG4gICAgICAgIGlmKGRpc3RhbmNlRm4gJiYgIWNsb2Nrd2lzZSkgcmMgPSAtcmM7XG4gICAgICAgIHZhciBtID0gc3FydChvdi54Km92LnggKyBvdi55Km92LnkpO1xuICAgICAgICBvdi54IC89IG07XG4gICAgICAgIG92LnkgLz0gbTtcbiAgICAgICAgbnBbdCsxXSA9IHtcbiAgICAgICAgICB4OiBwLnggKyByYypvdi54LFxuICAgICAgICAgIHk6IHAueSArIHJjKm92LnlcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgIHJldHVybiBuZXcgQmV6aWVyKG5wKTtcbiAgICB9LFxuICAgIG91dGxpbmU6IGZ1bmN0aW9uKGQxLCBkMiwgZDMsIGQ0KSB7XG4gICAgICBkMiA9ICh0eXBlb2YgZDIgPT09IFwidW5kZWZpbmVkXCIpID8gZDEgOiBkMjtcbiAgICAgIHZhciByZWR1Y2VkID0gdGhpcy5yZWR1Y2UoKSxcbiAgICAgICAgICBsZW4gPSByZWR1Y2VkLmxlbmd0aCxcbiAgICAgICAgICBmY3VydmVzID0gW10sXG4gICAgICAgICAgYmN1cnZlcyA9IFtdLFxuICAgICAgICAgIHAsXG4gICAgICAgICAgYWxlbiA9IDAsXG4gICAgICAgICAgdGxlbiA9IHRoaXMubGVuZ3RoKCk7XG5cbiAgICAgIHZhciBncmFkdWF0ZWQgPSAodHlwZW9mIGQzICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBkNCAhPT0gXCJ1bmRlZmluZWRcIik7XG5cbiAgICAgIGZ1bmN0aW9uIGxpbmVhckRpc3RhbmNlRnVuY3Rpb24ocyxlLCB0bGVuLGFsZW4sc2xlbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICB2YXIgZjEgPSBhbGVuL3RsZW4sIGYyID0gKGFsZW4rc2xlbikvdGxlbiwgZCA9IGUtcztcbiAgICAgICAgICByZXR1cm4gdXRpbHMubWFwKHYsIDAsMSwgcytmMSpkLCBzK2YyKmQpO1xuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgLy8gZm9ybSBjdXJ2ZSBvdWxpbmVzXG4gICAgICByZWR1Y2VkLmZvckVhY2goZnVuY3Rpb24oc2VnbWVudCkge1xuICAgICAgICBzbGVuID0gc2VnbWVudC5sZW5ndGgoKTtcbiAgICAgICAgaWYgKGdyYWR1YXRlZCkge1xuICAgICAgICAgIGZjdXJ2ZXMucHVzaChzZWdtZW50LnNjYWxlKCAgbGluZWFyRGlzdGFuY2VGdW5jdGlvbiggZDEsIGQzLCB0bGVuLGFsZW4sc2xlbikgICkpO1xuICAgICAgICAgIGJjdXJ2ZXMucHVzaChzZWdtZW50LnNjYWxlKCAgbGluZWFyRGlzdGFuY2VGdW5jdGlvbigtZDIsLWQ0LCB0bGVuLGFsZW4sc2xlbikgICkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZjdXJ2ZXMucHVzaChzZWdtZW50LnNjYWxlKCBkMSkpO1xuICAgICAgICAgIGJjdXJ2ZXMucHVzaChzZWdtZW50LnNjYWxlKC1kMikpO1xuICAgICAgICB9XG4gICAgICAgIGFsZW4gKz0gc2xlbjtcbiAgICAgIH0pO1xuXG4gICAgICAvLyByZXZlcnNlIHRoZSBcInJldHVyblwiIG91dGxpbmVcbiAgICAgIGJjdXJ2ZXMgPSBiY3VydmVzLm1hcChmdW5jdGlvbihzKSB7XG4gICAgICAgIHAgPSBzLnBvaW50cztcbiAgICAgICAgaWYocFszXSkgeyBzLnBvaW50cyA9IFtwWzNdLHBbMl0scFsxXSxwWzBdXTsgfVxuICAgICAgICBlbHNlIHsgcy5wb2ludHMgPSBbcFsyXSxwWzFdLHBbMF1dOyB9XG4gICAgICAgIHJldHVybiBzO1xuICAgICAgfSkucmV2ZXJzZSgpO1xuXG4gICAgICAvLyBmb3JtIHRoZSBlbmRjYXBzIGFzIGxpbmVzXG4gICAgICB2YXIgZnMgPSBmY3VydmVzWzBdLnBvaW50c1swXSxcbiAgICAgICAgICBmZSA9IGZjdXJ2ZXNbbGVuLTFdLnBvaW50c1tmY3VydmVzW2xlbi0xXS5wb2ludHMubGVuZ3RoLTFdLFxuICAgICAgICAgIGJzID0gYmN1cnZlc1tsZW4tMV0ucG9pbnRzW2JjdXJ2ZXNbbGVuLTFdLnBvaW50cy5sZW5ndGgtMV0sXG4gICAgICAgICAgYmUgPSBiY3VydmVzWzBdLnBvaW50c1swXSxcbiAgICAgICAgICBscyA9IHV0aWxzLm1ha2VsaW5lKGJzLGZzKSxcbiAgICAgICAgICBsZSA9IHV0aWxzLm1ha2VsaW5lKGZlLGJlKSxcbiAgICAgICAgICBzZWdtZW50cyA9IFtsc10uY29uY2F0KGZjdXJ2ZXMpLmNvbmNhdChbbGVdKS5jb25jYXQoYmN1cnZlcyksXG4gICAgICAgICAgc2xlbiA9IHNlZ21lbnRzLmxlbmd0aDtcblxuICAgICAgcmV0dXJuIG5ldyBQb2x5QmV6aWVyKHNlZ21lbnRzKTtcbiAgICB9LFxuICAgIG91dGxpbmVzaGFwZXM6IGZ1bmN0aW9uKGQxLCBkMiwgY3VydmVJbnRlcnNlY3Rpb25UaHJlc2hvbGQpIHtcbiAgICAgIGQyID0gZDIgfHwgZDE7XG4gICAgICB2YXIgb3V0bGluZSA9IHRoaXMub3V0bGluZShkMSxkMikuY3VydmVzO1xuICAgICAgdmFyIHNoYXBlcyA9IFtdO1xuICAgICAgZm9yKHZhciBpPTEsIGxlbj1vdXRsaW5lLmxlbmd0aDsgaSA8IGxlbi8yOyBpKyspIHtcbiAgICAgICAgdmFyIHNoYXBlID0gdXRpbHMubWFrZXNoYXBlKG91dGxpbmVbaV0sIG91dGxpbmVbbGVuLWldLCBjdXJ2ZUludGVyc2VjdGlvblRocmVzaG9sZCk7XG4gICAgICAgIHNoYXBlLnN0YXJ0Y2FwLnZpcnR1YWwgPSAoaSA+IDEpO1xuICAgICAgICBzaGFwZS5lbmRjYXAudmlydHVhbCA9IChpIDwgbGVuLzItMSk7XG4gICAgICAgIHNoYXBlcy5wdXNoKHNoYXBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzaGFwZXM7XG4gICAgfSxcbiAgICBpbnRlcnNlY3RzOiBmdW5jdGlvbihjdXJ2ZSwgY3VydmVJbnRlcnNlY3Rpb25UaHJlc2hvbGQpIHtcbiAgICAgIGlmKCFjdXJ2ZSkgcmV0dXJuIHRoaXMuc2VsZmludGVyc2VjdHMoY3VydmVJbnRlcnNlY3Rpb25UaHJlc2hvbGQpO1xuICAgICAgaWYoY3VydmUucDEgJiYgY3VydmUucDIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZUludGVyc2VjdHMoY3VydmUpO1xuICAgICAgfVxuICAgICAgaWYoY3VydmUgaW5zdGFuY2VvZiBCZXppZXIpIHsgY3VydmUgPSBjdXJ2ZS5yZWR1Y2UoKTsgfVxuICAgICAgcmV0dXJuIHRoaXMuY3VydmVpbnRlcnNlY3RzKHRoaXMucmVkdWNlKCksIGN1cnZlLCBjdXJ2ZUludGVyc2VjdGlvblRocmVzaG9sZCk7XG4gICAgfSxcbiAgICBsaW5lSW50ZXJzZWN0czogZnVuY3Rpb24obGluZSkge1xuICAgICAgdmFyIG14ID0gbWluKGxpbmUucDEueCwgbGluZS5wMi54KSxcbiAgICAgICAgICBteSA9IG1pbihsaW5lLnAxLnksIGxpbmUucDIueSksXG4gICAgICAgICAgTVggPSBtYXgobGluZS5wMS54LCBsaW5lLnAyLngpLFxuICAgICAgICAgIE1ZID0gbWF4KGxpbmUucDEueSwgbGluZS5wMi55KSxcbiAgICAgICAgICBzZWxmPXRoaXM7XG4gICAgICByZXR1cm4gdXRpbHMucm9vdHModGhpcy5wb2ludHMsIGxpbmUpLmZpbHRlcihmdW5jdGlvbih0KSB7XG4gICAgICAgIHZhciBwID0gc2VsZi5nZXQodCk7XG4gICAgICAgIHJldHVybiB1dGlscy5iZXR3ZWVuKHAueCwgbXgsIE1YKSAmJiB1dGlscy5iZXR3ZWVuKHAueSwgbXksIE1ZKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2VsZmludGVyc2VjdHM6IGZ1bmN0aW9uKGN1cnZlSW50ZXJzZWN0aW9uVGhyZXNob2xkKSB7XG4gICAgICB2YXIgcmVkdWNlZCA9IHRoaXMucmVkdWNlKCk7XG4gICAgICAvLyBcInNpbXBsZVwiIGN1cnZlcyBjYW5ub3QgaW50ZXJzZWN0IHdpdGggdGhlaXIgZGlyZWN0XG4gICAgICAvLyBuZWlnaGJvdXIsIHNvIGZvciBlYWNoIHNlZ21lbnQgWCB3ZSBjaGVjayB3aGV0aGVyXG4gICAgICAvLyBpdCBpbnRlcnNlY3RzIFswOngtMl1beCsyOmxhc3RdLlxuICAgICAgdmFyIGksbGVuPXJlZHVjZWQubGVuZ3RoLTIscmVzdWx0cz1bXSxyZXN1bHQsbGVmdCxyaWdodDtcbiAgICAgIGZvcihpPTA7IGk8bGVuOyBpKyspIHtcbiAgICAgICAgbGVmdCA9IHJlZHVjZWQuc2xpY2UoaSxpKzEpO1xuICAgICAgICByaWdodCA9IHJlZHVjZWQuc2xpY2UoaSsyKTtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5jdXJ2ZWludGVyc2VjdHMobGVmdCwgcmlnaHQsIGN1cnZlSW50ZXJzZWN0aW9uVGhyZXNob2xkKTtcbiAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KCByZXN1bHQgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0sXG4gICAgY3VydmVpbnRlcnNlY3RzOiBmdW5jdGlvbihjMSwgYzIsIGN1cnZlSW50ZXJzZWN0aW9uVGhyZXNob2xkKSB7XG4gICAgICB2YXIgcGFpcnMgPSBbXTtcbiAgICAgIC8vIHN0ZXAgMTogcGFpciBvZmYgYW55IG92ZXJsYXBwaW5nIHNlZ21lbnRzXG4gICAgICBjMS5mb3JFYWNoKGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgYzIuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICAgICAgaWYobC5vdmVybGFwcyhyKSkge1xuICAgICAgICAgICAgcGFpcnMucHVzaCh7IGxlZnQ6IGwsIHJpZ2h0OiByIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIC8vIHN0ZXAgMjogZm9yIGVhY2ggcGFpcmluZywgcnVuIHRocm91Z2ggdGhlIGNvbnZlcmdlbmNlIGFsZ29yaXRobS5cbiAgICAgIHZhciBpbnRlcnNlY3Rpb25zID0gW107XG4gICAgICBwYWlycy5mb3JFYWNoKGZ1bmN0aW9uKHBhaXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHV0aWxzLnBhaXJpdGVyYXRpb24ocGFpci5sZWZ0LCBwYWlyLnJpZ2h0LCBjdXJ2ZUludGVyc2VjdGlvblRocmVzaG9sZCk7XG4gICAgICAgIGlmKHJlc3VsdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgaW50ZXJzZWN0aW9ucyA9IGludGVyc2VjdGlvbnMuY29uY2F0KHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gICAgfSxcbiAgICBhcmNzOiBmdW5jdGlvbihlcnJvclRocmVzaG9sZCkge1xuICAgICAgZXJyb3JUaHJlc2hvbGQgPSBlcnJvclRocmVzaG9sZCB8fCAwLjU7XG4gICAgICB2YXIgY2lyY2xlcyA9IFtdO1xuICAgICAgcmV0dXJuIHRoaXMuX2l0ZXJhdGUoZXJyb3JUaHJlc2hvbGQsIGNpcmNsZXMpO1xuICAgIH0sXG4gICAgX2Vycm9yOiBmdW5jdGlvbihwYywgbnAxLCBzLCBlKSB7XG4gICAgICB2YXIgcSA9IChlIC0gcykgLyA0LFxuICAgICAgICAgIGMxID0gdGhpcy5nZXQocyArIHEpLFxuICAgICAgICAgIGMyID0gdGhpcy5nZXQoZSAtIHEpLFxuICAgICAgICAgIHJlZiA9IHV0aWxzLmRpc3QocGMsIG5wMSksXG4gICAgICAgICAgZDEgID0gdXRpbHMuZGlzdChwYywgYzEpLFxuICAgICAgICAgIGQyICA9IHV0aWxzLmRpc3QocGMsIGMyKTtcbiAgICAgIHJldHVybiBhYnMoZDEtcmVmKSArIGFicyhkMi1yZWYpO1xuICAgIH0sXG4gICAgX2l0ZXJhdGU6IGZ1bmN0aW9uKGVycm9yVGhyZXNob2xkLCBjaXJjbGVzKSB7XG4gICAgICB2YXIgcyA9IDAsIGUgPSAxLCBzYWZldHk7XG4gICAgICAvLyB3ZSBkbyBhIGJpbmFyeSBzZWFyY2ggdG8gZmluZCB0aGUgXCJnb29kIGB0YCBjbG9zZXN0IHRvIG5vLWxvbmdlci1nb29kXCJcbiAgICAgIGRvIHtcbiAgICAgICAgc2FmZXR5PTA7XG5cbiAgICAgICAgLy8gc3RlcCAxOiBzdGFydCB3aXRoIHRoZSBtYXhpbXVtIHBvc3NpYmxlIGFyY1xuICAgICAgICBlID0gMTtcblxuICAgICAgICAvLyBwb2ludHM6XG4gICAgICAgIHZhciBucDEgPSB0aGlzLmdldChzKSwgbnAyLCBucDMsIGFyYywgcHJldl9hcmM7XG5cbiAgICAgICAgLy8gYm9vbGVhbnM6XG4gICAgICAgIHZhciBjdXJyX2dvb2QgPSBmYWxzZSwgcHJldl9nb29kID0gZmFsc2UsIGRvbmU7XG5cbiAgICAgICAgLy8gbnVtYmVyczpcbiAgICAgICAgdmFyIG0gPSBlLCBwcmV2X2UgPSAxLCBzdGVwID0gMDtcblxuICAgICAgICAvLyBzdGVwIDI6IGZpbmQgdGhlIGJlc3QgcG9zc2libGUgYXJjXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBwcmV2X2dvb2QgPSBjdXJyX2dvb2Q7XG4gICAgICAgICAgcHJldl9hcmMgPSBhcmM7XG4gICAgICAgICAgbSA9IChzICsgZSkvMjtcbiAgICAgICAgICBzdGVwKys7XG5cbiAgICAgICAgICBucDIgPSB0aGlzLmdldChtKTtcbiAgICAgICAgICBucDMgPSB0aGlzLmdldChlKTtcblxuICAgICAgICAgIGFyYyA9IHV0aWxzLmdldGNjZW50ZXIobnAxLCBucDIsIG5wMyk7XG5cbiAgICAgICAgICAvL2Fsc28gc2F2ZSB0aGUgdCB2YWx1ZXNcbiAgICAgICAgICBhcmMuaW50ZXJ2YWwgPSB7XG4gICAgICAgICAgICBzdGFydDogcyxcbiAgICAgICAgICAgIGVuZDogZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgZXJyb3IgPSB0aGlzLl9lcnJvcihhcmMsIG5wMSwgcywgZSk7XG4gICAgICAgICAgY3Vycl9nb29kID0gKGVycm9yIDw9IGVycm9yVGhyZXNob2xkKTtcblxuICAgICAgICAgIGRvbmUgPSBwcmV2X2dvb2QgJiYgIWN1cnJfZ29vZDtcbiAgICAgICAgICBpZighZG9uZSkgcHJldl9lID0gZTtcblxuICAgICAgICAgIC8vIHRoaXMgYXJjIGlzIGZpbmU6IHdlIGNhbiBtb3ZlICdlJyB1cCB0byBzZWUgaWYgd2UgY2FuIGZpbmQgYSB3aWRlciBhcmNcbiAgICAgICAgICBpZihjdXJyX2dvb2QpIHtcblxuICAgICAgICAgICAgLy8gaWYgZSBpcyBhbHJlYWR5IGF0IG1heCwgdGhlbiB3ZSdyZSBkb25lIGZvciB0aGlzIGFyYy5cbiAgICAgICAgICAgIGlmIChlID49IDEpIHtcbiAgICAgICAgICAgICAgYXJjLmludGVydmFsLmVuZCA9IHByZXZfZSA9IDE7XG4gICAgICAgICAgICAgIHByZXZfYXJjID0gYXJjO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIG5vdCwgbW92ZSBpdCB1cCBieSBoYWxmIHRoZSBpdGVyYXRpb24gZGlzdGFuY2VcbiAgICAgICAgICAgIGUgPSBlICsgKGUtcykvMjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB0aGlzIGlzIGEgYmFkIGFyYzogd2UgbmVlZCB0byBtb3ZlICdlJyBkb3duIHRvIGZpbmQgYSBnb29kIGFyY1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZSA9IG07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlKCFkb25lICYmIHNhZmV0eSsrPDEwMCk7XG5cbiAgICAgICAgaWYoc2FmZXR5Pj0xMDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiTDgzNTogW0ZdIGFyYyBmb3VuZFwiLCBzLCBwcmV2X2UsIHByZXZfYXJjLngsIHByZXZfYXJjLnksIHByZXZfYXJjLnMsIHByZXZfYXJjLmUpO1xuXG4gICAgICAgIHByZXZfYXJjID0gKHByZXZfYXJjID8gcHJldl9hcmMgOiBhcmMpO1xuICAgICAgICBjaXJjbGVzLnB1c2gocHJldl9hcmMpO1xuICAgICAgICBzID0gcHJldl9lO1xuICAgICAgfVxuICAgICAgd2hpbGUoZSA8IDEpO1xuICAgICAgcmV0dXJuIGNpcmNsZXM7XG4gICAgfVxuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gQmV6aWVyO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzLmpzJyk7XG5cbiAgLyoqXG4gICAqIFBvbHkgQmV6aWVyXG4gICAqIEBwYXJhbSB7W3R5cGVdfSBjdXJ2ZXMgW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgdmFyIFBvbHlCZXppZXIgPSBmdW5jdGlvbihjdXJ2ZXMpIHtcbiAgICB0aGlzLmN1cnZlcyA9IFtdO1xuICAgIHRoaXMuXzNkID0gZmFsc2U7XG4gICAgaWYoISFjdXJ2ZXMpIHtcbiAgICAgIHRoaXMuY3VydmVzID0gY3VydmVzO1xuICAgICAgdGhpcy5fM2QgPSB0aGlzLmN1cnZlc1swXS5fM2Q7XG4gICAgfVxuICB9XG5cbiAgUG9seUJlemllci5wcm90b3R5cGUgPSB7XG4gICAgdmFsdWVPZjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICAgIH0sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFwiW1wiICsgdGhpcy5jdXJ2ZXMubWFwKGZ1bmN0aW9uKGN1cnZlKSB7XG4gICAgICAgIHJldHVybiB1dGlscy5wb2ludHNUb1N0cmluZyhjdXJ2ZS5wb2ludHMpO1xuICAgICAgfSkuam9pbihcIiwgXCIpICsgXCJdXCI7XG4gICAgfSxcbiAgICBhZGRDdXJ2ZTogZnVuY3Rpb24oY3VydmUpIHtcbiAgICAgIHRoaXMuY3VydmVzLnB1c2goY3VydmUpO1xuICAgICAgdGhpcy5fM2QgPSB0aGlzLl8zZCB8fCBjdXJ2ZS5fM2Q7XG4gICAgfSxcbiAgICBsZW5ndGg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3VydmVzLm1hcChmdW5jdGlvbih2KSB7IHJldHVybiB2Lmxlbmd0aCgpOyB9KS5yZWR1Y2UoZnVuY3Rpb24oYSxiKSB7IHJldHVybiBhK2I7IH0pO1xuICAgIH0sXG4gICAgY3VydmU6IGZ1bmN0aW9uKGlkeCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3VydmVzW2lkeF07XG4gICAgfSxcbiAgICBiYm94OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjID0gdGhpcy5jdXJ2ZXM7XG4gICAgICB2YXIgYmJveCA9IGNbMF0uYmJveCgpO1xuICAgICAgZm9yKHZhciBpPTE7IGk8Yy5sZW5ndGg7IGkrKykge1xuICAgICAgICB1dGlscy5leHBhbmRib3goYmJveCwgY1tpXS5iYm94KCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJib3g7XG4gICAgfSxcbiAgICBvZmZzZXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHZhciBvZmZzZXQgPSBbXTtcbiAgICAgIHRoaXMuY3VydmVzLmZvckVhY2goZnVuY3Rpb24odikge1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXQuY29uY2F0KHYub2Zmc2V0KGQpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBQb2x5QmV6aWVyKG9mZnNldCk7XG4gICAgfVxuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gUG9seUJlemllcjtcbn0oKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIC8vIG1hdGgtaW5saW5pbmcuXG4gIHZhciBhYnMgPSBNYXRoLmFicyxcbiAgICAgIGNvcyA9IE1hdGguY29zLFxuICAgICAgc2luID0gTWF0aC5zaW4sXG4gICAgICBhY29zID0gTWF0aC5hY29zLFxuICAgICAgYXRhbjIgPSBNYXRoLmF0YW4yLFxuICAgICAgc3FydCA9IE1hdGguc3FydCxcbiAgICAgIHBvdyA9IE1hdGgucG93LFxuICAgICAgLy8gY3ViZSByb290IGZ1bmN0aW9uIHlpZWxkaW5nIHJlYWwgcm9vdHNcbiAgICAgIGNydCA9IGZ1bmN0aW9uKHYpIHsgcmV0dXJuICh2PDApID8gLXBvdygtdiwxLzMpIDogcG93KHYsMS8zKTsgfSxcbiAgICAgIC8vIHRyaWcgY29uc3RhbnRzXG4gICAgICBwaSA9IE1hdGguUEksXG4gICAgICB0YXUgPSAyKnBpLFxuICAgICAgcXVhcnQgPSBwaS8yLFxuICAgICAgLy8gZmxvYXQgcHJlY2lzaW9uIHNpZ25pZmljYW50IGRlY2ltYWxcbiAgICAgIGVwc2lsb24gPSAwLjAwMDAwMSxcbiAgICAgIC8vIGV4dHJlbWFzIHVzZWQgaW4gYmJveCBjYWxjdWxhdGlvbiBhbmQgc2ltaWxhciBhbGdvcml0aG1zXG4gICAgICBuTWF4ID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICBuTWluID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG5cbiAgLy8gQmV6aWVyIHV0aWxpdHkgZnVuY3Rpb25zXG4gIHZhciB1dGlscyA9IHtcbiAgICAvLyBMZWdlbmRyZS1HYXVzcyBhYnNjaXNzYWUgd2l0aCBuPTI0ICh4X2kgdmFsdWVzLCBkZWZpbmVkIGF0IGk9biBhcyB0aGUgcm9vdHMgb2YgdGhlIG50aCBvcmRlciBMZWdlbmRyZSBwb2x5bm9taWFsIFBuKHgpKVxuICAgIFR2YWx1ZXM6IFtcbiAgICAgIC0wLjA2NDA1Njg5Mjg2MjYwNTYyNjA4NTA0MzA4MjYyNDc0NTAzODU5MDksXG4gICAgICAgMC4wNjQwNTY4OTI4NjI2MDU2MjYwODUwNDMwODI2MjQ3NDUwMzg1OTA5LFxuICAgICAgLTAuMTkxMTE4ODY3NDczNjE2MzA5MTU4NjM5ODIwNzU3MDY5NjMxODQwNCxcbiAgICAgICAwLjE5MTExODg2NzQ3MzYxNjMwOTE1ODYzOTgyMDc1NzA2OTYzMTg0MDQsXG4gICAgICAtMC4zMTUwNDI2Nzk2OTYxNjMzNzQzODY3OTMyOTEzMTk4MTAyNDA3ODY0LFxuICAgICAgIDAuMzE1MDQyNjc5Njk2MTYzMzc0Mzg2NzkzMjkxMzE5ODEwMjQwNzg2NCxcbiAgICAgIC0wLjQzMzc5MzUwNzYyNjA0NTEzODQ4NzA4NDIzMTkxMzM0OTcxMjQ1MjQsXG4gICAgICAgMC40MzM3OTM1MDc2MjYwNDUxMzg0ODcwODQyMzE5MTMzNDk3MTI0NTI0LFxuICAgICAgLTAuNTQ1NDIxNDcxMzg4ODM5NTM1NjU4Mzc1NjE3MjE4MzcyMzcwMDEwNyxcbiAgICAgICAwLjU0NTQyMTQ3MTM4ODgzOTUzNTY1ODM3NTYxNzIxODM3MjM3MDAxMDcsXG4gICAgICAtMC42NDgwOTM2NTE5MzY5NzU1NjkyNTI0OTU3ODY5MTA3NDc2MjY2Njk2LFxuICAgICAgIDAuNjQ4MDkzNjUxOTM2OTc1NTY5MjUyNDk1Nzg2OTEwNzQ3NjI2NjY5NixcbiAgICAgIC0wLjc0MDEyNDE5MTU3ODU1NDM2NDI0MzgyODEwMzA5OTk3ODQyNTUyMzIsXG4gICAgICAgMC43NDAxMjQxOTE1Nzg1NTQzNjQyNDM4MjgxMDMwOTk5Nzg0MjU1MjMyLFxuICAgICAgLTAuODIwMDAxOTg1OTczOTAyOTIxOTUzOTQ5ODcyNjY5NzQ1MjA4MDc2MSxcbiAgICAgICAwLjgyMDAwMTk4NTk3MzkwMjkyMTk1Mzk0OTg3MjY2OTc0NTIwODA3NjEsXG4gICAgICAtMC44ODY0MTU1MjcwMDQ0MDEwMzQyMTMxNTQzNDE5ODIxOTY3NTUwODczLFxuICAgICAgIDAuODg2NDE1NTI3MDA0NDAxMDM0MjEzMTU0MzQxOTgyMTk2NzU1MDg3MyxcbiAgICAgIC0wLjkzODI3NDU1MjAwMjczMjc1ODUyMzY0OTAwMTcwODcyMTQ0OTY1NDgsXG4gICAgICAgMC45MzgyNzQ1NTIwMDI3MzI3NTg1MjM2NDkwMDE3MDg3MjE0NDk2NTQ4LFxuICAgICAgLTAuOTc0NzI4NTU1OTcxMzA5NDk4MTk4MzkxOTkzMDA4MTY5MDYxNzQxMSxcbiAgICAgICAwLjk3NDcyODU1NTk3MTMwOTQ5ODE5ODM5MTk5MzAwODE2OTA2MTc0MTEsXG4gICAgICAtMC45OTUxODcyMTk5OTcwMjEzNjAxNzk5OTc0MDk3MDA3MzY4MTE4NzQ1LFxuICAgICAgIDAuOTk1MTg3MjE5OTk3MDIxMzYwMTc5OTk3NDA5NzAwNzM2ODExODc0NVxuICAgIF0sXG5cbiAgICAvLyBMZWdlbmRyZS1HYXVzcyB3ZWlnaHRzIHdpdGggbj0yNCAod19pIHZhbHVlcywgZGVmaW5lZCBieSBhIGZ1bmN0aW9uIGxpbmtlZCB0byBpbiB0aGUgQmV6aWVyIHByaW1lciBhcnRpY2xlKVxuICAgIEN2YWx1ZXM6IFtcbiAgICAgIDAuMTI3OTM4MTk1MzQ2NzUyMTU2OTc0MDU2MTY1MjI0Njk1MzcxODUxNyxcbiAgICAgIDAuMTI3OTM4MTk1MzQ2NzUyMTU2OTc0MDU2MTY1MjI0Njk1MzcxODUxNyxcbiAgICAgIDAuMTI1ODM3NDU2MzQ2ODI4Mjk2MTIxMzc1MzgyNTExMTgzNjg4NzI2NCxcbiAgICAgIDAuMTI1ODM3NDU2MzQ2ODI4Mjk2MTIxMzc1MzgyNTExMTgzNjg4NzI2NCxcbiAgICAgIDAuMTIxNjcwNDcyOTI3ODAzMzkxMjA0NDYzMTUzNDc2MjYyNDI1NjA3MCxcbiAgICAgIDAuMTIxNjcwNDcyOTI3ODAzMzkxMjA0NDYzMTUzNDc2MjYyNDI1NjA3MCxcbiAgICAgIDAuMTE1NTA1NjY4MDUzNzI1NjAxMzUzMzQ0NDgzOTA2NzgzNTU5ODYyMixcbiAgICAgIDAuMTE1NTA1NjY4MDUzNzI1NjAxMzUzMzQ0NDgzOTA2NzgzNTU5ODYyMixcbiAgICAgIDAuMTA3NDQ0MjcwMTE1OTY1NjM0NzgyNTc3MzQyNDQ2NjA2MjIyNzk0NixcbiAgICAgIDAuMTA3NDQ0MjcwMTE1OTY1NjM0NzgyNTc3MzQyNDQ2NjA2MjIyNzk0NixcbiAgICAgIDAuMDk3NjE4NjUyMTA0MTEzODg4MjY5ODgwNjY0NDY0MjQ3MTU0NDI3OSxcbiAgICAgIDAuMDk3NjE4NjUyMTA0MTEzODg4MjY5ODgwNjY0NDY0MjQ3MTU0NDI3OSxcbiAgICAgIDAuMDg2MTkwMTYxNTMxOTUzMjc1OTE3MTg1MjAyOTgzNzQyNjY3MTg1MCxcbiAgICAgIDAuMDg2MTkwMTYxNTMxOTUzMjc1OTE3MTg1MjAyOTgzNzQyNjY3MTg1MCxcbiAgICAgIDAuMDczMzQ2NDgxNDExMDgwMzA1NzM0MDMzNjE1MjUzMTE2NTE4MTE5MyxcbiAgICAgIDAuMDczMzQ2NDgxNDExMDgwMzA1NzM0MDMzNjE1MjUzMTE2NTE4MTE5MyxcbiAgICAgIDAuMDU5Mjk4NTg0OTE1NDM2NzgwNzQ2MzY3NzU4NTAwMTA4NTg0NTQxMixcbiAgICAgIDAuMDU5Mjk4NTg0OTE1NDM2NzgwNzQ2MzY3NzU4NTAwMTA4NTg0NTQxMixcbiAgICAgIDAuMDQ0Mjc3NDM4ODE3NDE5ODA2MTY4NjAyNzQ4MjExMzM4MjI4ODU5MyxcbiAgICAgIDAuMDQ0Mjc3NDM4ODE3NDE5ODA2MTY4NjAyNzQ4MjExMzM4MjI4ODU5MyxcbiAgICAgIDAuMDI4NTMxMzg4NjI4OTMzNjYzMTgxMzA3ODE1OTUxODc4Mjg2NDQ5MSxcbiAgICAgIDAuMDI4NTMxMzg4NjI4OTMzNjYzMTgxMzA3ODE1OTUxODc4Mjg2NDQ5MSxcbiAgICAgIDAuMDEyMzQxMjI5Nzk5OTg3MTk5NTQ2ODA1NjY3MDcwMDM3MjkxNTc1OSxcbiAgICAgIDAuMDEyMzQxMjI5Nzk5OTg3MTk5NTQ2ODA1NjY3MDcwMDM3MjkxNTc1OVxuICAgIF0sXG5cbiAgICBhcmNmbjogZnVuY3Rpb24odCwgZGVyaXZhdGl2ZUZuKSB7XG4gICAgICB2YXIgZCA9IGRlcml2YXRpdmVGbih0KTtcbiAgICAgIHZhciBsID0gZC54KmQueCArIGQueSpkLnk7XG4gICAgICBpZih0eXBlb2YgZC56ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGwgKz0gZC56KmQuejtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzcXJ0KGwpO1xuICAgIH0sXG5cbiAgICBiZXR3ZWVuOiBmdW5jdGlvbih2LCBtLCBNKSB7XG4gICAgICByZXR1cm4gKG0gPD0gdiAmJiB2IDw9IE0pIHx8IHV0aWxzLmFwcHJveGltYXRlbHkodiwgbSkgfHwgdXRpbHMuYXBwcm94aW1hdGVseSh2LCBNKTtcbiAgICB9LFxuXG4gICAgYXBwcm94aW1hdGVseTogZnVuY3Rpb24oYSxiLHByZWNpc2lvbikge1xuICAgICAgcmV0dXJuIGFicyhhLWIpIDw9IChwcmVjaXNpb24gfHwgZXBzaWxvbik7XG4gICAgfSxcblxuICAgIGxlbmd0aDogZnVuY3Rpb24oZGVyaXZhdGl2ZUZuKSB7XG4gICAgICB2YXIgej0wLjUsc3VtPTAsbGVuPXV0aWxzLlR2YWx1ZXMubGVuZ3RoLGksdDtcbiAgICAgIGZvcihpPTA7IGk8bGVuOyBpKyspIHtcbiAgICAgICAgdCA9IHogKiB1dGlscy5UdmFsdWVzW2ldICsgejtcbiAgICAgICAgc3VtICs9IHV0aWxzLkN2YWx1ZXNbaV0gKiB1dGlscy5hcmNmbih0LGRlcml2YXRpdmVGbik7XG4gICAgICB9XG4gICAgICByZXR1cm4geiAqIHN1bTtcbiAgICB9LFxuXG4gICAgbWFwOiBmdW5jdGlvbih2LCBkcyxkZSwgdHMsdGUpIHtcbiAgICAgIHZhciBkMSA9IGRlLWRzLCBkMiA9IHRlLXRzLCB2MiA9ICB2LWRzLCByID0gdjIvZDE7XG4gICAgICByZXR1cm4gdHMgKyBkMipyO1xuICAgIH0sXG5cbiAgICBsZXJwOiBmdW5jdGlvbihyLCB2MSwgdjIpIHtcbiAgICAgIHZhciByZXQgPSB7XG4gICAgICAgIHg6IHYxLnggKyByKih2Mi54LXYxLngpLFxuICAgICAgICB5OiB2MS55ICsgcioodjIueS12MS55KVxuICAgICAgfTtcbiAgICAgIGlmKCEhdjEueiAmJiAhIXYyLnopIHtcbiAgICAgICAgcmV0LnogPSAgdjEueiArIHIqKHYyLnotdjEueik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICBwb2ludFRvU3RyaW5nOiBmdW5jdGlvbihwKSB7XG4gICAgICB2YXIgcyA9IHAueCtcIi9cIitwLnk7XG4gICAgICBpZih0eXBlb2YgcC56ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHMgKz0gXCIvXCIrcC56O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHM7XG4gICAgfSxcblxuICAgIHBvaW50c1RvU3RyaW5nOiBmdW5jdGlvbihwb2ludHMpIHtcbiAgICAgIHJldHVybiBcIltcIiArIHBvaW50cy5tYXAodXRpbHMucG9pbnRUb1N0cmluZykuam9pbihcIiwgXCIpICsgXCJdXCI7XG4gICAgfSxcblxuICAgIGNvcHk6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gICAgfSxcblxuICAgIGFuZ2xlOiBmdW5jdGlvbihvLHYxLHYyKSB7XG4gICAgICB2YXIgZHgxID0gdjEueCAtIG8ueCxcbiAgICAgICAgICBkeTEgPSB2MS55IC0gby55LFxuICAgICAgICAgIGR4MiA9IHYyLnggLSBvLngsXG4gICAgICAgICAgZHkyID0gdjIueSAtIG8ueSxcbiAgICAgICAgICBjcm9zcyA9IGR4MSpkeTIgLSBkeTEqZHgyLFxuICAgICAgICAgIGRvdCA9IGR4MSpkeDIgKyBkeTEqZHkyO1xuICAgICAgcmV0dXJuIGF0YW4yKGNyb3NzLCBkb3QpO1xuICAgIH0sXG5cbiAgICAvLyByb3VuZCBhcyBzdHJpbmcsIHRvIGF2b2lkIHJvdW5kaW5nIGVycm9yc1xuICAgIHJvdW5kOiBmdW5jdGlvbih2LCBkKSB7XG4gICAgICB2YXIgcyA9ICcnICsgdjtcbiAgICAgIHZhciBwb3MgPSBzLmluZGV4T2YoXCIuXCIpO1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQocy5zdWJzdHJpbmcoMCxwb3MrMStkKSk7XG4gICAgfSxcblxuICAgIGRpc3Q6IGZ1bmN0aW9uKHAxLCBwMikge1xuICAgICAgdmFyIGR4ID0gcDEueCAtIHAyLngsXG4gICAgICAgICAgZHkgPSBwMS55IC0gcDIueTtcbiAgICAgIHJldHVybiBzcXJ0KGR4KmR4K2R5KmR5KTtcbiAgICB9LFxuXG4gICAgY2xvc2VzdDogZnVuY3Rpb24oTFVULCBwb2ludCkge1xuICAgICAgdmFyIG1kaXN0ID0gcG93KDIsNjMpLCBtcG9zLCBkO1xuICAgICAgTFVULmZvckVhY2goZnVuY3Rpb24ocCwgaWR4KSB7XG4gICAgICAgIGQgPSB1dGlscy5kaXN0KHBvaW50LCBwKTtcbiAgICAgICAgaWYgKGQ8bWRpc3QpIHtcbiAgICAgICAgICBtZGlzdCA9IGQ7XG4gICAgICAgICAgbXBvcyA9IGlkeDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4geyBtZGlzdDptZGlzdCwgbXBvczptcG9zIH07XG4gICAgfSxcblxuICAgIGFiY3JhdGlvOiBmdW5jdGlvbih0LCBuKSB7XG4gICAgICAvLyBzZWUgcmF0aW8odCkgbm90ZSBvbiBodHRwOi8vcG9tYXguZ2l0aHViLmlvL2JlemllcmluZm8vI2FiY1xuICAgICAgaWYgKG4hPT0yICYmIG4hPT0zKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0ID0gMC41O1xuICAgICAgfSBlbHNlIGlmICh0PT09MCB8fCB0PT09MSkge1xuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH1cbiAgICAgIHZhciBib3R0b20gPSBwb3codCxuKSArIHBvdygxLXQsbiksIHRvcCA9IGJvdHRvbSAtIDE7XG4gICAgICByZXR1cm4gYWJzKHRvcC9ib3R0b20pO1xuICAgIH0sXG5cbiAgICBwcm9qZWN0aW9ucmF0aW86IGZ1bmN0aW9uKHQsIG4pIHtcbiAgICAgIC8vIHNlZSB1KHQpIG5vdGUgb24gaHR0cDovL3BvbWF4LmdpdGh1Yi5pby9iZXppZXJpbmZvLyNhYmNcbiAgICAgIGlmIChuIT09MiAmJiBuIT09Mykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdCA9IDAuNTtcbiAgICAgIH0gZWxzZSBpZiAodD09PTAgfHwgdD09PTEpIHtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9XG4gICAgICB2YXIgdG9wID0gcG93KDEtdCwgbiksIGJvdHRvbSA9IHBvdyh0LG4pICsgdG9wO1xuICAgICAgcmV0dXJuIHRvcC9ib3R0b207XG4gICAgfSxcblxuICAgIGxsaTg6IGZ1bmN0aW9uKHgxLHkxLHgyLHkyLHgzLHkzLHg0LHk0KSB7XG4gICAgICB2YXIgbng9KHgxKnkyLXkxKngyKSooeDMteDQpLSh4MS14MikqKHgzKnk0LXkzKng0KSxcbiAgICAgICAgICBueT0oeDEqeTIteTEqeDIpKih5My15NCktKHkxLXkyKSooeDMqeTQteTMqeDQpLFxuICAgICAgICAgIGQ9KHgxLXgyKSooeTMteTQpLSh5MS15MikqKHgzLXg0KTtcbiAgICAgIGlmKGQ9PTApIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICByZXR1cm4geyB4OiBueC9kLCB5OiBueS9kIH07XG4gICAgfSxcblxuICAgIGxsaTQ6IGZ1bmN0aW9uKHAxLHAyLHAzLHA0KSB7XG4gICAgICB2YXIgeDEgPSBwMS54LCB5MSA9IHAxLnksXG4gICAgICAgICAgeDIgPSBwMi54LCB5MiA9IHAyLnksXG4gICAgICAgICAgeDMgPSBwMy54LCB5MyA9IHAzLnksXG4gICAgICAgICAgeDQgPSBwNC54LCB5NCA9IHA0Lnk7XG4gICAgICByZXR1cm4gdXRpbHMubGxpOCh4MSx5MSx4Mix5Mix4Myx5Myx4NCx5NCk7XG4gICAgfSxcblxuICAgIGxsaTogZnVuY3Rpb24odjEsIHYyKSB7XG4gICAgICByZXR1cm4gdXRpbHMubGxpNCh2MSx2MS5jLHYyLHYyLmMpO1xuICAgIH0sXG5cbiAgICBtYWtlbGluZTogZnVuY3Rpb24ocDEscDIpIHtcbiAgICAgIHZhciBCZXppZXIgPSByZXF1aXJlKCcuL2JlemllcicpO1xuICAgICAgdmFyIHgxID0gcDEueCwgeTEgPSBwMS55LCB4MiA9IHAyLngsIHkyID0gcDIueSwgZHggPSAoeDIteDEpLzMsIGR5ID0gKHkyLXkxKS8zO1xuICAgICAgcmV0dXJuIG5ldyBCZXppZXIoeDEsIHkxLCB4MStkeCwgeTErZHksIHgxKzIqZHgsIHkxKzIqZHksIHgyLCB5Mik7XG4gICAgfSxcblxuICAgIGZpbmRiYm94OiBmdW5jdGlvbihzZWN0aW9ucykge1xuICAgICAgdmFyIG14PW5NYXgsbXk9bk1heCxNWD1uTWluLE1ZPW5NaW47XG4gICAgICBzZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFyIGJib3ggPSBzLmJib3goKTtcbiAgICAgICAgaWYobXggPiBiYm94LngubWluKSBteCA9IGJib3gueC5taW47XG4gICAgICAgIGlmKG15ID4gYmJveC55Lm1pbikgbXkgPSBiYm94LnkubWluO1xuICAgICAgICBpZihNWCA8IGJib3gueC5tYXgpIE1YID0gYmJveC54Lm1heDtcbiAgICAgICAgaWYoTVkgPCBiYm94LnkubWF4KSBNWSA9IGJib3gueS5tYXg7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHsgbWluOiBteCwgbWlkOihteCtNWCkvMiwgbWF4OiBNWCwgc2l6ZTpNWC1teCB9LFxuICAgICAgICB5OiB7IG1pbjogbXksIG1pZDoobXkrTVkpLzIsIG1heDogTVksIHNpemU6TVktbXkgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzaGFwZWludGVyc2VjdGlvbnM6IGZ1bmN0aW9uKHMxLCBiYm94MSwgczIsIGJib3gyLCBjdXJ2ZUludGVyc2VjdGlvblRocmVzaG9sZCkge1xuICAgICAgaWYoIXV0aWxzLmJib3hvdmVybGFwKGJib3gxLCBiYm94MikpIHJldHVybiBbXTtcbiAgICAgIHZhciBpbnRlcnNlY3Rpb25zID0gW107XG4gICAgICB2YXIgYTEgPSBbczEuc3RhcnRjYXAsIHMxLmZvcndhcmQsIHMxLmJhY2ssIHMxLmVuZGNhcF07XG4gICAgICB2YXIgYTIgPSBbczIuc3RhcnRjYXAsIHMyLmZvcndhcmQsIHMyLmJhY2ssIHMyLmVuZGNhcF07XG4gICAgICBhMS5mb3JFYWNoKGZ1bmN0aW9uKGwxKSB7XG4gICAgICAgIGlmKGwxLnZpcnR1YWwpIHJldHVybjtcbiAgICAgICAgYTIuZm9yRWFjaChmdW5jdGlvbihsMikge1xuICAgICAgICAgIGlmKGwyLnZpcnR1YWwpIHJldHVybjtcbiAgICAgICAgICB2YXIgaXNzID0gbDEuaW50ZXJzZWN0cyhsMiwgY3VydmVJbnRlcnNlY3Rpb25UaHJlc2hvbGQpO1xuICAgICAgICAgIGlmKGlzcy5sZW5ndGg+MCkge1xuICAgICAgICAgICAgaXNzLmMxID0gbDE7XG4gICAgICAgICAgICBpc3MuYzIgPSBsMjtcbiAgICAgICAgICAgIGlzcy5zMSA9IHMxO1xuICAgICAgICAgICAgaXNzLnMyID0gczI7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25zLnB1c2goaXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbiAgICB9LFxuXG4gICAgbWFrZXNoYXBlOiBmdW5jdGlvbihmb3J3YXJkLCBiYWNrLCBjdXJ2ZUludGVyc2VjdGlvblRocmVzaG9sZCkge1xuICAgICAgdmFyIGJwbCA9IGJhY2sucG9pbnRzLmxlbmd0aDtcbiAgICAgIHZhciBmcGwgPSBmb3J3YXJkLnBvaW50cy5sZW5ndGg7XG4gICAgICB2YXIgc3RhcnQgID0gdXRpbHMubWFrZWxpbmUoYmFjay5wb2ludHNbYnBsLTFdLCBmb3J3YXJkLnBvaW50c1swXSk7XG4gICAgICB2YXIgZW5kICAgID0gdXRpbHMubWFrZWxpbmUoZm9yd2FyZC5wb2ludHNbZnBsLTFdLCBiYWNrLnBvaW50c1swXSk7XG4gICAgICB2YXIgc2hhcGUgID0ge1xuICAgICAgICBzdGFydGNhcDogc3RhcnQsXG4gICAgICAgIGZvcndhcmQ6IGZvcndhcmQsXG4gICAgICAgIGJhY2s6IGJhY2ssXG4gICAgICAgIGVuZGNhcDogZW5kLFxuICAgICAgICBiYm94OiB1dGlscy5maW5kYmJveChbc3RhcnQsIGZvcndhcmQsIGJhY2ssIGVuZF0pXG4gICAgICB9O1xuICAgICAgdmFyIHNlbGYgPSB1dGlscztcbiAgICAgIHNoYXBlLmludGVyc2VjdGlvbnMgPSBmdW5jdGlvbihzMikge1xuICAgICAgICByZXR1cm4gc2VsZi5zaGFwZWludGVyc2VjdGlvbnMoc2hhcGUsc2hhcGUuYmJveCxzMixzMi5iYm94LCBjdXJ2ZUludGVyc2VjdGlvblRocmVzaG9sZCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHNoYXBlO1xuICAgIH0sXG5cbiAgICBnZXRtaW5tYXg6IGZ1bmN0aW9uKGN1cnZlLCBkLCBsaXN0KSB7XG4gICAgICBpZighbGlzdCkgcmV0dXJuIHsgbWluOjAsIG1heDowIH07XG4gICAgICB2YXIgbWluPW5NYXgsIG1heD1uTWluLHQsYztcbiAgICAgIGlmKGxpc3QuaW5kZXhPZigwKT09PS0xKSB7IGxpc3QgPSBbMF0uY29uY2F0KGxpc3QpOyB9XG4gICAgICBpZihsaXN0LmluZGV4T2YoMSk9PT0tMSkgeyBsaXN0LnB1c2goMSk7IH1cbiAgICAgIGZvcih2YXIgaT0wLGxlbj1saXN0Lmxlbmd0aDsgaTxsZW47IGkrKykge1xuICAgICAgICB0ID0gbGlzdFtpXTtcbiAgICAgICAgYyA9IGN1cnZlLmdldCh0KTtcbiAgICAgICAgaWYoY1tkXSA8IG1pbikgeyBtaW4gPSBjW2RdOyB9XG4gICAgICAgIGlmKGNbZF0gPiBtYXgpIHsgbWF4ID0gY1tkXTsgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgbWluOm1pbiwgbWlkOihtaW4rbWF4KS8yLCBtYXg6bWF4LCBzaXplOm1heC1taW4gfTtcbiAgICB9LFxuXG4gICAgYWxpZ246IGZ1bmN0aW9uKHBvaW50cywgbGluZSkge1xuICAgICAgdmFyIHR4ID0gbGluZS5wMS54LFxuICAgICAgICAgIHR5ID0gbGluZS5wMS55LFxuICAgICAgICAgIGEgPSAtYXRhbjIobGluZS5wMi55LXR5LCBsaW5lLnAyLngtdHgpLFxuICAgICAgICAgIGQgPSBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB4OiAodi54LXR4KSpjb3MoYSkgLSAodi55LXR5KSpzaW4oYSksXG4gICAgICAgICAgICAgIHk6ICh2LngtdHgpKnNpbihhKSArICh2LnktdHkpKmNvcyhhKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgcmV0dXJuIHBvaW50cy5tYXAoZCk7XG4gICAgfSxcblxuICAgIHJvb3RzOiBmdW5jdGlvbihwb2ludHMsIGxpbmUpIHtcbiAgICAgIGxpbmUgPSBsaW5lIHx8IHtwMTp7eDowLHk6MH0scDI6e3g6MSx5OjB9fTtcbiAgICAgIHZhciBvcmRlciA9IHBvaW50cy5sZW5ndGggLSAxO1xuICAgICAgdmFyIHAgPSB1dGlscy5hbGlnbihwb2ludHMsIGxpbmUpO1xuICAgICAgdmFyIHJlZHVjZSA9IGZ1bmN0aW9uKHQpIHsgcmV0dXJuIDA8PXQgJiYgdCA8PTE7IH07XG5cbiAgICAgIGlmIChvcmRlciA9PT0gMikge1xuICAgICAgICB2YXIgYSA9IHBbMF0ueSxcbiAgICAgICAgICAgIGIgPSBwWzFdLnksXG4gICAgICAgICAgICBjID0gcFsyXS55LFxuICAgICAgICAgICAgZCA9IGEgLSAyKmIgKyBjO1xuICAgICAgICBpZihkIT09MCkge1xuICAgICAgICAgIHZhciBtMSA9IC1zcXJ0KGIqYi1hKmMpLFxuICAgICAgICAgICAgICBtMiA9IC1hK2IsXG4gICAgICAgICAgICAgIHYxID0gLSggbTErbTIpL2QsXG4gICAgICAgICAgICAgIHYyID0gLSgtbTErbTIpL2Q7XG4gICAgICAgICAgcmV0dXJuIFt2MSwgdjJdLmZpbHRlcihyZWR1Y2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoYiE9PWMgJiYgZD09PTApIHtcbiAgICAgICAgICByZXR1cm4gWyAoMipiLWMpLzIqKGItYykgXS5maWx0ZXIocmVkdWNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIC8vIHNlZSBodHRwOi8vd3d3LnRyYW5zNG1pbmQuY29tL3BlcnNvbmFsX2RldmVsb3BtZW50L21hdGhlbWF0aWNzL3BvbHlub21pYWxzL2N1YmljQWxnZWJyYS5odG1cbiAgICAgIHZhciBwYSA9IHBbMF0ueSxcbiAgICAgICAgICBwYiA9IHBbMV0ueSxcbiAgICAgICAgICBwYyA9IHBbMl0ueSxcbiAgICAgICAgICBwZCA9IHBbM10ueSxcbiAgICAgICAgICBkID0gKC1wYSArIDMqcGIgLSAzKnBjICsgcGQpLFxuICAgICAgICAgIGEgPSAoMypwYSAtIDYqcGIgKyAzKnBjKSAvIGQsXG4gICAgICAgICAgYiA9ICgtMypwYSArIDMqcGIpIC8gZCxcbiAgICAgICAgICBjID0gcGEgLyBkLFxuICAgICAgICAgIHAgPSAoMypiIC0gYSphKS8zLFxuICAgICAgICAgIHAzID0gcC8zLFxuICAgICAgICAgIHEgPSAoMiphKmEqYSAtIDkqYSpiICsgMjcqYykvMjcsXG4gICAgICAgICAgcTIgPSBxLzIsXG4gICAgICAgICAgZGlzY3JpbWluYW50ID0gcTIqcTIgKyBwMypwMypwMyxcbiAgICAgICAgICB1MSx2MSx4MSx4Mix4MztcbiAgICAgICBpZiAoZGlzY3JpbWluYW50IDwgMCkge1xuICAgICAgICB2YXIgbXAzID0gLXAvMyxcbiAgICAgICAgICAgIG1wMzMgPSBtcDMqbXAzKm1wMyxcbiAgICAgICAgICAgIHIgPSBzcXJ0KCBtcDMzICksXG4gICAgICAgICAgICB0ID0gLXEvKDIqciksXG4gICAgICAgICAgICBjb3NwaGkgPSB0PC0xID8gLTEgOiB0PjEgPyAxIDogdCxcbiAgICAgICAgICAgIHBoaSA9IGFjb3MoY29zcGhpKSxcbiAgICAgICAgICAgIGNydHIgPSBjcnQociksXG4gICAgICAgICAgICB0MSA9IDIqY3J0cjtcbiAgICAgICAgeDEgPSB0MSAqIGNvcyhwaGkvMykgLSBhLzM7XG4gICAgICAgIHgyID0gdDEgKiBjb3MoKHBoaSt0YXUpLzMpIC0gYS8zO1xuICAgICAgICB4MyA9IHQxICogY29zKChwaGkrMip0YXUpLzMpIC0gYS8zO1xuICAgICAgICByZXR1cm4gW3gxLCB4MiwgeDNdLmZpbHRlcihyZWR1Y2UpO1xuICAgICAgfSBlbHNlIGlmKGRpc2NyaW1pbmFudCA9PT0gMCkge1xuICAgICAgICB1MSA9IHEyIDwgMCA/IGNydCgtcTIpIDogLWNydChxMik7XG4gICAgICAgIHgxID0gMip1MS1hLzM7XG4gICAgICAgIHgyID0gLXUxIC0gYS8zO1xuICAgICAgICByZXR1cm4gW3gxLHgyXS5maWx0ZXIocmVkdWNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzZCA9IHNxcnQoZGlzY3JpbWluYW50KTtcbiAgICAgICAgdTEgPSBjcnQoLXEyK3NkKTtcbiAgICAgICAgdjEgPSBjcnQocTIrc2QpO1xuICAgICAgICByZXR1cm4gW3UxLXYxLWEvM10uZmlsdGVyKHJlZHVjZSk7O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBkcm9vdHM6IGZ1bmN0aW9uKHApIHtcbiAgICAgIC8vIHF1YWRyYXRpYyByb290cyBhcmUgZWFzeVxuICAgICAgaWYocC5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgdmFyIGEgPSBwWzBdLFxuICAgICAgICAgICAgYiA9IHBbMV0sXG4gICAgICAgICAgICBjID0gcFsyXSxcbiAgICAgICAgICAgIGQgPSBhIC0gMipiICsgYztcbiAgICAgICAgaWYoZCE9PTApIHtcbiAgICAgICAgICB2YXIgbTEgPSAtc3FydChiKmItYSpjKSxcbiAgICAgICAgICAgICAgbTIgPSAtYStiLFxuICAgICAgICAgICAgICB2MSA9IC0oIG0xK20yKS9kLFxuICAgICAgICAgICAgICB2MiA9IC0oLW0xK20yKS9kO1xuICAgICAgICAgIHJldHVybiBbdjEsIHYyXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGIhPT1jICYmIGQ9PT0wKSB7XG4gICAgICAgICAgcmV0dXJuIFsoMipiLWMpLygyKihiLWMpKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICAvLyBsaW5lYXIgcm9vdHMgYXJlIGV2ZW4gZWFzaWVyXG4gICAgICBpZihwLmxlbmd0aCA9PT0gMikge1xuICAgICAgICB2YXIgYSA9IHBbMF0sIGIgPSBwWzFdO1xuICAgICAgICBpZihhIT09Yikge1xuICAgICAgICAgIHJldHVybiBbYS8oYS1iKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBpbmZsZWN0aW9uczogZnVuY3Rpb24ocG9pbnRzKSB7XG4gICAgICBpZiAocG9pbnRzLmxlbmd0aDw0KSByZXR1cm4gW107XG5cbiAgICAgIC8vIEZJWE1FOiBUT0RPOiBhZGQgaW4gaW5mbGVjdGlvbiBhYnN0cmFjdGlvbiBmb3IgcXVhcnRpYysgY3VydmVzP1xuXG4gICAgICB2YXIgcCA9IHV0aWxzLmFsaWduKHBvaW50cywgeyBwMTogcG9pbnRzWzBdLCBwMjogcG9pbnRzLnNsaWNlKC0xKVswXSB9KSxcbiAgICAgICAgICBhID0gcFsyXS54ICogcFsxXS55LFxuICAgICAgICAgIGIgPSBwWzNdLnggKiBwWzFdLnksXG4gICAgICAgICAgYyA9IHBbMV0ueCAqIHBbMl0ueSxcbiAgICAgICAgICBkID0gcFszXS54ICogcFsyXS55LFxuICAgICAgICAgIHYxID0gMTggKiAoLTMqYSArIDIqYiArIDMqYyAtIGQpLFxuICAgICAgICAgIHYyID0gMTggKiAoMyphIC0gYiAtIDMqYyksXG4gICAgICAgICAgdjMgPSAxOCAqIChjIC0gYSk7XG5cbiAgICAgIGlmICh1dGlscy5hcHByb3hpbWF0ZWx5KHYxLDApKXtcbiAgICAgICAgaWYoIXV0aWxzLmFwcHJveGltYXRlbHkodjIsMCkpe1xuICAgICAgICAgIHZhciB0ID0gLXYzL3YyO1xuICAgICAgICAgIGlmICgwIDw9IHQgJiYgdCA8PSAxKVxuICAgICAgICAgICAgIHJldHVybiBbdF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHJtID0gdjIqdjIgLSA0KnYxKnYzLFxuICAgICAgICAgIHNxID0gTWF0aC5zcXJ0KHRybSksXG4gICAgICAgICAgZCA9IDIgKiB2MTtcblxuICAgICAgaWYgKHV0aWxzLmFwcHJveGltYXRlbHkoZCwwKSkgcmV0dXJuIFtdO1xuXG4gICAgICByZXR1cm4gWyhzcS12MikvZCwgLSh2MitzcSkvZF0uZmlsdGVyKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgcmV0dXJuICgwIDw9IHIgJiYgciA8PSAxKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBiYm94b3ZlcmxhcDogZnVuY3Rpb24oYjEsYjIpIHtcbiAgICAgIHZhciBkaW1zPVsneCcsJ3knXSxsZW49ZGltcy5sZW5ndGgsaSxkaW0sbCx0LGRcbiAgICAgIGZvcihpPTA7IGk8bGVuOyBpKyspIHtcbiAgICAgICAgZGltID0gZGltc1tpXTtcbiAgICAgICAgbCA9IGIxW2RpbV0ubWlkO1xuICAgICAgICB0ID0gYjJbZGltXS5taWQ7XG4gICAgICAgIGQgPSAoYjFbZGltXS5zaXplICsgYjJbZGltXS5zaXplKS8yO1xuICAgICAgICBpZihhYnMobC10KSA+PSBkKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgZXhwYW5kYm94OiBmdW5jdGlvbihiYm94LCBfYmJveCkge1xuICAgICAgaWYoX2Jib3gueC5taW4gPCBiYm94LngubWluKSB7IGJib3gueC5taW4gPSBfYmJveC54Lm1pbjsgfVxuICAgICAgaWYoX2Jib3gueS5taW4gPCBiYm94LnkubWluKSB7IGJib3gueS5taW4gPSBfYmJveC55Lm1pbjsgfVxuICAgICAgaWYoX2Jib3gueiAmJiBfYmJveC56Lm1pbiA8IGJib3guei5taW4pIHsgYmJveC56Lm1pbiA9IF9iYm94LnoubWluOyB9XG4gICAgICBpZihfYmJveC54Lm1heCA+IGJib3gueC5tYXgpIHsgYmJveC54Lm1heCA9IF9iYm94LngubWF4OyB9XG4gICAgICBpZihfYmJveC55Lm1heCA+IGJib3gueS5tYXgpIHsgYmJveC55Lm1heCA9IF9iYm94LnkubWF4OyB9XG4gICAgICBpZihfYmJveC56ICYmIF9iYm94LnoubWF4ID4gYmJveC56Lm1heCkgeyBiYm94LnoubWF4ID0gX2Jib3guei5tYXg7IH1cbiAgICAgIGJib3gueC5taWQgPSAoYmJveC54Lm1pbiArIGJib3gueC5tYXgpLzI7XG4gICAgICBiYm94LnkubWlkID0gKGJib3gueS5taW4gKyBiYm94LnkubWF4KS8yO1xuICAgICAgaWYoYmJveC56KSB7IGJib3guei5taWQgPSAoYmJveC56Lm1pbiArIGJib3guei5tYXgpLzI7IH1cbiAgICAgIGJib3gueC5zaXplID0gYmJveC54Lm1heCAtIGJib3gueC5taW47XG4gICAgICBiYm94Lnkuc2l6ZSA9IGJib3gueS5tYXggLSBiYm94LnkubWluO1xuICAgICAgaWYoYmJveC56KSB7IGJib3guei5zaXplID0gYmJveC56Lm1heCAtIGJib3guei5taW47IH1cbiAgICB9LFxuXG4gICAgcGFpcml0ZXJhdGlvbjogZnVuY3Rpb24oYzEsIGMyLCBjdXJ2ZUludGVyc2VjdGlvblRocmVzaG9sZCkge1xuICAgICAgdmFyIGMxYiA9IGMxLmJib3goKSxcbiAgICAgICAgICBjMmIgPSBjMi5iYm94KCksXG4gICAgICAgICAgciA9IDEwMDAwMCxcbiAgICAgICAgICB0aHJlc2hvbGQgPSBjdXJ2ZUludGVyc2VjdGlvblRocmVzaG9sZCB8fCAwLjU7XG4gICAgICBpZihjMWIueC5zaXplICsgYzFiLnkuc2l6ZSA8IHRocmVzaG9sZCAmJiBjMmIueC5zaXplICsgYzJiLnkuc2l6ZSA8IHRocmVzaG9sZCkge1xuICAgICAgICByZXR1cm4gWyAoKHIgKiAoYzEuX3QxK2MxLl90MikvMil8MCkvciArIFwiL1wiICsgKChyICogKGMyLl90MStjMi5fdDIpLzIpfDApL3IgXTtcbiAgICAgIH1cbiAgICAgIHZhciBjYzEgPSBjMS5zcGxpdCgwLjUpLFxuICAgICAgICAgIGNjMiA9IGMyLnNwbGl0KDAuNSksXG4gICAgICAgICAgcGFpcnMgPSBbXG4gICAgICAgICAgICB7bGVmdDogY2MxLmxlZnQsIHJpZ2h0OiBjYzIubGVmdCB9LFxuICAgICAgICAgICAge2xlZnQ6IGNjMS5sZWZ0LCByaWdodDogY2MyLnJpZ2h0IH0sXG4gICAgICAgICAgICB7bGVmdDogY2MxLnJpZ2h0LCByaWdodDogY2MyLnJpZ2h0IH0sXG4gICAgICAgICAgICB7bGVmdDogY2MxLnJpZ2h0LCByaWdodDogY2MyLmxlZnQgfV07XG4gICAgICBwYWlycyA9IHBhaXJzLmZpbHRlcihmdW5jdGlvbihwYWlyKSB7XG4gICAgICAgIHJldHVybiB1dGlscy5iYm94b3ZlcmxhcChwYWlyLmxlZnQuYmJveCgpLHBhaXIucmlnaHQuYmJveCgpKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgIGlmKHBhaXJzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHJlc3VsdHM7XG4gICAgICBwYWlycy5mb3JFYWNoKGZ1bmN0aW9uKHBhaXIpIHtcbiAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KFxuICAgICAgICAgIHV0aWxzLnBhaXJpdGVyYXRpb24ocGFpci5sZWZ0LCBwYWlyLnJpZ2h0LCB0aHJlc2hvbGQpXG4gICAgICAgICk7XG4gICAgICB9KVxuICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuZmlsdGVyKGZ1bmN0aW9uKHYsaSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0cy5pbmRleE9mKHYpID09PSBpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9LFxuXG4gICAgZ2V0Y2NlbnRlcjogZnVuY3Rpb24ocDEscDIscDMpIHtcbiAgICAgIHZhciBkeDEgPSAocDIueCAtIHAxLngpLFxuICAgICAgICAgIGR5MSA9IChwMi55IC0gcDEueSksXG4gICAgICAgICAgZHgyID0gKHAzLnggLSBwMi54KSxcbiAgICAgICAgICBkeTIgPSAocDMueSAtIHAyLnkpO1xuICAgICAgdmFyIGR4MXAgPSBkeDEgKiBjb3MocXVhcnQpIC0gZHkxICogc2luKHF1YXJ0KSxcbiAgICAgICAgICBkeTFwID0gZHgxICogc2luKHF1YXJ0KSArIGR5MSAqIGNvcyhxdWFydCksXG4gICAgICAgICAgZHgycCA9IGR4MiAqIGNvcyhxdWFydCkgLSBkeTIgKiBzaW4ocXVhcnQpLFxuICAgICAgICAgIGR5MnAgPSBkeDIgKiBzaW4ocXVhcnQpICsgZHkyICogY29zKHF1YXJ0KTtcbiAgICAgIC8vIGNob3JkIG1pZHBvaW50c1xuICAgICAgdmFyIG14MSA9IChwMS54ICsgcDIueCkvMixcbiAgICAgICAgICBteTEgPSAocDEueSArIHAyLnkpLzIsXG4gICAgICAgICAgbXgyID0gKHAyLnggKyBwMy54KS8yLFxuICAgICAgICAgIG15MiA9IChwMi55ICsgcDMueSkvMjtcbiAgICAgIC8vIG1pZHBvaW50IG9mZnNldHNcbiAgICAgIHZhciBteDFuID0gbXgxICsgZHgxcCxcbiAgICAgICAgICBteTFuID0gbXkxICsgZHkxcCxcbiAgICAgICAgICBteDJuID0gbXgyICsgZHgycCxcbiAgICAgICAgICBteTJuID0gbXkyICsgZHkycDtcbiAgICAgIC8vIGludGVyc2VjdGlvbiBvZiB0aGVzZSBsaW5lczpcbiAgICAgIHZhciBhcmMgPSB1dGlscy5sbGk4KG14MSxteTEsbXgxbixteTFuLCBteDIsbXkyLG14Mm4sbXkybiksXG4gICAgICAgICAgciA9IHV0aWxzLmRpc3QoYXJjLHAxKSxcbiAgICAgICAgICAvLyBhcmMgc3RhcnQvZW5kIHZhbHVlcywgb3ZlciBtaWQgcG9pbnQ6XG4gICAgICAgICAgcyA9IGF0YW4yKHAxLnkgLSBhcmMueSwgcDEueCAtIGFyYy54KSxcbiAgICAgICAgICBtID0gYXRhbjIocDIueSAtIGFyYy55LCBwMi54IC0gYXJjLngpLFxuICAgICAgICAgIGUgPSBhdGFuMihwMy55IC0gYXJjLnksIHAzLnggLSBhcmMueCksXG4gICAgICAgICAgXztcbiAgICAgIC8vIGRldGVybWluZSBhcmMgZGlyZWN0aW9uIChjdy9jY3cgY29ycmVjdGlvbilcbiAgICAgIGlmIChzPGUpIHtcbiAgICAgICAgLy8gaWYgczxtPGUsIGFyYyhzLCBlKVxuICAgICAgICAvLyBpZiBtPHM8ZSwgYXJjKGUsIHMgKyB0YXUpXG4gICAgICAgIC8vIGlmIHM8ZTxtLCBhcmMoZSwgcyArIHRhdSlcbiAgICAgICAgaWYgKHM+bSB8fCBtPmUpIHsgcyArPSB0YXU7IH1cbiAgICAgICAgaWYgKHM+ZSkgeyBfPWU7IGU9czsgcz1fOyB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBlPG08cywgYXJjKGUsIHMpXG4gICAgICAgIC8vIGlmIG08ZTxzLCBhcmMocywgZSArIHRhdSlcbiAgICAgICAgLy8gaWYgZTxzPG0sIGFyYyhzLCBlICsgdGF1KVxuICAgICAgICBpZiAoZTxtICYmIG08cykgeyBfPWU7IGU9czsgcz1fOyB9IGVsc2UgeyBlICs9IHRhdTsgfVxuICAgICAgfVxuICAgICAgLy8gYXNzaWduIGFuZCBkb25lLlxuICAgICAgYXJjLnMgPSBzO1xuICAgICAgYXJjLmUgPSBlO1xuICAgICAgYXJjLnIgPSByO1xuICAgICAgcmV0dXJuIGFyYztcbiAgICB9XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSB1dGlscztcbn0oKSk7XG4iLCIvLyBUaW55Q29sb3IgdjEuNC4xXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYmdyaW5zL1RpbnlDb2xvclxuLy8gQnJpYW4gR3JpbnN0ZWFkLCBNSVQgTGljZW5zZVxuXG4oZnVuY3Rpb24oTWF0aCkge1xuXG52YXIgdHJpbUxlZnQgPSAvXlxccysvLFxuICAgIHRyaW1SaWdodCA9IC9cXHMrJC8sXG4gICAgdGlueUNvdW50ZXIgPSAwLFxuICAgIG1hdGhSb3VuZCA9IE1hdGgucm91bmQsXG4gICAgbWF0aE1pbiA9IE1hdGgubWluLFxuICAgIG1hdGhNYXggPSBNYXRoLm1heCxcbiAgICBtYXRoUmFuZG9tID0gTWF0aC5yYW5kb207XG5cbmZ1bmN0aW9uIHRpbnljb2xvciAoY29sb3IsIG9wdHMpIHtcblxuICAgIGNvbG9yID0gKGNvbG9yKSA/IGNvbG9yIDogJyc7XG4gICAgb3B0cyA9IG9wdHMgfHwgeyB9O1xuXG4gICAgLy8gSWYgaW5wdXQgaXMgYWxyZWFkeSBhIHRpbnljb2xvciwgcmV0dXJuIGl0c2VsZlxuICAgIGlmIChjb2xvciBpbnN0YW5jZW9mIHRpbnljb2xvcikge1xuICAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gICAgLy8gSWYgd2UgYXJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLCBjYWxsIHVzaW5nIG5ldyBpbnN0ZWFkXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIHRpbnljb2xvcikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aW55Y29sb3IoY29sb3IsIG9wdHMpO1xuICAgIH1cblxuICAgIHZhciByZ2IgPSBpbnB1dFRvUkdCKGNvbG9yKTtcbiAgICB0aGlzLl9vcmlnaW5hbElucHV0ID0gY29sb3IsXG4gICAgdGhpcy5fciA9IHJnYi5yLFxuICAgIHRoaXMuX2cgPSByZ2IuZyxcbiAgICB0aGlzLl9iID0gcmdiLmIsXG4gICAgdGhpcy5fYSA9IHJnYi5hLFxuICAgIHRoaXMuX3JvdW5kQSA9IG1hdGhSb3VuZCgxMDAqdGhpcy5fYSkgLyAxMDAsXG4gICAgdGhpcy5fZm9ybWF0ID0gb3B0cy5mb3JtYXQgfHwgcmdiLmZvcm1hdDtcbiAgICB0aGlzLl9ncmFkaWVudFR5cGUgPSBvcHRzLmdyYWRpZW50VHlwZTtcblxuICAgIC8vIERvbid0IGxldCB0aGUgcmFuZ2Ugb2YgWzAsMjU1XSBjb21lIGJhY2sgaW4gWzAsMV0uXG4gICAgLy8gUG90ZW50aWFsbHkgbG9zZSBhIGxpdHRsZSBiaXQgb2YgcHJlY2lzaW9uIGhlcmUsIGJ1dCB3aWxsIGZpeCBpc3N1ZXMgd2hlcmVcbiAgICAvLyAuNSBnZXRzIGludGVycHJldGVkIGFzIGhhbGYgb2YgdGhlIHRvdGFsLCBpbnN0ZWFkIG9mIGhhbGYgb2YgMVxuICAgIC8vIElmIGl0IHdhcyBzdXBwb3NlZCB0byBiZSAxMjgsIHRoaXMgd2FzIGFscmVhZHkgdGFrZW4gY2FyZSBvZiBieSBgaW5wdXRUb1JnYmBcbiAgICBpZiAodGhpcy5fciA8IDEpIHsgdGhpcy5fciA9IG1hdGhSb3VuZCh0aGlzLl9yKTsgfVxuICAgIGlmICh0aGlzLl9nIDwgMSkgeyB0aGlzLl9nID0gbWF0aFJvdW5kKHRoaXMuX2cpOyB9XG4gICAgaWYgKHRoaXMuX2IgPCAxKSB7IHRoaXMuX2IgPSBtYXRoUm91bmQodGhpcy5fYik7IH1cblxuICAgIHRoaXMuX29rID0gcmdiLm9rO1xuICAgIHRoaXMuX3RjX2lkID0gdGlueUNvdW50ZXIrKztcbn1cblxudGlueWNvbG9yLnByb3RvdHlwZSA9IHtcbiAgICBpc0Rhcms6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCcmlnaHRuZXNzKCkgPCAxMjg7XG4gICAgfSxcbiAgICBpc0xpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzRGFyaygpO1xuICAgIH0sXG4gICAgaXNWYWxpZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vaztcbiAgICB9LFxuICAgIGdldE9yaWdpbmFsSW5wdXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX29yaWdpbmFsSW5wdXQ7XG4gICAgfSxcbiAgICBnZXRGb3JtYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9ybWF0O1xuICAgIH0sXG4gICAgZ2V0QWxwaGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYTtcbiAgICB9LFxuICAgIGdldEJyaWdodG5lc3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL2h0dHA6Ly93d3cudzMub3JnL1RSL0FFUlQjY29sb3ItY29udHJhc3RcbiAgICAgICAgdmFyIHJnYiA9IHRoaXMudG9SZ2IoKTtcbiAgICAgICAgcmV0dXJuIChyZ2IuciAqIDI5OSArIHJnYi5nICogNTg3ICsgcmdiLmIgKiAxMTQpIC8gMTAwMDtcbiAgICB9LFxuICAgIGdldEx1bWluYW5jZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vaHR0cDovL3d3dy53My5vcmcvVFIvMjAwOC9SRUMtV0NBRzIwLTIwMDgxMjExLyNyZWxhdGl2ZWx1bWluYW5jZWRlZlxuICAgICAgICB2YXIgcmdiID0gdGhpcy50b1JnYigpO1xuICAgICAgICB2YXIgUnNSR0IsIEdzUkdCLCBCc1JHQiwgUiwgRywgQjtcbiAgICAgICAgUnNSR0IgPSByZ2Iuci8yNTU7XG4gICAgICAgIEdzUkdCID0gcmdiLmcvMjU1O1xuICAgICAgICBCc1JHQiA9IHJnYi5iLzI1NTtcblxuICAgICAgICBpZiAoUnNSR0IgPD0gMC4wMzkyOCkge1IgPSBSc1JHQiAvIDEyLjkyO30gZWxzZSB7UiA9IE1hdGgucG93KCgoUnNSR0IgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCk7fVxuICAgICAgICBpZiAoR3NSR0IgPD0gMC4wMzkyOCkge0cgPSBHc1JHQiAvIDEyLjkyO30gZWxzZSB7RyA9IE1hdGgucG93KCgoR3NSR0IgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCk7fVxuICAgICAgICBpZiAoQnNSR0IgPD0gMC4wMzkyOCkge0IgPSBCc1JHQiAvIDEyLjkyO30gZWxzZSB7QiA9IE1hdGgucG93KCgoQnNSR0IgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCk7fVxuICAgICAgICByZXR1cm4gKDAuMjEyNiAqIFIpICsgKDAuNzE1MiAqIEcpICsgKDAuMDcyMiAqIEIpO1xuICAgIH0sXG4gICAgc2V0QWxwaGE6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2EgPSBib3VuZEFscGhhKHZhbHVlKTtcbiAgICAgICAgdGhpcy5fcm91bmRBID0gbWF0aFJvdW5kKDEwMCp0aGlzLl9hKSAvIDEwMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICB0b0hzdjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoc3YgPSByZ2JUb0hzdih0aGlzLl9yLCB0aGlzLl9nLCB0aGlzLl9iKTtcbiAgICAgICAgcmV0dXJuIHsgaDogaHN2LmggKiAzNjAsIHM6IGhzdi5zLCB2OiBoc3YudiwgYTogdGhpcy5fYSB9O1xuICAgIH0sXG4gICAgdG9Ic3ZTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaHN2ID0gcmdiVG9Ic3YodGhpcy5fciwgdGhpcy5fZywgdGhpcy5fYik7XG4gICAgICAgIHZhciBoID0gbWF0aFJvdW5kKGhzdi5oICogMzYwKSwgcyA9IG1hdGhSb3VuZChoc3YucyAqIDEwMCksIHYgPSBtYXRoUm91bmQoaHN2LnYgKiAxMDApO1xuICAgICAgICByZXR1cm4gKHRoaXMuX2EgPT0gMSkgP1xuICAgICAgICAgIFwiaHN2KFwiICArIGggKyBcIiwgXCIgKyBzICsgXCIlLCBcIiArIHYgKyBcIiUpXCIgOlxuICAgICAgICAgIFwiaHN2YShcIiArIGggKyBcIiwgXCIgKyBzICsgXCIlLCBcIiArIHYgKyBcIiUsIFwiKyB0aGlzLl9yb3VuZEEgKyBcIilcIjtcbiAgICB9LFxuICAgIHRvSHNsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhzbCA9IHJnYlRvSHNsKHRoaXMuX3IsIHRoaXMuX2csIHRoaXMuX2IpO1xuICAgICAgICByZXR1cm4geyBoOiBoc2wuaCAqIDM2MCwgczogaHNsLnMsIGw6IGhzbC5sLCBhOiB0aGlzLl9hIH07XG4gICAgfSxcbiAgICB0b0hzbFN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoc2wgPSByZ2JUb0hzbCh0aGlzLl9yLCB0aGlzLl9nLCB0aGlzLl9iKTtcbiAgICAgICAgdmFyIGggPSBtYXRoUm91bmQoaHNsLmggKiAzNjApLCBzID0gbWF0aFJvdW5kKGhzbC5zICogMTAwKSwgbCA9IG1hdGhSb3VuZChoc2wubCAqIDEwMCk7XG4gICAgICAgIHJldHVybiAodGhpcy5fYSA9PSAxKSA/XG4gICAgICAgICAgXCJoc2woXCIgICsgaCArIFwiLCBcIiArIHMgKyBcIiUsIFwiICsgbCArIFwiJSlcIiA6XG4gICAgICAgICAgXCJoc2xhKFwiICsgaCArIFwiLCBcIiArIHMgKyBcIiUsIFwiICsgbCArIFwiJSwgXCIrIHRoaXMuX3JvdW5kQSArIFwiKVwiO1xuICAgIH0sXG4gICAgdG9IZXg6IGZ1bmN0aW9uKGFsbG93M0NoYXIpIHtcbiAgICAgICAgcmV0dXJuIHJnYlRvSGV4KHRoaXMuX3IsIHRoaXMuX2csIHRoaXMuX2IsIGFsbG93M0NoYXIpO1xuICAgIH0sXG4gICAgdG9IZXhTdHJpbmc6IGZ1bmN0aW9uKGFsbG93M0NoYXIpIHtcbiAgICAgICAgcmV0dXJuICcjJyArIHRoaXMudG9IZXgoYWxsb3czQ2hhcik7XG4gICAgfSxcbiAgICB0b0hleDg6IGZ1bmN0aW9uKGFsbG93NENoYXIpIHtcbiAgICAgICAgcmV0dXJuIHJnYmFUb0hleCh0aGlzLl9yLCB0aGlzLl9nLCB0aGlzLl9iLCB0aGlzLl9hLCBhbGxvdzRDaGFyKTtcbiAgICB9LFxuICAgIHRvSGV4OFN0cmluZzogZnVuY3Rpb24oYWxsb3c0Q2hhcikge1xuICAgICAgICByZXR1cm4gJyMnICsgdGhpcy50b0hleDgoYWxsb3c0Q2hhcik7XG4gICAgfSxcbiAgICB0b1JnYjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7IHI6IG1hdGhSb3VuZCh0aGlzLl9yKSwgZzogbWF0aFJvdW5kKHRoaXMuX2cpLCBiOiBtYXRoUm91bmQodGhpcy5fYiksIGE6IHRoaXMuX2EgfTtcbiAgICB9LFxuICAgIHRvUmdiU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9hID09IDEpID9cbiAgICAgICAgICBcInJnYihcIiAgKyBtYXRoUm91bmQodGhpcy5fcikgKyBcIiwgXCIgKyBtYXRoUm91bmQodGhpcy5fZykgKyBcIiwgXCIgKyBtYXRoUm91bmQodGhpcy5fYikgKyBcIilcIiA6XG4gICAgICAgICAgXCJyZ2JhKFwiICsgbWF0aFJvdW5kKHRoaXMuX3IpICsgXCIsIFwiICsgbWF0aFJvdW5kKHRoaXMuX2cpICsgXCIsIFwiICsgbWF0aFJvdW5kKHRoaXMuX2IpICsgXCIsIFwiICsgdGhpcy5fcm91bmRBICsgXCIpXCI7XG4gICAgfSxcbiAgICB0b1BlcmNlbnRhZ2VSZ2I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4geyByOiBtYXRoUm91bmQoYm91bmQwMSh0aGlzLl9yLCAyNTUpICogMTAwKSArIFwiJVwiLCBnOiBtYXRoUm91bmQoYm91bmQwMSh0aGlzLl9nLCAyNTUpICogMTAwKSArIFwiJVwiLCBiOiBtYXRoUm91bmQoYm91bmQwMSh0aGlzLl9iLCAyNTUpICogMTAwKSArIFwiJVwiLCBhOiB0aGlzLl9hIH07XG4gICAgfSxcbiAgICB0b1BlcmNlbnRhZ2VSZ2JTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2EgPT0gMSkgP1xuICAgICAgICAgIFwicmdiKFwiICArIG1hdGhSb3VuZChib3VuZDAxKHRoaXMuX3IsIDI1NSkgKiAxMDApICsgXCIlLCBcIiArIG1hdGhSb3VuZChib3VuZDAxKHRoaXMuX2csIDI1NSkgKiAxMDApICsgXCIlLCBcIiArIG1hdGhSb3VuZChib3VuZDAxKHRoaXMuX2IsIDI1NSkgKiAxMDApICsgXCIlKVwiIDpcbiAgICAgICAgICBcInJnYmEoXCIgKyBtYXRoUm91bmQoYm91bmQwMSh0aGlzLl9yLCAyNTUpICogMTAwKSArIFwiJSwgXCIgKyBtYXRoUm91bmQoYm91bmQwMSh0aGlzLl9nLCAyNTUpICogMTAwKSArIFwiJSwgXCIgKyBtYXRoUm91bmQoYm91bmQwMSh0aGlzLl9iLCAyNTUpICogMTAwKSArIFwiJSwgXCIgKyB0aGlzLl9yb3VuZEEgKyBcIilcIjtcbiAgICB9LFxuICAgIHRvTmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9hID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJ0cmFuc3BhcmVudFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2EgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGV4TmFtZXNbcmdiVG9IZXgodGhpcy5fciwgdGhpcy5fZywgdGhpcy5fYiwgdHJ1ZSldIHx8IGZhbHNlO1xuICAgIH0sXG4gICAgdG9GaWx0ZXI6IGZ1bmN0aW9uKHNlY29uZENvbG9yKSB7XG4gICAgICAgIHZhciBoZXg4U3RyaW5nID0gJyMnICsgcmdiYVRvQXJnYkhleCh0aGlzLl9yLCB0aGlzLl9nLCB0aGlzLl9iLCB0aGlzLl9hKTtcbiAgICAgICAgdmFyIHNlY29uZEhleDhTdHJpbmcgPSBoZXg4U3RyaW5nO1xuICAgICAgICB2YXIgZ3JhZGllbnRUeXBlID0gdGhpcy5fZ3JhZGllbnRUeXBlID8gXCJHcmFkaWVudFR5cGUgPSAxLCBcIiA6IFwiXCI7XG5cbiAgICAgICAgaWYgKHNlY29uZENvbG9yKSB7XG4gICAgICAgICAgICB2YXIgcyA9IHRpbnljb2xvcihzZWNvbmRDb2xvcik7XG4gICAgICAgICAgICBzZWNvbmRIZXg4U3RyaW5nID0gJyMnICsgcmdiYVRvQXJnYkhleChzLl9yLCBzLl9nLCBzLl9iLCBzLl9hKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudChcIitncmFkaWVudFR5cGUrXCJzdGFydENvbG9yc3RyPVwiK2hleDhTdHJpbmcrXCIsZW5kQ29sb3JzdHI9XCIrc2Vjb25kSGV4OFN0cmluZytcIilcIjtcbiAgICB9LFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbihmb3JtYXQpIHtcbiAgICAgICAgdmFyIGZvcm1hdFNldCA9ICEhZm9ybWF0O1xuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgdGhpcy5fZm9ybWF0O1xuXG4gICAgICAgIHZhciBmb3JtYXR0ZWRTdHJpbmcgPSBmYWxzZTtcbiAgICAgICAgdmFyIGhhc0FscGhhID0gdGhpcy5fYSA8IDEgJiYgdGhpcy5fYSA+PSAwO1xuICAgICAgICB2YXIgbmVlZHNBbHBoYUZvcm1hdCA9ICFmb3JtYXRTZXQgJiYgaGFzQWxwaGEgJiYgKGZvcm1hdCA9PT0gXCJoZXhcIiB8fCBmb3JtYXQgPT09IFwiaGV4NlwiIHx8IGZvcm1hdCA9PT0gXCJoZXgzXCIgfHwgZm9ybWF0ID09PSBcImhleDRcIiB8fCBmb3JtYXQgPT09IFwiaGV4OFwiIHx8IGZvcm1hdCA9PT0gXCJuYW1lXCIpO1xuXG4gICAgICAgIGlmIChuZWVkc0FscGhhRm9ybWF0KSB7XG4gICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIFwidHJhbnNwYXJlbnRcIiwgYWxsIG90aGVyIG5vbi1hbHBoYSBmb3JtYXRzXG4gICAgICAgICAgICAvLyB3aWxsIHJldHVybiByZ2JhIHdoZW4gdGhlcmUgaXMgdHJhbnNwYXJlbmN5LlxuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJuYW1lXCIgJiYgdGhpcy5fYSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvTmFtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9SZ2JTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcInJnYlwiKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRTdHJpbmcgPSB0aGlzLnRvUmdiU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJwcmdiXCIpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9QZXJjZW50YWdlUmdiU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJoZXhcIiB8fCBmb3JtYXQgPT09IFwiaGV4NlwiKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRTdHJpbmcgPSB0aGlzLnRvSGV4U3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJoZXgzXCIpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9IZXhTdHJpbmcodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJoZXg0XCIpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9IZXg4U3RyaW5nKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwiaGV4OFwiKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRTdHJpbmcgPSB0aGlzLnRvSGV4OFN0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwibmFtZVwiKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRTdHJpbmcgPSB0aGlzLnRvTmFtZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwiaHNsXCIpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9Ic2xTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImhzdlwiKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRTdHJpbmcgPSB0aGlzLnRvSHN2U3RyaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybWF0dGVkU3RyaW5nIHx8IHRoaXMudG9IZXhTdHJpbmcoKTtcbiAgICB9LFxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRpbnljb2xvcih0aGlzLnRvU3RyaW5nKCkpO1xuICAgIH0sXG5cbiAgICBfYXBwbHlNb2RpZmljYXRpb246IGZ1bmN0aW9uKGZuLCBhcmdzKSB7XG4gICAgICAgIHZhciBjb2xvciA9IGZuLmFwcGx5KG51bGwsIFt0aGlzXS5jb25jYXQoW10uc2xpY2UuY2FsbChhcmdzKSkpO1xuICAgICAgICB0aGlzLl9yID0gY29sb3IuX3I7XG4gICAgICAgIHRoaXMuX2cgPSBjb2xvci5fZztcbiAgICAgICAgdGhpcy5fYiA9IGNvbG9yLl9iO1xuICAgICAgICB0aGlzLnNldEFscGhhKGNvbG9yLl9hKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBsaWdodGVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5TW9kaWZpY2F0aW9uKGxpZ2h0ZW4sIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBicmlnaHRlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseU1vZGlmaWNhdGlvbihicmlnaHRlbiwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGRhcmtlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseU1vZGlmaWNhdGlvbihkYXJrZW4sIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBkZXNhdHVyYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5TW9kaWZpY2F0aW9uKGRlc2F0dXJhdGUsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBzYXR1cmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseU1vZGlmaWNhdGlvbihzYXR1cmF0ZSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGdyZXlzY2FsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseU1vZGlmaWNhdGlvbihncmV5c2NhbGUsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBzcGluOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5TW9kaWZpY2F0aW9uKHNwaW4sIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIF9hcHBseUNvbWJpbmF0aW9uOiBmdW5jdGlvbihmbiwgYXJncykge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgW3RoaXNdLmNvbmNhdChbXS5zbGljZS5jYWxsKGFyZ3MpKSk7XG4gICAgfSxcbiAgICBhbmFsb2dvdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlDb21iaW5hdGlvbihhbmFsb2dvdXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBjb21wbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5Q29tYmluYXRpb24oY29tcGxlbWVudCwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIG1vbm9jaHJvbWF0aWM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlDb21iaW5hdGlvbihtb25vY2hyb21hdGljLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgc3BsaXRjb21wbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5Q29tYmluYXRpb24oc3BsaXRjb21wbGVtZW50LCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgdHJpYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlDb21iaW5hdGlvbih0cmlhZCwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHRldHJhZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseUNvbWJpbmF0aW9uKHRldHJhZCwgYXJndW1lbnRzKTtcbiAgICB9XG59O1xuXG4vLyBJZiBpbnB1dCBpcyBhbiBvYmplY3QsIGZvcmNlIDEgaW50byBcIjEuMFwiIHRvIGhhbmRsZSByYXRpb3MgcHJvcGVybHlcbi8vIFN0cmluZyBpbnB1dCByZXF1aXJlcyBcIjEuMFwiIGFzIGlucHV0LCBzbyAxIHdpbGwgYmUgdHJlYXRlZCBhcyAxXG50aW55Y29sb3IuZnJvbVJhdGlvID0gZnVuY3Rpb24oY29sb3IsIG9wdHMpIHtcbiAgICBpZiAodHlwZW9mIGNvbG9yID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdmFyIG5ld0NvbG9yID0ge307XG4gICAgICAgIGZvciAodmFyIGkgaW4gY29sb3IpIHtcbiAgICAgICAgICAgIGlmIChjb2xvci5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBcImFcIikge1xuICAgICAgICAgICAgICAgICAgICBuZXdDb2xvcltpXSA9IGNvbG9yW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29sb3JbaV0gPSBjb252ZXJ0VG9QZXJjZW50YWdlKGNvbG9yW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29sb3IgPSBuZXdDb2xvcjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGlueWNvbG9yKGNvbG9yLCBvcHRzKTtcbn07XG5cbi8vIEdpdmVuIGEgc3RyaW5nIG9yIG9iamVjdCwgY29udmVydCB0aGF0IGlucHV0IHRvIFJHQlxuLy8gUG9zc2libGUgc3RyaW5nIGlucHV0czpcbi8vXG4vLyAgICAgXCJyZWRcIlxuLy8gICAgIFwiI2YwMFwiIG9yIFwiZjAwXCJcbi8vICAgICBcIiNmZjAwMDBcIiBvciBcImZmMDAwMFwiXG4vLyAgICAgXCIjZmYwMDAwMDBcIiBvciBcImZmMDAwMDAwXCJcbi8vICAgICBcInJnYiAyNTUgMCAwXCIgb3IgXCJyZ2IgKDI1NSwgMCwgMClcIlxuLy8gICAgIFwicmdiIDEuMCAwIDBcIiBvciBcInJnYiAoMSwgMCwgMClcIlxuLy8gICAgIFwicmdiYSAoMjU1LCAwLCAwLCAxKVwiIG9yIFwicmdiYSAyNTUsIDAsIDAsIDFcIlxuLy8gICAgIFwicmdiYSAoMS4wLCAwLCAwLCAxKVwiIG9yIFwicmdiYSAxLjAsIDAsIDAsIDFcIlxuLy8gICAgIFwiaHNsKDAsIDEwMCUsIDUwJSlcIiBvciBcImhzbCAwIDEwMCUgNTAlXCJcbi8vICAgICBcImhzbGEoMCwgMTAwJSwgNTAlLCAxKVwiIG9yIFwiaHNsYSAwIDEwMCUgNTAlLCAxXCJcbi8vICAgICBcImhzdigwLCAxMDAlLCAxMDAlKVwiIG9yIFwiaHN2IDAgMTAwJSAxMDAlXCJcbi8vXG5mdW5jdGlvbiBpbnB1dFRvUkdCKGNvbG9yKSB7XG5cbiAgICB2YXIgcmdiID0geyByOiAwLCBnOiAwLCBiOiAwIH07XG4gICAgdmFyIGEgPSAxO1xuICAgIHZhciBzID0gbnVsbDtcbiAgICB2YXIgdiA9IG51bGw7XG4gICAgdmFyIGwgPSBudWxsO1xuICAgIHZhciBvayA9IGZhbHNlO1xuICAgIHZhciBmb3JtYXQgPSBmYWxzZTtcblxuICAgIGlmICh0eXBlb2YgY29sb3IgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb2xvciA9IHN0cmluZ0lucHV0VG9PYmplY3QoY29sb3IpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29sb3IgPT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAoaXNWYWxpZENTU1VuaXQoY29sb3IucikgJiYgaXNWYWxpZENTU1VuaXQoY29sb3IuZykgJiYgaXNWYWxpZENTU1VuaXQoY29sb3IuYikpIHtcbiAgICAgICAgICAgIHJnYiA9IHJnYlRvUmdiKGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIpO1xuICAgICAgICAgICAgb2sgPSB0cnVlO1xuICAgICAgICAgICAgZm9ybWF0ID0gU3RyaW5nKGNvbG9yLnIpLnN1YnN0cigtMSkgPT09IFwiJVwiID8gXCJwcmdiXCIgOiBcInJnYlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzVmFsaWRDU1NVbml0KGNvbG9yLmgpICYmIGlzVmFsaWRDU1NVbml0KGNvbG9yLnMpICYmIGlzVmFsaWRDU1NVbml0KGNvbG9yLnYpKSB7XG4gICAgICAgICAgICBzID0gY29udmVydFRvUGVyY2VudGFnZShjb2xvci5zKTtcbiAgICAgICAgICAgIHYgPSBjb252ZXJ0VG9QZXJjZW50YWdlKGNvbG9yLnYpO1xuICAgICAgICAgICAgcmdiID0gaHN2VG9SZ2IoY29sb3IuaCwgcywgdik7XG4gICAgICAgICAgICBvayA9IHRydWU7XG4gICAgICAgICAgICBmb3JtYXQgPSBcImhzdlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzVmFsaWRDU1NVbml0KGNvbG9yLmgpICYmIGlzVmFsaWRDU1NVbml0KGNvbG9yLnMpICYmIGlzVmFsaWRDU1NVbml0KGNvbG9yLmwpKSB7XG4gICAgICAgICAgICBzID0gY29udmVydFRvUGVyY2VudGFnZShjb2xvci5zKTtcbiAgICAgICAgICAgIGwgPSBjb252ZXJ0VG9QZXJjZW50YWdlKGNvbG9yLmwpO1xuICAgICAgICAgICAgcmdiID0gaHNsVG9SZ2IoY29sb3IuaCwgcywgbCk7XG4gICAgICAgICAgICBvayA9IHRydWU7XG4gICAgICAgICAgICBmb3JtYXQgPSBcImhzbFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbG9yLmhhc093blByb3BlcnR5KFwiYVwiKSkge1xuICAgICAgICAgICAgYSA9IGNvbG9yLmE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhID0gYm91bmRBbHBoYShhKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIG9rOiBvayxcbiAgICAgICAgZm9ybWF0OiBjb2xvci5mb3JtYXQgfHwgZm9ybWF0LFxuICAgICAgICByOiBtYXRoTWluKDI1NSwgbWF0aE1heChyZ2IuciwgMCkpLFxuICAgICAgICBnOiBtYXRoTWluKDI1NSwgbWF0aE1heChyZ2IuZywgMCkpLFxuICAgICAgICBiOiBtYXRoTWluKDI1NSwgbWF0aE1heChyZ2IuYiwgMCkpLFxuICAgICAgICBhOiBhXG4gICAgfTtcbn1cblxuXG4vLyBDb252ZXJzaW9uIEZ1bmN0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gYHJnYlRvSHNsYCwgYHJnYlRvSHN2YCwgYGhzbFRvUmdiYCwgYGhzdlRvUmdiYCBtb2RpZmllZCBmcm9tOlxuLy8gPGh0dHA6Ly9tamlqYWNrc29uLmNvbS8yMDA4LzAyL3JnYi10by1oc2wtYW5kLXJnYi10by1oc3YtY29sb3ItbW9kZWwtY29udmVyc2lvbi1hbGdvcml0aG1zLWluLWphdmFzY3JpcHQ+XG5cbi8vIGByZ2JUb1JnYmBcbi8vIEhhbmRsZSBib3VuZHMgLyBwZXJjZW50YWdlIGNoZWNraW5nIHRvIGNvbmZvcm0gdG8gQ1NTIGNvbG9yIHNwZWNcbi8vIDxodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yLz5cbi8vICpBc3N1bWVzOiogciwgZywgYiBpbiBbMCwgMjU1XSBvciBbMCwgMV1cbi8vICpSZXR1cm5zOiogeyByLCBnLCBiIH0gaW4gWzAsIDI1NV1cbmZ1bmN0aW9uIHJnYlRvUmdiKHIsIGcsIGIpe1xuICAgIHJldHVybiB7XG4gICAgICAgIHI6IGJvdW5kMDEociwgMjU1KSAqIDI1NSxcbiAgICAgICAgZzogYm91bmQwMShnLCAyNTUpICogMjU1LFxuICAgICAgICBiOiBib3VuZDAxKGIsIDI1NSkgKiAyNTVcbiAgICB9O1xufVxuXG4vLyBgcmdiVG9Ic2xgXG4vLyBDb252ZXJ0cyBhbiBSR0IgY29sb3IgdmFsdWUgdG8gSFNMLlxuLy8gKkFzc3VtZXM6KiByLCBnLCBhbmQgYiBhcmUgY29udGFpbmVkIGluIFswLCAyNTVdIG9yIFswLCAxXVxuLy8gKlJldHVybnM6KiB7IGgsIHMsIGwgfSBpbiBbMCwxXVxuZnVuY3Rpb24gcmdiVG9Ic2wociwgZywgYikge1xuXG4gICAgciA9IGJvdW5kMDEociwgMjU1KTtcbiAgICBnID0gYm91bmQwMShnLCAyNTUpO1xuICAgIGIgPSBib3VuZDAxKGIsIDI1NSk7XG5cbiAgICB2YXIgbWF4ID0gbWF0aE1heChyLCBnLCBiKSwgbWluID0gbWF0aE1pbihyLCBnLCBiKTtcbiAgICB2YXIgaCwgcywgbCA9IChtYXggKyBtaW4pIC8gMjtcblxuICAgIGlmKG1heCA9PSBtaW4pIHtcbiAgICAgICAgaCA9IHMgPSAwOyAvLyBhY2hyb21hdGljXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgZCA9IG1heCAtIG1pbjtcbiAgICAgICAgcyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pO1xuICAgICAgICBzd2l0Y2gobWF4KSB7XG4gICAgICAgICAgICBjYXNlIHI6IGggPSAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGc6IGggPSAoYiAtIHIpIC8gZCArIDI7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBiOiBoID0gKHIgLSBnKSAvIGQgKyA0OyBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGggLz0gNjtcbiAgICB9XG5cbiAgICByZXR1cm4geyBoOiBoLCBzOiBzLCBsOiBsIH07XG59XG5cbi8vIGBoc2xUb1JnYmBcbi8vIENvbnZlcnRzIGFuIEhTTCBjb2xvciB2YWx1ZSB0byBSR0IuXG4vLyAqQXNzdW1lczoqIGggaXMgY29udGFpbmVkIGluIFswLCAxXSBvciBbMCwgMzYwXSBhbmQgcyBhbmQgbCBhcmUgY29udGFpbmVkIFswLCAxXSBvciBbMCwgMTAwXVxuLy8gKlJldHVybnM6KiB7IHIsIGcsIGIgfSBpbiB0aGUgc2V0IFswLCAyNTVdXG5mdW5jdGlvbiBoc2xUb1JnYihoLCBzLCBsKSB7XG4gICAgdmFyIHIsIGcsIGI7XG5cbiAgICBoID0gYm91bmQwMShoLCAzNjApO1xuICAgIHMgPSBib3VuZDAxKHMsIDEwMCk7XG4gICAgbCA9IGJvdW5kMDEobCwgMTAwKTtcblxuICAgIGZ1bmN0aW9uIGh1ZTJyZ2IocCwgcSwgdCkge1xuICAgICAgICBpZih0IDwgMCkgdCArPSAxO1xuICAgICAgICBpZih0ID4gMSkgdCAtPSAxO1xuICAgICAgICBpZih0IDwgMS82KSByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcbiAgICAgICAgaWYodCA8IDEvMikgcmV0dXJuIHE7XG4gICAgICAgIGlmKHQgPCAyLzMpIHJldHVybiBwICsgKHEgLSBwKSAqICgyLzMgLSB0KSAqIDY7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cblxuICAgIGlmKHMgPT09IDApIHtcbiAgICAgICAgciA9IGcgPSBiID0gbDsgLy8gYWNocm9tYXRpY1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHEgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xuICAgICAgICB2YXIgcCA9IDIgKiBsIC0gcTtcbiAgICAgICAgciA9IGh1ZTJyZ2IocCwgcSwgaCArIDEvMyk7XG4gICAgICAgIGcgPSBodWUycmdiKHAsIHEsIGgpO1xuICAgICAgICBiID0gaHVlMnJnYihwLCBxLCBoIC0gMS8zKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyByOiByICogMjU1LCBnOiBnICogMjU1LCBiOiBiICogMjU1IH07XG59XG5cbi8vIGByZ2JUb0hzdmBcbi8vIENvbnZlcnRzIGFuIFJHQiBjb2xvciB2YWx1ZSB0byBIU1Zcbi8vICpBc3N1bWVzOiogciwgZywgYW5kIGIgYXJlIGNvbnRhaW5lZCBpbiB0aGUgc2V0IFswLCAyNTVdIG9yIFswLCAxXVxuLy8gKlJldHVybnM6KiB7IGgsIHMsIHYgfSBpbiBbMCwxXVxuZnVuY3Rpb24gcmdiVG9Ic3YociwgZywgYikge1xuXG4gICAgciA9IGJvdW5kMDEociwgMjU1KTtcbiAgICBnID0gYm91bmQwMShnLCAyNTUpO1xuICAgIGIgPSBib3VuZDAxKGIsIDI1NSk7XG5cbiAgICB2YXIgbWF4ID0gbWF0aE1heChyLCBnLCBiKSwgbWluID0gbWF0aE1pbihyLCBnLCBiKTtcbiAgICB2YXIgaCwgcywgdiA9IG1heDtcblxuICAgIHZhciBkID0gbWF4IC0gbWluO1xuICAgIHMgPSBtYXggPT09IDAgPyAwIDogZCAvIG1heDtcblxuICAgIGlmKG1heCA9PSBtaW4pIHtcbiAgICAgICAgaCA9IDA7IC8vIGFjaHJvbWF0aWNcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN3aXRjaChtYXgpIHtcbiAgICAgICAgICAgIGNhc2UgcjogaCA9IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZzogaCA9IChiIC0gcikgLyBkICsgMjsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGI6IGggPSAociAtIGcpIC8gZCArIDQ7IGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGggLz0gNjtcbiAgICB9XG4gICAgcmV0dXJuIHsgaDogaCwgczogcywgdjogdiB9O1xufVxuXG4vLyBgaHN2VG9SZ2JgXG4vLyBDb252ZXJ0cyBhbiBIU1YgY29sb3IgdmFsdWUgdG8gUkdCLlxuLy8gKkFzc3VtZXM6KiBoIGlzIGNvbnRhaW5lZCBpbiBbMCwgMV0gb3IgWzAsIDM2MF0gYW5kIHMgYW5kIHYgYXJlIGNvbnRhaW5lZCBpbiBbMCwgMV0gb3IgWzAsIDEwMF1cbi8vICpSZXR1cm5zOiogeyByLCBnLCBiIH0gaW4gdGhlIHNldCBbMCwgMjU1XVxuIGZ1bmN0aW9uIGhzdlRvUmdiKGgsIHMsIHYpIHtcblxuICAgIGggPSBib3VuZDAxKGgsIDM2MCkgKiA2O1xuICAgIHMgPSBib3VuZDAxKHMsIDEwMCk7XG4gICAgdiA9IGJvdW5kMDEodiwgMTAwKTtcblxuICAgIHZhciBpID0gTWF0aC5mbG9vcihoKSxcbiAgICAgICAgZiA9IGggLSBpLFxuICAgICAgICBwID0gdiAqICgxIC0gcyksXG4gICAgICAgIHEgPSB2ICogKDEgLSBmICogcyksXG4gICAgICAgIHQgPSB2ICogKDEgLSAoMSAtIGYpICogcyksXG4gICAgICAgIG1vZCA9IGkgJSA2LFxuICAgICAgICByID0gW3YsIHEsIHAsIHAsIHQsIHZdW21vZF0sXG4gICAgICAgIGcgPSBbdCwgdiwgdiwgcSwgcCwgcF1bbW9kXSxcbiAgICAgICAgYiA9IFtwLCBwLCB0LCB2LCB2LCBxXVttb2RdO1xuXG4gICAgcmV0dXJuIHsgcjogciAqIDI1NSwgZzogZyAqIDI1NSwgYjogYiAqIDI1NSB9O1xufVxuXG4vLyBgcmdiVG9IZXhgXG4vLyBDb252ZXJ0cyBhbiBSR0IgY29sb3IgdG8gaGV4XG4vLyBBc3N1bWVzIHIsIGcsIGFuZCBiIGFyZSBjb250YWluZWQgaW4gdGhlIHNldCBbMCwgMjU1XVxuLy8gUmV0dXJucyBhIDMgb3IgNiBjaGFyYWN0ZXIgaGV4XG5mdW5jdGlvbiByZ2JUb0hleChyLCBnLCBiLCBhbGxvdzNDaGFyKSB7XG5cbiAgICB2YXIgaGV4ID0gW1xuICAgICAgICBwYWQyKG1hdGhSb3VuZChyKS50b1N0cmluZygxNikpLFxuICAgICAgICBwYWQyKG1hdGhSb3VuZChnKS50b1N0cmluZygxNikpLFxuICAgICAgICBwYWQyKG1hdGhSb3VuZChiKS50b1N0cmluZygxNikpXG4gICAgXTtcblxuICAgIC8vIFJldHVybiBhIDMgY2hhcmFjdGVyIGhleCBpZiBwb3NzaWJsZVxuICAgIGlmIChhbGxvdzNDaGFyICYmIGhleFswXS5jaGFyQXQoMCkgPT0gaGV4WzBdLmNoYXJBdCgxKSAmJiBoZXhbMV0uY2hhckF0KDApID09IGhleFsxXS5jaGFyQXQoMSkgJiYgaGV4WzJdLmNoYXJBdCgwKSA9PSBoZXhbMl0uY2hhckF0KDEpKSB7XG4gICAgICAgIHJldHVybiBoZXhbMF0uY2hhckF0KDApICsgaGV4WzFdLmNoYXJBdCgwKSArIGhleFsyXS5jaGFyQXQoMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhleC5qb2luKFwiXCIpO1xufVxuXG4vLyBgcmdiYVRvSGV4YFxuLy8gQ29udmVydHMgYW4gUkdCQSBjb2xvciBwbHVzIGFscGhhIHRyYW5zcGFyZW5jeSB0byBoZXhcbi8vIEFzc3VtZXMgciwgZywgYiBhcmUgY29udGFpbmVkIGluIHRoZSBzZXQgWzAsIDI1NV0gYW5kXG4vLyBhIGluIFswLCAxXS4gUmV0dXJucyBhIDQgb3IgOCBjaGFyYWN0ZXIgcmdiYSBoZXhcbmZ1bmN0aW9uIHJnYmFUb0hleChyLCBnLCBiLCBhLCBhbGxvdzRDaGFyKSB7XG5cbiAgICB2YXIgaGV4ID0gW1xuICAgICAgICBwYWQyKG1hdGhSb3VuZChyKS50b1N0cmluZygxNikpLFxuICAgICAgICBwYWQyKG1hdGhSb3VuZChnKS50b1N0cmluZygxNikpLFxuICAgICAgICBwYWQyKG1hdGhSb3VuZChiKS50b1N0cmluZygxNikpLFxuICAgICAgICBwYWQyKGNvbnZlcnREZWNpbWFsVG9IZXgoYSkpXG4gICAgXTtcblxuICAgIC8vIFJldHVybiBhIDQgY2hhcmFjdGVyIGhleCBpZiBwb3NzaWJsZVxuICAgIGlmIChhbGxvdzRDaGFyICYmIGhleFswXS5jaGFyQXQoMCkgPT0gaGV4WzBdLmNoYXJBdCgxKSAmJiBoZXhbMV0uY2hhckF0KDApID09IGhleFsxXS5jaGFyQXQoMSkgJiYgaGV4WzJdLmNoYXJBdCgwKSA9PSBoZXhbMl0uY2hhckF0KDEpICYmIGhleFszXS5jaGFyQXQoMCkgPT0gaGV4WzNdLmNoYXJBdCgxKSkge1xuICAgICAgICByZXR1cm4gaGV4WzBdLmNoYXJBdCgwKSArIGhleFsxXS5jaGFyQXQoMCkgKyBoZXhbMl0uY2hhckF0KDApICsgaGV4WzNdLmNoYXJBdCgwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGV4LmpvaW4oXCJcIik7XG59XG5cbi8vIGByZ2JhVG9BcmdiSGV4YFxuLy8gQ29udmVydHMgYW4gUkdCQSBjb2xvciB0byBhbiBBUkdCIEhleDggc3RyaW5nXG4vLyBSYXJlbHkgdXNlZCwgYnV0IHJlcXVpcmVkIGZvciBcInRvRmlsdGVyKClcIlxuZnVuY3Rpb24gcmdiYVRvQXJnYkhleChyLCBnLCBiLCBhKSB7XG5cbiAgICB2YXIgaGV4ID0gW1xuICAgICAgICBwYWQyKGNvbnZlcnREZWNpbWFsVG9IZXgoYSkpLFxuICAgICAgICBwYWQyKG1hdGhSb3VuZChyKS50b1N0cmluZygxNikpLFxuICAgICAgICBwYWQyKG1hdGhSb3VuZChnKS50b1N0cmluZygxNikpLFxuICAgICAgICBwYWQyKG1hdGhSb3VuZChiKS50b1N0cmluZygxNikpXG4gICAgXTtcblxuICAgIHJldHVybiBoZXguam9pbihcIlwiKTtcbn1cblxuLy8gYGVxdWFsc2Bcbi8vIENhbiBiZSBjYWxsZWQgd2l0aCBhbnkgdGlueWNvbG9yIGlucHV0XG50aW55Y29sb3IuZXF1YWxzID0gZnVuY3Rpb24gKGNvbG9yMSwgY29sb3IyKSB7XG4gICAgaWYgKCFjb2xvcjEgfHwgIWNvbG9yMikgeyByZXR1cm4gZmFsc2U7IH1cbiAgICByZXR1cm4gdGlueWNvbG9yKGNvbG9yMSkudG9SZ2JTdHJpbmcoKSA9PSB0aW55Y29sb3IoY29sb3IyKS50b1JnYlN0cmluZygpO1xufTtcblxudGlueWNvbG9yLnJhbmRvbSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aW55Y29sb3IuZnJvbVJhdGlvKHtcbiAgICAgICAgcjogbWF0aFJhbmRvbSgpLFxuICAgICAgICBnOiBtYXRoUmFuZG9tKCksXG4gICAgICAgIGI6IG1hdGhSYW5kb20oKVxuICAgIH0pO1xufTtcblxuXG4vLyBNb2RpZmljYXRpb24gRnVuY3Rpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUaGFua3MgdG8gbGVzcy5qcyBmb3Igc29tZSBvZiB0aGUgYmFzaWNzIGhlcmVcbi8vIDxodHRwczovL2dpdGh1Yi5jb20vY2xvdWRoZWFkL2xlc3MuanMvYmxvYi9tYXN0ZXIvbGliL2xlc3MvZnVuY3Rpb25zLmpzPlxuXG5mdW5jdGlvbiBkZXNhdHVyYXRlKGNvbG9yLCBhbW91bnQpIHtcbiAgICBhbW91bnQgPSAoYW1vdW50ID09PSAwKSA/IDAgOiAoYW1vdW50IHx8IDEwKTtcbiAgICB2YXIgaHNsID0gdGlueWNvbG9yKGNvbG9yKS50b0hzbCgpO1xuICAgIGhzbC5zIC09IGFtb3VudCAvIDEwMDtcbiAgICBoc2wucyA9IGNsYW1wMDEoaHNsLnMpO1xuICAgIHJldHVybiB0aW55Y29sb3IoaHNsKTtcbn1cblxuZnVuY3Rpb24gc2F0dXJhdGUoY29sb3IsIGFtb3VudCkge1xuICAgIGFtb3VudCA9IChhbW91bnQgPT09IDApID8gMCA6IChhbW91bnQgfHwgMTApO1xuICAgIHZhciBoc2wgPSB0aW55Y29sb3IoY29sb3IpLnRvSHNsKCk7XG4gICAgaHNsLnMgKz0gYW1vdW50IC8gMTAwO1xuICAgIGhzbC5zID0gY2xhbXAwMShoc2wucyk7XG4gICAgcmV0dXJuIHRpbnljb2xvcihoc2wpO1xufVxuXG5mdW5jdGlvbiBncmV5c2NhbGUoY29sb3IpIHtcbiAgICByZXR1cm4gdGlueWNvbG9yKGNvbG9yKS5kZXNhdHVyYXRlKDEwMCk7XG59XG5cbmZ1bmN0aW9uIGxpZ2h0ZW4gKGNvbG9yLCBhbW91bnQpIHtcbiAgICBhbW91bnQgPSAoYW1vdW50ID09PSAwKSA/IDAgOiAoYW1vdW50IHx8IDEwKTtcbiAgICB2YXIgaHNsID0gdGlueWNvbG9yKGNvbG9yKS50b0hzbCgpO1xuICAgIGhzbC5sICs9IGFtb3VudCAvIDEwMDtcbiAgICBoc2wubCA9IGNsYW1wMDEoaHNsLmwpO1xuICAgIHJldHVybiB0aW55Y29sb3IoaHNsKTtcbn1cblxuZnVuY3Rpb24gYnJpZ2h0ZW4oY29sb3IsIGFtb3VudCkge1xuICAgIGFtb3VudCA9IChhbW91bnQgPT09IDApID8gMCA6IChhbW91bnQgfHwgMTApO1xuICAgIHZhciByZ2IgPSB0aW55Y29sb3IoY29sb3IpLnRvUmdiKCk7XG4gICAgcmdiLnIgPSBtYXRoTWF4KDAsIG1hdGhNaW4oMjU1LCByZ2IuciAtIG1hdGhSb3VuZCgyNTUgKiAtIChhbW91bnQgLyAxMDApKSkpO1xuICAgIHJnYi5nID0gbWF0aE1heCgwLCBtYXRoTWluKDI1NSwgcmdiLmcgLSBtYXRoUm91bmQoMjU1ICogLSAoYW1vdW50IC8gMTAwKSkpKTtcbiAgICByZ2IuYiA9IG1hdGhNYXgoMCwgbWF0aE1pbigyNTUsIHJnYi5iIC0gbWF0aFJvdW5kKDI1NSAqIC0gKGFtb3VudCAvIDEwMCkpKSk7XG4gICAgcmV0dXJuIHRpbnljb2xvcihyZ2IpO1xufVxuXG5mdW5jdGlvbiBkYXJrZW4gKGNvbG9yLCBhbW91bnQpIHtcbiAgICBhbW91bnQgPSAoYW1vdW50ID09PSAwKSA/IDAgOiAoYW1vdW50IHx8IDEwKTtcbiAgICB2YXIgaHNsID0gdGlueWNvbG9yKGNvbG9yKS50b0hzbCgpO1xuICAgIGhzbC5sIC09IGFtb3VudCAvIDEwMDtcbiAgICBoc2wubCA9IGNsYW1wMDEoaHNsLmwpO1xuICAgIHJldHVybiB0aW55Y29sb3IoaHNsKTtcbn1cblxuLy8gU3BpbiB0YWtlcyBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGFtb3VudCB3aXRoaW4gWy0zNjAsIDM2MF0gaW5kaWNhdGluZyB0aGUgY2hhbmdlIG9mIGh1ZS5cbi8vIFZhbHVlcyBvdXRzaWRlIG9mIHRoaXMgcmFuZ2Ugd2lsbCBiZSB3cmFwcGVkIGludG8gdGhpcyByYW5nZS5cbmZ1bmN0aW9uIHNwaW4oY29sb3IsIGFtb3VudCkge1xuICAgIHZhciBoc2wgPSB0aW55Y29sb3IoY29sb3IpLnRvSHNsKCk7XG4gICAgdmFyIGh1ZSA9IChoc2wuaCArIGFtb3VudCkgJSAzNjA7XG4gICAgaHNsLmggPSBodWUgPCAwID8gMzYwICsgaHVlIDogaHVlO1xuICAgIHJldHVybiB0aW55Y29sb3IoaHNsKTtcbn1cblxuLy8gQ29tYmluYXRpb24gRnVuY3Rpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRoYW5rcyB0byBqUXVlcnkgeENvbG9yIGZvciBzb21lIG9mIHRoZSBpZGVhcyBiZWhpbmQgdGhlc2Vcbi8vIDxodHRwczovL2dpdGh1Yi5jb20vaW5mdXNpb24valF1ZXJ5LXhjb2xvci9ibG9iL21hc3Rlci9qcXVlcnkueGNvbG9yLmpzPlxuXG5mdW5jdGlvbiBjb21wbGVtZW50KGNvbG9yKSB7XG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICBoc2wuaCA9IChoc2wuaCArIDE4MCkgJSAzNjA7XG4gICAgcmV0dXJuIHRpbnljb2xvcihoc2wpO1xufVxuXG5mdW5jdGlvbiB0cmlhZChjb2xvcikge1xuICAgIHZhciBoc2wgPSB0aW55Y29sb3IoY29sb3IpLnRvSHNsKCk7XG4gICAgdmFyIGggPSBoc2wuaDtcbiAgICByZXR1cm4gW1xuICAgICAgICB0aW55Y29sb3IoY29sb3IpLFxuICAgICAgICB0aW55Y29sb3IoeyBoOiAoaCArIDEyMCkgJSAzNjAsIHM6IGhzbC5zLCBsOiBoc2wubCB9KSxcbiAgICAgICAgdGlueWNvbG9yKHsgaDogKGggKyAyNDApICUgMzYwLCBzOiBoc2wucywgbDogaHNsLmwgfSlcbiAgICBdO1xufVxuXG5mdW5jdGlvbiB0ZXRyYWQoY29sb3IpIHtcbiAgICB2YXIgaHNsID0gdGlueWNvbG9yKGNvbG9yKS50b0hzbCgpO1xuICAgIHZhciBoID0gaHNsLmg7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgdGlueWNvbG9yKGNvbG9yKSxcbiAgICAgICAgdGlueWNvbG9yKHsgaDogKGggKyA5MCkgJSAzNjAsIHM6IGhzbC5zLCBsOiBoc2wubCB9KSxcbiAgICAgICAgdGlueWNvbG9yKHsgaDogKGggKyAxODApICUgMzYwLCBzOiBoc2wucywgbDogaHNsLmwgfSksXG4gICAgICAgIHRpbnljb2xvcih7IGg6IChoICsgMjcwKSAlIDM2MCwgczogaHNsLnMsIGw6IGhzbC5sIH0pXG4gICAgXTtcbn1cblxuZnVuY3Rpb24gc3BsaXRjb21wbGVtZW50KGNvbG9yKSB7XG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICB2YXIgaCA9IGhzbC5oO1xuICAgIHJldHVybiBbXG4gICAgICAgIHRpbnljb2xvcihjb2xvciksXG4gICAgICAgIHRpbnljb2xvcih7IGg6IChoICsgNzIpICUgMzYwLCBzOiBoc2wucywgbDogaHNsLmx9KSxcbiAgICAgICAgdGlueWNvbG9yKHsgaDogKGggKyAyMTYpICUgMzYwLCBzOiBoc2wucywgbDogaHNsLmx9KVxuICAgIF07XG59XG5cbmZ1bmN0aW9uIGFuYWxvZ291cyhjb2xvciwgcmVzdWx0cywgc2xpY2VzKSB7XG4gICAgcmVzdWx0cyA9IHJlc3VsdHMgfHwgNjtcbiAgICBzbGljZXMgPSBzbGljZXMgfHwgMzA7XG5cbiAgICB2YXIgaHNsID0gdGlueWNvbG9yKGNvbG9yKS50b0hzbCgpO1xuICAgIHZhciBwYXJ0ID0gMzYwIC8gc2xpY2VzO1xuICAgIHZhciByZXQgPSBbdGlueWNvbG9yKGNvbG9yKV07XG5cbiAgICBmb3IgKGhzbC5oID0gKChoc2wuaCAtIChwYXJ0ICogcmVzdWx0cyA+PiAxKSkgKyA3MjApICUgMzYwOyAtLXJlc3VsdHM7ICkge1xuICAgICAgICBoc2wuaCA9IChoc2wuaCArIHBhcnQpICUgMzYwO1xuICAgICAgICByZXQucHVzaCh0aW55Y29sb3IoaHNsKSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG1vbm9jaHJvbWF0aWMoY29sb3IsIHJlc3VsdHMpIHtcbiAgICByZXN1bHRzID0gcmVzdWx0cyB8fCA2O1xuICAgIHZhciBoc3YgPSB0aW55Y29sb3IoY29sb3IpLnRvSHN2KCk7XG4gICAgdmFyIGggPSBoc3YuaCwgcyA9IGhzdi5zLCB2ID0gaHN2LnY7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIHZhciBtb2RpZmljYXRpb24gPSAxIC8gcmVzdWx0cztcblxuICAgIHdoaWxlIChyZXN1bHRzLS0pIHtcbiAgICAgICAgcmV0LnB1c2godGlueWNvbG9yKHsgaDogaCwgczogcywgdjogdn0pKTtcbiAgICAgICAgdiA9ICh2ICsgbW9kaWZpY2F0aW9uKSAlIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbn1cblxuLy8gVXRpbGl0eSBGdW5jdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG50aW55Y29sb3IubWl4ID0gZnVuY3Rpb24oY29sb3IxLCBjb2xvcjIsIGFtb3VudCkge1xuICAgIGFtb3VudCA9IChhbW91bnQgPT09IDApID8gMCA6IChhbW91bnQgfHwgNTApO1xuXG4gICAgdmFyIHJnYjEgPSB0aW55Y29sb3IoY29sb3IxKS50b1JnYigpO1xuICAgIHZhciByZ2IyID0gdGlueWNvbG9yKGNvbG9yMikudG9SZ2IoKTtcblxuICAgIHZhciBwID0gYW1vdW50IC8gMTAwO1xuXG4gICAgdmFyIHJnYmEgPSB7XG4gICAgICAgIHI6ICgocmdiMi5yIC0gcmdiMS5yKSAqIHApICsgcmdiMS5yLFxuICAgICAgICBnOiAoKHJnYjIuZyAtIHJnYjEuZykgKiBwKSArIHJnYjEuZyxcbiAgICAgICAgYjogKChyZ2IyLmIgLSByZ2IxLmIpICogcCkgKyByZ2IxLmIsXG4gICAgICAgIGE6ICgocmdiMi5hIC0gcmdiMS5hKSAqIHApICsgcmdiMS5hXG4gICAgfTtcblxuICAgIHJldHVybiB0aW55Y29sb3IocmdiYSk7XG59O1xuXG5cbi8vIFJlYWRhYmlsaXR5IEZ1bmN0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyA8aHR0cDovL3d3dy53My5vcmcvVFIvMjAwOC9SRUMtV0NBRzIwLTIwMDgxMjExLyNjb250cmFzdC1yYXRpb2RlZiAoV0NBRyBWZXJzaW9uIDIpXG5cbi8vIGBjb250cmFzdGBcbi8vIEFuYWx5emUgdGhlIDIgY29sb3JzIGFuZCByZXR1cm5zIHRoZSBjb2xvciBjb250cmFzdCBkZWZpbmVkIGJ5IChXQ0FHIFZlcnNpb24gMilcbnRpbnljb2xvci5yZWFkYWJpbGl0eSA9IGZ1bmN0aW9uKGNvbG9yMSwgY29sb3IyKSB7XG4gICAgdmFyIGMxID0gdGlueWNvbG9yKGNvbG9yMSk7XG4gICAgdmFyIGMyID0gdGlueWNvbG9yKGNvbG9yMik7XG4gICAgcmV0dXJuIChNYXRoLm1heChjMS5nZXRMdW1pbmFuY2UoKSxjMi5nZXRMdW1pbmFuY2UoKSkrMC4wNSkgLyAoTWF0aC5taW4oYzEuZ2V0THVtaW5hbmNlKCksYzIuZ2V0THVtaW5hbmNlKCkpKzAuMDUpO1xufTtcblxuLy8gYGlzUmVhZGFibGVgXG4vLyBFbnN1cmUgdGhhdCBmb3JlZ3JvdW5kIGFuZCBiYWNrZ3JvdW5kIGNvbG9yIGNvbWJpbmF0aW9ucyBtZWV0IFdDQUcyIGd1aWRlbGluZXMuXG4vLyBUaGUgdGhpcmQgYXJndW1lbnQgaXMgYW4gb3B0aW9uYWwgT2JqZWN0LlxuLy8gICAgICB0aGUgJ2xldmVsJyBwcm9wZXJ0eSBzdGF0ZXMgJ0FBJyBvciAnQUFBJyAtIGlmIG1pc3Npbmcgb3IgaW52YWxpZCwgaXQgZGVmYXVsdHMgdG8gJ0FBJztcbi8vICAgICAgdGhlICdzaXplJyBwcm9wZXJ0eSBzdGF0ZXMgJ2xhcmdlJyBvciAnc21hbGwnIC0gaWYgbWlzc2luZyBvciBpbnZhbGlkLCBpdCBkZWZhdWx0cyB0byAnc21hbGwnLlxuLy8gSWYgdGhlIGVudGlyZSBvYmplY3QgaXMgYWJzZW50LCBpc1JlYWRhYmxlIGRlZmF1bHRzIHRvIHtsZXZlbDpcIkFBXCIsc2l6ZTpcInNtYWxsXCJ9LlxuXG4vLyAqRXhhbXBsZSpcbi8vICAgIHRpbnljb2xvci5pc1JlYWRhYmxlKFwiIzAwMFwiLCBcIiMxMTFcIikgPT4gZmFsc2Vcbi8vICAgIHRpbnljb2xvci5pc1JlYWRhYmxlKFwiIzAwMFwiLCBcIiMxMTFcIix7bGV2ZWw6XCJBQVwiLHNpemU6XCJsYXJnZVwifSkgPT4gZmFsc2VcbnRpbnljb2xvci5pc1JlYWRhYmxlID0gZnVuY3Rpb24oY29sb3IxLCBjb2xvcjIsIHdjYWcyKSB7XG4gICAgdmFyIHJlYWRhYmlsaXR5ID0gdGlueWNvbG9yLnJlYWRhYmlsaXR5KGNvbG9yMSwgY29sb3IyKTtcbiAgICB2YXIgd2NhZzJQYXJtcywgb3V0O1xuXG4gICAgb3V0ID0gZmFsc2U7XG5cbiAgICB3Y2FnMlBhcm1zID0gdmFsaWRhdGVXQ0FHMlBhcm1zKHdjYWcyKTtcbiAgICBzd2l0Y2ggKHdjYWcyUGFybXMubGV2ZWwgKyB3Y2FnMlBhcm1zLnNpemUpIHtcbiAgICAgICAgY2FzZSBcIkFBc21hbGxcIjpcbiAgICAgICAgY2FzZSBcIkFBQWxhcmdlXCI6XG4gICAgICAgICAgICBvdXQgPSByZWFkYWJpbGl0eSA+PSA0LjU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkFBbGFyZ2VcIjpcbiAgICAgICAgICAgIG91dCA9IHJlYWRhYmlsaXR5ID49IDM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkFBQXNtYWxsXCI6XG4gICAgICAgICAgICBvdXQgPSByZWFkYWJpbGl0eSA+PSA3O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG5cbn07XG5cbi8vIGBtb3N0UmVhZGFibGVgXG4vLyBHaXZlbiBhIGJhc2UgY29sb3IgYW5kIGEgbGlzdCBvZiBwb3NzaWJsZSBmb3JlZ3JvdW5kIG9yIGJhY2tncm91bmRcbi8vIGNvbG9ycyBmb3IgdGhhdCBiYXNlLCByZXR1cm5zIHRoZSBtb3N0IHJlYWRhYmxlIGNvbG9yLlxuLy8gT3B0aW9uYWxseSByZXR1cm5zIEJsYWNrIG9yIFdoaXRlIGlmIHRoZSBtb3N0IHJlYWRhYmxlIGNvbG9yIGlzIHVucmVhZGFibGUuXG4vLyAqRXhhbXBsZSpcbi8vICAgIHRpbnljb2xvci5tb3N0UmVhZGFibGUodGlueWNvbG9yLm1vc3RSZWFkYWJsZShcIiMxMjNcIiwgW1wiIzEyNFwiLCBcIiMxMjVcIl0se2luY2x1ZGVGYWxsYmFja0NvbG9yczpmYWxzZX0pLnRvSGV4U3RyaW5nKCk7IC8vIFwiIzExMjI1NVwiXG4vLyAgICB0aW55Y29sb3IubW9zdFJlYWRhYmxlKHRpbnljb2xvci5tb3N0UmVhZGFibGUoXCIjMTIzXCIsIFtcIiMxMjRcIiwgXCIjMTI1XCJdLHtpbmNsdWRlRmFsbGJhY2tDb2xvcnM6dHJ1ZX0pLnRvSGV4U3RyaW5nKCk7ICAvLyBcIiNmZmZmZmZcIlxuLy8gICAgdGlueWNvbG9yLm1vc3RSZWFkYWJsZShcIiNhODAxNWFcIiwgW1wiI2ZhZjNmM1wiXSx7aW5jbHVkZUZhbGxiYWNrQ29sb3JzOnRydWUsbGV2ZWw6XCJBQUFcIixzaXplOlwibGFyZ2VcIn0pLnRvSGV4U3RyaW5nKCk7IC8vIFwiI2ZhZjNmM1wiXG4vLyAgICB0aW55Y29sb3IubW9zdFJlYWRhYmxlKFwiI2E4MDE1YVwiLCBbXCIjZmFmM2YzXCJdLHtpbmNsdWRlRmFsbGJhY2tDb2xvcnM6dHJ1ZSxsZXZlbDpcIkFBQVwiLHNpemU6XCJzbWFsbFwifSkudG9IZXhTdHJpbmcoKTsgLy8gXCIjZmZmZmZmXCJcbnRpbnljb2xvci5tb3N0UmVhZGFibGUgPSBmdW5jdGlvbihiYXNlQ29sb3IsIGNvbG9yTGlzdCwgYXJncykge1xuICAgIHZhciBiZXN0Q29sb3IgPSBudWxsO1xuICAgIHZhciBiZXN0U2NvcmUgPSAwO1xuICAgIHZhciByZWFkYWJpbGl0eTtcbiAgICB2YXIgaW5jbHVkZUZhbGxiYWNrQ29sb3JzLCBsZXZlbCwgc2l6ZSA7XG4gICAgYXJncyA9IGFyZ3MgfHwge307XG4gICAgaW5jbHVkZUZhbGxiYWNrQ29sb3JzID0gYXJncy5pbmNsdWRlRmFsbGJhY2tDb2xvcnMgO1xuICAgIGxldmVsID0gYXJncy5sZXZlbDtcbiAgICBzaXplID0gYXJncy5zaXplO1xuXG4gICAgZm9yICh2YXIgaT0gMDsgaSA8IGNvbG9yTGlzdC5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgcmVhZGFiaWxpdHkgPSB0aW55Y29sb3IucmVhZGFiaWxpdHkoYmFzZUNvbG9yLCBjb2xvckxpc3RbaV0pO1xuICAgICAgICBpZiAocmVhZGFiaWxpdHkgPiBiZXN0U2NvcmUpIHtcbiAgICAgICAgICAgIGJlc3RTY29yZSA9IHJlYWRhYmlsaXR5O1xuICAgICAgICAgICAgYmVzdENvbG9yID0gdGlueWNvbG9yKGNvbG9yTGlzdFtpXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGlueWNvbG9yLmlzUmVhZGFibGUoYmFzZUNvbG9yLCBiZXN0Q29sb3IsIHtcImxldmVsXCI6bGV2ZWwsXCJzaXplXCI6c2l6ZX0pIHx8ICFpbmNsdWRlRmFsbGJhY2tDb2xvcnMpIHtcbiAgICAgICAgcmV0dXJuIGJlc3RDb2xvcjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFyZ3MuaW5jbHVkZUZhbGxiYWNrQ29sb3JzPWZhbHNlO1xuICAgICAgICByZXR1cm4gdGlueWNvbG9yLm1vc3RSZWFkYWJsZShiYXNlQ29sb3IsW1wiI2ZmZlwiLCBcIiMwMDBcIl0sYXJncyk7XG4gICAgfVxufTtcblxuXG4vLyBCaWcgTGlzdCBvZiBDb2xvcnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gPGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtY29sb3IvI3N2Zy1jb2xvcj5cbnZhciBuYW1lcyA9IHRpbnljb2xvci5uYW1lcyA9IHtcbiAgICBhbGljZWJsdWU6IFwiZjBmOGZmXCIsXG4gICAgYW50aXF1ZXdoaXRlOiBcImZhZWJkN1wiLFxuICAgIGFxdWE6IFwiMGZmXCIsXG4gICAgYXF1YW1hcmluZTogXCI3ZmZmZDRcIixcbiAgICBhenVyZTogXCJmMGZmZmZcIixcbiAgICBiZWlnZTogXCJmNWY1ZGNcIixcbiAgICBiaXNxdWU6IFwiZmZlNGM0XCIsXG4gICAgYmxhY2s6IFwiMDAwXCIsXG4gICAgYmxhbmNoZWRhbG1vbmQ6IFwiZmZlYmNkXCIsXG4gICAgYmx1ZTogXCIwMGZcIixcbiAgICBibHVldmlvbGV0OiBcIjhhMmJlMlwiLFxuICAgIGJyb3duOiBcImE1MmEyYVwiLFxuICAgIGJ1cmx5d29vZDogXCJkZWI4ODdcIixcbiAgICBidXJudHNpZW5uYTogXCJlYTdlNWRcIixcbiAgICBjYWRldGJsdWU6IFwiNWY5ZWEwXCIsXG4gICAgY2hhcnRyZXVzZTogXCI3ZmZmMDBcIixcbiAgICBjaG9jb2xhdGU6IFwiZDI2OTFlXCIsXG4gICAgY29yYWw6IFwiZmY3ZjUwXCIsXG4gICAgY29ybmZsb3dlcmJsdWU6IFwiNjQ5NWVkXCIsXG4gICAgY29ybnNpbGs6IFwiZmZmOGRjXCIsXG4gICAgY3JpbXNvbjogXCJkYzE0M2NcIixcbiAgICBjeWFuOiBcIjBmZlwiLFxuICAgIGRhcmtibHVlOiBcIjAwMDA4YlwiLFxuICAgIGRhcmtjeWFuOiBcIjAwOGI4YlwiLFxuICAgIGRhcmtnb2xkZW5yb2Q6IFwiYjg4NjBiXCIsXG4gICAgZGFya2dyYXk6IFwiYTlhOWE5XCIsXG4gICAgZGFya2dyZWVuOiBcIjAwNjQwMFwiLFxuICAgIGRhcmtncmV5OiBcImE5YTlhOVwiLFxuICAgIGRhcmtraGFraTogXCJiZGI3NmJcIixcbiAgICBkYXJrbWFnZW50YTogXCI4YjAwOGJcIixcbiAgICBkYXJrb2xpdmVncmVlbjogXCI1NTZiMmZcIixcbiAgICBkYXJrb3JhbmdlOiBcImZmOGMwMFwiLFxuICAgIGRhcmtvcmNoaWQ6IFwiOTkzMmNjXCIsXG4gICAgZGFya3JlZDogXCI4YjAwMDBcIixcbiAgICBkYXJrc2FsbW9uOiBcImU5OTY3YVwiLFxuICAgIGRhcmtzZWFncmVlbjogXCI4ZmJjOGZcIixcbiAgICBkYXJrc2xhdGVibHVlOiBcIjQ4M2Q4YlwiLFxuICAgIGRhcmtzbGF0ZWdyYXk6IFwiMmY0ZjRmXCIsXG4gICAgZGFya3NsYXRlZ3JleTogXCIyZjRmNGZcIixcbiAgICBkYXJrdHVycXVvaXNlOiBcIjAwY2VkMVwiLFxuICAgIGRhcmt2aW9sZXQ6IFwiOTQwMGQzXCIsXG4gICAgZGVlcHBpbms6IFwiZmYxNDkzXCIsXG4gICAgZGVlcHNreWJsdWU6IFwiMDBiZmZmXCIsXG4gICAgZGltZ3JheTogXCI2OTY5NjlcIixcbiAgICBkaW1ncmV5OiBcIjY5Njk2OVwiLFxuICAgIGRvZGdlcmJsdWU6IFwiMWU5MGZmXCIsXG4gICAgZmlyZWJyaWNrOiBcImIyMjIyMlwiLFxuICAgIGZsb3JhbHdoaXRlOiBcImZmZmFmMFwiLFxuICAgIGZvcmVzdGdyZWVuOiBcIjIyOGIyMlwiLFxuICAgIGZ1Y2hzaWE6IFwiZjBmXCIsXG4gICAgZ2FpbnNib3JvOiBcImRjZGNkY1wiLFxuICAgIGdob3N0d2hpdGU6IFwiZjhmOGZmXCIsXG4gICAgZ29sZDogXCJmZmQ3MDBcIixcbiAgICBnb2xkZW5yb2Q6IFwiZGFhNTIwXCIsXG4gICAgZ3JheTogXCI4MDgwODBcIixcbiAgICBncmVlbjogXCIwMDgwMDBcIixcbiAgICBncmVlbnllbGxvdzogXCJhZGZmMmZcIixcbiAgICBncmV5OiBcIjgwODA4MFwiLFxuICAgIGhvbmV5ZGV3OiBcImYwZmZmMFwiLFxuICAgIGhvdHBpbms6IFwiZmY2OWI0XCIsXG4gICAgaW5kaWFucmVkOiBcImNkNWM1Y1wiLFxuICAgIGluZGlnbzogXCI0YjAwODJcIixcbiAgICBpdm9yeTogXCJmZmZmZjBcIixcbiAgICBraGFraTogXCJmMGU2OGNcIixcbiAgICBsYXZlbmRlcjogXCJlNmU2ZmFcIixcbiAgICBsYXZlbmRlcmJsdXNoOiBcImZmZjBmNVwiLFxuICAgIGxhd25ncmVlbjogXCI3Y2ZjMDBcIixcbiAgICBsZW1vbmNoaWZmb246IFwiZmZmYWNkXCIsXG4gICAgbGlnaHRibHVlOiBcImFkZDhlNlwiLFxuICAgIGxpZ2h0Y29yYWw6IFwiZjA4MDgwXCIsXG4gICAgbGlnaHRjeWFuOiBcImUwZmZmZlwiLFxuICAgIGxpZ2h0Z29sZGVucm9keWVsbG93OiBcImZhZmFkMlwiLFxuICAgIGxpZ2h0Z3JheTogXCJkM2QzZDNcIixcbiAgICBsaWdodGdyZWVuOiBcIjkwZWU5MFwiLFxuICAgIGxpZ2h0Z3JleTogXCJkM2QzZDNcIixcbiAgICBsaWdodHBpbms6IFwiZmZiNmMxXCIsXG4gICAgbGlnaHRzYWxtb246IFwiZmZhMDdhXCIsXG4gICAgbGlnaHRzZWFncmVlbjogXCIyMGIyYWFcIixcbiAgICBsaWdodHNreWJsdWU6IFwiODdjZWZhXCIsXG4gICAgbGlnaHRzbGF0ZWdyYXk6IFwiNzg5XCIsXG4gICAgbGlnaHRzbGF0ZWdyZXk6IFwiNzg5XCIsXG4gICAgbGlnaHRzdGVlbGJsdWU6IFwiYjBjNGRlXCIsXG4gICAgbGlnaHR5ZWxsb3c6IFwiZmZmZmUwXCIsXG4gICAgbGltZTogXCIwZjBcIixcbiAgICBsaW1lZ3JlZW46IFwiMzJjZDMyXCIsXG4gICAgbGluZW46IFwiZmFmMGU2XCIsXG4gICAgbWFnZW50YTogXCJmMGZcIixcbiAgICBtYXJvb246IFwiODAwMDAwXCIsXG4gICAgbWVkaXVtYXF1YW1hcmluZTogXCI2NmNkYWFcIixcbiAgICBtZWRpdW1ibHVlOiBcIjAwMDBjZFwiLFxuICAgIG1lZGl1bW9yY2hpZDogXCJiYTU1ZDNcIixcbiAgICBtZWRpdW1wdXJwbGU6IFwiOTM3MGRiXCIsXG4gICAgbWVkaXVtc2VhZ3JlZW46IFwiM2NiMzcxXCIsXG4gICAgbWVkaXVtc2xhdGVibHVlOiBcIjdiNjhlZVwiLFxuICAgIG1lZGl1bXNwcmluZ2dyZWVuOiBcIjAwZmE5YVwiLFxuICAgIG1lZGl1bXR1cnF1b2lzZTogXCI0OGQxY2NcIixcbiAgICBtZWRpdW12aW9sZXRyZWQ6IFwiYzcxNTg1XCIsXG4gICAgbWlkbmlnaHRibHVlOiBcIjE5MTk3MFwiLFxuICAgIG1pbnRjcmVhbTogXCJmNWZmZmFcIixcbiAgICBtaXN0eXJvc2U6IFwiZmZlNGUxXCIsXG4gICAgbW9jY2FzaW46IFwiZmZlNGI1XCIsXG4gICAgbmF2YWpvd2hpdGU6IFwiZmZkZWFkXCIsXG4gICAgbmF2eTogXCIwMDAwODBcIixcbiAgICBvbGRsYWNlOiBcImZkZjVlNlwiLFxuICAgIG9saXZlOiBcIjgwODAwMFwiLFxuICAgIG9saXZlZHJhYjogXCI2YjhlMjNcIixcbiAgICBvcmFuZ2U6IFwiZmZhNTAwXCIsXG4gICAgb3JhbmdlcmVkOiBcImZmNDUwMFwiLFxuICAgIG9yY2hpZDogXCJkYTcwZDZcIixcbiAgICBwYWxlZ29sZGVucm9kOiBcImVlZThhYVwiLFxuICAgIHBhbGVncmVlbjogXCI5OGZiOThcIixcbiAgICBwYWxldHVycXVvaXNlOiBcImFmZWVlZVwiLFxuICAgIHBhbGV2aW9sZXRyZWQ6IFwiZGI3MDkzXCIsXG4gICAgcGFwYXlhd2hpcDogXCJmZmVmZDVcIixcbiAgICBwZWFjaHB1ZmY6IFwiZmZkYWI5XCIsXG4gICAgcGVydTogXCJjZDg1M2ZcIixcbiAgICBwaW5rOiBcImZmYzBjYlwiLFxuICAgIHBsdW06IFwiZGRhMGRkXCIsXG4gICAgcG93ZGVyYmx1ZTogXCJiMGUwZTZcIixcbiAgICBwdXJwbGU6IFwiODAwMDgwXCIsXG4gICAgcmViZWNjYXB1cnBsZTogXCI2NjMzOTlcIixcbiAgICByZWQ6IFwiZjAwXCIsXG4gICAgcm9zeWJyb3duOiBcImJjOGY4ZlwiLFxuICAgIHJveWFsYmx1ZTogXCI0MTY5ZTFcIixcbiAgICBzYWRkbGVicm93bjogXCI4YjQ1MTNcIixcbiAgICBzYWxtb246IFwiZmE4MDcyXCIsXG4gICAgc2FuZHlicm93bjogXCJmNGE0NjBcIixcbiAgICBzZWFncmVlbjogXCIyZThiNTdcIixcbiAgICBzZWFzaGVsbDogXCJmZmY1ZWVcIixcbiAgICBzaWVubmE6IFwiYTA1MjJkXCIsXG4gICAgc2lsdmVyOiBcImMwYzBjMFwiLFxuICAgIHNreWJsdWU6IFwiODdjZWViXCIsXG4gICAgc2xhdGVibHVlOiBcIjZhNWFjZFwiLFxuICAgIHNsYXRlZ3JheTogXCI3MDgwOTBcIixcbiAgICBzbGF0ZWdyZXk6IFwiNzA4MDkwXCIsXG4gICAgc25vdzogXCJmZmZhZmFcIixcbiAgICBzcHJpbmdncmVlbjogXCIwMGZmN2ZcIixcbiAgICBzdGVlbGJsdWU6IFwiNDY4MmI0XCIsXG4gICAgdGFuOiBcImQyYjQ4Y1wiLFxuICAgIHRlYWw6IFwiMDA4MDgwXCIsXG4gICAgdGhpc3RsZTogXCJkOGJmZDhcIixcbiAgICB0b21hdG86IFwiZmY2MzQ3XCIsXG4gICAgdHVycXVvaXNlOiBcIjQwZTBkMFwiLFxuICAgIHZpb2xldDogXCJlZTgyZWVcIixcbiAgICB3aGVhdDogXCJmNWRlYjNcIixcbiAgICB3aGl0ZTogXCJmZmZcIixcbiAgICB3aGl0ZXNtb2tlOiBcImY1ZjVmNVwiLFxuICAgIHllbGxvdzogXCJmZjBcIixcbiAgICB5ZWxsb3dncmVlbjogXCI5YWNkMzJcIlxufTtcblxuLy8gTWFrZSBpdCBlYXN5IHRvIGFjY2VzcyBjb2xvcnMgdmlhIGBoZXhOYW1lc1toZXhdYFxudmFyIGhleE5hbWVzID0gdGlueWNvbG9yLmhleE5hbWVzID0gZmxpcChuYW1lcyk7XG5cblxuLy8gVXRpbGl0aWVzXG4vLyAtLS0tLS0tLS1cblxuLy8gYHsgJ25hbWUxJzogJ3ZhbDEnIH1gIGJlY29tZXMgYHsgJ3ZhbDEnOiAnbmFtZTEnIH1gXG5mdW5jdGlvbiBmbGlwKG8pIHtcbiAgICB2YXIgZmxpcHBlZCA9IHsgfTtcbiAgICBmb3IgKHZhciBpIGluIG8pIHtcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIGZsaXBwZWRbb1tpXV0gPSBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmbGlwcGVkO1xufVxuXG4vLyBSZXR1cm4gYSB2YWxpZCBhbHBoYSB2YWx1ZSBbMCwxXSB3aXRoIGFsbCBpbnZhbGlkIHZhbHVlcyBiZWluZyBzZXQgdG8gMVxuZnVuY3Rpb24gYm91bmRBbHBoYShhKSB7XG4gICAgYSA9IHBhcnNlRmxvYXQoYSk7XG5cbiAgICBpZiAoaXNOYU4oYSkgfHwgYSA8IDAgfHwgYSA+IDEpIHtcbiAgICAgICAgYSA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG59XG5cbi8vIFRha2UgaW5wdXQgZnJvbSBbMCwgbl0gYW5kIHJldHVybiBpdCBhcyBbMCwgMV1cbmZ1bmN0aW9uIGJvdW5kMDEobiwgbWF4KSB7XG4gICAgaWYgKGlzT25lUG9pbnRaZXJvKG4pKSB7IG4gPSBcIjEwMCVcIjsgfVxuXG4gICAgdmFyIHByb2Nlc3NQZXJjZW50ID0gaXNQZXJjZW50YWdlKG4pO1xuICAgIG4gPSBtYXRoTWluKG1heCwgbWF0aE1heCgwLCBwYXJzZUZsb2F0KG4pKSk7XG5cbiAgICAvLyBBdXRvbWF0aWNhbGx5IGNvbnZlcnQgcGVyY2VudGFnZSBpbnRvIG51bWJlclxuICAgIGlmIChwcm9jZXNzUGVyY2VudCkge1xuICAgICAgICBuID0gcGFyc2VJbnQobiAqIG1heCwgMTApIC8gMTAwO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnNcbiAgICBpZiAoKE1hdGguYWJzKG4gLSBtYXgpIDwgMC4wMDAwMDEpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIC8vIENvbnZlcnQgaW50byBbMCwgMV0gcmFuZ2UgaWYgaXQgaXNuJ3QgYWxyZWFkeVxuICAgIHJldHVybiAobiAlIG1heCkgLyBwYXJzZUZsb2F0KG1heCk7XG59XG5cbi8vIEZvcmNlIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuZnVuY3Rpb24gY2xhbXAwMSh2YWwpIHtcbiAgICByZXR1cm4gbWF0aE1pbigxLCBtYXRoTWF4KDAsIHZhbCkpO1xufVxuXG4vLyBQYXJzZSBhIGJhc2UtMTYgaGV4IHZhbHVlIGludG8gYSBiYXNlLTEwIGludGVnZXJcbmZ1bmN0aW9uIHBhcnNlSW50RnJvbUhleCh2YWwpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodmFsLCAxNik7XG59XG5cbi8vIE5lZWQgdG8gaGFuZGxlIDEuMCBhcyAxMDAlLCBzaW5jZSBvbmNlIGl0IGlzIGEgbnVtYmVyLCB0aGVyZSBpcyBubyBkaWZmZXJlbmNlIGJldHdlZW4gaXQgYW5kIDFcbi8vIDxodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc0MjIwNzIvamF2YXNjcmlwdC1ob3ctdG8tZGV0ZWN0LW51bWJlci1hcy1hLWRlY2ltYWwtaW5jbHVkaW5nLTEtMD5cbmZ1bmN0aW9uIGlzT25lUG9pbnRaZXJvKG4pIHtcbiAgICByZXR1cm4gdHlwZW9mIG4gPT0gXCJzdHJpbmdcIiAmJiBuLmluZGV4T2YoJy4nKSAhPSAtMSAmJiBwYXJzZUZsb2F0KG4pID09PSAxO1xufVxuXG4vLyBDaGVjayB0byBzZWUgaWYgc3RyaW5nIHBhc3NlZCBpbiBpcyBhIHBlcmNlbnRhZ2VcbmZ1bmN0aW9uIGlzUGVyY2VudGFnZShuKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBuID09PSBcInN0cmluZ1wiICYmIG4uaW5kZXhPZignJScpICE9IC0xO1xufVxuXG4vLyBGb3JjZSBhIGhleCB2YWx1ZSB0byBoYXZlIDIgY2hhcmFjdGVyc1xuZnVuY3Rpb24gcGFkMihjKSB7XG4gICAgcmV0dXJuIGMubGVuZ3RoID09IDEgPyAnMCcgKyBjIDogJycgKyBjO1xufVxuXG4vLyBSZXBsYWNlIGEgZGVjaW1hbCB3aXRoIGl0J3MgcGVyY2VudGFnZSB2YWx1ZVxuZnVuY3Rpb24gY29udmVydFRvUGVyY2VudGFnZShuKSB7XG4gICAgaWYgKG4gPD0gMSkge1xuICAgICAgICBuID0gKG4gKiAxMDApICsgXCIlXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIG47XG59XG5cbi8vIENvbnZlcnRzIGEgZGVjaW1hbCB0byBhIGhleCB2YWx1ZVxuZnVuY3Rpb24gY29udmVydERlY2ltYWxUb0hleChkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQocGFyc2VGbG9hdChkKSAqIDI1NSkudG9TdHJpbmcoMTYpO1xufVxuLy8gQ29udmVydHMgYSBoZXggdmFsdWUgdG8gYSBkZWNpbWFsXG5mdW5jdGlvbiBjb252ZXJ0SGV4VG9EZWNpbWFsKGgpIHtcbiAgICByZXR1cm4gKHBhcnNlSW50RnJvbUhleChoKSAvIDI1NSk7XG59XG5cbnZhciBtYXRjaGVycyA9IChmdW5jdGlvbigpIHtcblxuICAgIC8vIDxodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXZhbHVlcy8jaW50ZWdlcnM+XG4gICAgdmFyIENTU19JTlRFR0VSID0gXCJbLVxcXFwrXT9cXFxcZCslP1wiO1xuXG4gICAgLy8gPGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtdmFsdWVzLyNudW1iZXItdmFsdWU+XG4gICAgdmFyIENTU19OVU1CRVIgPSBcIlstXFxcXCtdP1xcXFxkKlxcXFwuXFxcXGQrJT9cIjtcblxuICAgIC8vIEFsbG93IHBvc2l0aXZlL25lZ2F0aXZlIGludGVnZXIvbnVtYmVyLiAgRG9uJ3QgY2FwdHVyZSB0aGUgZWl0aGVyL29yLCBqdXN0IHRoZSBlbnRpcmUgb3V0Y29tZS5cbiAgICB2YXIgQ1NTX1VOSVQgPSBcIig/OlwiICsgQ1NTX05VTUJFUiArIFwiKXwoPzpcIiArIENTU19JTlRFR0VSICsgXCIpXCI7XG5cbiAgICAvLyBBY3R1YWwgbWF0Y2hpbmcuXG4gICAgLy8gUGFyZW50aGVzZXMgYW5kIGNvbW1hcyBhcmUgb3B0aW9uYWwsIGJ1dCBub3QgcmVxdWlyZWQuXG4gICAgLy8gV2hpdGVzcGFjZSBjYW4gdGFrZSB0aGUgcGxhY2Ugb2YgY29tbWFzIG9yIG9wZW5pbmcgcGFyZW5cbiAgICB2YXIgUEVSTUlTU0lWRV9NQVRDSDMgPSBcIltcXFxcc3xcXFxcKF0rKFwiICsgQ1NTX1VOSVQgKyBcIilbLHxcXFxcc10rKFwiICsgQ1NTX1VOSVQgKyBcIilbLHxcXFxcc10rKFwiICsgQ1NTX1VOSVQgKyBcIilcXFxccypcXFxcKT9cIjtcbiAgICB2YXIgUEVSTUlTU0lWRV9NQVRDSDQgPSBcIltcXFxcc3xcXFxcKF0rKFwiICsgQ1NTX1VOSVQgKyBcIilbLHxcXFxcc10rKFwiICsgQ1NTX1VOSVQgKyBcIilbLHxcXFxcc10rKFwiICsgQ1NTX1VOSVQgKyBcIilbLHxcXFxcc10rKFwiICsgQ1NTX1VOSVQgKyBcIilcXFxccypcXFxcKT9cIjtcblxuICAgIHJldHVybiB7XG4gICAgICAgIENTU19VTklUOiBuZXcgUmVnRXhwKENTU19VTklUKSxcbiAgICAgICAgcmdiOiBuZXcgUmVnRXhwKFwicmdiXCIgKyBQRVJNSVNTSVZFX01BVENIMyksXG4gICAgICAgIHJnYmE6IG5ldyBSZWdFeHAoXCJyZ2JhXCIgKyBQRVJNSVNTSVZFX01BVENINCksXG4gICAgICAgIGhzbDogbmV3IFJlZ0V4cChcImhzbFwiICsgUEVSTUlTU0lWRV9NQVRDSDMpLFxuICAgICAgICBoc2xhOiBuZXcgUmVnRXhwKFwiaHNsYVwiICsgUEVSTUlTU0lWRV9NQVRDSDQpLFxuICAgICAgICBoc3Y6IG5ldyBSZWdFeHAoXCJoc3ZcIiArIFBFUk1JU1NJVkVfTUFUQ0gzKSxcbiAgICAgICAgaHN2YTogbmV3IFJlZ0V4cChcImhzdmFcIiArIFBFUk1JU1NJVkVfTUFUQ0g0KSxcbiAgICAgICAgaGV4MzogL14jPyhbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KSQvLFxuICAgICAgICBoZXg2OiAvXiM/KFswLTlhLWZBLUZdezJ9KShbMC05YS1mQS1GXXsyfSkoWzAtOWEtZkEtRl17Mn0pJC8sXG4gICAgICAgIGhleDQ6IC9eIz8oWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pJC8sXG4gICAgICAgIGhleDg6IC9eIz8oWzAtOWEtZkEtRl17Mn0pKFswLTlhLWZBLUZdezJ9KShbMC05YS1mQS1GXXsyfSkoWzAtOWEtZkEtRl17Mn0pJC9cbiAgICB9O1xufSkoKTtcblxuLy8gYGlzVmFsaWRDU1NVbml0YFxuLy8gVGFrZSBpbiBhIHNpbmdsZSBzdHJpbmcgLyBudW1iZXIgYW5kIGNoZWNrIHRvIHNlZSBpZiBpdCBsb29rcyBsaWtlIGEgQ1NTIHVuaXRcbi8vIChzZWUgYG1hdGNoZXJzYCBhYm92ZSBmb3IgZGVmaW5pdGlvbikuXG5mdW5jdGlvbiBpc1ZhbGlkQ1NTVW5pdChjb2xvcikge1xuICAgIHJldHVybiAhIW1hdGNoZXJzLkNTU19VTklULmV4ZWMoY29sb3IpO1xufVxuXG4vLyBgc3RyaW5nSW5wdXRUb09iamVjdGBcbi8vIFBlcm1pc3NpdmUgc3RyaW5nIHBhcnNpbmcuICBUYWtlIGluIGEgbnVtYmVyIG9mIGZvcm1hdHMsIGFuZCBvdXRwdXQgYW4gb2JqZWN0XG4vLyBiYXNlZCBvbiBkZXRlY3RlZCBmb3JtYXQuICBSZXR1cm5zIGB7IHIsIGcsIGIgfWAgb3IgYHsgaCwgcywgbCB9YCBvciBgeyBoLCBzLCB2fWBcbmZ1bmN0aW9uIHN0cmluZ0lucHV0VG9PYmplY3QoY29sb3IpIHtcblxuICAgIGNvbG9yID0gY29sb3IucmVwbGFjZSh0cmltTGVmdCwnJykucmVwbGFjZSh0cmltUmlnaHQsICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBuYW1lZCA9IGZhbHNlO1xuICAgIGlmIChuYW1lc1tjb2xvcl0pIHtcbiAgICAgICAgY29sb3IgPSBuYW1lc1tjb2xvcl07XG4gICAgICAgIG5hbWVkID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29sb3IgPT0gJ3RyYW5zcGFyZW50Jykge1xuICAgICAgICByZXR1cm4geyByOiAwLCBnOiAwLCBiOiAwLCBhOiAwLCBmb3JtYXQ6IFwibmFtZVwiIH07XG4gICAgfVxuXG4gICAgLy8gVHJ5IHRvIG1hdGNoIHN0cmluZyBpbnB1dCB1c2luZyByZWd1bGFyIGV4cHJlc3Npb25zLlxuICAgIC8vIEtlZXAgbW9zdCBvZiB0aGUgbnVtYmVyIGJvdW5kaW5nIG91dCBvZiB0aGlzIGZ1bmN0aW9uIC0gZG9uJ3Qgd29ycnkgYWJvdXQgWzAsMV0gb3IgWzAsMTAwXSBvciBbMCwzNjBdXG4gICAgLy8gSnVzdCByZXR1cm4gYW4gb2JqZWN0IGFuZCBsZXQgdGhlIGNvbnZlcnNpb24gZnVuY3Rpb25zIGhhbmRsZSB0aGF0LlxuICAgIC8vIFRoaXMgd2F5IHRoZSByZXN1bHQgd2lsbCBiZSB0aGUgc2FtZSB3aGV0aGVyIHRoZSB0aW55Y29sb3IgaXMgaW5pdGlhbGl6ZWQgd2l0aCBzdHJpbmcgb3Igb2JqZWN0LlxuICAgIHZhciBtYXRjaDtcbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMucmdiLmV4ZWMoY29sb3IpKSkge1xuICAgICAgICByZXR1cm4geyByOiBtYXRjaFsxXSwgZzogbWF0Y2hbMl0sIGI6IG1hdGNoWzNdIH07XG4gICAgfVxuICAgIGlmICgobWF0Y2ggPSBtYXRjaGVycy5yZ2JhLmV4ZWMoY29sb3IpKSkge1xuICAgICAgICByZXR1cm4geyByOiBtYXRjaFsxXSwgZzogbWF0Y2hbMl0sIGI6IG1hdGNoWzNdLCBhOiBtYXRjaFs0XSB9O1xuICAgIH1cbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMuaHNsLmV4ZWMoY29sb3IpKSkge1xuICAgICAgICByZXR1cm4geyBoOiBtYXRjaFsxXSwgczogbWF0Y2hbMl0sIGw6IG1hdGNoWzNdIH07XG4gICAgfVxuICAgIGlmICgobWF0Y2ggPSBtYXRjaGVycy5oc2xhLmV4ZWMoY29sb3IpKSkge1xuICAgICAgICByZXR1cm4geyBoOiBtYXRjaFsxXSwgczogbWF0Y2hbMl0sIGw6IG1hdGNoWzNdLCBhOiBtYXRjaFs0XSB9O1xuICAgIH1cbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMuaHN2LmV4ZWMoY29sb3IpKSkge1xuICAgICAgICByZXR1cm4geyBoOiBtYXRjaFsxXSwgczogbWF0Y2hbMl0sIHY6IG1hdGNoWzNdIH07XG4gICAgfVxuICAgIGlmICgobWF0Y2ggPSBtYXRjaGVycy5oc3ZhLmV4ZWMoY29sb3IpKSkge1xuICAgICAgICByZXR1cm4geyBoOiBtYXRjaFsxXSwgczogbWF0Y2hbMl0sIHY6IG1hdGNoWzNdLCBhOiBtYXRjaFs0XSB9O1xuICAgIH1cbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMuaGV4OC5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHI6IHBhcnNlSW50RnJvbUhleChtYXRjaFsxXSksXG4gICAgICAgICAgICBnOiBwYXJzZUludEZyb21IZXgobWF0Y2hbMl0pLFxuICAgICAgICAgICAgYjogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzNdKSxcbiAgICAgICAgICAgIGE6IGNvbnZlcnRIZXhUb0RlY2ltYWwobWF0Y2hbNF0pLFxuICAgICAgICAgICAgZm9ybWF0OiBuYW1lZCA/IFwibmFtZVwiIDogXCJoZXg4XCJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLmhleDYuZXhlYyhjb2xvcikpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByOiBwYXJzZUludEZyb21IZXgobWF0Y2hbMV0pLFxuICAgICAgICAgICAgZzogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzJdKSxcbiAgICAgICAgICAgIGI6IHBhcnNlSW50RnJvbUhleChtYXRjaFszXSksXG4gICAgICAgICAgICBmb3JtYXQ6IG5hbWVkID8gXCJuYW1lXCIgOiBcImhleFwiXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICgobWF0Y2ggPSBtYXRjaGVycy5oZXg0LmV4ZWMoY29sb3IpKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcjogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzFdICsgJycgKyBtYXRjaFsxXSksXG4gICAgICAgICAgICBnOiBwYXJzZUludEZyb21IZXgobWF0Y2hbMl0gKyAnJyArIG1hdGNoWzJdKSxcbiAgICAgICAgICAgIGI6IHBhcnNlSW50RnJvbUhleChtYXRjaFszXSArICcnICsgbWF0Y2hbM10pLFxuICAgICAgICAgICAgYTogY29udmVydEhleFRvRGVjaW1hbChtYXRjaFs0XSArICcnICsgbWF0Y2hbNF0pLFxuICAgICAgICAgICAgZm9ybWF0OiBuYW1lZCA/IFwibmFtZVwiIDogXCJoZXg4XCJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLmhleDMuZXhlYyhjb2xvcikpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByOiBwYXJzZUludEZyb21IZXgobWF0Y2hbMV0gKyAnJyArIG1hdGNoWzFdKSxcbiAgICAgICAgICAgIGc6IHBhcnNlSW50RnJvbUhleChtYXRjaFsyXSArICcnICsgbWF0Y2hbMl0pLFxuICAgICAgICAgICAgYjogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzNdICsgJycgKyBtYXRjaFszXSksXG4gICAgICAgICAgICBmb3JtYXQ6IG5hbWVkID8gXCJuYW1lXCIgOiBcImhleFwiXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVdDQUcyUGFybXMocGFybXMpIHtcbiAgICAvLyByZXR1cm4gdmFsaWQgV0NBRzIgcGFybXMgZm9yIGlzUmVhZGFibGUuXG4gICAgLy8gSWYgaW5wdXQgcGFybXMgYXJlIGludmFsaWQsIHJldHVybiB7XCJsZXZlbFwiOlwiQUFcIiwgXCJzaXplXCI6XCJzbWFsbFwifVxuICAgIHZhciBsZXZlbCwgc2l6ZTtcbiAgICBwYXJtcyA9IHBhcm1zIHx8IHtcImxldmVsXCI6XCJBQVwiLCBcInNpemVcIjpcInNtYWxsXCJ9O1xuICAgIGxldmVsID0gKHBhcm1zLmxldmVsIHx8IFwiQUFcIikudG9VcHBlckNhc2UoKTtcbiAgICBzaXplID0gKHBhcm1zLnNpemUgfHwgXCJzbWFsbFwiKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsZXZlbCAhPT0gXCJBQVwiICYmIGxldmVsICE9PSBcIkFBQVwiKSB7XG4gICAgICAgIGxldmVsID0gXCJBQVwiO1xuICAgIH1cbiAgICBpZiAoc2l6ZSAhPT0gXCJzbWFsbFwiICYmIHNpemUgIT09IFwibGFyZ2VcIikge1xuICAgICAgICBzaXplID0gXCJzbWFsbFwiO1xuICAgIH1cbiAgICByZXR1cm4ge1wibGV2ZWxcIjpsZXZlbCwgXCJzaXplXCI6c2l6ZX07XG59XG5cbi8vIE5vZGU6IEV4cG9ydCBmdW5jdGlvblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRpbnljb2xvcjtcbn1cbi8vIEFNRC9yZXF1aXJlanM6IERlZmluZSB0aGUgbW9kdWxlXG5lbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkge3JldHVybiB0aW55Y29sb3I7fSk7XG59XG4vLyBCcm93c2VyOiBFeHBvc2UgdG8gd2luZG93XG5lbHNlIHtcbiAgICB3aW5kb3cudGlueWNvbG9yID0gdGlueWNvbG9yO1xufVxuXG59KShNYXRoKTtcbiIsIlxudmFyIHppcCA9IHJlcXVpcmUoJ3ppcCcpO1xuXG5mdW5jdGlvbiBjcmVhdGVVcmwoc3JjKXtcbiAgdmFyIGJsb2IgPSBuZXcgQmxvYihbc3JjXSwgeyB0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcgfSk7XG4gIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xufVxuXG52YXIgeldvcmtlciA9IGNyZWF0ZVVybChcIi8qIGpzaGludCB3b3JrZXI6dHJ1ZSAqL1xcbihmdW5jdGlvbiBtYWluKGdsb2JhbCkge1xcblxcdFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG5cXHRpZiAoZ2xvYmFsLnpXb3JrZXJJbml0aWFsaXplZClcXG5cXHRcXHR0aHJvdyBuZXcgRXJyb3IoJ3otd29ya2VyLmpzIHNob3VsZCBiZSBydW4gb25seSBvbmNlJyk7XFxuXFx0Z2xvYmFsLnpXb3JrZXJJbml0aWFsaXplZCA9IHRydWU7XFxuXFxuXFx0YWRkRXZlbnRMaXN0ZW5lcihcXFwibWVzc2FnZVxcXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XFxuXFx0XFx0dmFyIG1lc3NhZ2UgPSBldmVudC5kYXRhLCB0eXBlID0gbWVzc2FnZS50eXBlLCBzbiA9IG1lc3NhZ2Uuc247XFxuXFx0XFx0dmFyIGhhbmRsZXIgPSBoYW5kbGVyc1t0eXBlXTtcXG5cXHRcXHRpZiAoaGFuZGxlcikge1xcblxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0aGFuZGxlcihtZXNzYWdlKTtcXG5cXHRcXHRcXHR9IGNhdGNoIChlKSB7XFxuXFx0XFx0XFx0XFx0b25FcnJvcih0eXBlLCBzbiwgZSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHRcXHQvL2ZvciBkZWJ1Z1xcblxcdFxcdC8vcG9zdE1lc3NhZ2Uoe3R5cGU6ICdlY2hvJywgb3JpZ2luYWxUeXBlOiB0eXBlLCBzbjogc259KTtcXG5cXHR9KTtcXG5cXG5cXHR2YXIgaGFuZGxlcnMgPSB7XFxuXFx0XFx0aW1wb3J0U2NyaXB0czogZG9JbXBvcnRTY3JpcHRzLFxcblxcdFxcdG5ld1Rhc2s6IG5ld1Rhc2ssXFxuXFx0XFx0YXBwZW5kOiBwcm9jZXNzRGF0YSxcXG5cXHRcXHRmbHVzaDogcHJvY2Vzc0RhdGEsXFxuXFx0fTtcXG5cXG5cXHQvLyBkZWZsYXRlci9pbmZsYXRlciB0YXNrcyBpbmRleGVkIGJ5IHNlcmlhbCBudW1iZXJzXFxuXFx0dmFyIHRhc2tzID0ge307XFxuXFxuXFx0ZnVuY3Rpb24gZG9JbXBvcnRTY3JpcHRzKG1zZykge1xcblxcdFxcdGlmIChtc2cuc2NyaXB0cyAmJiBtc2cuc2NyaXB0cy5sZW5ndGggPiAwKVxcblxcdFxcdFxcdGltcG9ydFNjcmlwdHMuYXBwbHkodW5kZWZpbmVkLCBtc2cuc2NyaXB0cyk7XFxuXFx0XFx0cG9zdE1lc3NhZ2Uoe3R5cGU6ICdpbXBvcnRTY3JpcHRzJ30pO1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBuZXdUYXNrKG1zZykge1xcblxcdFxcdHZhciBDb2RlY0NsYXNzID0gZ2xvYmFsW21zZy5jb2RlY0NsYXNzXTtcXG5cXHRcXHR2YXIgc24gPSBtc2cuc247XFxuXFx0XFx0aWYgKHRhc2tzW3NuXSlcXG5cXHRcXHRcXHR0aHJvdyBFcnJvcignZHVwbGljYXRlZCBzbicpO1xcblxcdFxcdHRhc2tzW3NuXSA9ICB7XFxuXFx0XFx0XFx0Y29kZWM6IG5ldyBDb2RlY0NsYXNzKG1zZy5vcHRpb25zKSxcXG5cXHRcXHRcXHRjcmNJbnB1dDogbXNnLmNyY1R5cGUgPT09ICdpbnB1dCcsXFxuXFx0XFx0XFx0Y3JjT3V0cHV0OiBtc2cuY3JjVHlwZSA9PT0gJ291dHB1dCcsXFxuXFx0XFx0XFx0Y3JjOiBuZXcgQ3JjMzIoKSxcXG5cXHRcXHR9O1xcblxcdFxcdHBvc3RNZXNzYWdlKHt0eXBlOiAnbmV3VGFzaycsIHNuOiBzbn0pO1xcblxcdH1cXG5cXG5cXHQvLyBwZXJmb3JtYW5jZSBtYXkgbm90IGJlIHN1cHBvcnRlZFxcblxcdHZhciBub3cgPSBnbG9iYWwucGVyZm9ybWFuY2UgPyBnbG9iYWwucGVyZm9ybWFuY2Uubm93LmJpbmQoZ2xvYmFsLnBlcmZvcm1hbmNlKSA6IERhdGUubm93O1xcblxcblxcdGZ1bmN0aW9uIHByb2Nlc3NEYXRhKG1zZykge1xcblxcdFxcdHZhciBzbiA9IG1zZy5zbiwgdHlwZSA9IG1zZy50eXBlLCBpbnB1dCA9IG1zZy5kYXRhO1xcblxcdFxcdHZhciB0YXNrID0gdGFza3Nbc25dO1xcblxcdFxcdC8vIGFsbG93IGNyZWF0aW5nIGNvZGVjIG9uIGZpcnN0IGFwcGVuZFxcblxcdFxcdGlmICghdGFzayAmJiBtc2cuY29kZWNDbGFzcykge1xcblxcdFxcdFxcdG5ld1Rhc2sobXNnKTtcXG5cXHRcXHRcXHR0YXNrID0gdGFza3Nbc25dO1xcblxcdFxcdH1cXG5cXHRcXHR2YXIgaXNBcHBlbmQgPSB0eXBlID09PSAnYXBwZW5kJztcXG5cXHRcXHR2YXIgc3RhcnQgPSBub3coKTtcXG5cXHRcXHR2YXIgb3V0cHV0O1xcblxcdFxcdGlmIChpc0FwcGVuZCkge1xcblxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0b3V0cHV0ID0gdGFzay5jb2RlYy5hcHBlbmQoaW5wdXQsIGZ1bmN0aW9uIG9ucHJvZ3Jlc3MobG9hZGVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0cG9zdE1lc3NhZ2Uoe3R5cGU6ICdwcm9ncmVzcycsIHNuOiBzbiwgbG9hZGVkOiBsb2FkZWR9KTtcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR9IGNhdGNoIChlKSB7XFxuXFx0XFx0XFx0XFx0ZGVsZXRlIHRhc2tzW3NuXTtcXG5cXHRcXHRcXHRcXHR0aHJvdyBlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdGRlbGV0ZSB0YXNrc1tzbl07XFxuXFx0XFx0XFx0b3V0cHV0ID0gdGFzay5jb2RlYy5mbHVzaCgpO1xcblxcdFxcdH1cXG5cXHRcXHR2YXIgY29kZWNUaW1lID0gbm93KCkgLSBzdGFydDtcXG5cXG5cXHRcXHRzdGFydCA9IG5vdygpO1xcblxcdFxcdGlmIChpbnB1dCAmJiB0YXNrLmNyY0lucHV0KVxcblxcdFxcdFxcdHRhc2suY3JjLmFwcGVuZChpbnB1dCk7XFxuXFx0XFx0aWYgKG91dHB1dCAmJiB0YXNrLmNyY091dHB1dClcXG5cXHRcXHRcXHR0YXNrLmNyYy5hcHBlbmQob3V0cHV0KTtcXG5cXHRcXHR2YXIgY3JjVGltZSA9IG5vdygpIC0gc3RhcnQ7XFxuXFxuXFx0XFx0dmFyIHJtc2cgPSB7dHlwZTogdHlwZSwgc246IHNuLCBjb2RlY1RpbWU6IGNvZGVjVGltZSwgY3JjVGltZTogY3JjVGltZX07XFxuXFx0XFx0dmFyIHRyYW5zZmVyYWJsZXMgPSBbXTtcXG5cXHRcXHRpZiAob3V0cHV0KSB7XFxuXFx0XFx0XFx0cm1zZy5kYXRhID0gb3V0cHV0O1xcblxcdFxcdFxcdHRyYW5zZmVyYWJsZXMucHVzaChvdXRwdXQuYnVmZmVyKTtcXG5cXHRcXHR9XFxuXFx0XFx0aWYgKCFpc0FwcGVuZCAmJiAodGFzay5jcmNJbnB1dCB8fCB0YXNrLmNyY091dHB1dCkpXFxuXFx0XFx0XFx0cm1zZy5jcmMgPSB0YXNrLmNyYy5nZXQoKTtcXG5cXHRcXHRcXG5cXHRcXHQvLyBwb3N0aW5nIGEgbWVzc2FnZSB3aXRoIHRyYW5zZmVyYWJsZXMgd2lsbCBmYWlsIG9uIElFMTBcXG5cXHRcXHR0cnkge1xcblxcdFxcdFxcdHBvc3RNZXNzYWdlKHJtc2csIHRyYW5zZmVyYWJsZXMpO1xcblxcdFxcdH0gY2F0Y2goZXgpIHtcXG5cXHRcXHRcXHRwb3N0TWVzc2FnZShybXNnKTsgLy8gcmV0cnkgd2l0aG91dCB0cmFuc2ZlcmFibGVzXFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBvbkVycm9yKHR5cGUsIHNuLCBlKSB7XFxuXFx0XFx0dmFyIG1zZyA9IHtcXG5cXHRcXHRcXHR0eXBlOiB0eXBlLFxcblxcdFxcdFxcdHNuOiBzbixcXG5cXHRcXHRcXHRlcnJvcjogZm9ybWF0RXJyb3IoZSlcXG5cXHRcXHR9O1xcblxcdFxcdHBvc3RNZXNzYWdlKG1zZyk7XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGZvcm1hdEVycm9yKGUpIHtcXG5cXHRcXHRyZXR1cm4geyBtZXNzYWdlOiBlLm1lc3NhZ2UsIHN0YWNrOiBlLnN0YWNrIH07XFxuXFx0fVxcblxcblxcdC8vIENyYzMyIGNvZGUgY29waWVkIGZyb20gZmlsZSB6aXAuanNcXG5cXHRmdW5jdGlvbiBDcmMzMigpIHtcXG5cXHRcXHR0aGlzLmNyYyA9IC0xO1xcblxcdH1cXG5cXHRDcmMzMi5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKGRhdGEpIHtcXG5cXHRcXHR2YXIgY3JjID0gdGhpcy5jcmMgfCAwLCB0YWJsZSA9IHRoaXMudGFibGU7XFxuXFx0XFx0Zm9yICh2YXIgb2Zmc2V0ID0gMCwgbGVuID0gZGF0YS5sZW5ndGggfCAwOyBvZmZzZXQgPCBsZW47IG9mZnNldCsrKVxcblxcdFxcdFxcdGNyYyA9IChjcmMgPj4+IDgpIF4gdGFibGVbKGNyYyBeIGRhdGFbb2Zmc2V0XSkgJiAweEZGXTtcXG5cXHRcXHR0aGlzLmNyYyA9IGNyYztcXG5cXHR9O1xcblxcdENyYzMyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQoKSB7XFxuXFx0XFx0cmV0dXJuIH50aGlzLmNyYztcXG5cXHR9O1xcblxcdENyYzMyLnByb3RvdHlwZS50YWJsZSA9IChmdW5jdGlvbigpIHtcXG5cXHRcXHR2YXIgaSwgaiwgdCwgdGFibGUgPSBbXTsgLy8gVWludDMyQXJyYXkgaXMgYWN0dWFsbHkgc2xvd2VyIHRoYW4gW11cXG5cXHRcXHRmb3IgKGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcXG5cXHRcXHRcXHR0ID0gaTtcXG5cXHRcXHRcXHRmb3IgKGogPSAwOyBqIDwgODsgaisrKVxcblxcdFxcdFxcdFxcdGlmICh0ICYgMSlcXG5cXHRcXHRcXHRcXHRcXHR0ID0gKHQgPj4+IDEpIF4gMHhFREI4ODMyMDtcXG5cXHRcXHRcXHRcXHRlbHNlXFxuXFx0XFx0XFx0XFx0XFx0dCA9IHQgPj4+IDE7XFxuXFx0XFx0XFx0dGFibGVbaV0gPSB0O1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gdGFibGU7XFxuXFx0fSkoKTtcXG5cXG5cXHQvLyBcXFwibm8tb3BcXFwiIGNvZGVjXFxuXFx0ZnVuY3Rpb24gTk9PUCgpIHt9XFxuXFx0Z2xvYmFsLk5PT1AgPSBOT09QO1xcblxcdE5PT1AucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZChieXRlcywgb25wcm9ncmVzcykge1xcblxcdFxcdHJldHVybiBieXRlcztcXG5cXHR9O1xcblxcdE5PT1AucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gZmx1c2goKSB7fTtcXG59KSh0aGlzKTtcXG5cIik7XG56aXAud29ya2VyU2NyaXB0cyA9IHtcbiAgZGVmbGF0ZXI6IFt6V29ya2VyLCBjcmVhdGVVcmwoXCIvKlxcbiBDb3B5cmlnaHQgKGMpIDIwMTMgR2lsZGFzIExvcm1lYXUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXFxuXFxuIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxcbiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcXG5cXG4gMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxcbiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxcblxcbiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBcXG4gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIFxcbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cXG5cXG4gMy4gVGhlIG5hbWVzIG9mIHRoZSBhdXRob3JzIG1heSBub3QgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHNcXG4gZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXFxuXFxuIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgYGBBUyBJUycnIEFORCBBTlkgRVhQUkVTU0VEIE9SIElNUExJRUQgV0FSUkFOVElFUyxcXG4gSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORFxcbiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgSkNSQUZULFxcbiBJTkMuIE9SIEFOWSBDT05UUklCVVRPUlMgVE8gVEhJUyBTT0ZUV0FSRSBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULFxcbiBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXFxuIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLFxcbiBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXFxuIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXFxuIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSxcXG4gRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cXG4gKi9cXG5cXG4vKlxcbiAqIFRoaXMgcHJvZ3JhbSBpcyBiYXNlZCBvbiBKWmxpYiAxLjAuMiB5bW5rLCBKQ3JhZnQsSW5jLlxcbiAqIEpabGliIGlzIGJhc2VkIG9uIHpsaWItMS4xLjMsIHNvIGFsbCBjcmVkaXQgc2hvdWxkIGdvIGF1dGhvcnNcXG4gKiBKZWFuLWxvdXAgR2FpbGx5KGpsb3VwQGd6aXAub3JnKSBhbmQgTWFyayBBZGxlcihtYWRsZXJAYWx1bW5pLmNhbHRlY2guZWR1KVxcbiAqIGFuZCBjb250cmlidXRvcnMgb2YgemxpYi5cXG4gKi9cXG5cXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XFxuXFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdC8vIEdsb2JhbFxcblxcblxcdHZhciBNQVhfQklUUyA9IDE1O1xcblxcdHZhciBEX0NPREVTID0gMzA7XFxuXFx0dmFyIEJMX0NPREVTID0gMTk7XFxuXFxuXFx0dmFyIExFTkdUSF9DT0RFUyA9IDI5O1xcblxcdHZhciBMSVRFUkFMUyA9IDI1NjtcXG5cXHR2YXIgTF9DT0RFUyA9IChMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVMpO1xcblxcdHZhciBIRUFQX1NJWkUgPSAoMiAqIExfQ09ERVMgKyAxKTtcXG5cXG5cXHR2YXIgRU5EX0JMT0NLID0gMjU2O1xcblxcblxcdC8vIEJpdCBsZW5ndGggY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CTF9CSVRTIGJpdHNcXG5cXHR2YXIgTUFYX0JMX0JJVFMgPSA3O1xcblxcblxcdC8vIHJlcGVhdCBwcmV2aW91cyBiaXQgbGVuZ3RoIDMtNiB0aW1lcyAoMiBiaXRzIG9mIHJlcGVhdCBjb3VudClcXG5cXHR2YXIgUkVQXzNfNiA9IDE2O1xcblxcblxcdC8vIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDMtMTAgdGltZXMgKDMgYml0cyBvZiByZXBlYXQgY291bnQpXFxuXFx0dmFyIFJFUFpfM18xMCA9IDE3O1xcblxcblxcdC8vIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDExLTEzOCB0aW1lcyAoNyBiaXRzIG9mIHJlcGVhdCBjb3VudClcXG5cXHR2YXIgUkVQWl8xMV8xMzggPSAxODtcXG5cXG5cXHQvLyBUaGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcyBhcmUgc2VudCBpbiBvcmRlciBvZiBkZWNyZWFzaW5nXFxuXFx0Ly8gcHJvYmFiaWxpdHksIHRvIGF2b2lkIHRyYW5zbWl0dGluZyB0aGUgbGVuZ3RocyBmb3IgdW51c2VkIGJpdFxcblxcdC8vIGxlbmd0aCBjb2Rlcy5cXG5cXG5cXHR2YXIgQnVmX3NpemUgPSA4ICogMjtcXG5cXG5cXHQvLyBKWmxpYiB2ZXJzaW9uIDogXFxcIjEuMC4yXFxcIlxcblxcdHZhciBaX0RFRkFVTFRfQ09NUFJFU1NJT04gPSAtMTtcXG5cXG5cXHQvLyBjb21wcmVzc2lvbiBzdHJhdGVneVxcblxcdHZhciBaX0ZJTFRFUkVEID0gMTtcXG5cXHR2YXIgWl9IVUZGTUFOX09OTFkgPSAyO1xcblxcdHZhciBaX0RFRkFVTFRfU1RSQVRFR1kgPSAwO1xcblxcblxcdHZhciBaX05PX0ZMVVNIID0gMDtcXG5cXHR2YXIgWl9QQVJUSUFMX0ZMVVNIID0gMTtcXG5cXHR2YXIgWl9GVUxMX0ZMVVNIID0gMztcXG5cXHR2YXIgWl9GSU5JU0ggPSA0O1xcblxcblxcdHZhciBaX09LID0gMDtcXG5cXHR2YXIgWl9TVFJFQU1fRU5EID0gMTtcXG5cXHR2YXIgWl9ORUVEX0RJQ1QgPSAyO1xcblxcdHZhciBaX1NUUkVBTV9FUlJPUiA9IC0yO1xcblxcdHZhciBaX0RBVEFfRVJST1IgPSAtMztcXG5cXHR2YXIgWl9CVUZfRVJST1IgPSAtNTtcXG5cXG5cXHQvLyBUcmVlXFxuXFxuXFx0Ly8gc2VlIGRlZmluaXRpb24gb2YgYXJyYXkgZGlzdF9jb2RlIGJlbG93XFxuXFx0dmFyIF9kaXN0X2NvZGUgPSBbIDAsIDEsIDIsIDMsIDQsIDQsIDUsIDUsIDYsIDYsIDYsIDYsIDcsIDcsIDcsIDcsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDksIDksIDksIDksIDksIDksIDksIDksIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsIDEwLFxcblxcdFxcdFxcdDEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsIDExLCAxMSwgMTEsIDExLCAxMSwgMTEsIDExLCAxMSwgMTEsIDExLCAxMSwgMTEsIDExLCAxMSwgMTEsIDExLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLFxcblxcdFxcdFxcdDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLFxcblxcdFxcdFxcdDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LFxcblxcdFxcdFxcdDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LFxcblxcdFxcdFxcdDE0LCAxNCwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LFxcblxcdFxcdFxcdDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMCwgMCwgMTYsIDE3LCAxOCwgMTgsIDE5LCAxOSxcXG5cXHRcXHRcXHQyMCwgMjAsIDIwLCAyMCwgMjEsIDIxLCAyMSwgMjEsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCxcXG5cXHRcXHRcXHQyNCwgMjQsIDI0LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNixcXG5cXHRcXHRcXHQyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNyxcXG5cXHRcXHRcXHQyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCxcXG5cXHRcXHRcXHQyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOSxcXG5cXHRcXHRcXHQyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSxcXG5cXHRcXHRcXHQyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjkgXTtcXG5cXG5cXHRmdW5jdGlvbiBUcmVlKCkge1xcblxcdFxcdHZhciB0aGF0ID0gdGhpcztcXG5cXG5cXHRcXHQvLyBkeW5fdHJlZTsgLy8gdGhlIGR5bmFtaWMgdHJlZVxcblxcdFxcdC8vIG1heF9jb2RlOyAvLyBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3lcXG5cXHRcXHQvLyBzdGF0X2Rlc2M7IC8vIHRoZSBjb3JyZXNwb25kaW5nIHN0YXRpYyB0cmVlXFxuXFxuXFx0XFx0Ly8gQ29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyBmb3IgYSB0cmVlIGFuZCB1cGRhdGUgdGhlIHRvdGFsIGJpdFxcblxcdFxcdC8vIGxlbmd0aFxcblxcdFxcdC8vIGZvciB0aGUgY3VycmVudCBibG9jay5cXG5cXHRcXHQvLyBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQsIGhlYXBbaGVhcF9tYXhdIGFuZFxcblxcdFxcdC8vIGFib3ZlIGFyZSB0aGUgdHJlZSBub2RlcyBzb3J0ZWQgYnkgaW5jcmVhc2luZyBmcmVxdWVuY3kuXFxuXFx0XFx0Ly8gT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZCBsZW4gaXMgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGgsIHRoZVxcblxcdFxcdC8vIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBmcmVxdWVuY2llcyBmb3IgZWFjaCBiaXQgbGVuZ3RoLlxcblxcdFxcdC8vIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpc1xcblxcdFxcdC8vIG5vdCBudWxsLlxcblxcdFxcdGZ1bmN0aW9uIGdlbl9iaXRsZW4ocykge1xcblxcdFxcdFxcdHZhciB0cmVlID0gdGhhdC5keW5fdHJlZTtcXG5cXHRcXHRcXHR2YXIgc3RyZWUgPSB0aGF0LnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcXG5cXHRcXHRcXHR2YXIgZXh0cmEgPSB0aGF0LnN0YXRfZGVzYy5leHRyYV9iaXRzO1xcblxcdFxcdFxcdHZhciBiYXNlID0gdGhhdC5zdGF0X2Rlc2MuZXh0cmFfYmFzZTtcXG5cXHRcXHRcXHR2YXIgbWF4X2xlbmd0aCA9IHRoYXQuc3RhdF9kZXNjLm1heF9sZW5ndGg7XFxuXFx0XFx0XFx0dmFyIGg7IC8vIGhlYXAgaW5kZXhcXG5cXHRcXHRcXHR2YXIgbiwgbTsgLy8gaXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGVsZW1lbnRzXFxuXFx0XFx0XFx0dmFyIGJpdHM7IC8vIGJpdCBsZW5ndGhcXG5cXHRcXHRcXHR2YXIgeGJpdHM7IC8vIGV4dHJhIGJpdHNcXG5cXHRcXHRcXHR2YXIgZjsgLy8gZnJlcXVlbmN5XFxuXFx0XFx0XFx0dmFyIG92ZXJmbG93ID0gMDsgLy8gbnVtYmVyIG9mIGVsZW1lbnRzIHdpdGggYml0IGxlbmd0aCB0b28gbGFyZ2VcXG5cXG5cXHRcXHRcXHRmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspXFxuXFx0XFx0XFx0XFx0cy5ibF9jb3VudFtiaXRzXSA9IDA7XFxuXFxuXFx0XFx0XFx0Ly8gSW4gYSBmaXJzdCBwYXNzLCBjb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzICh3aGljaCBtYXlcXG5cXHRcXHRcXHQvLyBvdmVyZmxvdyBpbiB0aGUgY2FzZSBvZiB0aGUgYml0IGxlbmd0aCB0cmVlKS5cXG5cXHRcXHRcXHR0cmVlW3MuaGVhcFtzLmhlYXBfbWF4XSAqIDIgKyAxXSA9IDA7IC8vIHJvb3Qgb2YgdGhlIGhlYXBcXG5cXG5cXHRcXHRcXHRmb3IgKGggPSBzLmhlYXBfbWF4ICsgMTsgaCA8IEhFQVBfU0laRTsgaCsrKSB7XFxuXFx0XFx0XFx0XFx0biA9IHMuaGVhcFtoXTtcXG5cXHRcXHRcXHRcXHRiaXRzID0gdHJlZVt0cmVlW24gKiAyICsgMV0gKiAyICsgMV0gKyAxO1xcblxcdFxcdFxcdFxcdGlmIChiaXRzID4gbWF4X2xlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdGJpdHMgPSBtYXhfbGVuZ3RoO1xcblxcdFxcdFxcdFxcdFxcdG92ZXJmbG93Kys7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHRyZWVbbiAqIDIgKyAxXSA9IGJpdHM7XFxuXFx0XFx0XFx0XFx0Ly8gV2Ugb3ZlcndyaXRlIHRyZWVbbioyKzFdIHdoaWNoIGlzIG5vIGxvbmdlciBuZWVkZWRcXG5cXG5cXHRcXHRcXHRcXHRpZiAobiA+IHRoYXQubWF4X2NvZGUpXFxuXFx0XFx0XFx0XFx0XFx0Y29udGludWU7IC8vIG5vdCBhIGxlYWYgbm9kZVxcblxcblxcdFxcdFxcdFxcdHMuYmxfY291bnRbYml0c10rKztcXG5cXHRcXHRcXHRcXHR4Yml0cyA9IDA7XFxuXFx0XFx0XFx0XFx0aWYgKG4gPj0gYmFzZSlcXG5cXHRcXHRcXHRcXHRcXHR4Yml0cyA9IGV4dHJhW24gLSBiYXNlXTtcXG5cXHRcXHRcXHRcXHRmID0gdHJlZVtuICogMl07XFxuXFx0XFx0XFx0XFx0cy5vcHRfbGVuICs9IGYgKiAoYml0cyArIHhiaXRzKTtcXG5cXHRcXHRcXHRcXHRpZiAoc3RyZWUpXFxuXFx0XFx0XFx0XFx0XFx0cy5zdGF0aWNfbGVuICs9IGYgKiAoc3RyZWVbbiAqIDIgKyAxXSArIHhiaXRzKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKG92ZXJmbG93ID09PSAwKVxcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXG5cXHRcXHRcXHQvLyBUaGlzIGhhcHBlbnMgZm9yIGV4YW1wbGUgb24gb2JqMiBhbmQgcGljIG9mIHRoZSBDYWxnYXJ5IGNvcnB1c1xcblxcdFxcdFxcdC8vIEZpbmQgdGhlIGZpcnN0IGJpdCBsZW5ndGggd2hpY2ggY291bGQgaW5jcmVhc2U6XFxuXFx0XFx0XFx0ZG8ge1xcblxcdFxcdFxcdFxcdGJpdHMgPSBtYXhfbGVuZ3RoIC0gMTtcXG5cXHRcXHRcXHRcXHR3aGlsZSAocy5ibF9jb3VudFtiaXRzXSA9PT0gMClcXG5cXHRcXHRcXHRcXHRcXHRiaXRzLS07XFxuXFx0XFx0XFx0XFx0cy5ibF9jb3VudFtiaXRzXS0tOyAvLyBtb3ZlIG9uZSBsZWFmIGRvd24gdGhlIHRyZWVcXG5cXHRcXHRcXHRcXHRzLmJsX2NvdW50W2JpdHMgKyAxXSArPSAyOyAvLyBtb3ZlIG9uZSBvdmVyZmxvdyBpdGVtIGFzIGl0cyBicm90aGVyXFxuXFx0XFx0XFx0XFx0cy5ibF9jb3VudFttYXhfbGVuZ3RoXS0tO1xcblxcdFxcdFxcdFxcdC8vIFRoZSBicm90aGVyIG9mIHRoZSBvdmVyZmxvdyBpdGVtIGFsc28gbW92ZXMgb25lIHN0ZXAgdXAsXFxuXFx0XFx0XFx0XFx0Ly8gYnV0IHRoaXMgZG9lcyBub3QgYWZmZWN0IGJsX2NvdW50W21heF9sZW5ndGhdXFxuXFx0XFx0XFx0XFx0b3ZlcmZsb3cgLT0gMjtcXG5cXHRcXHRcXHR9IHdoaWxlIChvdmVyZmxvdyA+IDApO1xcblxcblxcdFxcdFxcdGZvciAoYml0cyA9IG1heF9sZW5ndGg7IGJpdHMgIT09IDA7IGJpdHMtLSkge1xcblxcdFxcdFxcdFxcdG4gPSBzLmJsX2NvdW50W2JpdHNdO1xcblxcdFxcdFxcdFxcdHdoaWxlIChuICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0bSA9IHMuaGVhcFstLWhdO1xcblxcdFxcdFxcdFxcdFxcdGlmIChtID4gdGhhdC5tYXhfY29kZSlcXG5cXHRcXHRcXHRcXHRcXHRcXHRjb250aW51ZTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodHJlZVttICogMiArIDFdICE9IGJpdHMpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzLm9wdF9sZW4gKz0gKGJpdHMgLSB0cmVlW20gKiAyICsgMV0pICogdHJlZVttICogMl07XFxuXFx0XFx0XFx0XFx0XFx0XFx0dHJlZVttICogMiArIDFdID0gYml0cztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0bi0tO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFJldmVyc2UgdGhlIGZpcnN0IGxlbiBiaXRzIG9mIGEgY29kZSwgdXNpbmcgc3RyYWlnaHRmb3J3YXJkIGNvZGUgKGFcXG5cXHRcXHQvLyBmYXN0ZXJcXG5cXHRcXHQvLyBtZXRob2Qgd291bGQgdXNlIGEgdGFibGUpXFxuXFx0XFx0Ly8gSU4gYXNzZXJ0aW9uOiAxIDw9IGxlbiA8PSAxNVxcblxcdFxcdGZ1bmN0aW9uIGJpX3JldmVyc2UoY29kZSwgLy8gdGhlIHZhbHVlIHRvIGludmVydFxcblxcdFxcdGxlbiAvLyBpdHMgYml0IGxlbmd0aFxcblxcdFxcdCkge1xcblxcdFxcdFxcdHZhciByZXMgPSAwO1xcblxcdFxcdFxcdGRvIHtcXG5cXHRcXHRcXHRcXHRyZXMgfD0gY29kZSAmIDE7XFxuXFx0XFx0XFx0XFx0Y29kZSA+Pj49IDE7XFxuXFx0XFx0XFx0XFx0cmVzIDw8PSAxO1xcblxcdFxcdFxcdH0gd2hpbGUgKC0tbGVuID4gMCk7XFxuXFx0XFx0XFx0cmV0dXJuIHJlcyA+Pj4gMTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gR2VuZXJhdGUgdGhlIGNvZGVzIGZvciBhIGdpdmVuIHRyZWUgYW5kIGJpdCBjb3VudHMgKHdoaWNoIG5lZWQgbm90IGJlXFxuXFx0XFx0Ly8gb3B0aW1hbCkuXFxuXFx0XFx0Ly8gSU4gYXNzZXJ0aW9uOiB0aGUgYXJyYXkgYmxfY291bnQgY29udGFpbnMgdGhlIGJpdCBsZW5ndGggc3RhdGlzdGljcyBmb3JcXG5cXHRcXHQvLyB0aGUgZ2l2ZW4gdHJlZSBhbmQgdGhlIGZpZWxkIGxlbiBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxcblxcdFxcdC8vIE9VVCBhc3NlcnRpb246IHRoZSBmaWVsZCBjb2RlIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMgb2Ygbm9uXFxuXFx0XFx0Ly8gemVybyBjb2RlIGxlbmd0aC5cXG5cXHRcXHRmdW5jdGlvbiBnZW5fY29kZXModHJlZSwgLy8gdGhlIHRyZWUgdG8gZGVjb3JhdGVcXG5cXHRcXHRtYXhfY29kZSwgLy8gbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5XFxuXFx0XFx0YmxfY291bnQgLy8gbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aFxcblxcdFxcdCkge1xcblxcdFxcdFxcdHZhciBuZXh0X2NvZGUgPSBbXTsgLy8gbmV4dCBjb2RlIHZhbHVlIGZvciBlYWNoXFxuXFx0XFx0XFx0Ly8gYml0IGxlbmd0aFxcblxcdFxcdFxcdHZhciBjb2RlID0gMDsgLy8gcnVubmluZyBjb2RlIHZhbHVlXFxuXFx0XFx0XFx0dmFyIGJpdHM7IC8vIGJpdCBpbmRleFxcblxcdFxcdFxcdHZhciBuOyAvLyBjb2RlIGluZGV4XFxuXFx0XFx0XFx0dmFyIGxlbjtcXG5cXG5cXHRcXHRcXHQvLyBUaGUgZGlzdHJpYnV0aW9uIGNvdW50cyBhcmUgZmlyc3QgdXNlZCB0byBnZW5lcmF0ZSB0aGUgY29kZSB2YWx1ZXNcXG5cXHRcXHRcXHQvLyB3aXRob3V0IGJpdCByZXZlcnNhbC5cXG5cXHRcXHRcXHRmb3IgKGJpdHMgPSAxOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcXG5cXHRcXHRcXHRcXHRuZXh0X2NvZGVbYml0c10gPSBjb2RlID0gKChjb2RlICsgYmxfY291bnRbYml0cyAtIDFdKSA8PCAxKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQ2hlY2sgdGhhdCB0aGUgYml0IGNvdW50cyBpbiBibF9jb3VudCBhcmUgY29uc2lzdGVudC4gVGhlIGxhc3QgY29kZVxcblxcdFxcdFxcdC8vIG11c3QgYmUgYWxsIG9uZXMuXFxuXFx0XFx0XFx0Ly8gQXNzZXJ0IChjb2RlICsgYmxfY291bnRbTUFYX0JJVFNdLTEgPT0gKDE8PE1BWF9CSVRTKS0xLFxcblxcdFxcdFxcdC8vIFxcXCJpbmNvbnNpc3RlbnQgYml0IGNvdW50c1xcXCIpO1xcblxcdFxcdFxcdC8vIFRyYWNldigoc3RkZXJyLFxcXCJcXFxcbmdlbl9jb2RlczogbWF4X2NvZGUgJWQgXFxcIiwgbWF4X2NvZGUpKTtcXG5cXG5cXHRcXHRcXHRmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcXG5cXHRcXHRcXHRcXHRsZW4gPSB0cmVlW24gKiAyICsgMV07XFxuXFx0XFx0XFx0XFx0aWYgKGxlbiA9PT0gMClcXG5cXHRcXHRcXHRcXHRcXHRjb250aW51ZTtcXG5cXHRcXHRcXHRcXHQvLyBOb3cgcmV2ZXJzZSB0aGUgYml0c1xcblxcdFxcdFxcdFxcdHRyZWVbbiAqIDJdID0gYmlfcmV2ZXJzZShuZXh0X2NvZGVbbGVuXSsrLCBsZW4pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQ29uc3RydWN0IG9uZSBIdWZmbWFuIHRyZWUgYW5kIGFzc2lnbnMgdGhlIGNvZGUgYml0IHN0cmluZ3MgYW5kIGxlbmd0aHMuXFxuXFx0XFx0Ly8gVXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoIGZvciB0aGUgY3VycmVudCBibG9jay5cXG5cXHRcXHQvLyBJTiBhc3NlcnRpb246IHRoZSBmaWVsZCBmcmVxIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXFxuXFx0XFx0Ly8gT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZHMgbGVuIGFuZCBjb2RlIGFyZSBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aFxcblxcdFxcdC8vIGFuZCBjb3JyZXNwb25kaW5nIGNvZGUuIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzXFxuXFx0XFx0Ly8gYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzIG5vdCBudWxsLiBUaGUgZmllbGQgbWF4X2NvZGUgaXMgc2V0LlxcblxcdFxcdHRoYXQuYnVpbGRfdHJlZSA9IGZ1bmN0aW9uKHMpIHtcXG5cXHRcXHRcXHR2YXIgdHJlZSA9IHRoYXQuZHluX3RyZWU7XFxuXFx0XFx0XFx0dmFyIHN0cmVlID0gdGhhdC5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XFxuXFx0XFx0XFx0dmFyIGVsZW1zID0gdGhhdC5zdGF0X2Rlc2MuZWxlbXM7XFxuXFx0XFx0XFx0dmFyIG4sIG07IC8vIGl0ZXJhdGUgb3ZlciBoZWFwIGVsZW1lbnRzXFxuXFx0XFx0XFx0dmFyIG1heF9jb2RlID0gLTE7IC8vIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeVxcblxcdFxcdFxcdHZhciBub2RlOyAvLyBuZXcgbm9kZSBiZWluZyBjcmVhdGVkXFxuXFxuXFx0XFx0XFx0Ly8gQ29uc3RydWN0IHRoZSBpbml0aWFsIGhlYXAsIHdpdGggbGVhc3QgZnJlcXVlbnQgZWxlbWVudCBpblxcblxcdFxcdFxcdC8vIGhlYXBbMV0uIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uXFxuXFx0XFx0XFx0Ly8gaGVhcFswXSBpcyBub3QgdXNlZC5cXG5cXHRcXHRcXHRzLmhlYXBfbGVuID0gMDtcXG5cXHRcXHRcXHRzLmhlYXBfbWF4ID0gSEVBUF9TSVpFO1xcblxcblxcdFxcdFxcdGZvciAobiA9IDA7IG4gPCBlbGVtczsgbisrKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRyZWVbbiAqIDJdICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0cy5oZWFwWysrcy5oZWFwX2xlbl0gPSBtYXhfY29kZSA9IG47XFxuXFx0XFx0XFx0XFx0XFx0cy5kZXB0aFtuXSA9IDA7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHR0cmVlW24gKiAyICsgMV0gPSAwO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gVGhlIHBremlwIGZvcm1hdCByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IG9uZSBkaXN0YW5jZSBjb2RlIGV4aXN0cyxcXG5cXHRcXHRcXHQvLyBhbmQgdGhhdCBhdCBsZWFzdCBvbmUgYml0IHNob3VsZCBiZSBzZW50IGV2ZW4gaWYgdGhlcmUgaXMgb25seSBvbmVcXG5cXHRcXHRcXHQvLyBwb3NzaWJsZSBjb2RlLiBTbyB0byBhdm9pZCBzcGVjaWFsIGNoZWNrcyBsYXRlciBvbiB3ZSBmb3JjZSBhdCBsZWFzdFxcblxcdFxcdFxcdC8vIHR3byBjb2RlcyBvZiBub24gemVybyBmcmVxdWVuY3kuXFxuXFx0XFx0XFx0d2hpbGUgKHMuaGVhcF9sZW4gPCAyKSB7XFxuXFx0XFx0XFx0XFx0bm9kZSA9IHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gbWF4X2NvZGUgPCAyID8gKyttYXhfY29kZSA6IDA7XFxuXFx0XFx0XFx0XFx0dHJlZVtub2RlICogMl0gPSAxO1xcblxcdFxcdFxcdFxcdHMuZGVwdGhbbm9kZV0gPSAwO1xcblxcdFxcdFxcdFxcdHMub3B0X2xlbi0tO1xcblxcdFxcdFxcdFxcdGlmIChzdHJlZSlcXG5cXHRcXHRcXHRcXHRcXHRzLnN0YXRpY19sZW4gLT0gc3RyZWVbbm9kZSAqIDIgKyAxXTtcXG5cXHRcXHRcXHRcXHQvLyBub2RlIGlzIDAgb3IgMSBzbyBpdCBkb2VzIG5vdCBoYXZlIGV4dHJhIGJpdHNcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dGhhdC5tYXhfY29kZSA9IG1heF9jb2RlO1xcblxcblxcdFxcdFxcdC8vIFRoZSBlbGVtZW50cyBoZWFwW2hlYXBfbGVuLzIrMSAuLiBoZWFwX2xlbl0gYXJlIGxlYXZlcyBvZiB0aGUgdHJlZSxcXG5cXHRcXHRcXHQvLyBlc3RhYmxpc2ggc3ViLWhlYXBzIG9mIGluY3JlYXNpbmcgbGVuZ3RoczpcXG5cXG5cXHRcXHRcXHRmb3IgKG4gPSBNYXRoLmZsb29yKHMuaGVhcF9sZW4gLyAyKTsgbiA+PSAxOyBuLS0pXFxuXFx0XFx0XFx0XFx0cy5wcWRvd25oZWFwKHRyZWUsIG4pO1xcblxcblxcdFxcdFxcdC8vIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGJ5IHJlcGVhdGVkbHkgY29tYmluaW5nIHRoZSBsZWFzdCB0d29cXG5cXHRcXHRcXHQvLyBmcmVxdWVudCBub2Rlcy5cXG5cXG5cXHRcXHRcXHRub2RlID0gZWxlbXM7IC8vIG5leHQgaW50ZXJuYWwgbm9kZSBvZiB0aGUgdHJlZVxcblxcdFxcdFxcdGRvIHtcXG5cXHRcXHRcXHRcXHQvLyBuID0gbm9kZSBvZiBsZWFzdCBmcmVxdWVuY3lcXG5cXHRcXHRcXHRcXHRuID0gcy5oZWFwWzFdO1xcblxcdFxcdFxcdFxcdHMuaGVhcFsxXSA9IHMuaGVhcFtzLmhlYXBfbGVuLS1dO1xcblxcdFxcdFxcdFxcdHMucHFkb3duaGVhcCh0cmVlLCAxKTtcXG5cXHRcXHRcXHRcXHRtID0gcy5oZWFwWzFdOyAvLyBtID0gbm9kZSBvZiBuZXh0IGxlYXN0IGZyZXF1ZW5jeVxcblxcblxcdFxcdFxcdFxcdHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbjsgLy8ga2VlcCB0aGUgbm9kZXMgc29ydGVkIGJ5IGZyZXF1ZW5jeVxcblxcdFxcdFxcdFxcdHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBDcmVhdGUgYSBuZXcgbm9kZSBmYXRoZXIgb2YgbiBhbmQgbVxcblxcdFxcdFxcdFxcdHRyZWVbbm9kZSAqIDJdID0gKHRyZWVbbiAqIDJdICsgdHJlZVttICogMl0pO1xcblxcdFxcdFxcdFxcdHMuZGVwdGhbbm9kZV0gPSBNYXRoLm1heChzLmRlcHRoW25dLCBzLmRlcHRoW21dKSArIDE7XFxuXFx0XFx0XFx0XFx0dHJlZVtuICogMiArIDFdID0gdHJlZVttICogMiArIDFdID0gbm9kZTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBhbmQgaW5zZXJ0IHRoZSBuZXcgbm9kZSBpbiB0aGUgaGVhcFxcblxcdFxcdFxcdFxcdHMuaGVhcFsxXSA9IG5vZGUrKztcXG5cXHRcXHRcXHRcXHRzLnBxZG93bmhlYXAodHJlZSwgMSk7XFxuXFx0XFx0XFx0fSB3aGlsZSAocy5oZWFwX2xlbiA+PSAyKTtcXG5cXG5cXHRcXHRcXHRzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IHMuaGVhcFsxXTtcXG5cXG5cXHRcXHRcXHQvLyBBdCB0aGlzIHBvaW50LCB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LiBXZSBjYW4gbm93XFxuXFx0XFx0XFx0Ly8gZ2VuZXJhdGUgdGhlIGJpdCBsZW5ndGhzLlxcblxcblxcdFxcdFxcdGdlbl9iaXRsZW4ocyk7XFxuXFxuXFx0XFx0XFx0Ly8gVGhlIGZpZWxkIGxlbiBpcyBub3cgc2V0LCB3ZSBjYW4gZ2VuZXJhdGUgdGhlIGJpdCBjb2Rlc1xcblxcdFxcdFxcdGdlbl9jb2Rlcyh0cmVlLCB0aGF0Lm1heF9jb2RlLCBzLmJsX2NvdW50KTtcXG5cXHRcXHR9O1xcblxcblxcdH1cXG5cXG5cXHRUcmVlLl9sZW5ndGhfY29kZSA9IFsgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOCwgOSwgOSwgMTAsIDEwLCAxMSwgMTEsIDEyLCAxMiwgMTIsIDEyLCAxMywgMTMsIDEzLCAxMywgMTQsIDE0LCAxNCwgMTQsIDE1LCAxNSwgMTUsIDE1LCAxNiwgMTYsIDE2LCAxNixcXG5cXHRcXHRcXHQxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxNywgMTcsIDE3LCAxNywgMTcsIDE3LCAxOCwgMTgsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTgsIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCxcXG5cXHRcXHRcXHQyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMixcXG5cXHRcXHRcXHQyMiwgMjIsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCxcXG5cXHRcXHRcXHQyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSxcXG5cXHRcXHRcXHQyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNixcXG5cXHRcXHRcXHQyNiwgMjYsIDI2LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjggXTtcXG5cXG5cXHRUcmVlLmJhc2VfbGVuZ3RoID0gWyAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCAxMCwgMTIsIDE0LCAxNiwgMjAsIDI0LCAyOCwgMzIsIDQwLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAwIF07XFxuXFxuXFx0VHJlZS5iYXNlX2Rpc3QgPSBbIDAsIDEsIDIsIDMsIDQsIDYsIDgsIDEyLCAxNiwgMjQsIDMyLCA0OCwgNjQsIDk2LCAxMjgsIDE5MiwgMjU2LCAzODQsIDUxMiwgNzY4LCAxMDI0LCAxNTM2LCAyMDQ4LCAzMDcyLCA0MDk2LCA2MTQ0LCA4MTkyLCAxMjI4OCwgMTYzODQsXFxuXFx0XFx0XFx0MjQ1NzYgXTtcXG5cXG5cXHQvLyBNYXBwaW5nIGZyb20gYSBkaXN0YW5jZSB0byBhIGRpc3RhbmNlIGNvZGUuIGRpc3QgaXMgdGhlIGRpc3RhbmNlIC0gMSBhbmRcXG5cXHQvLyBtdXN0IG5vdCBoYXZlIHNpZGUgZWZmZWN0cy4gX2Rpc3RfY29kZVsyNTZdIGFuZCBfZGlzdF9jb2RlWzI1N10gYXJlIG5ldmVyXFxuXFx0Ly8gdXNlZC5cXG5cXHRUcmVlLmRfY29kZSA9IGZ1bmN0aW9uKGRpc3QpIHtcXG5cXHRcXHRyZXR1cm4gKChkaXN0KSA8IDI1NiA/IF9kaXN0X2NvZGVbZGlzdF0gOiBfZGlzdF9jb2RlWzI1NiArICgoZGlzdCkgPj4+IDcpXSk7XFxuXFx0fTtcXG5cXG5cXHQvLyBleHRyYSBiaXRzIGZvciBlYWNoIGxlbmd0aCBjb2RlXFxuXFx0VHJlZS5leHRyYV9sYml0cyA9IFsgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMSwgMSwgMSwgMSwgMiwgMiwgMiwgMiwgMywgMywgMywgMywgNCwgNCwgNCwgNCwgNSwgNSwgNSwgNSwgMCBdO1xcblxcblxcdC8vIGV4dHJhIGJpdHMgZm9yIGVhY2ggZGlzdGFuY2UgY29kZVxcblxcdFRyZWUuZXh0cmFfZGJpdHMgPSBbIDAsIDAsIDAsIDAsIDEsIDEsIDIsIDIsIDMsIDMsIDQsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDgsIDgsIDksIDksIDEwLCAxMCwgMTEsIDExLCAxMiwgMTIsIDEzLCAxMyBdO1xcblxcblxcdC8vIGV4dHJhIGJpdHMgZm9yIGVhY2ggYml0IGxlbmd0aCBjb2RlXFxuXFx0VHJlZS5leHRyYV9ibGJpdHMgPSBbIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDIsIDMsIDcgXTtcXG5cXG5cXHRUcmVlLmJsX29yZGVyID0gWyAxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1IF07XFxuXFxuXFx0Ly8gU3RhdGljVHJlZVxcblxcblxcdGZ1bmN0aW9uIFN0YXRpY1RyZWUoc3RhdGljX3RyZWUsIGV4dHJhX2JpdHMsIGV4dHJhX2Jhc2UsIGVsZW1zLCBtYXhfbGVuZ3RoKSB7XFxuXFx0XFx0dmFyIHRoYXQgPSB0aGlzO1xcblxcdFxcdHRoYXQuc3RhdGljX3RyZWUgPSBzdGF0aWNfdHJlZTtcXG5cXHRcXHR0aGF0LmV4dHJhX2JpdHMgPSBleHRyYV9iaXRzO1xcblxcdFxcdHRoYXQuZXh0cmFfYmFzZSA9IGV4dHJhX2Jhc2U7XFxuXFx0XFx0dGhhdC5lbGVtcyA9IGVsZW1zO1xcblxcdFxcdHRoYXQubWF4X2xlbmd0aCA9IG1heF9sZW5ndGg7XFxuXFx0fVxcblxcblxcdFN0YXRpY1RyZWUuc3RhdGljX2x0cmVlID0gWyAxMiwgOCwgMTQwLCA4LCA3NiwgOCwgMjA0LCA4LCA0NCwgOCwgMTcyLCA4LCAxMDgsIDgsIDIzNiwgOCwgMjgsIDgsIDE1NiwgOCwgOTIsIDgsIDIyMCwgOCwgNjAsIDgsIDE4OCwgOCwgMTI0LCA4LCAyNTIsIDgsIDIsIDgsXFxuXFx0XFx0XFx0MTMwLCA4LCA2NiwgOCwgMTk0LCA4LCAzNCwgOCwgMTYyLCA4LCA5OCwgOCwgMjI2LCA4LCAxOCwgOCwgMTQ2LCA4LCA4MiwgOCwgMjEwLCA4LCA1MCwgOCwgMTc4LCA4LCAxMTQsIDgsIDI0MiwgOCwgMTAsIDgsIDEzOCwgOCwgNzQsIDgsIDIwMiwgOCwgNDIsXFxuXFx0XFx0XFx0OCwgMTcwLCA4LCAxMDYsIDgsIDIzNCwgOCwgMjYsIDgsIDE1NCwgOCwgOTAsIDgsIDIxOCwgOCwgNTgsIDgsIDE4NiwgOCwgMTIyLCA4LCAyNTAsIDgsIDYsIDgsIDEzNCwgOCwgNzAsIDgsIDE5OCwgOCwgMzgsIDgsIDE2NiwgOCwgMTAyLCA4LCAyMzAsIDgsXFxuXFx0XFx0XFx0MjIsIDgsIDE1MCwgOCwgODYsIDgsIDIxNCwgOCwgNTQsIDgsIDE4MiwgOCwgMTE4LCA4LCAyNDYsIDgsIDE0LCA4LCAxNDIsIDgsIDc4LCA4LCAyMDYsIDgsIDQ2LCA4LCAxNzQsIDgsIDExMCwgOCwgMjM4LCA4LCAzMCwgOCwgMTU4LCA4LCA5NCwgOCxcXG5cXHRcXHRcXHQyMjIsIDgsIDYyLCA4LCAxOTAsIDgsIDEyNiwgOCwgMjU0LCA4LCAxLCA4LCAxMjksIDgsIDY1LCA4LCAxOTMsIDgsIDMzLCA4LCAxNjEsIDgsIDk3LCA4LCAyMjUsIDgsIDE3LCA4LCAxNDUsIDgsIDgxLCA4LCAyMDksIDgsIDQ5LCA4LCAxNzcsIDgsIDExMyxcXG5cXHRcXHRcXHQ4LCAyNDEsIDgsIDksIDgsIDEzNywgOCwgNzMsIDgsIDIwMSwgOCwgNDEsIDgsIDE2OSwgOCwgMTA1LCA4LCAyMzMsIDgsIDI1LCA4LCAxNTMsIDgsIDg5LCA4LCAyMTcsIDgsIDU3LCA4LCAxODUsIDgsIDEyMSwgOCwgMjQ5LCA4LCA1LCA4LCAxMzMsIDgsXFxuXFx0XFx0XFx0NjksIDgsIDE5NywgOCwgMzcsIDgsIDE2NSwgOCwgMTAxLCA4LCAyMjksIDgsIDIxLCA4LCAxNDksIDgsIDg1LCA4LCAyMTMsIDgsIDUzLCA4LCAxODEsIDgsIDExNywgOCwgMjQ1LCA4LCAxMywgOCwgMTQxLCA4LCA3NywgOCwgMjA1LCA4LCA0NSwgOCxcXG5cXHRcXHRcXHQxNzMsIDgsIDEwOSwgOCwgMjM3LCA4LCAyOSwgOCwgMTU3LCA4LCA5MywgOCwgMjIxLCA4LCA2MSwgOCwgMTg5LCA4LCAxMjUsIDgsIDI1MywgOCwgMTksIDksIDI3NSwgOSwgMTQ3LCA5LCA0MDMsIDksIDgzLCA5LCAzMzksIDksIDIxMSwgOSwgNDY3LCA5LFxcblxcdFxcdFxcdDUxLCA5LCAzMDcsIDksIDE3OSwgOSwgNDM1LCA5LCAxMTUsIDksIDM3MSwgOSwgMjQzLCA5LCA0OTksIDksIDExLCA5LCAyNjcsIDksIDEzOSwgOSwgMzk1LCA5LCA3NSwgOSwgMzMxLCA5LCAyMDMsIDksIDQ1OSwgOSwgNDMsIDksIDI5OSwgOSwgMTcxLCA5LFxcblxcdFxcdFxcdDQyNywgOSwgMTA3LCA5LCAzNjMsIDksIDIzNSwgOSwgNDkxLCA5LCAyNywgOSwgMjgzLCA5LCAxNTUsIDksIDQxMSwgOSwgOTEsIDksIDM0NywgOSwgMjE5LCA5LCA0NzUsIDksIDU5LCA5LCAzMTUsIDksIDE4NywgOSwgNDQzLCA5LCAxMjMsIDksIDM3OSxcXG5cXHRcXHRcXHQ5LCAyNTEsIDksIDUwNywgOSwgNywgOSwgMjYzLCA5LCAxMzUsIDksIDM5MSwgOSwgNzEsIDksIDMyNywgOSwgMTk5LCA5LCA0NTUsIDksIDM5LCA5LCAyOTUsIDksIDE2NywgOSwgNDIzLCA5LCAxMDMsIDksIDM1OSwgOSwgMjMxLCA5LCA0ODcsIDksIDIzLFxcblxcdFxcdFxcdDksIDI3OSwgOSwgMTUxLCA5LCA0MDcsIDksIDg3LCA5LCAzNDMsIDksIDIxNSwgOSwgNDcxLCA5LCA1NSwgOSwgMzExLCA5LCAxODMsIDksIDQzOSwgOSwgMTE5LCA5LCAzNzUsIDksIDI0NywgOSwgNTAzLCA5LCAxNSwgOSwgMjcxLCA5LCAxNDMsIDksXFxuXFx0XFx0XFx0Mzk5LCA5LCA3OSwgOSwgMzM1LCA5LCAyMDcsIDksIDQ2MywgOSwgNDcsIDksIDMwMywgOSwgMTc1LCA5LCA0MzEsIDksIDExMSwgOSwgMzY3LCA5LCAyMzksIDksIDQ5NSwgOSwgMzEsIDksIDI4NywgOSwgMTU5LCA5LCA0MTUsIDksIDk1LCA5LCAzNTEsIDksXFxuXFx0XFx0XFx0MjIzLCA5LCA0NzksIDksIDYzLCA5LCAzMTksIDksIDE5MSwgOSwgNDQ3LCA5LCAxMjcsIDksIDM4MywgOSwgMjU1LCA5LCA1MTEsIDksIDAsIDcsIDY0LCA3LCAzMiwgNywgOTYsIDcsIDE2LCA3LCA4MCwgNywgNDgsIDcsIDExMiwgNywgOCwgNywgNzIsIDcsXFxuXFx0XFx0XFx0NDAsIDcsIDEwNCwgNywgMjQsIDcsIDg4LCA3LCA1NiwgNywgMTIwLCA3LCA0LCA3LCA2OCwgNywgMzYsIDcsIDEwMCwgNywgMjAsIDcsIDg0LCA3LCA1MiwgNywgMTE2LCA3LCAzLCA4LCAxMzEsIDgsIDY3LCA4LCAxOTUsIDgsIDM1LCA4LCAxNjMsIDgsXFxuXFx0XFx0XFx0OTksIDgsIDIyNywgOCBdO1xcblxcblxcdFN0YXRpY1RyZWUuc3RhdGljX2R0cmVlID0gWyAwLCA1LCAxNiwgNSwgOCwgNSwgMjQsIDUsIDQsIDUsIDIwLCA1LCAxMiwgNSwgMjgsIDUsIDIsIDUsIDE4LCA1LCAxMCwgNSwgMjYsIDUsIDYsIDUsIDIyLCA1LCAxNCwgNSwgMzAsIDUsIDEsIDUsIDE3LCA1LCA5LCA1LFxcblxcdFxcdFxcdDI1LCA1LCA1LCA1LCAyMSwgNSwgMTMsIDUsIDI5LCA1LCAzLCA1LCAxOSwgNSwgMTEsIDUsIDI3LCA1LCA3LCA1LCAyMywgNSBdO1xcblxcblxcdFN0YXRpY1RyZWUuc3RhdGljX2xfZGVzYyA9IG5ldyBTdGF0aWNUcmVlKFN0YXRpY1RyZWUuc3RhdGljX2x0cmVlLCBUcmVlLmV4dHJhX2xiaXRzLCBMSVRFUkFMUyArIDEsIExfQ09ERVMsIE1BWF9CSVRTKTtcXG5cXG5cXHRTdGF0aWNUcmVlLnN0YXRpY19kX2Rlc2MgPSBuZXcgU3RhdGljVHJlZShTdGF0aWNUcmVlLnN0YXRpY19kdHJlZSwgVHJlZS5leHRyYV9kYml0cywgMCwgRF9DT0RFUywgTUFYX0JJVFMpO1xcblxcblxcdFN0YXRpY1RyZWUuc3RhdGljX2JsX2Rlc2MgPSBuZXcgU3RhdGljVHJlZShudWxsLCBUcmVlLmV4dHJhX2JsYml0cywgMCwgQkxfQ09ERVMsIE1BWF9CTF9CSVRTKTtcXG5cXG5cXHQvLyBEZWZsYXRlXFxuXFxuXFx0dmFyIE1BWF9NRU1fTEVWRUwgPSA5O1xcblxcdHZhciBERUZfTUVNX0xFVkVMID0gODtcXG5cXG5cXHRmdW5jdGlvbiBDb25maWcoZ29vZF9sZW5ndGgsIG1heF9sYXp5LCBuaWNlX2xlbmd0aCwgbWF4X2NoYWluLCBmdW5jKSB7XFxuXFx0XFx0dmFyIHRoYXQgPSB0aGlzO1xcblxcdFxcdHRoYXQuZ29vZF9sZW5ndGggPSBnb29kX2xlbmd0aDtcXG5cXHRcXHR0aGF0Lm1heF9sYXp5ID0gbWF4X2xhenk7XFxuXFx0XFx0dGhhdC5uaWNlX2xlbmd0aCA9IG5pY2VfbGVuZ3RoO1xcblxcdFxcdHRoYXQubWF4X2NoYWluID0gbWF4X2NoYWluO1xcblxcdFxcdHRoYXQuZnVuYyA9IGZ1bmM7XFxuXFx0fVxcblxcblxcdHZhciBTVE9SRUQgPSAwO1xcblxcdHZhciBGQVNUID0gMTtcXG5cXHR2YXIgU0xPVyA9IDI7XFxuXFx0dmFyIGNvbmZpZ190YWJsZSA9IFsgbmV3IENvbmZpZygwLCAwLCAwLCAwLCBTVE9SRUQpLCBuZXcgQ29uZmlnKDQsIDQsIDgsIDQsIEZBU1QpLCBuZXcgQ29uZmlnKDQsIDUsIDE2LCA4LCBGQVNUKSwgbmV3IENvbmZpZyg0LCA2LCAzMiwgMzIsIEZBU1QpLFxcblxcdFxcdFxcdG5ldyBDb25maWcoNCwgNCwgMTYsIDE2LCBTTE9XKSwgbmV3IENvbmZpZyg4LCAxNiwgMzIsIDMyLCBTTE9XKSwgbmV3IENvbmZpZyg4LCAxNiwgMTI4LCAxMjgsIFNMT1cpLCBuZXcgQ29uZmlnKDgsIDMyLCAxMjgsIDI1NiwgU0xPVyksXFxuXFx0XFx0XFx0bmV3IENvbmZpZygzMiwgMTI4LCAyNTgsIDEwMjQsIFNMT1cpLCBuZXcgQ29uZmlnKDMyLCAyNTgsIDI1OCwgNDA5NiwgU0xPVykgXTtcXG5cXG5cXHR2YXIgel9lcnJtc2cgPSBbIFxcXCJuZWVkIGRpY3Rpb25hcnlcXFwiLCAvLyBaX05FRURfRElDVFxcblxcdC8vIDJcXG5cXHRcXFwic3RyZWFtIGVuZFxcXCIsIC8vIFpfU1RSRUFNX0VORCAxXFxuXFx0XFxcIlxcXCIsIC8vIFpfT0sgMFxcblxcdFxcXCJcXFwiLCAvLyBaX0VSUk5PICgtMSlcXG5cXHRcXFwic3RyZWFtIGVycm9yXFxcIiwgLy8gWl9TVFJFQU1fRVJST1IgKC0yKVxcblxcdFxcXCJkYXRhIGVycm9yXFxcIiwgLy8gWl9EQVRBX0VSUk9SICgtMylcXG5cXHRcXFwiXFxcIiwgLy8gWl9NRU1fRVJST1IgKC00KVxcblxcdFxcXCJidWZmZXIgZXJyb3JcXFwiLCAvLyBaX0JVRl9FUlJPUiAoLTUpXFxuXFx0XFxcIlxcXCIsLy8gWl9WRVJTSU9OX0VSUk9SICgtNilcXG5cXHRcXFwiXFxcIiBdO1xcblxcblxcdC8vIGJsb2NrIG5vdCBjb21wbGV0ZWQsIG5lZWQgbW9yZSBpbnB1dCBvciBtb3JlIG91dHB1dFxcblxcdHZhciBOZWVkTW9yZSA9IDA7XFxuXFxuXFx0Ly8gYmxvY2sgZmx1c2ggcGVyZm9ybWVkXFxuXFx0dmFyIEJsb2NrRG9uZSA9IDE7XFxuXFxuXFx0Ly8gZmluaXNoIHN0YXJ0ZWQsIG5lZWQgb25seSBtb3JlIG91dHB1dCBhdCBuZXh0IGRlZmxhdGVcXG5cXHR2YXIgRmluaXNoU3RhcnRlZCA9IDI7XFxuXFxuXFx0Ly8gZmluaXNoIGRvbmUsIGFjY2VwdCBubyBtb3JlIGlucHV0IG9yIG91dHB1dFxcblxcdHZhciBGaW5pc2hEb25lID0gMztcXG5cXG5cXHQvLyBwcmVzZXQgZGljdGlvbmFyeSBmbGFnIGluIHpsaWIgaGVhZGVyXFxuXFx0dmFyIFBSRVNFVF9ESUNUID0gMHgyMDtcXG5cXG5cXHR2YXIgSU5JVF9TVEFURSA9IDQyO1xcblxcdHZhciBCVVNZX1NUQVRFID0gMTEzO1xcblxcdHZhciBGSU5JU0hfU1RBVEUgPSA2NjY7XFxuXFxuXFx0Ly8gVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kXFxuXFx0dmFyIFpfREVGTEFURUQgPSA4O1xcblxcblxcdHZhciBTVE9SRURfQkxPQ0sgPSAwO1xcblxcdHZhciBTVEFUSUNfVFJFRVMgPSAxO1xcblxcdHZhciBEWU5fVFJFRVMgPSAyO1xcblxcblxcdHZhciBNSU5fTUFUQ0ggPSAzO1xcblxcdHZhciBNQVhfTUFUQ0ggPSAyNTg7XFxuXFx0dmFyIE1JTl9MT09LQUhFQUQgPSAoTUFYX01BVENIICsgTUlOX01BVENIICsgMSk7XFxuXFxuXFx0ZnVuY3Rpb24gc21hbGxlcih0cmVlLCBuLCBtLCBkZXB0aCkge1xcblxcdFxcdHZhciB0bjIgPSB0cmVlW24gKiAyXTtcXG5cXHRcXHR2YXIgdG0yID0gdHJlZVttICogMl07XFxuXFx0XFx0cmV0dXJuICh0bjIgPCB0bTIgfHwgKHRuMiA9PSB0bTIgJiYgZGVwdGhbbl0gPD0gZGVwdGhbbV0pKTtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gRGVmbGF0ZSgpIHtcXG5cXG5cXHRcXHR2YXIgdGhhdCA9IHRoaXM7XFxuXFx0XFx0dmFyIHN0cm07IC8vIHBvaW50ZXIgYmFjayB0byB0aGlzIHpsaWIgc3RyZWFtXFxuXFx0XFx0dmFyIHN0YXR1czsgLy8gYXMgdGhlIG5hbWUgaW1wbGllc1xcblxcdFxcdC8vIHBlbmRpbmdfYnVmOyAvLyBvdXRwdXQgc3RpbGwgcGVuZGluZ1xcblxcdFxcdHZhciBwZW5kaW5nX2J1Zl9zaXplOyAvLyBzaXplIG9mIHBlbmRpbmdfYnVmXFxuXFx0XFx0Ly8gcGVuZGluZ19vdXQ7IC8vIG5leHQgcGVuZGluZyBieXRlIHRvIG91dHB1dCB0byB0aGUgc3RyZWFtXFxuXFx0XFx0Ly8gcGVuZGluZzsgLy8gbmIgb2YgYnl0ZXMgaW4gdGhlIHBlbmRpbmcgYnVmZmVyXFxuXFx0XFx0dmFyIG1ldGhvZDsgLy8gU1RPUkVEIChmb3IgemlwIG9ubHkpIG9yIERFRkxBVEVEXFxuXFx0XFx0dmFyIGxhc3RfZmx1c2g7IC8vIHZhbHVlIG9mIGZsdXNoIHBhcmFtIGZvciBwcmV2aW91cyBkZWZsYXRlIGNhbGxcXG5cXG5cXHRcXHR2YXIgd19zaXplOyAvLyBMWjc3IHdpbmRvdyBzaXplICgzMksgYnkgZGVmYXVsdClcXG5cXHRcXHR2YXIgd19iaXRzOyAvLyBsb2cyKHdfc2l6ZSkgKDguLjE2KVxcblxcdFxcdHZhciB3X21hc2s7IC8vIHdfc2l6ZSAtIDFcXG5cXG5cXHRcXHR2YXIgd2luZG93O1xcblxcdFxcdC8vIFNsaWRpbmcgd2luZG93LiBJbnB1dCBieXRlcyBhcmUgcmVhZCBpbnRvIHRoZSBzZWNvbmQgaGFsZiBvZiB0aGUgd2luZG93LFxcblxcdFxcdC8vIGFuZCBtb3ZlIHRvIHRoZSBmaXJzdCBoYWxmIGxhdGVyIHRvIGtlZXAgYSBkaWN0aW9uYXJ5IG9mIGF0IGxlYXN0IHdTaXplXFxuXFx0XFx0Ly8gYnl0ZXMuIFdpdGggdGhpcyBvcmdhbml6YXRpb24sIG1hdGNoZXMgYXJlIGxpbWl0ZWQgdG8gYSBkaXN0YW5jZSBvZlxcblxcdFxcdC8vIHdTaXplLU1BWF9NQVRDSCBieXRlcywgYnV0IHRoaXMgZW5zdXJlcyB0aGF0IElPIGlzIGFsd2F5c1xcblxcdFxcdC8vIHBlcmZvcm1lZCB3aXRoIGEgbGVuZ3RoIG11bHRpcGxlIG9mIHRoZSBibG9jayBzaXplLiBBbHNvLCBpdCBsaW1pdHNcXG5cXHRcXHQvLyB0aGUgd2luZG93IHNpemUgdG8gNjRLLCB3aGljaCBpcyBxdWl0ZSB1c2VmdWwgb24gTVNET1MuXFxuXFx0XFx0Ly8gVG8gZG86IHVzZSB0aGUgdXNlciBpbnB1dCBidWZmZXIgYXMgc2xpZGluZyB3aW5kb3cuXFxuXFxuXFx0XFx0dmFyIHdpbmRvd19zaXplO1xcblxcdFxcdC8vIEFjdHVhbCBzaXplIG9mIHdpbmRvdzogMip3U2l6ZSwgZXhjZXB0IHdoZW4gdGhlIHVzZXIgaW5wdXQgYnVmZmVyXFxuXFx0XFx0Ly8gaXMgZGlyZWN0bHkgdXNlZCBhcyBzbGlkaW5nIHdpbmRvdy5cXG5cXG5cXHRcXHR2YXIgcHJldjtcXG5cXHRcXHQvLyBMaW5rIHRvIG9sZGVyIHN0cmluZyB3aXRoIHNhbWUgaGFzaCBpbmRleC4gVG8gbGltaXQgdGhlIHNpemUgb2YgdGhpc1xcblxcdFxcdC8vIGFycmF5IHRvIDY0SywgdGhpcyBsaW5rIGlzIG1haW50YWluZWQgb25seSBmb3IgdGhlIGxhc3QgMzJLIHN0cmluZ3MuXFxuXFx0XFx0Ly8gQW4gaW5kZXggaW4gdGhpcyBhcnJheSBpcyB0aHVzIGEgd2luZG93IGluZGV4IG1vZHVsbyAzMksuXFxuXFxuXFx0XFx0dmFyIGhlYWQ7IC8vIEhlYWRzIG9mIHRoZSBoYXNoIGNoYWlucyBvciBOSUwuXFxuXFxuXFx0XFx0dmFyIGluc19oOyAvLyBoYXNoIGluZGV4IG9mIHN0cmluZyB0byBiZSBpbnNlcnRlZFxcblxcdFxcdHZhciBoYXNoX3NpemU7IC8vIG51bWJlciBvZiBlbGVtZW50cyBpbiBoYXNoIHRhYmxlXFxuXFx0XFx0dmFyIGhhc2hfYml0czsgLy8gbG9nMihoYXNoX3NpemUpXFxuXFx0XFx0dmFyIGhhc2hfbWFzazsgLy8gaGFzaF9zaXplLTFcXG5cXG5cXHRcXHQvLyBOdW1iZXIgb2YgYml0cyBieSB3aGljaCBpbnNfaCBtdXN0IGJlIHNoaWZ0ZWQgYXQgZWFjaCBpbnB1dFxcblxcdFxcdC8vIHN0ZXAuIEl0IG11c3QgYmUgc3VjaCB0aGF0IGFmdGVyIE1JTl9NQVRDSCBzdGVwcywgdGhlIG9sZGVzdFxcblxcdFxcdC8vIGJ5dGUgbm8gbG9uZ2VyIHRha2VzIHBhcnQgaW4gdGhlIGhhc2gga2V5LCB0aGF0IGlzOlxcblxcdFxcdC8vIGhhc2hfc2hpZnQgKiBNSU5fTUFUQ0ggPj0gaGFzaF9iaXRzXFxuXFx0XFx0dmFyIGhhc2hfc2hpZnQ7XFxuXFxuXFx0XFx0Ly8gV2luZG93IHBvc2l0aW9uIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGN1cnJlbnQgb3V0cHV0IGJsb2NrLiBHZXRzXFxuXFx0XFx0Ly8gbmVnYXRpdmUgd2hlbiB0aGUgd2luZG93IGlzIG1vdmVkIGJhY2t3YXJkcy5cXG5cXG5cXHRcXHR2YXIgYmxvY2tfc3RhcnQ7XFxuXFxuXFx0XFx0dmFyIG1hdGNoX2xlbmd0aDsgLy8gbGVuZ3RoIG9mIGJlc3QgbWF0Y2hcXG5cXHRcXHR2YXIgcHJldl9tYXRjaDsgLy8gcHJldmlvdXMgbWF0Y2hcXG5cXHRcXHR2YXIgbWF0Y2hfYXZhaWxhYmxlOyAvLyBzZXQgaWYgcHJldmlvdXMgbWF0Y2ggZXhpc3RzXFxuXFx0XFx0dmFyIHN0cnN0YXJ0OyAvLyBzdGFydCBvZiBzdHJpbmcgdG8gaW5zZXJ0XFxuXFx0XFx0dmFyIG1hdGNoX3N0YXJ0OyAvLyBzdGFydCBvZiBtYXRjaGluZyBzdHJpbmdcXG5cXHRcXHR2YXIgbG9va2FoZWFkOyAvLyBudW1iZXIgb2YgdmFsaWQgYnl0ZXMgYWhlYWQgaW4gd2luZG93XFxuXFxuXFx0XFx0Ly8gTGVuZ3RoIG9mIHRoZSBiZXN0IG1hdGNoIGF0IHByZXZpb3VzIHN0ZXAuIE1hdGNoZXMgbm90IGdyZWF0ZXIgdGhhbiB0aGlzXFxuXFx0XFx0Ly8gYXJlIGRpc2NhcmRlZC4gVGhpcyBpcyB1c2VkIGluIHRoZSBsYXp5IG1hdGNoIGV2YWx1YXRpb24uXFxuXFx0XFx0dmFyIHByZXZfbGVuZ3RoO1xcblxcblxcdFxcdC8vIFRvIHNwZWVkIHVwIGRlZmxhdGlvbiwgaGFzaCBjaGFpbnMgYXJlIG5ldmVyIHNlYXJjaGVkIGJleW9uZCB0aGlzXFxuXFx0XFx0Ly8gbGVuZ3RoLiBBIGhpZ2hlciBsaW1pdCBpbXByb3ZlcyBjb21wcmVzc2lvbiByYXRpbyBidXQgZGVncmFkZXMgdGhlIHNwZWVkLlxcblxcdFxcdHZhciBtYXhfY2hhaW5fbGVuZ3RoO1xcblxcblxcdFxcdC8vIEF0dGVtcHQgdG8gZmluZCBhIGJldHRlciBtYXRjaCBvbmx5IHdoZW4gdGhlIGN1cnJlbnQgbWF0Y2ggaXMgc3RyaWN0bHlcXG5cXHRcXHQvLyBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZS4gVGhpcyBtZWNoYW5pc20gaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvblxcblxcdFxcdC8vIGxldmVscyA+PSA0LlxcblxcdFxcdHZhciBtYXhfbGF6eV9tYXRjaDtcXG5cXG5cXHRcXHQvLyBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdFxcblxcdFxcdC8vIGdyZWF0ZXIgdGhhbiB0aGlzIGxlbmd0aC4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cXG5cXHRcXHQvLyBtYXhfaW5zZXJ0X2xlbmd0aCBpcyB1c2VkIG9ubHkgZm9yIGNvbXByZXNzaW9uIGxldmVscyA8PSAzLlxcblxcblxcdFxcdHZhciBsZXZlbDsgLy8gY29tcHJlc3Npb24gbGV2ZWwgKDEuLjkpXFxuXFx0XFx0dmFyIHN0cmF0ZWd5OyAvLyBmYXZvciBvciBmb3JjZSBIdWZmbWFuIGNvZGluZ1xcblxcblxcdFxcdC8vIFVzZSBhIGZhc3RlciBzZWFyY2ggd2hlbiB0aGUgcHJldmlvdXMgbWF0Y2ggaXMgbG9uZ2VyIHRoYW4gdGhpc1xcblxcdFxcdHZhciBnb29kX21hdGNoO1xcblxcblxcdFxcdC8vIFN0b3Agc2VhcmNoaW5nIHdoZW4gY3VycmVudCBtYXRjaCBleGNlZWRzIHRoaXNcXG5cXHRcXHR2YXIgbmljZV9tYXRjaDtcXG5cXG5cXHRcXHR2YXIgZHluX2x0cmVlOyAvLyBsaXRlcmFsIGFuZCBsZW5ndGggdHJlZVxcblxcdFxcdHZhciBkeW5fZHRyZWU7IC8vIGRpc3RhbmNlIHRyZWVcXG5cXHRcXHR2YXIgYmxfdHJlZTsgLy8gSHVmZm1hbiB0cmVlIGZvciBiaXQgbGVuZ3Roc1xcblxcblxcdFxcdHZhciBsX2Rlc2MgPSBuZXcgVHJlZSgpOyAvLyBkZXNjIGZvciBsaXRlcmFsIHRyZWVcXG5cXHRcXHR2YXIgZF9kZXNjID0gbmV3IFRyZWUoKTsgLy8gZGVzYyBmb3IgZGlzdGFuY2UgdHJlZVxcblxcdFxcdHZhciBibF9kZXNjID0gbmV3IFRyZWUoKTsgLy8gZGVzYyBmb3IgYml0IGxlbmd0aCB0cmVlXFxuXFxuXFx0XFx0Ly8gdGhhdC5oZWFwX2xlbjsgLy8gbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBoZWFwXFxuXFx0XFx0Ly8gdGhhdC5oZWFwX21heDsgLy8gZWxlbWVudCBvZiBsYXJnZXN0IGZyZXF1ZW5jeVxcblxcdFxcdC8vIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uIGhlYXBbMF0gaXMgbm90IHVzZWQuXFxuXFx0XFx0Ly8gVGhlIHNhbWUgaGVhcCBhcnJheSBpcyB1c2VkIHRvIGJ1aWxkIGFsbCB0cmVlcy5cXG5cXG5cXHRcXHQvLyBEZXB0aCBvZiBlYWNoIHN1YnRyZWUgdXNlZCBhcyB0aWUgYnJlYWtlciBmb3IgdHJlZXMgb2YgZXF1YWwgZnJlcXVlbmN5XFxuXFx0XFx0dGhhdC5kZXB0aCA9IFtdO1xcblxcblxcdFxcdHZhciBsX2J1ZjsgLy8gaW5kZXggZm9yIGxpdGVyYWxzIG9yIGxlbmd0aHMgKi9cXG5cXG5cXHRcXHQvLyBTaXplIG9mIG1hdGNoIGJ1ZmZlciBmb3IgbGl0ZXJhbHMvbGVuZ3Rocy4gVGhlcmUgYXJlIDQgcmVhc29ucyBmb3JcXG5cXHRcXHQvLyBsaW1pdGluZyBsaXRfYnVmc2l6ZSB0byA2NEs6XFxuXFx0XFx0Ly8gLSBmcmVxdWVuY2llcyBjYW4gYmUga2VwdCBpbiAxNiBiaXQgY291bnRlcnNcXG5cXHRcXHQvLyAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciB0aGUgZmlyc3QgYmxvY2ssIGFsbCBpbnB1dFxcblxcdFxcdC8vIGRhdGEgaXMgc3RpbGwgaW4gdGhlIHdpbmRvdyBzbyB3ZSBjYW4gc3RpbGwgZW1pdCBhIHN0b3JlZCBibG9jayBldmVuXFxuXFx0XFx0Ly8gd2hlbiBpbnB1dCBjb21lcyBmcm9tIHN0YW5kYXJkIGlucHV0LiAoVGhpcyBjYW4gYWxzbyBiZSBkb25lIGZvclxcblxcdFxcdC8vIGFsbCBibG9ja3MgaWYgbGl0X2J1ZnNpemUgaXMgbm90IGdyZWF0ZXIgdGhhbiAzMksuKVxcblxcdFxcdC8vIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIGEgZmlsZSBzbWFsbGVyIHRoYW4gNjRLLCB3ZSBjYW5cXG5cXHRcXHQvLyBldmVuIGVtaXQgYSBzdG9yZWQgZmlsZSBpbnN0ZWFkIG9mIGEgc3RvcmVkIGJsb2NrIChzYXZpbmcgNSBieXRlcykuXFxuXFx0XFx0Ly8gVGhpcyBpcyBhcHBsaWNhYmxlIG9ubHkgZm9yIHppcCAobm90IGd6aXAgb3IgemxpYikuXFxuXFx0XFx0Ly8gLSBjcmVhdGluZyBuZXcgSHVmZm1hbiB0cmVlcyBsZXNzIGZyZXF1ZW50bHkgbWF5IG5vdCBwcm92aWRlIGZhc3RcXG5cXHRcXHQvLyBhZGFwdGF0aW9uIHRvIGNoYW5nZXMgaW4gdGhlIGlucHV0IGRhdGEgc3RhdGlzdGljcy4gKFRha2UgZm9yXFxuXFx0XFx0Ly8gZXhhbXBsZSBhIGJpbmFyeSBmaWxlIHdpdGggcG9vcmx5IGNvbXByZXNzaWJsZSBjb2RlIGZvbGxvd2VkIGJ5XFxuXFx0XFx0Ly8gYSBoaWdobHkgY29tcHJlc3NpYmxlIHN0cmluZyB0YWJsZS4pIFNtYWxsZXIgYnVmZmVyIHNpemVzIGdpdmVcXG5cXHRcXHQvLyBmYXN0IGFkYXB0YXRpb24gYnV0IGhhdmUgb2YgY291cnNlIHRoZSBvdmVyaGVhZCBvZiB0cmFuc21pdHRpbmdcXG5cXHRcXHQvLyB0cmVlcyBtb3JlIGZyZXF1ZW50bHkuXFxuXFx0XFx0Ly8gLSBJIGNhbid0IGNvdW50IGFib3ZlIDRcXG5cXHRcXHR2YXIgbGl0X2J1ZnNpemU7XFxuXFxuXFx0XFx0dmFyIGxhc3RfbGl0OyAvLyBydW5uaW5nIGluZGV4IGluIGxfYnVmXFxuXFxuXFx0XFx0Ly8gQnVmZmVyIGZvciBkaXN0YW5jZXMuIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCBkX2J1ZiBhbmQgbF9idWYgaGF2ZVxcblxcdFxcdC8vIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy4gVG8gdXNlIGRpZmZlcmVudCBsZW5ndGhzLCBhbiBleHRyYSBmbGFnXFxuXFx0XFx0Ly8gYXJyYXkgd291bGQgYmUgbmVjZXNzYXJ5LlxcblxcblxcdFxcdHZhciBkX2J1ZjsgLy8gaW5kZXggb2YgcGVuZGlnX2J1ZlxcblxcblxcdFxcdC8vIHRoYXQub3B0X2xlbjsgLy8gYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggb3B0aW1hbCB0cmVlc1xcblxcdFxcdC8vIHRoYXQuc3RhdGljX2xlbjsgLy8gYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggc3RhdGljIHRyZWVzXFxuXFx0XFx0dmFyIG1hdGNoZXM7IC8vIG51bWJlciBvZiBzdHJpbmcgbWF0Y2hlcyBpbiBjdXJyZW50IGJsb2NrXFxuXFx0XFx0dmFyIGxhc3RfZW9iX2xlbjsgLy8gYml0IGxlbmd0aCBvZiBFT0IgY29kZSBmb3IgbGFzdCBibG9ja1xcblxcblxcdFxcdC8vIE91dHB1dCBidWZmZXIuIGJpdHMgYXJlIGluc2VydGVkIHN0YXJ0aW5nIGF0IHRoZSBib3R0b20gKGxlYXN0XFxuXFx0XFx0Ly8gc2lnbmlmaWNhbnQgYml0cykuXFxuXFx0XFx0dmFyIGJpX2J1ZjtcXG5cXG5cXHRcXHQvLyBOdW1iZXIgb2YgdmFsaWQgYml0cyBpbiBiaV9idWYuIEFsbCBiaXRzIGFib3ZlIHRoZSBsYXN0IHZhbGlkIGJpdFxcblxcdFxcdC8vIGFyZSBhbHdheXMgemVyby5cXG5cXHRcXHR2YXIgYmlfdmFsaWQ7XFxuXFxuXFx0XFx0Ly8gbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlXFxuXFx0XFx0dGhhdC5ibF9jb3VudCA9IFtdO1xcblxcblxcdFxcdC8vIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlc1xcblxcdFxcdHRoYXQuaGVhcCA9IFtdO1xcblxcblxcdFxcdGR5bl9sdHJlZSA9IFtdO1xcblxcdFxcdGR5bl9kdHJlZSA9IFtdO1xcblxcdFxcdGJsX3RyZWUgPSBbXTtcXG5cXG5cXHRcXHRmdW5jdGlvbiBsbV9pbml0KCkge1xcblxcdFxcdFxcdHZhciBpO1xcblxcdFxcdFxcdHdpbmRvd19zaXplID0gMiAqIHdfc2l6ZTtcXG5cXG5cXHRcXHRcXHRoZWFkW2hhc2hfc2l6ZSAtIDFdID0gMDtcXG5cXHRcXHRcXHRmb3IgKGkgPSAwOyBpIDwgaGFzaF9zaXplIC0gMTsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0aGVhZFtpXSA9IDA7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFNldCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnM6XFxuXFx0XFx0XFx0bWF4X2xhenlfbWF0Y2ggPSBjb25maWdfdGFibGVbbGV2ZWxdLm1heF9sYXp5O1xcblxcdFxcdFxcdGdvb2RfbWF0Y2ggPSBjb25maWdfdGFibGVbbGV2ZWxdLmdvb2RfbGVuZ3RoO1xcblxcdFxcdFxcdG5pY2VfbWF0Y2ggPSBjb25maWdfdGFibGVbbGV2ZWxdLm5pY2VfbGVuZ3RoO1xcblxcdFxcdFxcdG1heF9jaGFpbl9sZW5ndGggPSBjb25maWdfdGFibGVbbGV2ZWxdLm1heF9jaGFpbjtcXG5cXG5cXHRcXHRcXHRzdHJzdGFydCA9IDA7XFxuXFx0XFx0XFx0YmxvY2tfc3RhcnQgPSAwO1xcblxcdFxcdFxcdGxvb2thaGVhZCA9IDA7XFxuXFx0XFx0XFx0bWF0Y2hfbGVuZ3RoID0gcHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xcblxcdFxcdFxcdG1hdGNoX2F2YWlsYWJsZSA9IDA7XFxuXFx0XFx0XFx0aW5zX2ggPSAwO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBpbml0X2Jsb2NrKCkge1xcblxcdFxcdFxcdHZhciBpO1xcblxcdFxcdFxcdC8vIEluaXRpYWxpemUgdGhlIHRyZWVzLlxcblxcdFxcdFxcdGZvciAoaSA9IDA7IGkgPCBMX0NPREVTOyBpKyspXFxuXFx0XFx0XFx0XFx0ZHluX2x0cmVlW2kgKiAyXSA9IDA7XFxuXFx0XFx0XFx0Zm9yIChpID0gMDsgaSA8IERfQ09ERVM7IGkrKylcXG5cXHRcXHRcXHRcXHRkeW5fZHRyZWVbaSAqIDJdID0gMDtcXG5cXHRcXHRcXHRmb3IgKGkgPSAwOyBpIDwgQkxfQ09ERVM7IGkrKylcXG5cXHRcXHRcXHRcXHRibF90cmVlW2kgKiAyXSA9IDA7XFxuXFxuXFx0XFx0XFx0ZHluX2x0cmVlW0VORF9CTE9DSyAqIDJdID0gMTtcXG5cXHRcXHRcXHR0aGF0Lm9wdF9sZW4gPSB0aGF0LnN0YXRpY19sZW4gPSAwO1xcblxcdFxcdFxcdGxhc3RfbGl0ID0gbWF0Y2hlcyA9IDA7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEluaXRpYWxpemUgdGhlIHRyZWUgZGF0YSBzdHJ1Y3R1cmVzIGZvciBhIG5ldyB6bGliIHN0cmVhbS5cXG5cXHRcXHRmdW5jdGlvbiB0cl9pbml0KCkge1xcblxcblxcdFxcdFxcdGxfZGVzYy5keW5fdHJlZSA9IGR5bl9sdHJlZTtcXG5cXHRcXHRcXHRsX2Rlc2Muc3RhdF9kZXNjID0gU3RhdGljVHJlZS5zdGF0aWNfbF9kZXNjO1xcblxcblxcdFxcdFxcdGRfZGVzYy5keW5fdHJlZSA9IGR5bl9kdHJlZTtcXG5cXHRcXHRcXHRkX2Rlc2Muc3RhdF9kZXNjID0gU3RhdGljVHJlZS5zdGF0aWNfZF9kZXNjO1xcblxcblxcdFxcdFxcdGJsX2Rlc2MuZHluX3RyZWUgPSBibF90cmVlO1xcblxcdFxcdFxcdGJsX2Rlc2Muc3RhdF9kZXNjID0gU3RhdGljVHJlZS5zdGF0aWNfYmxfZGVzYztcXG5cXG5cXHRcXHRcXHRiaV9idWYgPSAwO1xcblxcdFxcdFxcdGJpX3ZhbGlkID0gMDtcXG5cXHRcXHRcXHRsYXN0X2VvYl9sZW4gPSA4OyAvLyBlbm91Z2ggbG9va2FoZWFkIGZvciBpbmZsYXRlXFxuXFxuXFx0XFx0XFx0Ly8gSW5pdGlhbGl6ZSB0aGUgZmlyc3QgYmxvY2sgb2YgdGhlIGZpcnN0IGZpbGU6XFxuXFx0XFx0XFx0aW5pdF9ibG9jaygpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBSZXN0b3JlIHRoZSBoZWFwIHByb3BlcnR5IGJ5IG1vdmluZyBkb3duIHRoZSB0cmVlIHN0YXJ0aW5nIGF0IG5vZGUgayxcXG5cXHRcXHQvLyBleGNoYW5naW5nIGEgbm9kZSB3aXRoIHRoZSBzbWFsbGVzdCBvZiBpdHMgdHdvIHNvbnMgaWYgbmVjZXNzYXJ5LFxcblxcdFxcdC8vIHN0b3BwaW5nXFxuXFx0XFx0Ly8gd2hlbiB0aGUgaGVhcCBwcm9wZXJ0eSBpcyByZS1lc3RhYmxpc2hlZCAoZWFjaCBmYXRoZXIgc21hbGxlciB0aGFuIGl0c1xcblxcdFxcdC8vIHR3byBzb25zKS5cXG5cXHRcXHR0aGF0LnBxZG93bmhlYXAgPSBmdW5jdGlvbih0cmVlLCAvLyB0aGUgdHJlZSB0byByZXN0b3JlXFxuXFx0XFx0ayAvLyBub2RlIHRvIG1vdmUgZG93blxcblxcdFxcdCkge1xcblxcdFxcdFxcdHZhciBoZWFwID0gdGhhdC5oZWFwO1xcblxcdFxcdFxcdHZhciB2ID0gaGVhcFtrXTtcXG5cXHRcXHRcXHR2YXIgaiA9IGsgPDwgMTsgLy8gbGVmdCBzb24gb2Yga1xcblxcdFxcdFxcdHdoaWxlIChqIDw9IHRoYXQuaGVhcF9sZW4pIHtcXG5cXHRcXHRcXHRcXHQvLyBTZXQgaiB0byB0aGUgc21hbGxlc3Qgb2YgdGhlIHR3byBzb25zOlxcblxcdFxcdFxcdFxcdGlmIChqIDwgdGhhdC5oZWFwX2xlbiAmJiBzbWFsbGVyKHRyZWUsIGhlYXBbaiArIDFdLCBoZWFwW2pdLCB0aGF0LmRlcHRoKSkge1xcblxcdFxcdFxcdFxcdFxcdGorKztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0Ly8gRXhpdCBpZiB2IGlzIHNtYWxsZXIgdGhhbiBib3RoIHNvbnNcXG5cXHRcXHRcXHRcXHRpZiAoc21hbGxlcih0cmVlLCB2LCBoZWFwW2pdLCB0aGF0LmRlcHRoKSlcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHQvLyBFeGNoYW5nZSB2IHdpdGggdGhlIHNtYWxsZXN0IHNvblxcblxcdFxcdFxcdFxcdGhlYXBba10gPSBoZWFwW2pdO1xcblxcdFxcdFxcdFxcdGsgPSBqO1xcblxcdFxcdFxcdFxcdC8vIEFuZCBjb250aW51ZSBkb3duIHRoZSB0cmVlLCBzZXR0aW5nIGogdG8gdGhlIGxlZnQgc29uIG9mIGtcXG5cXHRcXHRcXHRcXHRqIDw8PSAxO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRoZWFwW2tdID0gdjtcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIFNjYW4gYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgdG8gZGV0ZXJtaW5lIHRoZSBmcmVxdWVuY2llcyBvZiB0aGUgY29kZXNcXG5cXHRcXHQvLyBpbiB0aGUgYml0IGxlbmd0aCB0cmVlLlxcblxcdFxcdGZ1bmN0aW9uIHNjYW5fdHJlZSh0cmVlLC8vIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWRcXG5cXHRcXHRtYXhfY29kZSAvLyBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3lcXG5cXHRcXHQpIHtcXG5cXHRcXHRcXHR2YXIgbjsgLy8gaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50c1xcblxcdFxcdFxcdHZhciBwcmV2bGVuID0gLTE7IC8vIGxhc3QgZW1pdHRlZCBsZW5ndGhcXG5cXHRcXHRcXHR2YXIgY3VybGVuOyAvLyBsZW5ndGggb2YgY3VycmVudCBjb2RlXFxuXFx0XFx0XFx0dmFyIG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV07IC8vIGxlbmd0aCBvZiBuZXh0IGNvZGVcXG5cXHRcXHRcXHR2YXIgY291bnQgPSAwOyAvLyByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZVxcblxcdFxcdFxcdHZhciBtYXhfY291bnQgPSA3OyAvLyBtYXggcmVwZWF0IGNvdW50XFxuXFx0XFx0XFx0dmFyIG1pbl9jb3VudCA9IDQ7IC8vIG1pbiByZXBlYXQgY291bnRcXG5cXG5cXHRcXHRcXHRpZiAobmV4dGxlbiA9PT0gMCkge1xcblxcdFxcdFxcdFxcdG1heF9jb3VudCA9IDEzODtcXG5cXHRcXHRcXHRcXHRtaW5fY291bnQgPSAzO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0cmVlWyhtYXhfY29kZSArIDEpICogMiArIDFdID0gMHhmZmZmOyAvLyBndWFyZFxcblxcblxcdFxcdFxcdGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xcblxcdFxcdFxcdFxcdGN1cmxlbiA9IG5leHRsZW47XFxuXFx0XFx0XFx0XFx0bmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXTtcXG5cXHRcXHRcXHRcXHRpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT0gbmV4dGxlbikge1xcblxcdFxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcXG5cXHRcXHRcXHRcXHRcXHRibF90cmVlW2N1cmxlbiAqIDJdICs9IGNvdW50O1xcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGN1cmxlbiAhPSBwcmV2bGVuKVxcblxcdFxcdFxcdFxcdFxcdFxcdGJsX3RyZWVbY3VybGVuICogMl0rKztcXG5cXHRcXHRcXHRcXHRcXHRibF90cmVlW1JFUF8zXzYgKiAyXSsrO1xcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcXG5cXHRcXHRcXHRcXHRcXHRibF90cmVlW1JFUFpfM18xMCAqIDJdKys7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRibF90cmVlW1JFUFpfMTFfMTM4ICogMl0rKztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0Y291bnQgPSAwO1xcblxcdFxcdFxcdFxcdHByZXZsZW4gPSBjdXJsZW47XFxuXFx0XFx0XFx0XFx0aWYgKG5leHRsZW4gPT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRtYXhfY291bnQgPSAxMzg7XFxuXFx0XFx0XFx0XFx0XFx0bWluX2NvdW50ID0gMztcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGN1cmxlbiA9PSBuZXh0bGVuKSB7XFxuXFx0XFx0XFx0XFx0XFx0bWF4X2NvdW50ID0gNjtcXG5cXHRcXHRcXHRcXHRcXHRtaW5fY291bnQgPSAzO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0bWF4X2NvdW50ID0gNztcXG5cXHRcXHRcXHRcXHRcXHRtaW5fY291bnQgPSA0O1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGZvciB0aGUgYml0IGxlbmd0aHMgYW5kIHJldHVybiB0aGUgaW5kZXggaW5cXG5cXHRcXHQvLyBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cXG5cXHRcXHRmdW5jdGlvbiBidWlsZF9ibF90cmVlKCkge1xcblxcdFxcdFxcdHZhciBtYXhfYmxpbmRleDsgLy8gaW5kZXggb2YgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgb2Ygbm9uIHplcm8gZnJlcVxcblxcblxcdFxcdFxcdC8vIERldGVybWluZSB0aGUgYml0IGxlbmd0aCBmcmVxdWVuY2llcyBmb3IgbGl0ZXJhbCBhbmQgZGlzdGFuY2UgdHJlZXNcXG5cXHRcXHRcXHRzY2FuX3RyZWUoZHluX2x0cmVlLCBsX2Rlc2MubWF4X2NvZGUpO1xcblxcdFxcdFxcdHNjYW5fdHJlZShkeW5fZHRyZWUsIGRfZGVzYy5tYXhfY29kZSk7XFxuXFxuXFx0XFx0XFx0Ly8gQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZTpcXG5cXHRcXHRcXHRibF9kZXNjLmJ1aWxkX3RyZWUodGhhdCk7XFxuXFx0XFx0XFx0Ly8gb3B0X2xlbiBub3cgaW5jbHVkZXMgdGhlIGxlbmd0aCBvZiB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMsIGV4Y2VwdFxcblxcdFxcdFxcdC8vIHRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RocyBjb2RlcyBhbmQgdGhlIDUrNSs0IGJpdHMgZm9yIHRoZVxcblxcdFxcdFxcdC8vIGNvdW50cy5cXG5cXG5cXHRcXHRcXHQvLyBEZXRlcm1pbmUgdGhlIG51bWJlciBvZiBiaXQgbGVuZ3RoIGNvZGVzIHRvIHNlbmQuIFRoZSBwa3ppcCBmb3JtYXRcXG5cXHRcXHRcXHQvLyByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IDQgYml0IGxlbmd0aCBjb2RlcyBiZSBzZW50LiAoYXBwbm90ZS50eHQgc2F5c1xcblxcdFxcdFxcdC8vIDMgYnV0IHRoZSBhY3R1YWwgdmFsdWUgdXNlZCBpcyA0LilcXG5cXHRcXHRcXHRmb3IgKG1heF9ibGluZGV4ID0gQkxfQ09ERVMgLSAxOyBtYXhfYmxpbmRleCA+PSAzOyBtYXhfYmxpbmRleC0tKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGJsX3RyZWVbVHJlZS5ibF9vcmRlclttYXhfYmxpbmRleF0gKiAyICsgMV0gIT09IDApXFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8vIFVwZGF0ZSBvcHRfbGVuIHRvIGluY2x1ZGUgdGhlIGJpdCBsZW5ndGggdHJlZSBhbmQgY291bnRzXFxuXFx0XFx0XFx0dGhhdC5vcHRfbGVuICs9IDMgKiAobWF4X2JsaW5kZXggKyAxKSArIDUgKyA1ICsgNDtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbWF4X2JsaW5kZXg7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIE91dHB1dCBhIGJ5dGUgb24gdGhlIHN0cmVhbS5cXG5cXHRcXHQvLyBJTiBhc3NlcnRpb246IHRoZXJlIGlzIGVub3VnaCByb29tIGluIHBlbmRpbmdfYnVmLlxcblxcdFxcdGZ1bmN0aW9uIHB1dF9ieXRlKHApIHtcXG5cXHRcXHRcXHR0aGF0LnBlbmRpbmdfYnVmW3RoYXQucGVuZGluZysrXSA9IHA7XFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHB1dF9zaG9ydCh3KSB7XFxuXFx0XFx0XFx0cHV0X2J5dGUodyAmIDB4ZmYpO1xcblxcdFxcdFxcdHB1dF9ieXRlKCh3ID4+PiA4KSAmIDB4ZmYpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBwdXRTaG9ydE1TQihiKSB7XFxuXFx0XFx0XFx0cHV0X2J5dGUoKGIgPj4gOCkgJiAweGZmKTtcXG5cXHRcXHRcXHRwdXRfYnl0ZSgoYiAmIDB4ZmYpICYgMHhmZik7XFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHNlbmRfYml0cyh2YWx1ZSwgbGVuZ3RoKSB7XFxuXFx0XFx0XFx0dmFyIHZhbCwgbGVuID0gbGVuZ3RoO1xcblxcdFxcdFxcdGlmIChiaV92YWxpZCA+IEJ1Zl9zaXplIC0gbGVuKSB7XFxuXFx0XFx0XFx0XFx0dmFsID0gdmFsdWU7XFxuXFx0XFx0XFx0XFx0Ly8gYmlfYnVmIHw9ICh2YWwgPDwgYmlfdmFsaWQpO1xcblxcdFxcdFxcdFxcdGJpX2J1ZiB8PSAoKHZhbCA8PCBiaV92YWxpZCkgJiAweGZmZmYpO1xcblxcdFxcdFxcdFxcdHB1dF9zaG9ydChiaV9idWYpO1xcblxcdFxcdFxcdFxcdGJpX2J1ZiA9IHZhbCA+Pj4gKEJ1Zl9zaXplIC0gYmlfdmFsaWQpO1xcblxcdFxcdFxcdFxcdGJpX3ZhbGlkICs9IGxlbiAtIEJ1Zl9zaXplO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0Ly8gYmlfYnVmIHw9ICh2YWx1ZSkgPDwgYmlfdmFsaWQ7XFxuXFx0XFx0XFx0XFx0YmlfYnVmIHw9ICgoKHZhbHVlKSA8PCBiaV92YWxpZCkgJiAweGZmZmYpO1xcblxcdFxcdFxcdFxcdGJpX3ZhbGlkICs9IGxlbjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHNlbmRfY29kZShjLCB0cmVlKSB7XFxuXFx0XFx0XFx0dmFyIGMyID0gYyAqIDI7XFxuXFx0XFx0XFx0c2VuZF9iaXRzKHRyZWVbYzJdICYgMHhmZmZmLCB0cmVlW2MyICsgMV0gJiAweGZmZmYpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBTZW5kIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIGluIGNvbXByZXNzZWQgZm9ybSwgdXNpbmcgdGhlIGNvZGVzIGluXFxuXFx0XFx0Ly8gYmxfdHJlZS5cXG5cXHRcXHRmdW5jdGlvbiBzZW5kX3RyZWUodHJlZSwvLyB0aGUgdHJlZSB0byBiZSBzZW50XFxuXFx0XFx0bWF4X2NvZGUgLy8gYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5XFxuXFx0XFx0KSB7XFxuXFx0XFx0XFx0dmFyIG47IC8vIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHNcXG5cXHRcXHRcXHR2YXIgcHJldmxlbiA9IC0xOyAvLyBsYXN0IGVtaXR0ZWQgbGVuZ3RoXFxuXFx0XFx0XFx0dmFyIGN1cmxlbjsgLy8gbGVuZ3RoIG9mIGN1cnJlbnQgY29kZVxcblxcdFxcdFxcdHZhciBuZXh0bGVuID0gdHJlZVswICogMiArIDFdOyAvLyBsZW5ndGggb2YgbmV4dCBjb2RlXFxuXFx0XFx0XFx0dmFyIGNvdW50ID0gMDsgLy8gcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGVcXG5cXHRcXHRcXHR2YXIgbWF4X2NvdW50ID0gNzsgLy8gbWF4IHJlcGVhdCBjb3VudFxcblxcdFxcdFxcdHZhciBtaW5fY291bnQgPSA0OyAvLyBtaW4gcmVwZWF0IGNvdW50XFxuXFxuXFx0XFx0XFx0aWYgKG5leHRsZW4gPT09IDApIHtcXG5cXHRcXHRcXHRcXHRtYXhfY291bnQgPSAxMzg7XFxuXFx0XFx0XFx0XFx0bWluX2NvdW50ID0gMztcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Zm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XFxuXFx0XFx0XFx0XFx0Y3VybGVuID0gbmV4dGxlbjtcXG5cXHRcXHRcXHRcXHRuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdO1xcblxcdFxcdFxcdFxcdGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PSBuZXh0bGVuKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y29udGludWU7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xcblxcdFxcdFxcdFxcdFxcdGRvIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzZW5kX2NvZGUoY3VybGVuLCBibF90cmVlKTtcXG5cXHRcXHRcXHRcXHRcXHR9IHdoaWxlICgtLWNvdW50ICE9PSAwKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdGlmIChjdXJsZW4gIT0gcHJldmxlbikge1xcblxcdFxcdFxcdFxcdFxcdFxcdHNlbmRfY29kZShjdXJsZW4sIGJsX3RyZWUpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNvdW50LS07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHNlbmRfY29kZShSRVBfM182LCBibF90cmVlKTtcXG5cXHRcXHRcXHRcXHRcXHRzZW5kX2JpdHMoY291bnQgLSAzLCAyKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XFxuXFx0XFx0XFx0XFx0XFx0c2VuZF9jb2RlKFJFUFpfM18xMCwgYmxfdHJlZSk7XFxuXFx0XFx0XFx0XFx0XFx0c2VuZF9iaXRzKGNvdW50IC0gMywgMyk7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRzZW5kX2NvZGUoUkVQWl8xMV8xMzgsIGJsX3RyZWUpO1xcblxcdFxcdFxcdFxcdFxcdHNlbmRfYml0cyhjb3VudCAtIDExLCA3KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0Y291bnQgPSAwO1xcblxcdFxcdFxcdFxcdHByZXZsZW4gPSBjdXJsZW47XFxuXFx0XFx0XFx0XFx0aWYgKG5leHRsZW4gPT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRtYXhfY291bnQgPSAxMzg7XFxuXFx0XFx0XFx0XFx0XFx0bWluX2NvdW50ID0gMztcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGN1cmxlbiA9PSBuZXh0bGVuKSB7XFxuXFx0XFx0XFx0XFx0XFx0bWF4X2NvdW50ID0gNjtcXG5cXHRcXHRcXHRcXHRcXHRtaW5fY291bnQgPSAzO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0bWF4X2NvdW50ID0gNztcXG5cXHRcXHRcXHRcXHRcXHRtaW5fY291bnQgPSA0O1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFNlbmQgdGhlIGhlYWRlciBmb3IgYSBibG9jayB1c2luZyBkeW5hbWljIEh1ZmZtYW4gdHJlZXM6IHRoZSBjb3VudHMsIHRoZVxcblxcdFxcdC8vIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMsIHRoZSBsaXRlcmFsIHRyZWUgYW5kIHRoZSBkaXN0YW5jZSB0cmVlLlxcblxcdFxcdC8vIElOIGFzc2VydGlvbjogbGNvZGVzID49IDI1NywgZGNvZGVzID49IDEsIGJsY29kZXMgPj0gNC5cXG5cXHRcXHRmdW5jdGlvbiBzZW5kX2FsbF90cmVlcyhsY29kZXMsIGRjb2RlcywgYmxjb2Rlcykge1xcblxcdFxcdFxcdHZhciByYW5rOyAvLyBpbmRleCBpbiBibF9vcmRlclxcblxcblxcdFxcdFxcdHNlbmRfYml0cyhsY29kZXMgLSAyNTcsIDUpOyAvLyBub3QgKzI1NSBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHRcXG5cXHRcXHRcXHRzZW5kX2JpdHMoZGNvZGVzIC0gMSwgNSk7XFxuXFx0XFx0XFx0c2VuZF9iaXRzKGJsY29kZXMgLSA0LCA0KTsgLy8gbm90IC0zIGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dFxcblxcdFxcdFxcdGZvciAocmFuayA9IDA7IHJhbmsgPCBibGNvZGVzOyByYW5rKyspIHtcXG5cXHRcXHRcXHRcXHRzZW5kX2JpdHMoYmxfdHJlZVtUcmVlLmJsX29yZGVyW3JhbmtdICogMiArIDFdLCAzKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0c2VuZF90cmVlKGR5bl9sdHJlZSwgbGNvZGVzIC0gMSk7IC8vIGxpdGVyYWwgdHJlZVxcblxcdFxcdFxcdHNlbmRfdHJlZShkeW5fZHRyZWUsIGRjb2RlcyAtIDEpOyAvLyBkaXN0YW5jZSB0cmVlXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEZsdXNoIHRoZSBiaXQgYnVmZmVyLCBrZWVwaW5nIGF0IG1vc3QgNyBiaXRzIGluIGl0LlxcblxcdFxcdGZ1bmN0aW9uIGJpX2ZsdXNoKCkge1xcblxcdFxcdFxcdGlmIChiaV92YWxpZCA9PSAxNikge1xcblxcdFxcdFxcdFxcdHB1dF9zaG9ydChiaV9idWYpO1xcblxcdFxcdFxcdFxcdGJpX2J1ZiA9IDA7XFxuXFx0XFx0XFx0XFx0YmlfdmFsaWQgPSAwO1xcblxcdFxcdFxcdH0gZWxzZSBpZiAoYmlfdmFsaWQgPj0gOCkge1xcblxcdFxcdFxcdFxcdHB1dF9ieXRlKGJpX2J1ZiAmIDB4ZmYpO1xcblxcdFxcdFxcdFxcdGJpX2J1ZiA+Pj49IDg7XFxuXFx0XFx0XFx0XFx0YmlfdmFsaWQgLT0gODtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFNlbmQgb25lIGVtcHR5IHN0YXRpYyBibG9jayB0byBnaXZlIGVub3VnaCBsb29rYWhlYWQgZm9yIGluZmxhdGUuXFxuXFx0XFx0Ly8gVGhpcyB0YWtlcyAxMCBiaXRzLCBvZiB3aGljaCA3IG1heSByZW1haW4gaW4gdGhlIGJpdCBidWZmZXIuXFxuXFx0XFx0Ly8gVGhlIGN1cnJlbnQgaW5mbGF0ZSBjb2RlIHJlcXVpcmVzIDkgYml0cyBvZiBsb29rYWhlYWQuIElmIHRoZVxcblxcdFxcdC8vIGxhc3QgdHdvIGNvZGVzIGZvciB0aGUgcHJldmlvdXMgYmxvY2sgKHJlYWwgY29kZSBwbHVzIEVPQikgd2VyZSBjb2RlZFxcblxcdFxcdC8vIG9uIDUgYml0cyBvciBsZXNzLCBpbmZsYXRlIG1heSBoYXZlIG9ubHkgNSszIGJpdHMgb2YgbG9va2FoZWFkIHRvIGRlY29kZVxcblxcdFxcdC8vIHRoZSBsYXN0IHJlYWwgY29kZS4gSW4gdGhpcyBjYXNlIHdlIHNlbmQgdHdvIGVtcHR5IHN0YXRpYyBibG9ja3MgaW5zdGVhZFxcblxcdFxcdC8vIG9mIG9uZS4gKFRoZXJlIGFyZSBubyBwcm9ibGVtcyBpZiB0aGUgcHJldmlvdXMgYmxvY2sgaXMgc3RvcmVkIG9yIGZpeGVkLilcXG5cXHRcXHQvLyBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgYXNzdW1lIHRoZSB3b3JzdCBjYXNlIG9mIGxhc3QgcmVhbCBjb2RlIGVuY29kZWRcXG5cXHRcXHQvLyBvbiBvbmUgYml0IG9ubHkuXFxuXFx0XFx0ZnVuY3Rpb24gX3RyX2FsaWduKCkge1xcblxcdFxcdFxcdHNlbmRfYml0cyhTVEFUSUNfVFJFRVMgPDwgMSwgMyk7XFxuXFx0XFx0XFx0c2VuZF9jb2RlKEVORF9CTE9DSywgU3RhdGljVHJlZS5zdGF0aWNfbHRyZWUpO1xcblxcblxcdFxcdFxcdGJpX2ZsdXNoKCk7XFxuXFxuXFx0XFx0XFx0Ly8gT2YgdGhlIDEwIGJpdHMgZm9yIHRoZSBlbXB0eSBibG9jaywgd2UgaGF2ZSBhbHJlYWR5IHNlbnRcXG5cXHRcXHRcXHQvLyAoMTAgLSBiaV92YWxpZCkgYml0cy4gVGhlIGxvb2thaGVhZCBmb3IgdGhlIGxhc3QgcmVhbCBjb2RlIChiZWZvcmVcXG5cXHRcXHRcXHQvLyB0aGUgRU9CIG9mIHRoZSBwcmV2aW91cyBibG9jaykgd2FzIHRodXMgYXQgbGVhc3Qgb25lIHBsdXMgdGhlIGxlbmd0aFxcblxcdFxcdFxcdC8vIG9mIHRoZSBFT0IgcGx1cyB3aGF0IHdlIGhhdmUganVzdCBzZW50IG9mIHRoZSBlbXB0eSBzdGF0aWMgYmxvY2suXFxuXFx0XFx0XFx0aWYgKDEgKyBsYXN0X2VvYl9sZW4gKyAxMCAtIGJpX3ZhbGlkIDwgOSkge1xcblxcdFxcdFxcdFxcdHNlbmRfYml0cyhTVEFUSUNfVFJFRVMgPDwgMSwgMyk7XFxuXFx0XFx0XFx0XFx0c2VuZF9jb2RlKEVORF9CTE9DSywgU3RhdGljVHJlZS5zdGF0aWNfbHRyZWUpO1xcblxcdFxcdFxcdFxcdGJpX2ZsdXNoKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGxhc3RfZW9iX2xlbiA9IDc7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFNhdmUgdGhlIG1hdGNoIGluZm8gYW5kIHRhbGx5IHRoZSBmcmVxdWVuY3kgY291bnRzLiBSZXR1cm4gdHJ1ZSBpZlxcblxcdFxcdC8vIHRoZSBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZC5cXG5cXHRcXHRmdW5jdGlvbiBfdHJfdGFsbHkoZGlzdCwgLy8gZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmdcXG5cXHRcXHRsYyAvLyBtYXRjaCBsZW5ndGgtTUlOX01BVENIIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0PT0wKVxcblxcdFxcdCkge1xcblxcdFxcdFxcdHZhciBvdXRfbGVuZ3RoLCBpbl9sZW5ndGgsIGRjb2RlO1xcblxcdFxcdFxcdHRoYXQucGVuZGluZ19idWZbZF9idWYgKyBsYXN0X2xpdCAqIDJdID0gKGRpc3QgPj4+IDgpICYgMHhmZjtcXG5cXHRcXHRcXHR0aGF0LnBlbmRpbmdfYnVmW2RfYnVmICsgbGFzdF9saXQgKiAyICsgMV0gPSBkaXN0ICYgMHhmZjtcXG5cXG5cXHRcXHRcXHR0aGF0LnBlbmRpbmdfYnVmW2xfYnVmICsgbGFzdF9saXRdID0gbGMgJiAweGZmO1xcblxcdFxcdFxcdGxhc3RfbGl0Kys7XFxuXFxuXFx0XFx0XFx0aWYgKGRpc3QgPT09IDApIHtcXG5cXHRcXHRcXHRcXHQvLyBsYyBpcyB0aGUgdW5tYXRjaGVkIGNoYXJcXG5cXHRcXHRcXHRcXHRkeW5fbHRyZWVbbGMgKiAyXSsrO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0bWF0Y2hlcysrO1xcblxcdFxcdFxcdFxcdC8vIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0hcXG5cXHRcXHRcXHRcXHRkaXN0LS07IC8vIGRpc3QgPSBtYXRjaCBkaXN0YW5jZSAtIDFcXG5cXHRcXHRcXHRcXHRkeW5fbHRyZWVbKFRyZWUuX2xlbmd0aF9jb2RlW2xjXSArIExJVEVSQUxTICsgMSkgKiAyXSsrO1xcblxcdFxcdFxcdFxcdGR5bl9kdHJlZVtUcmVlLmRfY29kZShkaXN0KSAqIDJdKys7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICgobGFzdF9saXQgJiAweDFmZmYpID09PSAwICYmIGxldmVsID4gMikge1xcblxcdFxcdFxcdFxcdC8vIENvbXB1dGUgYW4gdXBwZXIgYm91bmQgZm9yIHRoZSBjb21wcmVzc2VkIGxlbmd0aFxcblxcdFxcdFxcdFxcdG91dF9sZW5ndGggPSBsYXN0X2xpdCAqIDg7XFxuXFx0XFx0XFx0XFx0aW5fbGVuZ3RoID0gc3Ryc3RhcnQgLSBibG9ja19zdGFydDtcXG5cXHRcXHRcXHRcXHRmb3IgKGRjb2RlID0gMDsgZGNvZGUgPCBEX0NPREVTOyBkY29kZSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0b3V0X2xlbmd0aCArPSBkeW5fZHRyZWVbZGNvZGUgKiAyXSAqICg1ICsgVHJlZS5leHRyYV9kYml0c1tkY29kZV0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRvdXRfbGVuZ3RoID4+Pj0gMztcXG5cXHRcXHRcXHRcXHRpZiAoKG1hdGNoZXMgPCBNYXRoLmZsb29yKGxhc3RfbGl0IC8gMikpICYmIG91dF9sZW5ndGggPCBNYXRoLmZsb29yKGluX2xlbmd0aCAvIDIpKVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gKGxhc3RfbGl0ID09IGxpdF9idWZzaXplIC0gMSk7XFxuXFx0XFx0XFx0Ly8gV2UgYXZvaWQgZXF1YWxpdHkgd2l0aCBsaXRfYnVmc2l6ZSBiZWNhdXNlIG9mIHdyYXBhcm91bmQgYXQgNjRLXFxuXFx0XFx0XFx0Ly8gb24gMTYgYml0IG1hY2hpbmVzIGFuZCBiZWNhdXNlIHN0b3JlZCBibG9ja3MgYXJlIHJlc3RyaWN0ZWQgdG9cXG5cXHRcXHRcXHQvLyA2NEstMSBieXRlcy5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gU2VuZCB0aGUgYmxvY2sgZGF0YSBjb21wcmVzc2VkIHVzaW5nIHRoZSBnaXZlbiBIdWZmbWFuIHRyZWVzXFxuXFx0XFx0ZnVuY3Rpb24gY29tcHJlc3NfYmxvY2sobHRyZWUsIGR0cmVlKSB7XFxuXFx0XFx0XFx0dmFyIGRpc3Q7IC8vIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nXFxuXFx0XFx0XFx0dmFyIGxjOyAvLyBtYXRjaCBsZW5ndGggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3QgPT09IDApXFxuXFx0XFx0XFx0dmFyIGx4ID0gMDsgLy8gcnVubmluZyBpbmRleCBpbiBsX2J1ZlxcblxcdFxcdFxcdHZhciBjb2RlOyAvLyB0aGUgY29kZSB0byBzZW5kXFxuXFx0XFx0XFx0dmFyIGV4dHJhOyAvLyBudW1iZXIgb2YgZXh0cmEgYml0cyB0byBzZW5kXFxuXFxuXFx0XFx0XFx0aWYgKGxhc3RfbGl0ICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0ZG8ge1xcblxcdFxcdFxcdFxcdFxcdGRpc3QgPSAoKHRoYXQucGVuZGluZ19idWZbZF9idWYgKyBseCAqIDJdIDw8IDgpICYgMHhmZjAwKSB8ICh0aGF0LnBlbmRpbmdfYnVmW2RfYnVmICsgbHggKiAyICsgMV0gJiAweGZmKTtcXG5cXHRcXHRcXHRcXHRcXHRsYyA9ICh0aGF0LnBlbmRpbmdfYnVmW2xfYnVmICsgbHhdKSAmIDB4ZmY7XFxuXFx0XFx0XFx0XFx0XFx0bHgrKztcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoZGlzdCA9PT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHNlbmRfY29kZShsYywgbHRyZWUpOyAvLyBzZW5kIGEgbGl0ZXJhbCBieXRlXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29kZSA9IFRyZWUuX2xlbmd0aF9jb2RlW2xjXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRzZW5kX2NvZGUoY29kZSArIExJVEVSQUxTICsgMSwgbHRyZWUpOyAvLyBzZW5kIHRoZSBsZW5ndGhcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBjb2RlXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZXh0cmEgPSBUcmVlLmV4dHJhX2xiaXRzW2NvZGVdO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChleHRyYSAhPT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGxjIC09IFRyZWUuYmFzZV9sZW5ndGhbY29kZV07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2VuZF9iaXRzKGxjLCBleHRyYSk7IC8vIHNlbmQgdGhlIGV4dHJhIGxlbmd0aCBiaXRzXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGRpc3QtLTsgLy8gZGlzdCBpcyBub3cgdGhlIG1hdGNoIGRpc3RhbmNlIC0gMVxcblxcdFxcdFxcdFxcdFxcdFxcdGNvZGUgPSBUcmVlLmRfY29kZShkaXN0KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRzZW5kX2NvZGUoY29kZSwgZHRyZWUpOyAvLyBzZW5kIHRoZSBkaXN0YW5jZSBjb2RlXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZXh0cmEgPSBUcmVlLmV4dHJhX2RiaXRzW2NvZGVdO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChleHRyYSAhPT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRpc3QgLT0gVHJlZS5iYXNlX2Rpc3RbY29kZV07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2VuZF9iaXRzKGRpc3QsIGV4dHJhKTsgLy8gc2VuZCB0aGUgZXh0cmEgZGlzdGFuY2UgYml0c1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9IC8vIGxpdGVyYWwgb3IgbWF0Y2ggcGFpciA/XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gQ2hlY2sgdGhhdCB0aGUgb3ZlcmxheSBiZXR3ZWVuIHBlbmRpbmdfYnVmIGFuZCBkX2J1ZitsX2J1ZiBpc1xcblxcdFxcdFxcdFxcdFxcdC8vIG9rOlxcblxcdFxcdFxcdFxcdH0gd2hpbGUgKGx4IDwgbGFzdF9saXQpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRzZW5kX2NvZGUoRU5EX0JMT0NLLCBsdHJlZSk7XFxuXFx0XFx0XFx0bGFzdF9lb2JfbGVuID0gbHRyZWVbRU5EX0JMT0NLICogMiArIDFdO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBGbHVzaCB0aGUgYml0IGJ1ZmZlciBhbmQgYWxpZ24gdGhlIG91dHB1dCBvbiBhIGJ5dGUgYm91bmRhcnlcXG5cXHRcXHRmdW5jdGlvbiBiaV93aW5kdXAoKSB7XFxuXFx0XFx0XFx0aWYgKGJpX3ZhbGlkID4gOCkge1xcblxcdFxcdFxcdFxcdHB1dF9zaG9ydChiaV9idWYpO1xcblxcdFxcdFxcdH0gZWxzZSBpZiAoYmlfdmFsaWQgPiAwKSB7XFxuXFx0XFx0XFx0XFx0cHV0X2J5dGUoYmlfYnVmICYgMHhmZik7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGJpX2J1ZiA9IDA7XFxuXFx0XFx0XFx0YmlfdmFsaWQgPSAwO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBDb3B5IGEgc3RvcmVkIGJsb2NrLCBzdG9yaW5nIGZpcnN0IHRoZSBsZW5ndGggYW5kIGl0c1xcblxcdFxcdC8vIG9uZSdzIGNvbXBsZW1lbnQgaWYgcmVxdWVzdGVkLlxcblxcdFxcdGZ1bmN0aW9uIGNvcHlfYmxvY2soYnVmLCAvLyB0aGUgaW5wdXQgZGF0YVxcblxcdFxcdGxlbiwgLy8gaXRzIGxlbmd0aFxcblxcdFxcdGhlYWRlciAvLyB0cnVlIGlmIGJsb2NrIGhlYWRlciBtdXN0IGJlIHdyaXR0ZW5cXG5cXHRcXHQpIHtcXG5cXHRcXHRcXHRiaV93aW5kdXAoKTsgLy8gYWxpZ24gb24gYnl0ZSBib3VuZGFyeVxcblxcdFxcdFxcdGxhc3RfZW9iX2xlbiA9IDg7IC8vIGVub3VnaCBsb29rYWhlYWQgZm9yIGluZmxhdGVcXG5cXG5cXHRcXHRcXHRpZiAoaGVhZGVyKSB7XFxuXFx0XFx0XFx0XFx0cHV0X3Nob3J0KGxlbik7XFxuXFx0XFx0XFx0XFx0cHV0X3Nob3J0KH5sZW4pO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGF0LnBlbmRpbmdfYnVmLnNldCh3aW5kb3cuc3ViYXJyYXkoYnVmLCBidWYgKyBsZW4pLCB0aGF0LnBlbmRpbmcpO1xcblxcdFxcdFxcdHRoYXQucGVuZGluZyArPSBsZW47XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFNlbmQgYSBzdG9yZWQgYmxvY2tcXG5cXHRcXHRmdW5jdGlvbiBfdHJfc3RvcmVkX2Jsb2NrKGJ1ZiwgLy8gaW5wdXQgYmxvY2tcXG5cXHRcXHRzdG9yZWRfbGVuLCAvLyBsZW5ndGggb2YgaW5wdXQgYmxvY2tcXG5cXHRcXHRlb2YgLy8gdHJ1ZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGVcXG5cXHRcXHQpIHtcXG5cXHRcXHRcXHRzZW5kX2JpdHMoKFNUT1JFRF9CTE9DSyA8PCAxKSArIChlb2YgPyAxIDogMCksIDMpOyAvLyBzZW5kIGJsb2NrIHR5cGVcXG5cXHRcXHRcXHRjb3B5X2Jsb2NrKGJ1Ziwgc3RvcmVkX2xlbiwgdHJ1ZSk7IC8vIHdpdGggaGVhZGVyXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZyBmb3IgdGhlIGN1cnJlbnQgYmxvY2s6IGR5bmFtaWMgdHJlZXMsIHN0YXRpY1xcblxcdFxcdC8vIHRyZWVzIG9yIHN0b3JlLCBhbmQgb3V0cHV0IHRoZSBlbmNvZGVkIGJsb2NrIHRvIHRoZSB6aXAgZmlsZS5cXG5cXHRcXHRmdW5jdGlvbiBfdHJfZmx1c2hfYmxvY2soYnVmLCAvLyBpbnB1dCBibG9jaywgb3IgTlVMTCBpZiB0b28gb2xkXFxuXFx0XFx0c3RvcmVkX2xlbiwgLy8gbGVuZ3RoIG9mIGlucHV0IGJsb2NrXFxuXFx0XFx0ZW9mIC8vIHRydWUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlXFxuXFx0XFx0KSB7XFxuXFx0XFx0XFx0dmFyIG9wdF9sZW5iLCBzdGF0aWNfbGVuYjsvLyBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGluIGJ5dGVzXFxuXFx0XFx0XFx0dmFyIG1heF9ibGluZGV4ID0gMDsgLy8gaW5kZXggb2YgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgb2Ygbm9uIHplcm8gZnJlcVxcblxcblxcdFxcdFxcdC8vIEJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzIHVubGVzcyBhIHN0b3JlZCBibG9jayBpcyBmb3JjZWRcXG5cXHRcXHRcXHRpZiAobGV2ZWwgPiAwKSB7XFxuXFx0XFx0XFx0XFx0Ly8gQ29uc3RydWN0IHRoZSBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlc1xcblxcdFxcdFxcdFxcdGxfZGVzYy5idWlsZF90cmVlKHRoYXQpO1xcblxcblxcdFxcdFxcdFxcdGRfZGVzYy5idWlsZF90cmVlKHRoYXQpO1xcblxcblxcdFxcdFxcdFxcdC8vIEF0IHRoaXMgcG9pbnQsIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gYXJlIHRoZSB0b3RhbCBiaXQgbGVuZ3Roc1xcblxcdFxcdFxcdFxcdC8vIG9mXFxuXFx0XFx0XFx0XFx0Ly8gdGhlIGNvbXByZXNzZWQgYmxvY2sgZGF0YSwgZXhjbHVkaW5nIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucy5cXG5cXG5cXHRcXHRcXHRcXHQvLyBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlIGZvciB0aGUgYWJvdmUgdHdvIHRyZWVzLCBhbmQgZ2V0IHRoZVxcblxcdFxcdFxcdFxcdC8vIGluZGV4XFxuXFx0XFx0XFx0XFx0Ly8gaW4gYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXFxuXFx0XFx0XFx0XFx0bWF4X2JsaW5kZXggPSBidWlsZF9ibF90cmVlKCk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nLiBDb21wdXRlIGZpcnN0IHRoZSBibG9jayBsZW5ndGggaW5cXG5cXHRcXHRcXHRcXHQvLyBieXRlc1xcblxcdFxcdFxcdFxcdG9wdF9sZW5iID0gKHRoYXQub3B0X2xlbiArIDMgKyA3KSA+Pj4gMztcXG5cXHRcXHRcXHRcXHRzdGF0aWNfbGVuYiA9ICh0aGF0LnN0YXRpY19sZW4gKyAzICsgNykgPj4+IDM7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKHN0YXRpY19sZW5iIDw9IG9wdF9sZW5iKVxcblxcdFxcdFxcdFxcdFxcdG9wdF9sZW5iID0gc3RhdGljX2xlbmI7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRvcHRfbGVuYiA9IHN0YXRpY19sZW5iID0gc3RvcmVkX2xlbiArIDU7IC8vIGZvcmNlIGEgc3RvcmVkIGJsb2NrXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICgoc3RvcmVkX2xlbiArIDQgPD0gb3B0X2xlbmIpICYmIGJ1ZiAhPSAtMSkge1xcblxcdFxcdFxcdFxcdC8vIDQ6IHR3byB3b3JkcyBmb3IgdGhlIGxlbmd0aHNcXG5cXHRcXHRcXHRcXHQvLyBUaGUgdGVzdCBidWYgIT0gTlVMTCBpcyBvbmx5IG5lY2Vzc2FyeSBpZiBMSVRfQlVGU0laRSA+IFdTSVpFLlxcblxcdFxcdFxcdFxcdC8vIE90aGVyd2lzZSB3ZSBjYW4ndCBoYXZlIHByb2Nlc3NlZCBtb3JlIHRoYW4gV1NJWkUgaW5wdXQgYnl0ZXNcXG5cXHRcXHRcXHRcXHQvLyBzaW5jZVxcblxcdFxcdFxcdFxcdC8vIHRoZSBsYXN0IGJsb2NrIGZsdXNoLCBiZWNhdXNlIGNvbXByZXNzaW9uIHdvdWxkIGhhdmUgYmVlblxcblxcdFxcdFxcdFxcdC8vIHN1Y2Nlc3NmdWwuIElmIExJVF9CVUZTSVpFIDw9IFdTSVpFLCBpdCBpcyBuZXZlciB0b28gbGF0ZSB0b1xcblxcdFxcdFxcdFxcdC8vIHRyYW5zZm9ybSBhIGJsb2NrIGludG8gYSBzdG9yZWQgYmxvY2suXFxuXFx0XFx0XFx0XFx0X3RyX3N0b3JlZF9ibG9jayhidWYsIHN0b3JlZF9sZW4sIGVvZik7XFxuXFx0XFx0XFx0fSBlbHNlIGlmIChzdGF0aWNfbGVuYiA9PSBvcHRfbGVuYikge1xcblxcdFxcdFxcdFxcdHNlbmRfYml0cygoU1RBVElDX1RSRUVTIDw8IDEpICsgKGVvZiA/IDEgOiAwKSwgMyk7XFxuXFx0XFx0XFx0XFx0Y29tcHJlc3NfYmxvY2soU3RhdGljVHJlZS5zdGF0aWNfbHRyZWUsIFN0YXRpY1RyZWUuc3RhdGljX2R0cmVlKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHNlbmRfYml0cygoRFlOX1RSRUVTIDw8IDEpICsgKGVvZiA/IDEgOiAwKSwgMyk7XFxuXFx0XFx0XFx0XFx0c2VuZF9hbGxfdHJlZXMobF9kZXNjLm1heF9jb2RlICsgMSwgZF9kZXNjLm1heF9jb2RlICsgMSwgbWF4X2JsaW5kZXggKyAxKTtcXG5cXHRcXHRcXHRcXHRjb21wcmVzc19ibG9jayhkeW5fbHRyZWUsIGR5bl9kdHJlZSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFRoZSBhYm92ZSBjaGVjayBpcyBtYWRlIG1vZCAyXjMyLCBmb3IgZmlsZXMgbGFyZ2VyIHRoYW4gNTEyIE1CXFxuXFx0XFx0XFx0Ly8gYW5kIHVMb25nIGltcGxlbWVudGVkIG9uIDMyIGJpdHMuXFxuXFxuXFx0XFx0XFx0aW5pdF9ibG9jaygpO1xcblxcblxcdFxcdFxcdGlmIChlb2YpIHtcXG5cXHRcXHRcXHRcXHRiaV93aW5kdXAoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIGZsdXNoX2Jsb2NrX29ubHkoZW9mKSB7XFxuXFx0XFx0XFx0X3RyX2ZsdXNoX2Jsb2NrKGJsb2NrX3N0YXJ0ID49IDAgPyBibG9ja19zdGFydCA6IC0xLCBzdHJzdGFydCAtIGJsb2NrX3N0YXJ0LCBlb2YpO1xcblxcdFxcdFxcdGJsb2NrX3N0YXJ0ID0gc3Ryc3RhcnQ7XFxuXFx0XFx0XFx0c3RybS5mbHVzaF9wZW5kaW5nKCk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEZpbGwgdGhlIHdpbmRvdyB3aGVuIHRoZSBsb29rYWhlYWQgYmVjb21lcyBpbnN1ZmZpY2llbnQuXFxuXFx0XFx0Ly8gVXBkYXRlcyBzdHJzdGFydCBhbmQgbG9va2FoZWFkLlxcblxcdFxcdC8vXFxuXFx0XFx0Ly8gSU4gYXNzZXJ0aW9uOiBsb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEXFxuXFx0XFx0Ly8gT1VUIGFzc2VydGlvbnM6IHN0cnN0YXJ0IDw9IHdpbmRvd19zaXplLU1JTl9MT09LQUhFQURcXG5cXHRcXHQvLyBBdCBsZWFzdCBvbmUgYnl0ZSBoYXMgYmVlbiByZWFkLCBvciBhdmFpbF9pbiA9PT0gMDsgcmVhZHMgYXJlXFxuXFx0XFx0Ly8gcGVyZm9ybWVkIGZvciBhdCBsZWFzdCB0d28gYnl0ZXMgKHJlcXVpcmVkIGZvciB0aGUgemlwIHRyYW5zbGF0ZV9lb2xcXG5cXHRcXHQvLyBvcHRpb24gLS0gbm90IHN1cHBvcnRlZCBoZXJlKS5cXG5cXHRcXHRmdW5jdGlvbiBmaWxsX3dpbmRvdygpIHtcXG5cXHRcXHRcXHR2YXIgbiwgbTtcXG5cXHRcXHRcXHR2YXIgcDtcXG5cXHRcXHRcXHR2YXIgbW9yZTsgLy8gQW1vdW50IG9mIGZyZWUgc3BhY2UgYXQgdGhlIGVuZCBvZiB0aGUgd2luZG93LlxcblxcblxcdFxcdFxcdGRvIHtcXG5cXHRcXHRcXHRcXHRtb3JlID0gKHdpbmRvd19zaXplIC0gbG9va2FoZWFkIC0gc3Ryc3RhcnQpO1xcblxcblxcdFxcdFxcdFxcdC8vIERlYWwgd2l0aCAhQCMkJSA2NEsgbGltaXQ6XFxuXFx0XFx0XFx0XFx0aWYgKG1vcmUgPT09IDAgJiYgc3Ryc3RhcnQgPT09IDAgJiYgbG9va2FoZWFkID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0bW9yZSA9IHdfc2l6ZTtcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKG1vcmUgPT0gLTEpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBWZXJ5IHVubGlrZWx5LCBidXQgcG9zc2libGUgb24gMTYgYml0IG1hY2hpbmUgaWYgc3Ryc3RhcnQgPT1cXG5cXHRcXHRcXHRcXHRcXHQvLyAwXFxuXFx0XFx0XFx0XFx0XFx0Ly8gYW5kIGxvb2thaGVhZCA9PSAxIChpbnB1dCBkb25lIG9uZSBieXRlIGF0IHRpbWUpXFxuXFx0XFx0XFx0XFx0XFx0bW9yZS0tO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIElmIHRoZSB3aW5kb3cgaXMgYWxtb3N0IGZ1bGwgYW5kIHRoZXJlIGlzIGluc3VmZmljaWVudFxcblxcdFxcdFxcdFxcdFxcdC8vIGxvb2thaGVhZCxcXG5cXHRcXHRcXHRcXHRcXHQvLyBtb3ZlIHRoZSB1cHBlciBoYWxmIHRvIHRoZSBsb3dlciBvbmUgdG8gbWFrZSByb29tIGluIHRoZVxcblxcdFxcdFxcdFxcdFxcdC8vIHVwcGVyIGhhbGYuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmIChzdHJzdGFydCA+PSB3X3NpemUgKyB3X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB7XFxuXFx0XFx0XFx0XFx0XFx0d2luZG93LnNldCh3aW5kb3cuc3ViYXJyYXkod19zaXplLCB3X3NpemUgKyB3X3NpemUpLCAwKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRtYXRjaF9zdGFydCAtPSB3X3NpemU7XFxuXFx0XFx0XFx0XFx0XFx0c3Ryc3RhcnQgLT0gd19zaXplOyAvLyB3ZSBub3cgaGF2ZSBzdHJzdGFydCA+PSBNQVhfRElTVFxcblxcdFxcdFxcdFxcdFxcdGJsb2NrX3N0YXJ0IC09IHdfc2l6ZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBTbGlkZSB0aGUgaGFzaCB0YWJsZSAoY291bGQgYmUgYXZvaWRlZCB3aXRoIDMyIGJpdCB2YWx1ZXNcXG5cXHRcXHRcXHRcXHRcXHQvLyBhdCB0aGUgZXhwZW5zZSBvZiBtZW1vcnkgdXNhZ2UpLiBXZSBzbGlkZSBldmVuIHdoZW4gbGV2ZWwgPT1cXG5cXHRcXHRcXHRcXHRcXHQvLyAwXFxuXFx0XFx0XFx0XFx0XFx0Ly8gdG8ga2VlcCB0aGUgaGFzaCB0YWJsZSBjb25zaXN0ZW50IGlmIHdlIHN3aXRjaCBiYWNrIHRvIGxldmVsXFxuXFx0XFx0XFx0XFx0XFx0Ly8gPiAwXFxuXFx0XFx0XFx0XFx0XFx0Ly8gbGF0ZXIuIChVc2luZyBsZXZlbCAwIHBlcm1hbmVudGx5IGlzIG5vdCBhbiBvcHRpbWFsIHVzYWdlIG9mXFxuXFx0XFx0XFx0XFx0XFx0Ly8gemxpYiwgc28gd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGlzIHBhdGhvbG9naWNhbCBjYXNlLilcXG5cXG5cXHRcXHRcXHRcXHRcXHRuID0gaGFzaF9zaXplO1xcblxcdFxcdFxcdFxcdFxcdHAgPSBuO1xcblxcdFxcdFxcdFxcdFxcdGRvIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtID0gKGhlYWRbLS1wXSAmIDB4ZmZmZik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aGVhZFtwXSA9IChtID49IHdfc2l6ZSA/IG0gLSB3X3NpemUgOiAwKTtcXG5cXHRcXHRcXHRcXHRcXHR9IHdoaWxlICgtLW4gIT09IDApO1xcblxcblxcdFxcdFxcdFxcdFxcdG4gPSB3X3NpemU7XFxuXFx0XFx0XFx0XFx0XFx0cCA9IG47XFxuXFx0XFx0XFx0XFx0XFx0ZG8ge1xcblxcdFxcdFxcdFxcdFxcdFxcdG0gPSAocHJldlstLXBdICYgMHhmZmZmKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwcmV2W3BdID0gKG0gPj0gd19zaXplID8gbSAtIHdfc2l6ZSA6IDApO1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIElmIG4gaXMgbm90IG9uIGFueSBoYXNoIGNoYWluLCBwcmV2W25dIGlzIGdhcmJhZ2UgYnV0XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gaXRzIHZhbHVlIHdpbGwgbmV2ZXIgYmUgdXNlZC5cXG5cXHRcXHRcXHRcXHRcXHR9IHdoaWxlICgtLW4gIT09IDApO1xcblxcdFxcdFxcdFxcdFxcdG1vcmUgKz0gd19zaXplO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoc3RybS5hdmFpbF9pbiA9PT0gMClcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSWYgdGhlcmUgd2FzIG5vIHNsaWRpbmc6XFxuXFx0XFx0XFx0XFx0Ly8gc3Ryc3RhcnQgPD0gV1NJWkUrTUFYX0RJU1QtMSAmJiBsb29rYWhlYWQgPD0gTUlOX0xPT0tBSEVBRCAtIDEgJiZcXG5cXHRcXHRcXHRcXHQvLyBtb3JlID09IHdpbmRvd19zaXplIC0gbG9va2FoZWFkIC0gc3Ryc3RhcnRcXG5cXHRcXHRcXHRcXHQvLyA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gKE1JTl9MT09LQUhFQUQtMSArIFdTSVpFICsgTUFYX0RJU1QtMSlcXG5cXHRcXHRcXHRcXHQvLyA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gMipXU0laRSArIDJcXG5cXHRcXHRcXHRcXHQvLyBJbiB0aGUgQklHX01FTSBvciBNTUFQIGNhc2UgKG5vdCB5ZXQgc3VwcG9ydGVkKSxcXG5cXHRcXHRcXHRcXHQvLyB3aW5kb3dfc2l6ZSA9PSBpbnB1dF9zaXplICsgTUlOX0xPT0tBSEVBRCAmJlxcblxcdFxcdFxcdFxcdC8vIHN0cnN0YXJ0ICsgcy0+bG9va2FoZWFkIDw9IGlucHV0X3NpemUgPT4gbW9yZSA+PSBNSU5fTE9PS0FIRUFELlxcblxcdFxcdFxcdFxcdC8vIE90aGVyd2lzZSwgd2luZG93X3NpemUgPT0gMipXU0laRSBzbyBtb3JlID49IDIuXFxuXFx0XFx0XFx0XFx0Ly8gSWYgdGhlcmUgd2FzIHNsaWRpbmcsIG1vcmUgPj0gV1NJWkUuIFNvIGluIGFsbCBjYXNlcywgbW9yZSA+PSAyLlxcblxcblxcdFxcdFxcdFxcdG4gPSBzdHJtLnJlYWRfYnVmKHdpbmRvdywgc3Ryc3RhcnQgKyBsb29rYWhlYWQsIG1vcmUpO1xcblxcdFxcdFxcdFxcdGxvb2thaGVhZCArPSBuO1xcblxcblxcdFxcdFxcdFxcdC8vIEluaXRpYWxpemUgdGhlIGhhc2ggdmFsdWUgbm93IHRoYXQgd2UgaGF2ZSBzb21lIGlucHV0OlxcblxcdFxcdFxcdFxcdGlmIChsb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XFxuXFx0XFx0XFx0XFx0XFx0aW5zX2ggPSB3aW5kb3dbc3Ryc3RhcnRdICYgMHhmZjtcXG5cXHRcXHRcXHRcXHRcXHRpbnNfaCA9ICgoKGluc19oKSA8PCBoYXNoX3NoaWZ0KSBeICh3aW5kb3dbc3Ryc3RhcnQgKyAxXSAmIDB4ZmYpKSAmIGhhc2hfbWFzaztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0Ly8gSWYgdGhlIHdob2xlIGlucHV0IGhhcyBsZXNzIHRoYW4gTUlOX01BVENIIGJ5dGVzLCBpbnNfaCBpc1xcblxcdFxcdFxcdFxcdC8vIGdhcmJhZ2UsXFxuXFx0XFx0XFx0XFx0Ly8gYnV0IHRoaXMgaXMgbm90IGltcG9ydGFudCBzaW5jZSBvbmx5IGxpdGVyYWwgYnl0ZXMgd2lsbCBiZVxcblxcdFxcdFxcdFxcdC8vIGVtaXR0ZWQuXFxuXFx0XFx0XFx0fSB3aGlsZSAobG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQ29weSB3aXRob3V0IGNvbXByZXNzaW9uIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLFxcblxcdFxcdC8vIHJldHVyblxcblxcdFxcdC8vIHRoZSBjdXJyZW50IGJsb2NrIHN0YXRlLlxcblxcdFxcdC8vIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgaW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IHNpbmNlXFxuXFx0XFx0Ly8gdW5jb21wcmVzc2libGUgZGF0YSBpcyBwcm9iYWJseSBub3QgdXNlZnVsLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWRcXG5cXHRcXHQvLyBvbmx5IGZvciB0aGUgbGV2ZWw9MCBjb21wcmVzc2lvbiBvcHRpb24uXFxuXFx0XFx0Ly8gTk9URTogdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgb3B0aW1pemVkIHRvIGF2b2lkIGV4dHJhIGNvcHlpbmcgZnJvbVxcblxcdFxcdC8vIHdpbmRvdyB0byBwZW5kaW5nX2J1Zi5cXG5cXHRcXHRmdW5jdGlvbiBkZWZsYXRlX3N0b3JlZChmbHVzaCkge1xcblxcdFxcdFxcdC8vIFN0b3JlZCBibG9ja3MgYXJlIGxpbWl0ZWQgdG8gMHhmZmZmIGJ5dGVzLCBwZW5kaW5nX2J1ZiBpcyBsaW1pdGVkXFxuXFx0XFx0XFx0Ly8gdG8gcGVuZGluZ19idWZfc2l6ZSwgYW5kIGVhY2ggc3RvcmVkIGJsb2NrIGhhcyBhIDUgYnl0ZSBoZWFkZXI6XFxuXFxuXFx0XFx0XFx0dmFyIG1heF9ibG9ja19zaXplID0gMHhmZmZmO1xcblxcdFxcdFxcdHZhciBtYXhfc3RhcnQ7XFxuXFxuXFx0XFx0XFx0aWYgKG1heF9ibG9ja19zaXplID4gcGVuZGluZ19idWZfc2l6ZSAtIDUpIHtcXG5cXHRcXHRcXHRcXHRtYXhfYmxvY2tfc2l6ZSA9IHBlbmRpbmdfYnVmX3NpemUgLSA1O1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBDb3B5IGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSBpbnB1dCB0byBvdXRwdXQ6XFxuXFx0XFx0XFx0d2hpbGUgKHRydWUpIHtcXG5cXHRcXHRcXHRcXHQvLyBGaWxsIHRoZSB3aW5kb3cgYXMgbXVjaCBhcyBwb3NzaWJsZTpcXG5cXHRcXHRcXHRcXHRpZiAobG9va2FoZWFkIDw9IDEpIHtcXG5cXHRcXHRcXHRcXHRcXHRmaWxsX3dpbmRvdygpO1xcblxcdFxcdFxcdFxcdFxcdGlmIChsb29rYWhlYWQgPT09IDAgJiYgZmx1c2ggPT0gWl9OT19GTFVTSClcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gTmVlZE1vcmU7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGxvb2thaGVhZCA9PT0gMClcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhazsgLy8gZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2tcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0c3Ryc3RhcnQgKz0gbG9va2FoZWFkO1xcblxcdFxcdFxcdFxcdGxvb2thaGVhZCA9IDA7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRW1pdCBhIHN0b3JlZCBibG9jayBpZiBwZW5kaW5nX2J1ZiB3aWxsIGJlIGZ1bGw6XFxuXFx0XFx0XFx0XFx0bWF4X3N0YXJ0ID0gYmxvY2tfc3RhcnQgKyBtYXhfYmxvY2tfc2l6ZTtcXG5cXHRcXHRcXHRcXHRpZiAoc3Ryc3RhcnQgPT09IDAgfHwgc3Ryc3RhcnQgPj0gbWF4X3N0YXJ0KSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gc3Ryc3RhcnQgPT09IDAgaXMgcG9zc2libGUgd2hlbiB3cmFwYXJvdW5kIG9uIDE2LWJpdCBtYWNoaW5lXFxuXFx0XFx0XFx0XFx0XFx0bG9va2FoZWFkID0gKHN0cnN0YXJ0IC0gbWF4X3N0YXJ0KTtcXG5cXHRcXHRcXHRcXHRcXHRzdHJzdGFydCA9IG1heF9zdGFydDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmbHVzaF9ibG9ja19vbmx5KGZhbHNlKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIE5lZWRNb3JlO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBGbHVzaCBpZiB3ZSBtYXkgaGF2ZSB0byBzbGlkZSwgb3RoZXJ3aXNlIGJsb2NrX3N0YXJ0IG1heSBiZWNvbWVcXG5cXHRcXHRcXHRcXHQvLyBuZWdhdGl2ZSBhbmQgdGhlIGRhdGEgd2lsbCBiZSBnb25lOlxcblxcdFxcdFxcdFxcdGlmIChzdHJzdGFydCAtIGJsb2NrX3N0YXJ0ID49IHdfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHtcXG5cXHRcXHRcXHRcXHRcXHRmbHVzaF9ibG9ja19vbmx5KGZhbHNlKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIE5lZWRNb3JlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Zmx1c2hfYmxvY2tfb25seShmbHVzaCA9PSBaX0ZJTklTSCk7XFxuXFx0XFx0XFx0aWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKVxcblxcdFxcdFxcdFxcdHJldHVybiAoZmx1c2ggPT0gWl9GSU5JU0gpID8gRmluaXNoU3RhcnRlZCA6IE5lZWRNb3JlO1xcblxcblxcdFxcdFxcdHJldHVybiBmbHVzaCA9PSBaX0ZJTklTSCA/IEZpbmlzaERvbmUgOiBCbG9ja0RvbmU7XFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIGxvbmdlc3RfbWF0Y2goY3VyX21hdGNoKSB7XFxuXFx0XFx0XFx0dmFyIGNoYWluX2xlbmd0aCA9IG1heF9jaGFpbl9sZW5ndGg7IC8vIG1heCBoYXNoIGNoYWluIGxlbmd0aFxcblxcdFxcdFxcdHZhciBzY2FuID0gc3Ryc3RhcnQ7IC8vIGN1cnJlbnQgc3RyaW5nXFxuXFx0XFx0XFx0dmFyIG1hdGNoOyAvLyBtYXRjaGVkIHN0cmluZ1xcblxcdFxcdFxcdHZhciBsZW47IC8vIGxlbmd0aCBvZiBjdXJyZW50IG1hdGNoXFxuXFx0XFx0XFx0dmFyIGJlc3RfbGVuID0gcHJldl9sZW5ndGg7IC8vIGJlc3QgbWF0Y2ggbGVuZ3RoIHNvIGZhclxcblxcdFxcdFxcdHZhciBsaW1pdCA9IHN0cnN0YXJ0ID4gKHdfc2l6ZSAtIE1JTl9MT09LQUhFQUQpID8gc3Ryc3RhcnQgLSAod19zaXplIC0gTUlOX0xPT0tBSEVBRCkgOiAwO1xcblxcdFxcdFxcdHZhciBfbmljZV9tYXRjaCA9IG5pY2VfbWF0Y2g7XFxuXFxuXFx0XFx0XFx0Ly8gU3RvcCB3aGVuIGN1cl9tYXRjaCBiZWNvbWVzIDw9IGxpbWl0LiBUbyBzaW1wbGlmeSB0aGUgY29kZSxcXG5cXHRcXHRcXHQvLyB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nIG9mIHdpbmRvdyBpbmRleCAwLlxcblxcblxcdFxcdFxcdHZhciB3bWFzayA9IHdfbWFzaztcXG5cXG5cXHRcXHRcXHR2YXIgc3RyZW5kID0gc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XFxuXFx0XFx0XFx0dmFyIHNjYW5fZW5kMSA9IHdpbmRvd1tzY2FuICsgYmVzdF9sZW4gLSAxXTtcXG5cXHRcXHRcXHR2YXIgc2Nhbl9lbmQgPSB3aW5kb3dbc2NhbiArIGJlc3RfbGVuXTtcXG5cXG5cXHRcXHRcXHQvLyBUaGUgY29kZSBpcyBvcHRpbWl6ZWQgZm9yIEhBU0hfQklUUyA+PSA4IGFuZCBNQVhfTUFUQ0gtMiBtdWx0aXBsZSBvZlxcblxcdFxcdFxcdC8vIDE2LlxcblxcdFxcdFxcdC8vIEl0IGlzIGVhc3kgdG8gZ2V0IHJpZCBvZiB0aGlzIG9wdGltaXphdGlvbiBpZiBuZWNlc3NhcnkuXFxuXFxuXFx0XFx0XFx0Ly8gRG8gbm90IHdhc3RlIHRvbyBtdWNoIHRpbWUgaWYgd2UgYWxyZWFkeSBoYXZlIGEgZ29vZCBtYXRjaDpcXG5cXHRcXHRcXHRpZiAocHJldl9sZW5ndGggPj0gZ29vZF9tYXRjaCkge1xcblxcdFxcdFxcdFxcdGNoYWluX2xlbmd0aCA+Pj0gMjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gRG8gbm90IGxvb2sgZm9yIG1hdGNoZXMgYmV5b25kIHRoZSBlbmQgb2YgdGhlIGlucHV0LiBUaGlzIGlzXFxuXFx0XFx0XFx0Ly8gbmVjZXNzYXJ5XFxuXFx0XFx0XFx0Ly8gdG8gbWFrZSBkZWZsYXRlIGRldGVybWluaXN0aWMuXFxuXFx0XFx0XFx0aWYgKF9uaWNlX21hdGNoID4gbG9va2FoZWFkKVxcblxcdFxcdFxcdFxcdF9uaWNlX21hdGNoID0gbG9va2FoZWFkO1xcblxcblxcdFxcdFxcdGRvIHtcXG5cXHRcXHRcXHRcXHRtYXRjaCA9IGN1cl9tYXRjaDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBTa2lwIHRvIG5leHQgbWF0Y2ggaWYgdGhlIG1hdGNoIGxlbmd0aCBjYW5ub3QgaW5jcmVhc2VcXG5cXHRcXHRcXHRcXHQvLyBvciBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIGxlc3MgdGhhbiAyOlxcblxcdFxcdFxcdFxcdGlmICh3aW5kb3dbbWF0Y2ggKyBiZXN0X2xlbl0gIT0gc2Nhbl9lbmQgfHwgd2luZG93W21hdGNoICsgYmVzdF9sZW4gLSAxXSAhPSBzY2FuX2VuZDEgfHwgd2luZG93W21hdGNoXSAhPSB3aW5kb3dbc2Nhbl1cXG5cXHRcXHRcXHRcXHRcXHRcXHR8fCB3aW5kb3dbKyttYXRjaF0gIT0gd2luZG93W3NjYW4gKyAxXSlcXG5cXHRcXHRcXHRcXHRcXHRjb250aW51ZTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBUaGUgY2hlY2sgYXQgYmVzdF9sZW4tMSBjYW4gYmUgcmVtb3ZlZCBiZWNhdXNlIGl0IHdpbGwgYmUgbWFkZVxcblxcdFxcdFxcdFxcdC8vIGFnYWluIGxhdGVyLiAoVGhpcyBoZXVyaXN0aWMgaXMgbm90IGFsd2F5cyBhIHdpbi4pXFxuXFx0XFx0XFx0XFx0Ly8gSXQgaXMgbm90IG5lY2Vzc2FyeSB0byBjb21wYXJlIHNjYW5bMl0gYW5kIG1hdGNoWzJdIHNpbmNlIHRoZXlcXG5cXHRcXHRcXHRcXHQvLyBhcmUgYWx3YXlzIGVxdWFsIHdoZW4gdGhlIG90aGVyIGJ5dGVzIG1hdGNoLCBnaXZlbiB0aGF0XFxuXFx0XFx0XFx0XFx0Ly8gdGhlIGhhc2gga2V5cyBhcmUgZXF1YWwgYW5kIHRoYXQgSEFTSF9CSVRTID49IDguXFxuXFx0XFx0XFx0XFx0c2NhbiArPSAyO1xcblxcdFxcdFxcdFxcdG1hdGNoKys7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gV2UgY2hlY2sgZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBldmVyeSA4dGggY29tcGFyaXNvbjtcXG5cXHRcXHRcXHRcXHQvLyB0aGUgMjU2dGggY2hlY2sgd2lsbCBiZSBtYWRlIGF0IHN0cnN0YXJ0KzI1OC5cXG5cXHRcXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0fSB3aGlsZSAod2luZG93Wysrc2Nhbl0gPT0gd2luZG93WysrbWF0Y2hdICYmIHdpbmRvd1srK3NjYW5dID09IHdpbmRvd1srK21hdGNoXSAmJiB3aW5kb3dbKytzY2FuXSA9PSB3aW5kb3dbKyttYXRjaF1cXG5cXHRcXHRcXHRcXHRcXHRcXHQmJiB3aW5kb3dbKytzY2FuXSA9PSB3aW5kb3dbKyttYXRjaF0gJiYgd2luZG93Wysrc2Nhbl0gPT0gd2luZG93WysrbWF0Y2hdICYmIHdpbmRvd1srK3NjYW5dID09IHdpbmRvd1srK21hdGNoXVxcblxcdFxcdFxcdFxcdFxcdFxcdCYmIHdpbmRvd1srK3NjYW5dID09IHdpbmRvd1srK21hdGNoXSAmJiB3aW5kb3dbKytzY2FuXSA9PSB3aW5kb3dbKyttYXRjaF0gJiYgc2NhbiA8IHN0cmVuZCk7XFxuXFxuXFx0XFx0XFx0XFx0bGVuID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xcblxcdFxcdFxcdFxcdHNjYW4gPSBzdHJlbmQgLSBNQVhfTUFUQ0g7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKGxlbiA+IGJlc3RfbGVuKSB7XFxuXFx0XFx0XFx0XFx0XFx0bWF0Y2hfc3RhcnQgPSBjdXJfbWF0Y2g7XFxuXFx0XFx0XFx0XFx0XFx0YmVzdF9sZW4gPSBsZW47XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGxlbiA+PSBfbmljZV9tYXRjaClcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRzY2FuX2VuZDEgPSB3aW5kb3dbc2NhbiArIGJlc3RfbGVuIC0gMV07XFxuXFx0XFx0XFx0XFx0XFx0c2Nhbl9lbmQgPSB3aW5kb3dbc2NhbiArIGJlc3RfbGVuXTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fSB3aGlsZSAoKGN1cl9tYXRjaCA9IChwcmV2W2N1cl9tYXRjaCAmIHdtYXNrXSAmIDB4ZmZmZikpID4gbGltaXQgJiYgLS1jaGFpbl9sZW5ndGggIT09IDApO1xcblxcblxcdFxcdFxcdGlmIChiZXN0X2xlbiA8PSBsb29rYWhlYWQpXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGJlc3RfbGVuO1xcblxcdFxcdFxcdHJldHVybiBsb29rYWhlYWQ7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIENvbXByZXNzIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCByZXR1cm4gdGhlIGN1cnJlbnRcXG5cXHRcXHQvLyBibG9jayBzdGF0ZS5cXG5cXHRcXHQvLyBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHBlcmZvcm0gbGF6eSBldmFsdWF0aW9uIG9mIG1hdGNoZXMgYW5kIGluc2VydHNcXG5cXHRcXHQvLyBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBvbmx5IGZvciB1bm1hdGNoZWQgc3RyaW5ncyBvciBmb3Igc2hvcnRcXG5cXHRcXHQvLyBtYXRjaGVzLiBJdCBpcyB1c2VkIG9ubHkgZm9yIHRoZSBmYXN0IGNvbXByZXNzaW9uIG9wdGlvbnMuXFxuXFx0XFx0ZnVuY3Rpb24gZGVmbGF0ZV9mYXN0KGZsdXNoKSB7XFxuXFx0XFx0XFx0Ly8gc2hvcnQgaGFzaF9oZWFkID0gMDsgLy8gaGVhZCBvZiB0aGUgaGFzaCBjaGFpblxcblxcdFxcdFxcdHZhciBoYXNoX2hlYWQgPSAwOyAvLyBoZWFkIG9mIHRoZSBoYXNoIGNoYWluXFxuXFx0XFx0XFx0dmFyIGJmbHVzaDsgLy8gc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkXFxuXFxuXFx0XFx0XFx0d2hpbGUgKHRydWUpIHtcXG5cXHRcXHRcXHRcXHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcXG5cXHRcXHRcXHRcXHQvLyBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xcblxcdFxcdFxcdFxcdC8vIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxcblxcdFxcdFxcdFxcdC8vIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXFxuXFx0XFx0XFx0XFx0aWYgKGxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcXG5cXHRcXHRcXHRcXHRcXHRmaWxsX3dpbmRvdygpO1xcblxcdFxcdFxcdFxcdFxcdGlmIChsb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09IFpfTk9fRkxVU0gpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gTmVlZE1vcmU7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmIChsb29rYWhlYWQgPT09IDApXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7IC8vIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcXG5cXHRcXHRcXHRcXHQvLyBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcXG5cXHRcXHRcXHRcXHRpZiAobG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xcblxcdFxcdFxcdFxcdFxcdGluc19oID0gKCgoaW5zX2gpIDw8IGhhc2hfc2hpZnQpIF4gKHdpbmRvd1soc3Ryc3RhcnQpICsgKE1JTl9NQVRDSCAtIDEpXSAmIDB4ZmYpKSAmIGhhc2hfbWFzaztcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBwcmV2W3N0cnN0YXJ0JndfbWFza109aGFzaF9oZWFkPWhlYWRbaW5zX2hdO1xcblxcdFxcdFxcdFxcdFxcdGhhc2hfaGVhZCA9IChoZWFkW2luc19oXSAmIDB4ZmZmZik7XFxuXFx0XFx0XFx0XFx0XFx0cHJldltzdHJzdGFydCAmIHdfbWFza10gPSBoZWFkW2luc19oXTtcXG5cXHRcXHRcXHRcXHRcXHRoZWFkW2luc19oXSA9IHN0cnN0YXJ0O1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxcblxcdFxcdFxcdFxcdC8vIEF0IHRoaXMgcG9pbnQgd2UgaGF2ZSBhbHdheXMgbWF0Y2hfbGVuZ3RoIDwgTUlOX01BVENIXFxuXFxuXFx0XFx0XFx0XFx0aWYgKGhhc2hfaGVhZCAhPT0gMCAmJiAoKHN0cnN0YXJ0IC0gaGFzaF9oZWFkKSAmIDB4ZmZmZikgPD0gd19zaXplIC0gTUlOX0xPT0tBSEVBRCkge1xcblxcdFxcdFxcdFxcdFxcdC8vIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXFxuXFx0XFx0XFx0XFx0XFx0Ly8gb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXFxuXFx0XFx0XFx0XFx0XFx0Ly8gb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxcblxcdFxcdFxcdFxcdFxcdGlmIChzdHJhdGVneSAhPSBaX0hVRkZNQU5fT05MWSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdG1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2goaGFzaF9oZWFkKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0Ly8gbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnRcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKG1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBjaGVja19tYXRjaChzdHJzdGFydCwgbWF0Y2hfc3RhcnQsIG1hdGNoX2xlbmd0aCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0YmZsdXNoID0gX3RyX3RhbGx5KHN0cnN0YXJ0IC0gbWF0Y2hfc3RhcnQsIG1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bG9va2FoZWFkIC09IG1hdGNoX2xlbmd0aDtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoXFxuXFx0XFx0XFx0XFx0XFx0Ly8gaXMgbm90IHRvbyBsYXJnZS4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cXG5cXHRcXHRcXHRcXHRcXHRpZiAobWF0Y2hfbGVuZ3RoIDw9IG1heF9sYXp5X21hdGNoICYmIGxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtYXRjaF9sZW5ndGgtLTsgLy8gc3RyaW5nIGF0IHN0cnN0YXJ0IGFscmVhZHkgaW4gaGFzaCB0YWJsZVxcblxcdFxcdFxcdFxcdFxcdFxcdGRvIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzdHJzdGFydCsrO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGluc19oID0gKChpbnNfaCA8PCBoYXNoX3NoaWZ0KSBeICh3aW5kb3dbKHN0cnN0YXJ0KSArIChNSU5fTUFUQ0ggLSAxKV0gJiAweGZmKSkgJiBoYXNoX21hc2s7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gcHJldltzdHJzdGFydCZ3X21hc2tdPWhhc2hfaGVhZD1oZWFkW2luc19oXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRoYXNoX2hlYWQgPSAoaGVhZFtpbnNfaF0gJiAweGZmZmYpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHByZXZbc3Ryc3RhcnQgJiB3X21hc2tdID0gaGVhZFtpbnNfaF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aGVhZFtpbnNfaF0gPSBzdHJzdGFydDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBzdHJzdGFydCBuZXZlciBleGNlZWRzIFdTSVpFLU1BWF9NQVRDSCwgc28gdGhlcmUgYXJlXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gYWx3YXlzIE1JTl9NQVRDSCBieXRlcyBhaGVhZC5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9IHdoaWxlICgtLW1hdGNoX2xlbmd0aCAhPT0gMCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c3Ryc3RhcnQrKztcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdHN0cnN0YXJ0ICs9IG1hdGNoX2xlbmd0aDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtYXRjaF9sZW5ndGggPSAwO1xcblxcdFxcdFxcdFxcdFxcdFxcdGluc19oID0gd2luZG93W3N0cnN0YXJ0XSAmIDB4ZmY7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aW5zX2ggPSAoKChpbnNfaCkgPDwgaGFzaF9zaGlmdCkgXiAod2luZG93W3N0cnN0YXJ0ICsgMV0gJiAweGZmKSkgJiBoYXNoX21hc2s7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gSWYgbG9va2FoZWFkIDwgTUlOX01BVENILCBpbnNfaCBpcyBnYXJiYWdlLCBidXQgaXQgZG9lc1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIG5vdFxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIG1hdHRlciBzaW5jZSBpdCB3aWxsIGJlIHJlY29tcHV0ZWQgYXQgbmV4dCBkZWZsYXRlIGNhbGwuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZVxcblxcblxcdFxcdFxcdFxcdFxcdGJmbHVzaCA9IF90cl90YWxseSgwLCB3aW5kb3dbc3Ryc3RhcnRdICYgMHhmZik7XFxuXFx0XFx0XFx0XFx0XFx0bG9va2FoZWFkLS07XFxuXFx0XFx0XFx0XFx0XFx0c3Ryc3RhcnQrKztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKGJmbHVzaCkge1xcblxcblxcdFxcdFxcdFxcdFxcdGZsdXNoX2Jsb2NrX29ubHkoZmFsc2UpO1xcblxcdFxcdFxcdFxcdFxcdGlmIChzdHJtLmF2YWlsX291dCA9PT0gMClcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gTmVlZE1vcmU7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRmbHVzaF9ibG9ja19vbmx5KGZsdXNoID09IFpfRklOSVNIKTtcXG5cXHRcXHRcXHRpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcXG5cXHRcXHRcXHRcXHRpZiAoZmx1c2ggPT0gWl9GSU5JU0gpXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIEZpbmlzaFN0YXJ0ZWQ7XFxuXFx0XFx0XFx0XFx0ZWxzZVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBOZWVkTW9yZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIGZsdXNoID09IFpfRklOSVNIID8gRmluaXNoRG9uZSA6IEJsb2NrRG9uZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gU2FtZSBhcyBhYm92ZSwgYnV0IGFjaGlldmVzIGJldHRlciBjb21wcmVzc2lvbi4gV2UgdXNlIGEgbGF6eVxcblxcdFxcdC8vIGV2YWx1YXRpb24gZm9yIG1hdGNoZXM6IGEgbWF0Y2ggaXMgZmluYWxseSBhZG9wdGVkIG9ubHkgaWYgdGhlcmUgaXNcXG5cXHRcXHQvLyBubyBiZXR0ZXIgbWF0Y2ggYXQgdGhlIG5leHQgd2luZG93IHBvc2l0aW9uLlxcblxcdFxcdGZ1bmN0aW9uIGRlZmxhdGVfc2xvdyhmbHVzaCkge1xcblxcdFxcdFxcdC8vIHNob3J0IGhhc2hfaGVhZCA9IDA7IC8vIGhlYWQgb2YgaGFzaCBjaGFpblxcblxcdFxcdFxcdHZhciBoYXNoX2hlYWQgPSAwOyAvLyBoZWFkIG9mIGhhc2ggY2hhaW5cXG5cXHRcXHRcXHR2YXIgYmZsdXNoOyAvLyBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWRcXG5cXHRcXHRcXHR2YXIgbWF4X2luc2VydDtcXG5cXG5cXHRcXHRcXHQvLyBQcm9jZXNzIHRoZSBpbnB1dCBibG9jay5cXG5cXHRcXHRcXHR3aGlsZSAodHJ1ZSkge1xcblxcdFxcdFxcdFxcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxcblxcdFxcdFxcdFxcdC8vIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXFxuXFx0XFx0XFx0XFx0Ly8gZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXFxuXFx0XFx0XFx0XFx0Ly8gc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cXG5cXG5cXHRcXHRcXHRcXHRpZiAobG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xcblxcdFxcdFxcdFxcdFxcdGZpbGxfd2luZG93KCk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT0gWl9OT19GTFVTSCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBOZWVkTW9yZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGxvb2thaGVhZCA9PT0gMClcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhazsgLy8gZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2tcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxcblxcdFxcdFxcdFxcdC8vIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxcblxcblxcdFxcdFxcdFxcdGlmIChsb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XFxuXFx0XFx0XFx0XFx0XFx0aW5zX2ggPSAoKChpbnNfaCkgPDwgaGFzaF9zaGlmdCkgXiAod2luZG93WyhzdHJzdGFydCkgKyAoTUlOX01BVENIIC0gMSldICYgMHhmZikpICYgaGFzaF9tYXNrO1xcblxcdFxcdFxcdFxcdFxcdC8vIHByZXZbc3Ryc3RhcnQmd19tYXNrXT1oYXNoX2hlYWQ9aGVhZFtpbnNfaF07XFxuXFx0XFx0XFx0XFx0XFx0aGFzaF9oZWFkID0gKGhlYWRbaW5zX2hdICYgMHhmZmZmKTtcXG5cXHRcXHRcXHRcXHRcXHRwcmV2W3N0cnN0YXJ0ICYgd19tYXNrXSA9IGhlYWRbaW5zX2hdO1xcblxcdFxcdFxcdFxcdFxcdGhlYWRbaW5zX2hdID0gc3Ryc3RhcnQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXFxuXFx0XFx0XFx0XFx0cHJldl9sZW5ndGggPSBtYXRjaF9sZW5ndGg7XFxuXFx0XFx0XFx0XFx0cHJldl9tYXRjaCA9IG1hdGNoX3N0YXJ0O1xcblxcdFxcdFxcdFxcdG1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKGhhc2hfaGVhZCAhPT0gMCAmJiBwcmV2X2xlbmd0aCA8IG1heF9sYXp5X21hdGNoICYmICgoc3Ryc3RhcnQgLSBoYXNoX2hlYWQpICYgMHhmZmZmKSA8PSB3X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcXG5cXHRcXHRcXHRcXHRcXHQvLyBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcXG5cXHRcXHRcXHRcXHRcXHQvLyBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHN0cmF0ZWd5ICE9IFpfSFVGRk1BTl9PTkxZKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChoYXNoX2hlYWQpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHQvLyBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydFxcblxcblxcdFxcdFxcdFxcdFxcdGlmIChtYXRjaF9sZW5ndGggPD0gNSAmJiAoc3RyYXRlZ3kgPT0gWl9GSUxURVJFRCB8fCAobWF0Y2hfbGVuZ3RoID09IE1JTl9NQVRDSCAmJiBzdHJzdGFydCAtIG1hdGNoX3N0YXJ0ID4gNDA5NikpKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gSWYgcHJldl9tYXRjaCBpcyBhbHNvIE1JTl9NQVRDSCwgbWF0Y2hfc3RhcnQgaXMgZ2FyYmFnZVxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGJ1dCB3ZSB3aWxsIGlnbm9yZSB0aGUgY3VycmVudCBtYXRjaCBhbnl3YXkuXFxuXFx0XFx0XFx0XFx0XFx0XFx0bWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIElmIHRoZXJlIHdhcyBhIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBzdGVwIGFuZCB0aGUgY3VycmVudFxcblxcdFxcdFxcdFxcdC8vIG1hdGNoIGlzIG5vdCBiZXR0ZXIsIG91dHB1dCB0aGUgcHJldmlvdXMgbWF0Y2g6XFxuXFx0XFx0XFx0XFx0aWYgKHByZXZfbGVuZ3RoID49IE1JTl9NQVRDSCAmJiBtYXRjaF9sZW5ndGggPD0gcHJldl9sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRtYXhfaW5zZXJ0ID0gc3Ryc3RhcnQgKyBsb29rYWhlYWQgLSBNSU5fTUFUQ0g7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gRG8gbm90IGluc2VydCBzdHJpbmdzIGluIGhhc2ggdGFibGUgYmV5b25kIHRoaXMuXFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gY2hlY2tfbWF0Y2goc3Ryc3RhcnQtMSwgcHJldl9tYXRjaCwgcHJldl9sZW5ndGgpO1xcblxcblxcdFxcdFxcdFxcdFxcdGJmbHVzaCA9IF90cl90YWxseShzdHJzdGFydCAtIDEgLSBwcmV2X21hdGNoLCBwcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gSW5zZXJ0IGluIGhhc2ggdGFibGUgYWxsIHN0cmluZ3MgdXAgdG8gdGhlIGVuZCBvZiB0aGUgbWF0Y2guXFxuXFx0XFx0XFx0XFx0XFx0Ly8gc3Ryc3RhcnQtMSBhbmQgc3Ryc3RhcnQgYXJlIGFscmVhZHkgaW5zZXJ0ZWQuIElmIHRoZXJlIGlzIG5vdFxcblxcdFxcdFxcdFxcdFxcdC8vIGVub3VnaCBsb29rYWhlYWQsIHRoZSBsYXN0IHR3byBzdHJpbmdzIGFyZSBub3QgaW5zZXJ0ZWQgaW5cXG5cXHRcXHRcXHRcXHRcXHQvLyB0aGUgaGFzaCB0YWJsZS5cXG5cXHRcXHRcXHRcXHRcXHRsb29rYWhlYWQgLT0gcHJldl9sZW5ndGggLSAxO1xcblxcdFxcdFxcdFxcdFxcdHByZXZfbGVuZ3RoIC09IDI7XFxuXFx0XFx0XFx0XFx0XFx0ZG8ge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICgrK3N0cnN0YXJ0IDw9IG1heF9pbnNlcnQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpbnNfaCA9ICgoKGluc19oKSA8PCBoYXNoX3NoaWZ0KSBeICh3aW5kb3dbKHN0cnN0YXJ0KSArIChNSU5fTUFUQ0ggLSAxKV0gJiAweGZmKSkgJiBoYXNoX21hc2s7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gcHJldltzdHJzdGFydCZ3X21hc2tdPWhhc2hfaGVhZD1oZWFkW2luc19oXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRoYXNoX2hlYWQgPSAoaGVhZFtpbnNfaF0gJiAweGZmZmYpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHByZXZbc3Ryc3RhcnQgJiB3X21hc2tdID0gaGVhZFtpbnNfaF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aGVhZFtpbnNfaF0gPSBzdHJzdGFydDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fSB3aGlsZSAoLS1wcmV2X2xlbmd0aCAhPT0gMCk7XFxuXFx0XFx0XFx0XFx0XFx0bWF0Y2hfYXZhaWxhYmxlID0gMDtcXG5cXHRcXHRcXHRcXHRcXHRtYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xcblxcdFxcdFxcdFxcdFxcdHN0cnN0YXJ0Kys7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKGJmbHVzaCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGZsdXNoX2Jsb2NrX29ubHkoZmFsc2UpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChzdHJtLmF2YWlsX291dCA9PT0gMClcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gTmVlZE1vcmU7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAobWF0Y2hfYXZhaWxhYmxlICE9PSAwKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gSWYgdGhlcmUgd2FzIG5vIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBwb3NpdGlvbiwgb3V0cHV0IGFcXG5cXHRcXHRcXHRcXHRcXHQvLyBzaW5nbGUgbGl0ZXJhbC4gSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYnV0IHRoZSBjdXJyZW50IG1hdGNoXFxuXFx0XFx0XFx0XFx0XFx0Ly8gaXMgbG9uZ2VyLCB0cnVuY2F0ZSB0aGUgcHJldmlvdXMgbWF0Y2ggdG8gYSBzaW5nbGUgbGl0ZXJhbC5cXG5cXG5cXHRcXHRcXHRcXHRcXHRiZmx1c2ggPSBfdHJfdGFsbHkoMCwgd2luZG93W3N0cnN0YXJ0IC0gMV0gJiAweGZmKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoYmZsdXNoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Zmx1c2hfYmxvY2tfb25seShmYWxzZSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHN0cnN0YXJ0Kys7XFxuXFx0XFx0XFx0XFx0XFx0bG9va2FoZWFkLS07XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKVxcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBOZWVkTW9yZTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdC8vIFRoZXJlIGlzIG5vIHByZXZpb3VzIG1hdGNoIHRvIGNvbXBhcmUgd2l0aCwgd2FpdCBmb3JcXG5cXHRcXHRcXHRcXHRcXHQvLyB0aGUgbmV4dCBzdGVwIHRvIGRlY2lkZS5cXG5cXG5cXHRcXHRcXHRcXHRcXHRtYXRjaF9hdmFpbGFibGUgPSAxO1xcblxcdFxcdFxcdFxcdFxcdHN0cnN0YXJ0Kys7XFxuXFx0XFx0XFx0XFx0XFx0bG9va2FoZWFkLS07XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAobWF0Y2hfYXZhaWxhYmxlICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0YmZsdXNoID0gX3RyX3RhbGx5KDAsIHdpbmRvd1tzdHJzdGFydCAtIDFdICYgMHhmZik7XFxuXFx0XFx0XFx0XFx0bWF0Y2hfYXZhaWxhYmxlID0gMDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Zmx1c2hfYmxvY2tfb25seShmbHVzaCA9PSBaX0ZJTklTSCk7XFxuXFxuXFx0XFx0XFx0aWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGZsdXNoID09IFpfRklOSVNIKVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBGaW5pc2hTdGFydGVkO1xcblxcdFxcdFxcdFxcdGVsc2VcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gTmVlZE1vcmU7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBmbHVzaCA9PSBaX0ZJTklTSCA/IEZpbmlzaERvbmUgOiBCbG9ja0RvbmU7XFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIGRlZmxhdGVSZXNldChzdHJtKSB7XFxuXFx0XFx0XFx0c3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gMDtcXG5cXHRcXHRcXHRzdHJtLm1zZyA9IG51bGw7IC8vXFxuXFx0XFx0XFx0XFxuXFx0XFx0XFx0dGhhdC5wZW5kaW5nID0gMDtcXG5cXHRcXHRcXHR0aGF0LnBlbmRpbmdfb3V0ID0gMDtcXG5cXG5cXHRcXHRcXHRzdGF0dXMgPSBCVVNZX1NUQVRFO1xcblxcblxcdFxcdFxcdGxhc3RfZmx1c2ggPSBaX05PX0ZMVVNIO1xcblxcblxcdFxcdFxcdHRyX2luaXQoKTtcXG5cXHRcXHRcXHRsbV9pbml0KCk7XFxuXFx0XFx0XFx0cmV0dXJuIFpfT0s7XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoYXQuZGVmbGF0ZUluaXQgPSBmdW5jdGlvbihzdHJtLCBfbGV2ZWwsIGJpdHMsIF9tZXRob2QsIG1lbUxldmVsLCBfc3RyYXRlZ3kpIHtcXG5cXHRcXHRcXHRpZiAoIV9tZXRob2QpXFxuXFx0XFx0XFx0XFx0X21ldGhvZCA9IFpfREVGTEFURUQ7XFxuXFx0XFx0XFx0aWYgKCFtZW1MZXZlbClcXG5cXHRcXHRcXHRcXHRtZW1MZXZlbCA9IERFRl9NRU1fTEVWRUw7XFxuXFx0XFx0XFx0aWYgKCFfc3RyYXRlZ3kpXFxuXFx0XFx0XFx0XFx0X3N0cmF0ZWd5ID0gWl9ERUZBVUxUX1NUUkFURUdZO1xcblxcblxcdFxcdFxcdC8vIGJ5dGVbXSBteV92ZXJzaW9uPVpMSUJfVkVSU0lPTjtcXG5cXG5cXHRcXHRcXHQvL1xcblxcdFxcdFxcdC8vIGlmICghdmVyc2lvbiB8fCB2ZXJzaW9uWzBdICE9IG15X3ZlcnNpb25bMF1cXG5cXHRcXHRcXHQvLyB8fCBzdHJlYW1fc2l6ZSAhPSBzaXplb2Yoel9zdHJlYW0pKSB7XFxuXFx0XFx0XFx0Ly8gcmV0dXJuIFpfVkVSU0lPTl9FUlJPUjtcXG5cXHRcXHRcXHQvLyB9XFxuXFxuXFx0XFx0XFx0c3RybS5tc2cgPSBudWxsO1xcblxcblxcdFxcdFxcdGlmIChfbGV2ZWwgPT0gWl9ERUZBVUxUX0NPTVBSRVNTSU9OKVxcblxcdFxcdFxcdFxcdF9sZXZlbCA9IDY7XFxuXFxuXFx0XFx0XFx0aWYgKG1lbUxldmVsIDwgMSB8fCBtZW1MZXZlbCA+IE1BWF9NRU1fTEVWRUwgfHwgX21ldGhvZCAhPSBaX0RFRkxBVEVEIHx8IGJpdHMgPCA5IHx8IGJpdHMgPiAxNSB8fCBfbGV2ZWwgPCAwIHx8IF9sZXZlbCA+IDkgfHwgX3N0cmF0ZWd5IDwgMFxcblxcdFxcdFxcdFxcdFxcdHx8IF9zdHJhdGVneSA+IFpfSFVGRk1BTl9PTkxZKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRzdHJtLmRzdGF0ZSA9IHRoYXQ7XFxuXFxuXFx0XFx0XFx0d19iaXRzID0gYml0cztcXG5cXHRcXHRcXHR3X3NpemUgPSAxIDw8IHdfYml0cztcXG5cXHRcXHRcXHR3X21hc2sgPSB3X3NpemUgLSAxO1xcblxcblxcdFxcdFxcdGhhc2hfYml0cyA9IG1lbUxldmVsICsgNztcXG5cXHRcXHRcXHRoYXNoX3NpemUgPSAxIDw8IGhhc2hfYml0cztcXG5cXHRcXHRcXHRoYXNoX21hc2sgPSBoYXNoX3NpemUgLSAxO1xcblxcdFxcdFxcdGhhc2hfc2hpZnQgPSBNYXRoLmZsb29yKChoYXNoX2JpdHMgKyBNSU5fTUFUQ0ggLSAxKSAvIE1JTl9NQVRDSCk7XFxuXFxuXFx0XFx0XFx0d2luZG93ID0gbmV3IFVpbnQ4QXJyYXkod19zaXplICogMik7XFxuXFx0XFx0XFx0cHJldiA9IFtdO1xcblxcdFxcdFxcdGhlYWQgPSBbXTtcXG5cXG5cXHRcXHRcXHRsaXRfYnVmc2l6ZSA9IDEgPDwgKG1lbUxldmVsICsgNik7IC8vIDE2SyBlbGVtZW50cyBieSBkZWZhdWx0XFxuXFxuXFx0XFx0XFx0Ly8gV2Ugb3ZlcmxheSBwZW5kaW5nX2J1ZiBhbmQgZF9idWYrbF9idWYuIFRoaXMgd29ya3Mgc2luY2UgdGhlIGF2ZXJhZ2VcXG5cXHRcXHRcXHQvLyBvdXRwdXQgc2l6ZSBmb3IgKGxlbmd0aCxkaXN0YW5jZSkgY29kZXMgaXMgPD0gMjQgYml0cy5cXG5cXHRcXHRcXHR0aGF0LnBlbmRpbmdfYnVmID0gbmV3IFVpbnQ4QXJyYXkobGl0X2J1ZnNpemUgKiA0KTtcXG5cXHRcXHRcXHRwZW5kaW5nX2J1Zl9zaXplID0gbGl0X2J1ZnNpemUgKiA0O1xcblxcblxcdFxcdFxcdGRfYnVmID0gTWF0aC5mbG9vcihsaXRfYnVmc2l6ZSAvIDIpO1xcblxcdFxcdFxcdGxfYnVmID0gKDEgKyAyKSAqIGxpdF9idWZzaXplO1xcblxcblxcdFxcdFxcdGxldmVsID0gX2xldmVsO1xcblxcblxcdFxcdFxcdHN0cmF0ZWd5ID0gX3N0cmF0ZWd5O1xcblxcdFxcdFxcdG1ldGhvZCA9IF9tZXRob2QgJiAweGZmO1xcblxcblxcdFxcdFxcdHJldHVybiBkZWZsYXRlUmVzZXQoc3RybSk7XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGF0LmRlZmxhdGVFbmQgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRpZiAoc3RhdHVzICE9IElOSVRfU1RBVEUgJiYgc3RhdHVzICE9IEJVU1lfU1RBVEUgJiYgc3RhdHVzICE9IEZJTklTSF9TVEFURSkge1xcblxcdFxcdFxcdFxcdHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Ly8gRGVhbGxvY2F0ZSBpbiByZXZlcnNlIG9yZGVyIG9mIGFsbG9jYXRpb25zOlxcblxcdFxcdFxcdHRoYXQucGVuZGluZ19idWYgPSBudWxsO1xcblxcdFxcdFxcdGhlYWQgPSBudWxsO1xcblxcdFxcdFxcdHByZXYgPSBudWxsO1xcblxcdFxcdFxcdHdpbmRvdyA9IG51bGw7XFxuXFx0XFx0XFx0Ly8gZnJlZVxcblxcdFxcdFxcdHRoYXQuZHN0YXRlID0gbnVsbDtcXG5cXHRcXHRcXHRyZXR1cm4gc3RhdHVzID09IEJVU1lfU1RBVEUgPyBaX0RBVEFfRVJST1IgOiBaX09LO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhhdC5kZWZsYXRlUGFyYW1zID0gZnVuY3Rpb24oc3RybSwgX2xldmVsLCBfc3RyYXRlZ3kpIHtcXG5cXHRcXHRcXHR2YXIgZXJyID0gWl9PSztcXG5cXG5cXHRcXHRcXHRpZiAoX2xldmVsID09IFpfREVGQVVMVF9DT01QUkVTU0lPTikge1xcblxcdFxcdFxcdFxcdF9sZXZlbCA9IDY7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChfbGV2ZWwgPCAwIHx8IF9sZXZlbCA+IDkgfHwgX3N0cmF0ZWd5IDwgMCB8fCBfc3RyYXRlZ3kgPiBaX0hVRkZNQU5fT05MWSkge1xcblxcdFxcdFxcdFxcdHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKGNvbmZpZ190YWJsZVtsZXZlbF0uZnVuYyAhPSBjb25maWdfdGFibGVbX2xldmVsXS5mdW5jICYmIHN0cm0udG90YWxfaW4gIT09IDApIHtcXG5cXHRcXHRcXHRcXHQvLyBGbHVzaCB0aGUgbGFzdCBidWZmZXI6XFxuXFx0XFx0XFx0XFx0ZXJyID0gc3RybS5kZWZsYXRlKFpfUEFSVElBTF9GTFVTSCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChsZXZlbCAhPSBfbGV2ZWwpIHtcXG5cXHRcXHRcXHRcXHRsZXZlbCA9IF9sZXZlbDtcXG5cXHRcXHRcXHRcXHRtYXhfbGF6eV9tYXRjaCA9IGNvbmZpZ190YWJsZVtsZXZlbF0ubWF4X2xhenk7XFxuXFx0XFx0XFx0XFx0Z29vZF9tYXRjaCA9IGNvbmZpZ190YWJsZVtsZXZlbF0uZ29vZF9sZW5ndGg7XFxuXFx0XFx0XFx0XFx0bmljZV9tYXRjaCA9IGNvbmZpZ190YWJsZVtsZXZlbF0ubmljZV9sZW5ndGg7XFxuXFx0XFx0XFx0XFx0bWF4X2NoYWluX2xlbmd0aCA9IGNvbmZpZ190YWJsZVtsZXZlbF0ubWF4X2NoYWluO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRzdHJhdGVneSA9IF9zdHJhdGVneTtcXG5cXHRcXHRcXHRyZXR1cm4gZXJyO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhhdC5kZWZsYXRlU2V0RGljdGlvbmFyeSA9IGZ1bmN0aW9uKHN0cm0sIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpIHtcXG5cXHRcXHRcXHR2YXIgbGVuZ3RoID0gZGljdExlbmd0aDtcXG5cXHRcXHRcXHR2YXIgbiwgaW5kZXggPSAwO1xcblxcblxcdFxcdFxcdGlmICghZGljdGlvbmFyeSB8fCBzdGF0dXMgIT0gSU5JVF9TVEFURSlcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxuXFxuXFx0XFx0XFx0aWYgKGxlbmd0aCA8IE1JTl9NQVRDSClcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWl9PSztcXG5cXHRcXHRcXHRpZiAobGVuZ3RoID4gd19zaXplIC0gTUlOX0xPT0tBSEVBRCkge1xcblxcdFxcdFxcdFxcdGxlbmd0aCA9IHdfc2l6ZSAtIE1JTl9MT09LQUhFQUQ7XFxuXFx0XFx0XFx0XFx0aW5kZXggPSBkaWN0TGVuZ3RoIC0gbGVuZ3RoOyAvLyB1c2UgdGhlIHRhaWwgb2YgdGhlIGRpY3Rpb25hcnlcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0d2luZG93LnNldChkaWN0aW9uYXJ5LnN1YmFycmF5KGluZGV4LCBpbmRleCArIGxlbmd0aCksIDApO1xcblxcblxcdFxcdFxcdHN0cnN0YXJ0ID0gbGVuZ3RoO1xcblxcdFxcdFxcdGJsb2NrX3N0YXJ0ID0gbGVuZ3RoO1xcblxcblxcdFxcdFxcdC8vIEluc2VydCBhbGwgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSAoZXhjZXB0IGZvciB0aGUgbGFzdCB0d28gYnl0ZXMpLlxcblxcdFxcdFxcdC8vIHMtPmxvb2thaGVhZCBzdGF5cyBudWxsLCBzbyBzLT5pbnNfaCB3aWxsIGJlIHJlY29tcHV0ZWQgYXQgdGhlIG5leHRcXG5cXHRcXHRcXHQvLyBjYWxsIG9mIGZpbGxfd2luZG93LlxcblxcblxcdFxcdFxcdGluc19oID0gd2luZG93WzBdICYgMHhmZjtcXG5cXHRcXHRcXHRpbnNfaCA9ICgoKGluc19oKSA8PCBoYXNoX3NoaWZ0KSBeICh3aW5kb3dbMV0gJiAweGZmKSkgJiBoYXNoX21hc2s7XFxuXFxuXFx0XFx0XFx0Zm9yIChuID0gMDsgbiA8PSBsZW5ndGggLSBNSU5fTUFUQ0g7IG4rKykge1xcblxcdFxcdFxcdFxcdGluc19oID0gKCgoaW5zX2gpIDw8IGhhc2hfc2hpZnQpIF4gKHdpbmRvd1sobikgKyAoTUlOX01BVENIIC0gMSldICYgMHhmZikpICYgaGFzaF9tYXNrO1xcblxcdFxcdFxcdFxcdHByZXZbbiAmIHdfbWFza10gPSBoZWFkW2luc19oXTtcXG5cXHRcXHRcXHRcXHRoZWFkW2luc19oXSA9IG47XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBaX09LO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhhdC5kZWZsYXRlID0gZnVuY3Rpb24oX3N0cm0sIGZsdXNoKSB7XFxuXFx0XFx0XFx0dmFyIGksIGhlYWRlciwgbGV2ZWxfZmxhZ3MsIG9sZF9mbHVzaCwgYnN0YXRlO1xcblxcblxcdFxcdFxcdGlmIChmbHVzaCA+IFpfRklOSVNIIHx8IGZsdXNoIDwgMCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCFfc3RybS5uZXh0X291dCB8fCAoIV9zdHJtLm5leHRfaW4gJiYgX3N0cm0uYXZhaWxfaW4gIT09IDApIHx8IChzdGF0dXMgPT0gRklOSVNIX1NUQVRFICYmIGZsdXNoICE9IFpfRklOSVNIKSkge1xcblxcdFxcdFxcdFxcdF9zdHJtLm1zZyA9IHpfZXJybXNnW1pfTkVFRF9ESUNUIC0gKFpfU1RSRUFNX0VSUk9SKV07XFxuXFx0XFx0XFx0XFx0cmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoX3N0cm0uYXZhaWxfb3V0ID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0X3N0cm0ubXNnID0gel9lcnJtc2dbWl9ORUVEX0RJQ1QgLSAoWl9CVUZfRVJST1IpXTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWl9CVUZfRVJST1I7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHN0cm0gPSBfc3RybTsgLy8ganVzdCBpbiBjYXNlXFxuXFx0XFx0XFx0b2xkX2ZsdXNoID0gbGFzdF9mbHVzaDtcXG5cXHRcXHRcXHRsYXN0X2ZsdXNoID0gZmx1c2g7XFxuXFxuXFx0XFx0XFx0Ly8gV3JpdGUgdGhlIHpsaWIgaGVhZGVyXFxuXFx0XFx0XFx0aWYgKHN0YXR1cyA9PSBJTklUX1NUQVRFKSB7XFxuXFx0XFx0XFx0XFx0aGVhZGVyID0gKFpfREVGTEFURUQgKyAoKHdfYml0cyAtIDgpIDw8IDQpKSA8PCA4O1xcblxcdFxcdFxcdFxcdGxldmVsX2ZsYWdzID0gKChsZXZlbCAtIDEpICYgMHhmZikgPj4gMTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAobGV2ZWxfZmxhZ3MgPiAzKVxcblxcdFxcdFxcdFxcdFxcdGxldmVsX2ZsYWdzID0gMztcXG5cXHRcXHRcXHRcXHRoZWFkZXIgfD0gKGxldmVsX2ZsYWdzIDw8IDYpO1xcblxcdFxcdFxcdFxcdGlmIChzdHJzdGFydCAhPT0gMClcXG5cXHRcXHRcXHRcXHRcXHRoZWFkZXIgfD0gUFJFU0VUX0RJQ1Q7XFxuXFx0XFx0XFx0XFx0aGVhZGVyICs9IDMxIC0gKGhlYWRlciAlIDMxKTtcXG5cXG5cXHRcXHRcXHRcXHRzdGF0dXMgPSBCVVNZX1NUQVRFO1xcblxcdFxcdFxcdFxcdHB1dFNob3J0TVNCKGhlYWRlcik7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGVcXG5cXHRcXHRcXHRpZiAodGhhdC5wZW5kaW5nICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0c3RybS5mbHVzaF9wZW5kaW5nKCk7XFxuXFx0XFx0XFx0XFx0aWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gY29uc29sZS5sb2coXFxcIiBhdmFpbF9vdXQ9PTBcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHQvLyBTaW5jZSBhdmFpbF9vdXQgaXMgMCwgZGVmbGF0ZSB3aWxsIGJlIGNhbGxlZCBhZ2FpbiB3aXRoXFxuXFx0XFx0XFx0XFx0XFx0Ly8gbW9yZSBvdXRwdXQgc3BhY2UsIGJ1dCBwb3NzaWJseSB3aXRoIGJvdGggcGVuZGluZyBhbmRcXG5cXHRcXHRcXHRcXHRcXHQvLyBhdmFpbF9pbiBlcXVhbCB0byB6ZXJvLiBUaGVyZSB3b24ndCBiZSBhbnl0aGluZyB0byBkbyxcXG5cXHRcXHRcXHRcXHRcXHQvLyBidXQgdGhpcyBpcyBub3QgYW4gZXJyb3Igc2l0dWF0aW9uIHNvIG1ha2Ugc3VyZSB3ZVxcblxcdFxcdFxcdFxcdFxcdC8vIHJldHVybiBPSyBpbnN0ZWFkIG9mIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwgb2YgZGVmbGF0ZTpcXG5cXHRcXHRcXHRcXHRcXHRsYXN0X2ZsdXNoID0gLTE7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIFpfT0s7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIE1ha2Ugc3VyZSB0aGVyZSBpcyBzb21ldGhpbmcgdG8gZG8gYW5kIGF2b2lkIGR1cGxpY2F0ZVxcblxcdFxcdFxcdFxcdC8vIGNvbnNlY3V0aXZlXFxuXFx0XFx0XFx0XFx0Ly8gZmx1c2hlcy4gRm9yIHJlcGVhdGVkIGFuZCB1c2VsZXNzIGNhbGxzIHdpdGggWl9GSU5JU0gsIHdlIGtlZXBcXG5cXHRcXHRcXHRcXHQvLyByZXR1cm5pbmcgWl9TVFJFQU1fRU5EIGluc3RlYWQgb2YgWl9CVUZGX0VSUk9SLlxcblxcdFxcdFxcdH0gZWxzZSBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiBmbHVzaCA8PSBvbGRfZmx1c2ggJiYgZmx1c2ggIT0gWl9GSU5JU0gpIHtcXG5cXHRcXHRcXHRcXHRzdHJtLm1zZyA9IHpfZXJybXNnW1pfTkVFRF9ESUNUIC0gKFpfQlVGX0VSUk9SKV07XFxuXFx0XFx0XFx0XFx0cmV0dXJuIFpfQlVGX0VSUk9SO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBVc2VyIG11c3Qgbm90IHByb3ZpZGUgbW9yZSBpbnB1dCBhZnRlciB0aGUgZmlyc3QgRklOSVNIOlxcblxcdFxcdFxcdGlmIChzdGF0dXMgPT0gRklOSVNIX1NUQVRFICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHtcXG5cXHRcXHRcXHRcXHRfc3RybS5tc2cgPSB6X2Vycm1zZ1taX05FRURfRElDVCAtIChaX0JVRl9FUlJPUildO1xcblxcdFxcdFxcdFxcdHJldHVybiBaX0JVRl9FUlJPUjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU3RhcnQgYSBuZXcgYmxvY2sgb3IgY29udGludWUgdGhlIGN1cnJlbnQgb25lLlxcblxcdFxcdFxcdGlmIChzdHJtLmF2YWlsX2luICE9PSAwIHx8IGxvb2thaGVhZCAhPT0gMCB8fCAoZmx1c2ggIT0gWl9OT19GTFVTSCAmJiBzdGF0dXMgIT0gRklOSVNIX1NUQVRFKSkge1xcblxcdFxcdFxcdFxcdGJzdGF0ZSA9IC0xO1xcblxcdFxcdFxcdFxcdHN3aXRjaCAoY29uZmlnX3RhYmxlW2xldmVsXS5mdW5jKSB7XFxuXFx0XFx0XFx0XFx0Y2FzZSBTVE9SRUQ6XFxuXFx0XFx0XFx0XFx0XFx0YnN0YXRlID0gZGVmbGF0ZV9zdG9yZWQoZmx1c2gpO1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdGNhc2UgRkFTVDpcXG5cXHRcXHRcXHRcXHRcXHRic3RhdGUgPSBkZWZsYXRlX2Zhc3QoZmx1c2gpO1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdGNhc2UgU0xPVzpcXG5cXHRcXHRcXHRcXHRcXHRic3RhdGUgPSBkZWZsYXRlX3Nsb3coZmx1c2gpO1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdGRlZmF1bHQ6XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmIChic3RhdGUgPT0gRmluaXNoU3RhcnRlZCB8fCBic3RhdGUgPT0gRmluaXNoRG9uZSkge1xcblxcdFxcdFxcdFxcdFxcdHN0YXR1cyA9IEZJTklTSF9TVEFURTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKGJzdGF0ZSA9PSBOZWVkTW9yZSB8fCBic3RhdGUgPT0gRmluaXNoU3RhcnRlZCkge1xcblxcdFxcdFxcdFxcdFxcdGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGxhc3RfZmx1c2ggPSAtMTsgLy8gYXZvaWQgQlVGX0VSUk9SIG5leHQgY2FsbCwgc2VlIGFib3ZlXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBaX09LO1xcblxcdFxcdFxcdFxcdFxcdC8vIElmIGZsdXNoICE9IFpfTk9fRkxVU0ggJiYgYXZhaWxfb3V0ID09PSAwLCB0aGUgbmV4dCBjYWxsXFxuXFx0XFx0XFx0XFx0XFx0Ly8gb2YgZGVmbGF0ZSBzaG91bGQgdXNlIHRoZSBzYW1lIGZsdXNoIHBhcmFtZXRlciB0byBtYWtlIHN1cmVcXG5cXHRcXHRcXHRcXHRcXHQvLyB0aGF0IHRoZSBmbHVzaCBpcyBjb21wbGV0ZS4gU28gd2UgZG9uJ3QgaGF2ZSB0byBvdXRwdXQgYW5cXG5cXHRcXHRcXHRcXHRcXHQvLyBlbXB0eSBibG9jayBoZXJlLCB0aGlzIHdpbGwgYmUgZG9uZSBhdCBuZXh0IGNhbGwuIFRoaXMgYWxzb1xcblxcdFxcdFxcdFxcdFxcdC8vIGVuc3VyZXMgdGhhdCBmb3IgYSB2ZXJ5IHNtYWxsIG91dHB1dCBidWZmZXIsIHdlIGVtaXQgYXQgbW9zdFxcblxcdFxcdFxcdFxcdFxcdC8vIG9uZSBlbXB0eSBibG9jay5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKGJzdGF0ZSA9PSBCbG9ja0RvbmUpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoZmx1c2ggPT0gWl9QQVJUSUFMX0ZMVVNIKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0X3RyX2FsaWduKCk7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHsgLy8gRlVMTF9GTFVTSCBvciBTWU5DX0ZMVVNIXFxuXFx0XFx0XFx0XFx0XFx0XFx0X3RyX3N0b3JlZF9ibG9jaygwLCAwLCBmYWxzZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gRm9yIGEgZnVsbCBmbHVzaCwgdGhpcyBlbXB0eSBibG9jayB3aWxsIGJlIHJlY29nbml6ZWRcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBhcyBhIHNwZWNpYWwgbWFya2VyIGJ5IGluZmxhdGVfc3luYygpLlxcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChmbHVzaCA9PSBaX0ZVTExfRkxVU0gpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBzdGF0ZS5oZWFkW3MuaGFzaF9zaXplLTFdPTA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Zm9yIChpID0gMDsgaSA8IGhhc2hfc2l6ZS8qLTEqLzsgaSsrKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGZvcmdldCBoaXN0b3J5XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aGVhZFtpXSA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRzdHJtLmZsdXNoX3BlbmRpbmcoKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRsYXN0X2ZsdXNoID0gLTE7IC8vIGF2b2lkIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwsIHNlZSBhYm92ZVxcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBaX09LO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChmbHVzaCAhPSBaX0ZJTklTSClcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWl9PSztcXG5cXHRcXHRcXHRyZXR1cm4gWl9TVFJFQU1fRU5EO1xcblxcdFxcdH07XFxuXFx0fVxcblxcblxcdC8vIFpTdHJlYW1cXG5cXG5cXHRmdW5jdGlvbiBaU3RyZWFtKCkge1xcblxcdFxcdHZhciB0aGF0ID0gdGhpcztcXG5cXHRcXHR0aGF0Lm5leHRfaW5faW5kZXggPSAwO1xcblxcdFxcdHRoYXQubmV4dF9vdXRfaW5kZXggPSAwO1xcblxcdFxcdC8vIHRoYXQubmV4dF9pbjsgLy8gbmV4dCBpbnB1dCBieXRlXFxuXFx0XFx0dGhhdC5hdmFpbF9pbiA9IDA7IC8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUgYXQgbmV4dF9pblxcblxcdFxcdHRoYXQudG90YWxfaW4gPSAwOyAvLyB0b3RhbCBuYiBvZiBpbnB1dCBieXRlcyByZWFkIHNvIGZhclxcblxcdFxcdC8vIHRoYXQubmV4dF9vdXQ7IC8vIG5leHQgb3V0cHV0IGJ5dGUgc2hvdWxkIGJlIHB1dCB0aGVyZVxcblxcdFxcdHRoYXQuYXZhaWxfb3V0ID0gMDsgLy8gcmVtYWluaW5nIGZyZWUgc3BhY2UgYXQgbmV4dF9vdXRcXG5cXHRcXHR0aGF0LnRvdGFsX291dCA9IDA7IC8vIHRvdGFsIG5iIG9mIGJ5dGVzIG91dHB1dCBzbyBmYXJcXG5cXHRcXHQvLyB0aGF0Lm1zZztcXG5cXHRcXHQvLyB0aGF0LmRzdGF0ZTtcXG5cXHR9XFxuXFxuXFx0WlN0cmVhbS5wcm90b3R5cGUgPSB7XFxuXFx0XFx0ZGVmbGF0ZUluaXQgOiBmdW5jdGlvbihsZXZlbCwgYml0cykge1xcblxcdFxcdFxcdHZhciB0aGF0ID0gdGhpcztcXG5cXHRcXHRcXHR0aGF0LmRzdGF0ZSA9IG5ldyBEZWZsYXRlKCk7XFxuXFx0XFx0XFx0aWYgKCFiaXRzKVxcblxcdFxcdFxcdFxcdGJpdHMgPSBNQVhfQklUUztcXG5cXHRcXHRcXHRyZXR1cm4gdGhhdC5kc3RhdGUuZGVmbGF0ZUluaXQodGhhdCwgbGV2ZWwsIGJpdHMpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZGVmbGF0ZSA6IGZ1bmN0aW9uKGZsdXNoKSB7XFxuXFx0XFx0XFx0dmFyIHRoYXQgPSB0aGlzO1xcblxcdFxcdFxcdGlmICghdGhhdC5kc3RhdGUpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiB0aGF0LmRzdGF0ZS5kZWZsYXRlKHRoYXQsIGZsdXNoKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdGRlZmxhdGVFbmQgOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHR2YXIgdGhhdCA9IHRoaXM7XFxuXFx0XFx0XFx0aWYgKCF0aGF0LmRzdGF0ZSlcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxuXFx0XFx0XFx0dmFyIHJldCA9IHRoYXQuZHN0YXRlLmRlZmxhdGVFbmQoKTtcXG5cXHRcXHRcXHR0aGF0LmRzdGF0ZSA9IG51bGw7XFxuXFx0XFx0XFx0cmV0dXJuIHJldDtcXG5cXHRcXHR9LFxcblxcblxcdFxcdGRlZmxhdGVQYXJhbXMgOiBmdW5jdGlvbihsZXZlbCwgc3RyYXRlZ3kpIHtcXG5cXHRcXHRcXHR2YXIgdGhhdCA9IHRoaXM7XFxuXFx0XFx0XFx0aWYgKCF0aGF0LmRzdGF0ZSlcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxuXFx0XFx0XFx0cmV0dXJuIHRoYXQuZHN0YXRlLmRlZmxhdGVQYXJhbXModGhhdCwgbGV2ZWwsIHN0cmF0ZWd5KTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdGRlZmxhdGVTZXREaWN0aW9uYXJ5IDogZnVuY3Rpb24oZGljdGlvbmFyeSwgZGljdExlbmd0aCkge1xcblxcdFxcdFxcdHZhciB0aGF0ID0gdGhpcztcXG5cXHRcXHRcXHRpZiAoIXRoYXQuZHN0YXRlKVxcblxcdFxcdFxcdFxcdHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXG5cXHRcXHRcXHRyZXR1cm4gdGhhdC5kc3RhdGUuZGVmbGF0ZVNldERpY3Rpb25hcnkodGhhdCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBSZWFkIGEgbmV3IGJ1ZmZlciBmcm9tIHRoZSBjdXJyZW50IGlucHV0IHN0cmVhbSwgdXBkYXRlIHRoZVxcblxcdFxcdC8vIHRvdGFsIG51bWJlciBvZiBieXRlcyByZWFkLiBBbGwgZGVmbGF0ZSgpIGlucHV0IGdvZXMgdGhyb3VnaFxcblxcdFxcdC8vIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0IHRvIGF2b2lkXFxuXFx0XFx0Ly8gYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPm5leHRfaW4gYnVmZmVyIGFuZCBjb3B5aW5nIGZyb20gaXQuXFxuXFx0XFx0Ly8gKFNlZSBhbHNvIGZsdXNoX3BlbmRpbmcoKSkuXFxuXFx0XFx0cmVhZF9idWYgOiBmdW5jdGlvbihidWYsIHN0YXJ0LCBzaXplKSB7XFxuXFx0XFx0XFx0dmFyIHRoYXQgPSB0aGlzO1xcblxcdFxcdFxcdHZhciBsZW4gPSB0aGF0LmF2YWlsX2luO1xcblxcdFxcdFxcdGlmIChsZW4gPiBzaXplKVxcblxcdFxcdFxcdFxcdGxlbiA9IHNpemU7XFxuXFx0XFx0XFx0aWYgKGxlbiA9PT0gMClcXG5cXHRcXHRcXHRcXHRyZXR1cm4gMDtcXG5cXHRcXHRcXHR0aGF0LmF2YWlsX2luIC09IGxlbjtcXG5cXHRcXHRcXHRidWYuc2V0KHRoYXQubmV4dF9pbi5zdWJhcnJheSh0aGF0Lm5leHRfaW5faW5kZXgsIHRoYXQubmV4dF9pbl9pbmRleCArIGxlbiksIHN0YXJ0KTtcXG5cXHRcXHRcXHR0aGF0Lm5leHRfaW5faW5kZXggKz0gbGVuO1xcblxcdFxcdFxcdHRoYXQudG90YWxfaW4gKz0gbGVuO1xcblxcdFxcdFxcdHJldHVybiBsZW47XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlLiBBbGwgZGVmbGF0ZSgpIG91dHB1dCBnb2VzXFxuXFx0XFx0Ly8gdGhyb3VnaCB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdFxcblxcdFxcdC8vIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5uZXh0X291dCBidWZmZXIgYW5kIGNvcHlpbmcgaW50byBpdC5cXG5cXHRcXHQvLyAoU2VlIGFsc28gcmVhZF9idWYoKSkuXFxuXFx0XFx0Zmx1c2hfcGVuZGluZyA6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHZhciB0aGF0ID0gdGhpcztcXG5cXHRcXHRcXHR2YXIgbGVuID0gdGhhdC5kc3RhdGUucGVuZGluZztcXG5cXG5cXHRcXHRcXHRpZiAobGVuID4gdGhhdC5hdmFpbF9vdXQpXFxuXFx0XFx0XFx0XFx0bGVuID0gdGhhdC5hdmFpbF9vdXQ7XFxuXFx0XFx0XFx0aWYgKGxlbiA9PT0gMClcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFxuXFx0XFx0XFx0Ly8gaWYgKHRoYXQuZHN0YXRlLnBlbmRpbmdfYnVmLmxlbmd0aCA8PSB0aGF0LmRzdGF0ZS5wZW5kaW5nX291dCB8fCB0aGF0Lm5leHRfb3V0Lmxlbmd0aCA8PSB0aGF0Lm5leHRfb3V0X2luZGV4XFxuXFx0XFx0XFx0Ly8gfHwgdGhhdC5kc3RhdGUucGVuZGluZ19idWYubGVuZ3RoIDwgKHRoYXQuZHN0YXRlLnBlbmRpbmdfb3V0ICsgbGVuKSB8fCB0aGF0Lm5leHRfb3V0Lmxlbmd0aCA8ICh0aGF0Lm5leHRfb3V0X2luZGV4ICtcXG5cXHRcXHRcXHQvLyBsZW4pKSB7XFxuXFx0XFx0XFx0Ly8gY29uc29sZS5sb2codGhhdC5kc3RhdGUucGVuZGluZ19idWYubGVuZ3RoICsgXFxcIiwgXFxcIiArIHRoYXQuZHN0YXRlLnBlbmRpbmdfb3V0ICsgXFxcIiwgXFxcIiArIHRoYXQubmV4dF9vdXQubGVuZ3RoICsgXFxcIiwgXFxcIiArXFxuXFx0XFx0XFx0Ly8gdGhhdC5uZXh0X291dF9pbmRleCArIFxcXCIsIFxcXCIgKyBsZW4pO1xcblxcdFxcdFxcdC8vIGNvbnNvbGUubG9nKFxcXCJhdmFpbF9vdXQ9XFxcIiArIHRoYXQuYXZhaWxfb3V0KTtcXG5cXHRcXHRcXHQvLyB9XFxuXFxuXFx0XFx0XFx0dGhhdC5uZXh0X291dC5zZXQodGhhdC5kc3RhdGUucGVuZGluZ19idWYuc3ViYXJyYXkodGhhdC5kc3RhdGUucGVuZGluZ19vdXQsIHRoYXQuZHN0YXRlLnBlbmRpbmdfb3V0ICsgbGVuKSwgdGhhdC5uZXh0X291dF9pbmRleCk7XFxuXFxuXFx0XFx0XFx0dGhhdC5uZXh0X291dF9pbmRleCArPSBsZW47XFxuXFx0XFx0XFx0dGhhdC5kc3RhdGUucGVuZGluZ19vdXQgKz0gbGVuO1xcblxcdFxcdFxcdHRoYXQudG90YWxfb3V0ICs9IGxlbjtcXG5cXHRcXHRcXHR0aGF0LmF2YWlsX291dCAtPSBsZW47XFxuXFx0XFx0XFx0dGhhdC5kc3RhdGUucGVuZGluZyAtPSBsZW47XFxuXFx0XFx0XFx0aWYgKHRoYXQuZHN0YXRlLnBlbmRpbmcgPT09IDApIHtcXG5cXHRcXHRcXHRcXHR0aGF0LmRzdGF0ZS5wZW5kaW5nX291dCA9IDA7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdC8vIERlZmxhdGVyXFxuXFxuXFx0ZnVuY3Rpb24gRGVmbGF0ZXIob3B0aW9ucykge1xcblxcdFxcdHZhciB0aGF0ID0gdGhpcztcXG5cXHRcXHR2YXIgeiA9IG5ldyBaU3RyZWFtKCk7XFxuXFx0XFx0dmFyIGJ1ZnNpemUgPSA1MTI7XFxuXFx0XFx0dmFyIGZsdXNoID0gWl9OT19GTFVTSDtcXG5cXHRcXHR2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYnVmc2l6ZSk7XFxuXFx0XFx0dmFyIGxldmVsID0gb3B0aW9ucyA/IG9wdGlvbnMubGV2ZWwgOiBaX0RFRkFVTFRfQ09NUFJFU1NJT047XFxuXFx0XFx0aWYgKHR5cGVvZiBsZXZlbCA9PSBcXFwidW5kZWZpbmVkXFxcIilcXG5cXHRcXHRcXHRsZXZlbCA9IFpfREVGQVVMVF9DT01QUkVTU0lPTjtcXG5cXHRcXHR6LmRlZmxhdGVJbml0KGxldmVsKTtcXG5cXHRcXHR6Lm5leHRfb3V0ID0gYnVmO1xcblxcblxcdFxcdHRoYXQuYXBwZW5kID0gZnVuY3Rpb24oZGF0YSwgb25wcm9ncmVzcykge1xcblxcdFxcdFxcdHZhciBlcnIsIGJ1ZmZlcnMgPSBbXSwgbGFzdEluZGV4ID0gMCwgYnVmZmVySW5kZXggPSAwLCBidWZmZXJTaXplID0gMCwgYXJyYXk7XFxuXFx0XFx0XFx0aWYgKCFkYXRhLmxlbmd0aClcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gMDtcXG5cXHRcXHRcXHR6Lm5leHRfaW4gPSBkYXRhO1xcblxcdFxcdFxcdHouYXZhaWxfaW4gPSBkYXRhLmxlbmd0aDtcXG5cXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0ei5uZXh0X291dF9pbmRleCA9IDA7XFxuXFx0XFx0XFx0XFx0ei5hdmFpbF9vdXQgPSBidWZzaXplO1xcblxcdFxcdFxcdFxcdGVyciA9IHouZGVmbGF0ZShmbHVzaCk7XFxuXFx0XFx0XFx0XFx0aWYgKGVyciAhPSBaX09LKVxcblxcdFxcdFxcdFxcdFxcdHRocm93IG5ldyBFcnJvcihcXFwiZGVmbGF0aW5nOiBcXFwiICsgei5tc2cpO1xcblxcdFxcdFxcdFxcdGlmICh6Lm5leHRfb3V0X2luZGV4KVxcblxcdFxcdFxcdFxcdFxcdGlmICh6Lm5leHRfb3V0X2luZGV4ID09IGJ1ZnNpemUpXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnVmZmVycy5wdXNoKG5ldyBVaW50OEFycmF5KGJ1ZikpO1xcblxcdFxcdFxcdFxcdFxcdGVsc2VcXG5cXHRcXHRcXHRcXHRcXHRcXHRidWZmZXJzLnB1c2gobmV3IFVpbnQ4QXJyYXkoYnVmLnN1YmFycmF5KDAsIHoubmV4dF9vdXRfaW5kZXgpKSk7XFxuXFx0XFx0XFx0XFx0YnVmZmVyU2l6ZSArPSB6Lm5leHRfb3V0X2luZGV4O1xcblxcdFxcdFxcdFxcdGlmIChvbnByb2dyZXNzICYmIHoubmV4dF9pbl9pbmRleCA+IDAgJiYgei5uZXh0X2luX2luZGV4ICE9IGxhc3RJbmRleCkge1xcblxcdFxcdFxcdFxcdFxcdG9ucHJvZ3Jlc3Moei5uZXh0X2luX2luZGV4KTtcXG5cXHRcXHRcXHRcXHRcXHRsYXN0SW5kZXggPSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gd2hpbGUgKHouYXZhaWxfaW4gPiAwIHx8IHouYXZhaWxfb3V0ID09PSAwKTtcXG5cXHRcXHRcXHRhcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlclNpemUpO1xcblxcdFxcdFxcdGJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbihjaHVuaykge1xcblxcdFxcdFxcdFxcdGFycmF5LnNldChjaHVuaywgYnVmZmVySW5kZXgpO1xcblxcdFxcdFxcdFxcdGJ1ZmZlckluZGV4ICs9IGNodW5rLmxlbmd0aDtcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRyZXR1cm4gYXJyYXk7XFxuXFx0XFx0fTtcXG5cXHRcXHR0aGF0LmZsdXNoID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0dmFyIGVyciwgYnVmZmVycyA9IFtdLCBidWZmZXJJbmRleCA9IDAsIGJ1ZmZlclNpemUgPSAwLCBhcnJheTtcXG5cXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0ei5uZXh0X291dF9pbmRleCA9IDA7XFxuXFx0XFx0XFx0XFx0ei5hdmFpbF9vdXQgPSBidWZzaXplO1xcblxcdFxcdFxcdFxcdGVyciA9IHouZGVmbGF0ZShaX0ZJTklTSCk7XFxuXFx0XFx0XFx0XFx0aWYgKGVyciAhPSBaX1NUUkVBTV9FTkQgJiYgZXJyICE9IFpfT0spXFxuXFx0XFx0XFx0XFx0XFx0dGhyb3cgbmV3IEVycm9yKFxcXCJkZWZsYXRpbmc6IFxcXCIgKyB6Lm1zZyk7XFxuXFx0XFx0XFx0XFx0aWYgKGJ1ZnNpemUgLSB6LmF2YWlsX291dCA+IDApXFxuXFx0XFx0XFx0XFx0XFx0YnVmZmVycy5wdXNoKG5ldyBVaW50OEFycmF5KGJ1Zi5zdWJhcnJheSgwLCB6Lm5leHRfb3V0X2luZGV4KSkpO1xcblxcdFxcdFxcdFxcdGJ1ZmZlclNpemUgKz0gei5uZXh0X291dF9pbmRleDtcXG5cXHRcXHRcXHR9IHdoaWxlICh6LmF2YWlsX2luID4gMCB8fCB6LmF2YWlsX291dCA9PT0gMCk7XFxuXFx0XFx0XFx0ei5kZWZsYXRlRW5kKCk7XFxuXFx0XFx0XFx0YXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXJTaXplKTtcXG5cXHRcXHRcXHRidWZmZXJzLmZvckVhY2goZnVuY3Rpb24oY2h1bmspIHtcXG5cXHRcXHRcXHRcXHRhcnJheS5zZXQoY2h1bmssIGJ1ZmZlckluZGV4KTtcXG5cXHRcXHRcXHRcXHRidWZmZXJJbmRleCArPSBjaHVuay5sZW5ndGg7XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0cmV0dXJuIGFycmF5O1xcblxcdFxcdH07XFxuXFx0fVxcblxcblxcdC8vICd6aXAnIG1heSBub3QgYmUgZGVmaW5lZCBpbiB6LXdvcmtlciBhbmQgc29tZSB0ZXN0c1xcblxcdHZhciBlbnYgPSBnbG9iYWwuemlwIHx8IGdsb2JhbDtcXG5cXHRlbnYuRGVmbGF0ZXIgPSBlbnYuX2p6bGliX0RlZmxhdGVyID0gRGVmbGF0ZXI7XFxufSkodGhpcyk7XFxuXCIpXSxcbiAgaW5mbGF0ZXI6IFt6V29ya2VyLCBjcmVhdGVVcmwoXCIvKlxcbiBDb3B5cmlnaHQgKGMpIDIwMTMgR2lsZGFzIExvcm1lYXUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXFxuXFxuIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxcbiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcXG5cXG4gMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxcbiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxcblxcbiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBcXG4gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIFxcbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cXG5cXG4gMy4gVGhlIG5hbWVzIG9mIHRoZSBhdXRob3JzIG1heSBub3QgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHNcXG4gZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXFxuXFxuIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgYGBBUyBJUycnIEFORCBBTlkgRVhQUkVTU0VEIE9SIElNUExJRUQgV0FSUkFOVElFUyxcXG4gSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORFxcbiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgSkNSQUZULFxcbiBJTkMuIE9SIEFOWSBDT05UUklCVVRPUlMgVE8gVEhJUyBTT0ZUV0FSRSBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULFxcbiBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXFxuIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLFxcbiBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXFxuIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXFxuIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSxcXG4gRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cXG4gKi9cXG5cXG4vKlxcbiAqIFRoaXMgcHJvZ3JhbSBpcyBiYXNlZCBvbiBKWmxpYiAxLjAuMiB5bW5rLCBKQ3JhZnQsSW5jLlxcbiAqIEpabGliIGlzIGJhc2VkIG9uIHpsaWItMS4xLjMsIHNvIGFsbCBjcmVkaXQgc2hvdWxkIGdvIGF1dGhvcnNcXG4gKiBKZWFuLWxvdXAgR2FpbGx5KGpsb3VwQGd6aXAub3JnKSBhbmQgTWFyayBBZGxlcihtYWRsZXJAYWx1bW5pLmNhbHRlY2guZWR1KVxcbiAqIGFuZCBjb250cmlidXRvcnMgb2YgemxpYi5cXG4gKi9cXG5cXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XFxuXFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdC8vIEdsb2JhbFxcblxcdHZhciBNQVhfQklUUyA9IDE1O1xcblxcblxcdHZhciBaX09LID0gMDtcXG5cXHR2YXIgWl9TVFJFQU1fRU5EID0gMTtcXG5cXHR2YXIgWl9ORUVEX0RJQ1QgPSAyO1xcblxcdHZhciBaX1NUUkVBTV9FUlJPUiA9IC0yO1xcblxcdHZhciBaX0RBVEFfRVJST1IgPSAtMztcXG5cXHR2YXIgWl9NRU1fRVJST1IgPSAtNDtcXG5cXHR2YXIgWl9CVUZfRVJST1IgPSAtNTtcXG5cXG5cXHR2YXIgaW5mbGF0ZV9tYXNrID0gWyAweDAwMDAwMDAwLCAweDAwMDAwMDAxLCAweDAwMDAwMDAzLCAweDAwMDAwMDA3LCAweDAwMDAwMDBmLCAweDAwMDAwMDFmLCAweDAwMDAwMDNmLCAweDAwMDAwMDdmLCAweDAwMDAwMGZmLCAweDAwMDAwMWZmLCAweDAwMDAwM2ZmLFxcblxcdFxcdFxcdDB4MDAwMDA3ZmYsIDB4MDAwMDBmZmYsIDB4MDAwMDFmZmYsIDB4MDAwMDNmZmYsIDB4MDAwMDdmZmYsIDB4MDAwMGZmZmYgXTtcXG5cXG5cXHR2YXIgTUFOWSA9IDE0NDA7XFxuXFxuXFx0Ly8gSlpsaWIgdmVyc2lvbiA6IFxcXCIxLjAuMlxcXCJcXG5cXHR2YXIgWl9OT19GTFVTSCA9IDA7XFxuXFx0dmFyIFpfRklOSVNIID0gNDtcXG5cXG5cXHQvLyBJbmZUcmVlXFxuXFx0dmFyIGZpeGVkX2JsID0gOTtcXG5cXHR2YXIgZml4ZWRfYmQgPSA1O1xcblxcblxcdHZhciBmaXhlZF90bCA9IFsgOTYsIDcsIDI1NiwgMCwgOCwgODAsIDAsIDgsIDE2LCA4NCwgOCwgMTE1LCA4MiwgNywgMzEsIDAsIDgsIDExMiwgMCwgOCwgNDgsIDAsIDksIDE5MiwgODAsIDcsIDEwLCAwLCA4LCA5NiwgMCwgOCwgMzIsIDAsIDksIDE2MCwgMCwgOCwgMCxcXG5cXHRcXHRcXHQwLCA4LCAxMjgsIDAsIDgsIDY0LCAwLCA5LCAyMjQsIDgwLCA3LCA2LCAwLCA4LCA4OCwgMCwgOCwgMjQsIDAsIDksIDE0NCwgODMsIDcsIDU5LCAwLCA4LCAxMjAsIDAsIDgsIDU2LCAwLCA5LCAyMDgsIDgxLCA3LCAxNywgMCwgOCwgMTA0LCAwLCA4LCA0MCxcXG5cXHRcXHRcXHQwLCA5LCAxNzYsIDAsIDgsIDgsIDAsIDgsIDEzNiwgMCwgOCwgNzIsIDAsIDksIDI0MCwgODAsIDcsIDQsIDAsIDgsIDg0LCAwLCA4LCAyMCwgODUsIDgsIDIyNywgODMsIDcsIDQzLCAwLCA4LCAxMTYsIDAsIDgsIDUyLCAwLCA5LCAyMDAsIDgxLCA3LCAxMyxcXG5cXHRcXHRcXHQwLCA4LCAxMDAsIDAsIDgsIDM2LCAwLCA5LCAxNjgsIDAsIDgsIDQsIDAsIDgsIDEzMiwgMCwgOCwgNjgsIDAsIDksIDIzMiwgODAsIDcsIDgsIDAsIDgsIDkyLCAwLCA4LCAyOCwgMCwgOSwgMTUyLCA4NCwgNywgODMsIDAsIDgsIDEyNCwgMCwgOCwgNjAsXFxuXFx0XFx0XFx0MCwgOSwgMjE2LCA4MiwgNywgMjMsIDAsIDgsIDEwOCwgMCwgOCwgNDQsIDAsIDksIDE4NCwgMCwgOCwgMTIsIDAsIDgsIDE0MCwgMCwgOCwgNzYsIDAsIDksIDI0OCwgODAsIDcsIDMsIDAsIDgsIDgyLCAwLCA4LCAxOCwgODUsIDgsIDE2MywgODMsIDcsXFxuXFx0XFx0XFx0MzUsIDAsIDgsIDExNCwgMCwgOCwgNTAsIDAsIDksIDE5NiwgODEsIDcsIDExLCAwLCA4LCA5OCwgMCwgOCwgMzQsIDAsIDksIDE2NCwgMCwgOCwgMiwgMCwgOCwgMTMwLCAwLCA4LCA2NiwgMCwgOSwgMjI4LCA4MCwgNywgNywgMCwgOCwgOTAsIDAsIDgsXFxuXFx0XFx0XFx0MjYsIDAsIDksIDE0OCwgODQsIDcsIDY3LCAwLCA4LCAxMjIsIDAsIDgsIDU4LCAwLCA5LCAyMTIsIDgyLCA3LCAxOSwgMCwgOCwgMTA2LCAwLCA4LCA0MiwgMCwgOSwgMTgwLCAwLCA4LCAxMCwgMCwgOCwgMTM4LCAwLCA4LCA3NCwgMCwgOSwgMjQ0LCA4MCxcXG5cXHRcXHRcXHQ3LCA1LCAwLCA4LCA4NiwgMCwgOCwgMjIsIDE5MiwgOCwgMCwgODMsIDcsIDUxLCAwLCA4LCAxMTgsIDAsIDgsIDU0LCAwLCA5LCAyMDQsIDgxLCA3LCAxNSwgMCwgOCwgMTAyLCAwLCA4LCAzOCwgMCwgOSwgMTcyLCAwLCA4LCA2LCAwLCA4LCAxMzQsIDAsXFxuXFx0XFx0XFx0OCwgNzAsIDAsIDksIDIzNiwgODAsIDcsIDksIDAsIDgsIDk0LCAwLCA4LCAzMCwgMCwgOSwgMTU2LCA4NCwgNywgOTksIDAsIDgsIDEyNiwgMCwgOCwgNjIsIDAsIDksIDIyMCwgODIsIDcsIDI3LCAwLCA4LCAxMTAsIDAsIDgsIDQ2LCAwLCA5LCAxODgsIDAsXFxuXFx0XFx0XFx0OCwgMTQsIDAsIDgsIDE0MiwgMCwgOCwgNzgsIDAsIDksIDI1MiwgOTYsIDcsIDI1NiwgMCwgOCwgODEsIDAsIDgsIDE3LCA4NSwgOCwgMTMxLCA4MiwgNywgMzEsIDAsIDgsIDExMywgMCwgOCwgNDksIDAsIDksIDE5NCwgODAsIDcsIDEwLCAwLCA4LCA5NyxcXG5cXHRcXHRcXHQwLCA4LCAzMywgMCwgOSwgMTYyLCAwLCA4LCAxLCAwLCA4LCAxMjksIDAsIDgsIDY1LCAwLCA5LCAyMjYsIDgwLCA3LCA2LCAwLCA4LCA4OSwgMCwgOCwgMjUsIDAsIDksIDE0NiwgODMsIDcsIDU5LCAwLCA4LCAxMjEsIDAsIDgsIDU3LCAwLCA5LCAyMTAsXFxuXFx0XFx0XFx0ODEsIDcsIDE3LCAwLCA4LCAxMDUsIDAsIDgsIDQxLCAwLCA5LCAxNzgsIDAsIDgsIDksIDAsIDgsIDEzNywgMCwgOCwgNzMsIDAsIDksIDI0MiwgODAsIDcsIDQsIDAsIDgsIDg1LCAwLCA4LCAyMSwgODAsIDgsIDI1OCwgODMsIDcsIDQzLCAwLCA4LCAxMTcsXFxuXFx0XFx0XFx0MCwgOCwgNTMsIDAsIDksIDIwMiwgODEsIDcsIDEzLCAwLCA4LCAxMDEsIDAsIDgsIDM3LCAwLCA5LCAxNzAsIDAsIDgsIDUsIDAsIDgsIDEzMywgMCwgOCwgNjksIDAsIDksIDIzNCwgODAsIDcsIDgsIDAsIDgsIDkzLCAwLCA4LCAyOSwgMCwgOSwgMTU0LFxcblxcdFxcdFxcdDg0LCA3LCA4MywgMCwgOCwgMTI1LCAwLCA4LCA2MSwgMCwgOSwgMjE4LCA4MiwgNywgMjMsIDAsIDgsIDEwOSwgMCwgOCwgNDUsIDAsIDksIDE4NiwgMCwgOCwgMTMsIDAsIDgsIDE0MSwgMCwgOCwgNzcsIDAsIDksIDI1MCwgODAsIDcsIDMsIDAsIDgsIDgzLFxcblxcdFxcdFxcdDAsIDgsIDE5LCA4NSwgOCwgMTk1LCA4MywgNywgMzUsIDAsIDgsIDExNSwgMCwgOCwgNTEsIDAsIDksIDE5OCwgODEsIDcsIDExLCAwLCA4LCA5OSwgMCwgOCwgMzUsIDAsIDksIDE2NiwgMCwgOCwgMywgMCwgOCwgMTMxLCAwLCA4LCA2NywgMCwgOSwgMjMwLFxcblxcdFxcdFxcdDgwLCA3LCA3LCAwLCA4LCA5MSwgMCwgOCwgMjcsIDAsIDksIDE1MCwgODQsIDcsIDY3LCAwLCA4LCAxMjMsIDAsIDgsIDU5LCAwLCA5LCAyMTQsIDgyLCA3LCAxOSwgMCwgOCwgMTA3LCAwLCA4LCA0MywgMCwgOSwgMTgyLCAwLCA4LCAxMSwgMCwgOCwgMTM5LFxcblxcdFxcdFxcdDAsIDgsIDc1LCAwLCA5LCAyNDYsIDgwLCA3LCA1LCAwLCA4LCA4NywgMCwgOCwgMjMsIDE5MiwgOCwgMCwgODMsIDcsIDUxLCAwLCA4LCAxMTksIDAsIDgsIDU1LCAwLCA5LCAyMDYsIDgxLCA3LCAxNSwgMCwgOCwgMTAzLCAwLCA4LCAzOSwgMCwgOSwgMTc0LFxcblxcdFxcdFxcdDAsIDgsIDcsIDAsIDgsIDEzNSwgMCwgOCwgNzEsIDAsIDksIDIzOCwgODAsIDcsIDksIDAsIDgsIDk1LCAwLCA4LCAzMSwgMCwgOSwgMTU4LCA4NCwgNywgOTksIDAsIDgsIDEyNywgMCwgOCwgNjMsIDAsIDksIDIyMiwgODIsIDcsIDI3LCAwLCA4LCAxMTEsXFxuXFx0XFx0XFx0MCwgOCwgNDcsIDAsIDksIDE5MCwgMCwgOCwgMTUsIDAsIDgsIDE0MywgMCwgOCwgNzksIDAsIDksIDI1NCwgOTYsIDcsIDI1NiwgMCwgOCwgODAsIDAsIDgsIDE2LCA4NCwgOCwgMTE1LCA4MiwgNywgMzEsIDAsIDgsIDExMiwgMCwgOCwgNDgsIDAsIDksXFxuXFx0XFx0XFx0MTkzLCA4MCwgNywgMTAsIDAsIDgsIDk2LCAwLCA4LCAzMiwgMCwgOSwgMTYxLCAwLCA4LCAwLCAwLCA4LCAxMjgsIDAsIDgsIDY0LCAwLCA5LCAyMjUsIDgwLCA3LCA2LCAwLCA4LCA4OCwgMCwgOCwgMjQsIDAsIDksIDE0NSwgODMsIDcsIDU5LCAwLCA4LFxcblxcdFxcdFxcdDEyMCwgMCwgOCwgNTYsIDAsIDksIDIwOSwgODEsIDcsIDE3LCAwLCA4LCAxMDQsIDAsIDgsIDQwLCAwLCA5LCAxNzcsIDAsIDgsIDgsIDAsIDgsIDEzNiwgMCwgOCwgNzIsIDAsIDksIDI0MSwgODAsIDcsIDQsIDAsIDgsIDg0LCAwLCA4LCAyMCwgODUsIDgsXFxuXFx0XFx0XFx0MjI3LCA4MywgNywgNDMsIDAsIDgsIDExNiwgMCwgOCwgNTIsIDAsIDksIDIwMSwgODEsIDcsIDEzLCAwLCA4LCAxMDAsIDAsIDgsIDM2LCAwLCA5LCAxNjksIDAsIDgsIDQsIDAsIDgsIDEzMiwgMCwgOCwgNjgsIDAsIDksIDIzMywgODAsIDcsIDgsIDAsIDgsXFxuXFx0XFx0XFx0OTIsIDAsIDgsIDI4LCAwLCA5LCAxNTMsIDg0LCA3LCA4MywgMCwgOCwgMTI0LCAwLCA4LCA2MCwgMCwgOSwgMjE3LCA4MiwgNywgMjMsIDAsIDgsIDEwOCwgMCwgOCwgNDQsIDAsIDksIDE4NSwgMCwgOCwgMTIsIDAsIDgsIDE0MCwgMCwgOCwgNzYsIDAsIDksXFxuXFx0XFx0XFx0MjQ5LCA4MCwgNywgMywgMCwgOCwgODIsIDAsIDgsIDE4LCA4NSwgOCwgMTYzLCA4MywgNywgMzUsIDAsIDgsIDExNCwgMCwgOCwgNTAsIDAsIDksIDE5NywgODEsIDcsIDExLCAwLCA4LCA5OCwgMCwgOCwgMzQsIDAsIDksIDE2NSwgMCwgOCwgMiwgMCwgOCxcXG5cXHRcXHRcXHQxMzAsIDAsIDgsIDY2LCAwLCA5LCAyMjksIDgwLCA3LCA3LCAwLCA4LCA5MCwgMCwgOCwgMjYsIDAsIDksIDE0OSwgODQsIDcsIDY3LCAwLCA4LCAxMjIsIDAsIDgsIDU4LCAwLCA5LCAyMTMsIDgyLCA3LCAxOSwgMCwgOCwgMTA2LCAwLCA4LCA0MiwgMCwgOSxcXG5cXHRcXHRcXHQxODEsIDAsIDgsIDEwLCAwLCA4LCAxMzgsIDAsIDgsIDc0LCAwLCA5LCAyNDUsIDgwLCA3LCA1LCAwLCA4LCA4NiwgMCwgOCwgMjIsIDE5MiwgOCwgMCwgODMsIDcsIDUxLCAwLCA4LCAxMTgsIDAsIDgsIDU0LCAwLCA5LCAyMDUsIDgxLCA3LCAxNSwgMCwgOCxcXG5cXHRcXHRcXHQxMDIsIDAsIDgsIDM4LCAwLCA5LCAxNzMsIDAsIDgsIDYsIDAsIDgsIDEzNCwgMCwgOCwgNzAsIDAsIDksIDIzNywgODAsIDcsIDksIDAsIDgsIDk0LCAwLCA4LCAzMCwgMCwgOSwgMTU3LCA4NCwgNywgOTksIDAsIDgsIDEyNiwgMCwgOCwgNjIsIDAsIDksXFxuXFx0XFx0XFx0MjIxLCA4MiwgNywgMjcsIDAsIDgsIDExMCwgMCwgOCwgNDYsIDAsIDksIDE4OSwgMCwgOCwgMTQsIDAsIDgsIDE0MiwgMCwgOCwgNzgsIDAsIDksIDI1MywgOTYsIDcsIDI1NiwgMCwgOCwgODEsIDAsIDgsIDE3LCA4NSwgOCwgMTMxLCA4MiwgNywgMzEsIDAsXFxuXFx0XFx0XFx0OCwgMTEzLCAwLCA4LCA0OSwgMCwgOSwgMTk1LCA4MCwgNywgMTAsIDAsIDgsIDk3LCAwLCA4LCAzMywgMCwgOSwgMTYzLCAwLCA4LCAxLCAwLCA4LCAxMjksIDAsIDgsIDY1LCAwLCA5LCAyMjcsIDgwLCA3LCA2LCAwLCA4LCA4OSwgMCwgOCwgMjUsIDAsIDksXFxuXFx0XFx0XFx0MTQ3LCA4MywgNywgNTksIDAsIDgsIDEyMSwgMCwgOCwgNTcsIDAsIDksIDIxMSwgODEsIDcsIDE3LCAwLCA4LCAxMDUsIDAsIDgsIDQxLCAwLCA5LCAxNzksIDAsIDgsIDksIDAsIDgsIDEzNywgMCwgOCwgNzMsIDAsIDksIDI0MywgODAsIDcsIDQsIDAsIDgsXFxuXFx0XFx0XFx0ODUsIDAsIDgsIDIxLCA4MCwgOCwgMjU4LCA4MywgNywgNDMsIDAsIDgsIDExNywgMCwgOCwgNTMsIDAsIDksIDIwMywgODEsIDcsIDEzLCAwLCA4LCAxMDEsIDAsIDgsIDM3LCAwLCA5LCAxNzEsIDAsIDgsIDUsIDAsIDgsIDEzMywgMCwgOCwgNjksIDAsIDksXFxuXFx0XFx0XFx0MjM1LCA4MCwgNywgOCwgMCwgOCwgOTMsIDAsIDgsIDI5LCAwLCA5LCAxNTUsIDg0LCA3LCA4MywgMCwgOCwgMTI1LCAwLCA4LCA2MSwgMCwgOSwgMjE5LCA4MiwgNywgMjMsIDAsIDgsIDEwOSwgMCwgOCwgNDUsIDAsIDksIDE4NywgMCwgOCwgMTMsIDAsIDgsXFxuXFx0XFx0XFx0MTQxLCAwLCA4LCA3NywgMCwgOSwgMjUxLCA4MCwgNywgMywgMCwgOCwgODMsIDAsIDgsIDE5LCA4NSwgOCwgMTk1LCA4MywgNywgMzUsIDAsIDgsIDExNSwgMCwgOCwgNTEsIDAsIDksIDE5OSwgODEsIDcsIDExLCAwLCA4LCA5OSwgMCwgOCwgMzUsIDAsIDksXFxuXFx0XFx0XFx0MTY3LCAwLCA4LCAzLCAwLCA4LCAxMzEsIDAsIDgsIDY3LCAwLCA5LCAyMzEsIDgwLCA3LCA3LCAwLCA4LCA5MSwgMCwgOCwgMjcsIDAsIDksIDE1MSwgODQsIDcsIDY3LCAwLCA4LCAxMjMsIDAsIDgsIDU5LCAwLCA5LCAyMTUsIDgyLCA3LCAxOSwgMCwgOCxcXG5cXHRcXHRcXHQxMDcsIDAsIDgsIDQzLCAwLCA5LCAxODMsIDAsIDgsIDExLCAwLCA4LCAxMzksIDAsIDgsIDc1LCAwLCA5LCAyNDcsIDgwLCA3LCA1LCAwLCA4LCA4NywgMCwgOCwgMjMsIDE5MiwgOCwgMCwgODMsIDcsIDUxLCAwLCA4LCAxMTksIDAsIDgsIDU1LCAwLCA5LFxcblxcdFxcdFxcdDIwNywgODEsIDcsIDE1LCAwLCA4LCAxMDMsIDAsIDgsIDM5LCAwLCA5LCAxNzUsIDAsIDgsIDcsIDAsIDgsIDEzNSwgMCwgOCwgNzEsIDAsIDksIDIzOSwgODAsIDcsIDksIDAsIDgsIDk1LCAwLCA4LCAzMSwgMCwgOSwgMTU5LCA4NCwgNywgOTksIDAsIDgsXFxuXFx0XFx0XFx0MTI3LCAwLCA4LCA2MywgMCwgOSwgMjIzLCA4MiwgNywgMjcsIDAsIDgsIDExMSwgMCwgOCwgNDcsIDAsIDksIDE5MSwgMCwgOCwgMTUsIDAsIDgsIDE0MywgMCwgOCwgNzksIDAsIDksIDI1NSBdO1xcblxcdHZhciBmaXhlZF90ZCA9IFsgODAsIDUsIDEsIDg3LCA1LCAyNTcsIDgzLCA1LCAxNywgOTEsIDUsIDQwOTcsIDgxLCA1LCA1LCA4OSwgNSwgMTAyNSwgODUsIDUsIDY1LCA5MywgNSwgMTYzODUsIDgwLCA1LCAzLCA4OCwgNSwgNTEzLCA4NCwgNSwgMzMsIDkyLCA1LFxcblxcdFxcdFxcdDgxOTMsIDgyLCA1LCA5LCA5MCwgNSwgMjA0OSwgODYsIDUsIDEyOSwgMTkyLCA1LCAyNDU3NywgODAsIDUsIDIsIDg3LCA1LCAzODUsIDgzLCA1LCAyNSwgOTEsIDUsIDYxNDUsIDgxLCA1LCA3LCA4OSwgNSwgMTUzNywgODUsIDUsIDk3LCA5MywgNSxcXG5cXHRcXHRcXHQyNDU3NywgODAsIDUsIDQsIDg4LCA1LCA3NjksIDg0LCA1LCA0OSwgOTIsIDUsIDEyMjg5LCA4MiwgNSwgMTMsIDkwLCA1LCAzMDczLCA4NiwgNSwgMTkzLCAxOTIsIDUsIDI0NTc3IF07XFxuXFxuXFx0Ly8gVGFibGVzIGZvciBkZWZsYXRlIGZyb20gUEtaSVAncyBhcHBub3RlLnR4dC5cXG5cXHR2YXIgY3BsZW5zID0gWyAvLyBDb3B5IGxlbmd0aHMgZm9yIGxpdGVyYWwgY29kZXMgMjU3Li4yODVcXG5cXHQzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEzLCAxNSwgMTcsIDE5LCAyMywgMjcsIDMxLCAzNSwgNDMsIDUxLCA1OSwgNjcsIDgzLCA5OSwgMTE1LCAxMzEsIDE2MywgMTk1LCAyMjcsIDI1OCwgMCwgMCBdO1xcblxcblxcdC8vIHNlZSBub3RlICMxMyBhYm92ZSBhYm91dCAyNThcXG5cXHR2YXIgY3BsZXh0ID0gWyAvLyBFeHRyYSBiaXRzIGZvciBsaXRlcmFsIGNvZGVzIDI1Ny4uMjg1XFxuXFx0MCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMSwgMSwgMSwgMSwgMiwgMiwgMiwgMiwgMywgMywgMywgMywgNCwgNCwgNCwgNCwgNSwgNSwgNSwgNSwgMCwgMTEyLCAxMTIgLy8gMTEyPT1pbnZhbGlkXFxuXFx0XTtcXG5cXG5cXHR2YXIgY3BkaXN0ID0gWyAvLyBDb3B5IG9mZnNldHMgZm9yIGRpc3RhbmNlIGNvZGVzIDAuLjI5XFxuXFx0MSwgMiwgMywgNCwgNSwgNywgOSwgMTMsIDE3LCAyNSwgMzMsIDQ5LCA2NSwgOTcsIDEyOSwgMTkzLCAyNTcsIDM4NSwgNTEzLCA3NjksIDEwMjUsIDE1MzcsIDIwNDksIDMwNzMsIDQwOTcsIDYxNDUsIDgxOTMsIDEyMjg5LCAxNjM4NSwgMjQ1NzcgXTtcXG5cXG5cXHR2YXIgY3BkZXh0ID0gWyAvLyBFeHRyYSBiaXRzIGZvciBkaXN0YW5jZSBjb2Rlc1xcblxcdDAsIDAsIDAsIDAsIDEsIDEsIDIsIDIsIDMsIDMsIDQsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDgsIDgsIDksIDksIDEwLCAxMCwgMTEsIDExLCAxMiwgMTIsIDEzLCAxMyBdO1xcblxcblxcdC8vIElmIEJNQVggbmVlZHMgdG8gYmUgbGFyZ2VyIHRoYW4gMTYsIHRoZW4gaCBhbmQgeFtdIHNob3VsZCBiZSB1TG9uZy5cXG5cXHR2YXIgQk1BWCA9IDE1OyAvLyBtYXhpbXVtIGJpdCBsZW5ndGggb2YgYW55IGNvZGVcXG5cXG5cXHRmdW5jdGlvbiBJbmZUcmVlKCkge1xcblxcdFxcdHZhciB0aGF0ID0gdGhpcztcXG5cXG5cXHRcXHR2YXIgaG47IC8vIGh1ZnRzIHVzZWQgaW4gc3BhY2VcXG5cXHRcXHR2YXIgdjsgLy8gd29yayBhcmVhIGZvciBodWZ0X2J1aWxkXFxuXFx0XFx0dmFyIGM7IC8vIGJpdCBsZW5ndGggY291bnQgdGFibGVcXG5cXHRcXHR2YXIgcjsgLy8gdGFibGUgZW50cnkgZm9yIHN0cnVjdHVyZSBhc3NpZ25tZW50XFxuXFx0XFx0dmFyIHU7IC8vIHRhYmxlIHN0YWNrXFxuXFx0XFx0dmFyIHg7IC8vIGJpdCBvZmZzZXRzLCB0aGVuIGNvZGUgc3RhY2tcXG5cXG5cXHRcXHRmdW5jdGlvbiBodWZ0X2J1aWxkKGIsIC8vIGNvZGUgbGVuZ3RocyBpbiBiaXRzIChhbGwgYXNzdW1lZCA8PVxcblxcdFxcdC8vIEJNQVgpXFxuXFx0XFx0YmluZGV4LCBuLCAvLyBudW1iZXIgb2YgY29kZXMgKGFzc3VtZWQgPD0gMjg4KVxcblxcdFxcdHMsIC8vIG51bWJlciBvZiBzaW1wbGUtdmFsdWVkIGNvZGVzICgwLi5zLTEpXFxuXFx0XFx0ZCwgLy8gbGlzdCBvZiBiYXNlIHZhbHVlcyBmb3Igbm9uLXNpbXBsZSBjb2Rlc1xcblxcdFxcdGUsIC8vIGxpc3Qgb2YgZXh0cmEgYml0cyBmb3Igbm9uLXNpbXBsZSBjb2Rlc1xcblxcdFxcdHQsIC8vIHJlc3VsdDogc3RhcnRpbmcgdGFibGVcXG5cXHRcXHRtLCAvLyBtYXhpbXVtIGxvb2t1cCBiaXRzLCByZXR1cm5zIGFjdHVhbFxcblxcdFxcdGhwLC8vIHNwYWNlIGZvciB0cmVlc1xcblxcdFxcdGhuLC8vIGh1ZnRzIHVzZWQgaW4gc3BhY2VcXG5cXHRcXHR2IC8vIHdvcmtpbmcgYXJlYTogdmFsdWVzIGluIG9yZGVyIG9mIGJpdCBsZW5ndGhcXG5cXHRcXHQpIHtcXG5cXHRcXHRcXHQvLyBHaXZlbiBhIGxpc3Qgb2YgY29kZSBsZW5ndGhzIGFuZCBhIG1heGltdW0gdGFibGUgc2l6ZSwgbWFrZSBhIHNldCBvZlxcblxcdFxcdFxcdC8vIHRhYmxlcyB0byBkZWNvZGUgdGhhdCBzZXQgb2YgY29kZXMuIFJldHVybiBaX09LIG9uIHN1Y2Nlc3MsXFxuXFx0XFx0XFx0Ly8gWl9CVUZfRVJST1JcXG5cXHRcXHRcXHQvLyBpZiB0aGUgZ2l2ZW4gY29kZSBzZXQgaXMgaW5jb21wbGV0ZSAodGhlIHRhYmxlcyBhcmUgc3RpbGwgYnVpbHQgaW5cXG5cXHRcXHRcXHQvLyB0aGlzXFxuXFx0XFx0XFx0Ly8gY2FzZSksIFpfREFUQV9FUlJPUiBpZiB0aGUgaW5wdXQgaXMgaW52YWxpZCAoYW4gb3Zlci1zdWJzY3JpYmVkIHNldFxcblxcdFxcdFxcdC8vIG9mXFxuXFx0XFx0XFx0Ly8gbGVuZ3RocyksIG9yIFpfTUVNX0VSUk9SIGlmIG5vdCBlbm91Z2ggbWVtb3J5LlxcblxcblxcdFxcdFxcdHZhciBhOyAvLyBjb3VudGVyIGZvciBjb2RlcyBvZiBsZW5ndGgga1xcblxcdFxcdFxcdHZhciBmOyAvLyBpIHJlcGVhdHMgaW4gdGFibGUgZXZlcnkgZiBlbnRyaWVzXFxuXFx0XFx0XFx0dmFyIGc7IC8vIG1heGltdW0gY29kZSBsZW5ndGhcXG5cXHRcXHRcXHR2YXIgaDsgLy8gdGFibGUgbGV2ZWxcXG5cXHRcXHRcXHR2YXIgaTsgLy8gY291bnRlciwgY3VycmVudCBjb2RlXFxuXFx0XFx0XFx0dmFyIGo7IC8vIGNvdW50ZXJcXG5cXHRcXHRcXHR2YXIgazsgLy8gbnVtYmVyIG9mIGJpdHMgaW4gY3VycmVudCBjb2RlXFxuXFx0XFx0XFx0dmFyIGw7IC8vIGJpdHMgcGVyIHRhYmxlIChyZXR1cm5lZCBpbiBtKVxcblxcdFxcdFxcdHZhciBtYXNrOyAvLyAoMSA8PCB3KSAtIDEsIHRvIGF2b2lkIGNjIC1PIGJ1ZyBvbiBIUFxcblxcdFxcdFxcdHZhciBwOyAvLyBwb2ludGVyIGludG8gY1tdLCBiW10sIG9yIHZbXVxcblxcdFxcdFxcdHZhciBxOyAvLyBwb2ludHMgdG8gY3VycmVudCB0YWJsZVxcblxcdFxcdFxcdHZhciB3OyAvLyBiaXRzIGJlZm9yZSB0aGlzIHRhYmxlID09IChsICogaClcXG5cXHRcXHRcXHR2YXIgeHA7IC8vIHBvaW50ZXIgaW50byB4XFxuXFx0XFx0XFx0dmFyIHk7IC8vIG51bWJlciBvZiBkdW1teSBjb2RlcyBhZGRlZFxcblxcdFxcdFxcdHZhciB6OyAvLyBudW1iZXIgb2YgZW50cmllcyBpbiBjdXJyZW50IHRhYmxlXFxuXFxuXFx0XFx0XFx0Ly8gR2VuZXJhdGUgY291bnRzIGZvciBlYWNoIGJpdCBsZW5ndGhcXG5cXG5cXHRcXHRcXHRwID0gMDtcXG5cXHRcXHRcXHRpID0gbjtcXG5cXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0Y1tiW2JpbmRleCArIHBdXSsrO1xcblxcdFxcdFxcdFxcdHArKztcXG5cXHRcXHRcXHRcXHRpLS07IC8vIGFzc3VtZSBhbGwgZW50cmllcyA8PSBCTUFYXFxuXFx0XFx0XFx0fSB3aGlsZSAoaSAhPT0gMCk7XFxuXFxuXFx0XFx0XFx0aWYgKGNbMF0gPT0gbikgeyAvLyBudWxsIGlucHV0LS1hbGwgemVybyBsZW5ndGggY29kZXNcXG5cXHRcXHRcXHRcXHR0WzBdID0gLTE7XFxuXFx0XFx0XFx0XFx0bVswXSA9IDA7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIFpfT0s7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEZpbmQgbWluaW11bSBhbmQgbWF4aW11bSBsZW5ndGgsIGJvdW5kICptIGJ5IHRob3NlXFxuXFx0XFx0XFx0bCA9IG1bMF07XFxuXFx0XFx0XFx0Zm9yIChqID0gMTsgaiA8PSBCTUFYOyBqKyspXFxuXFx0XFx0XFx0XFx0aWYgKGNbal0gIT09IDApXFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0ayA9IGo7IC8vIG1pbmltdW0gY29kZSBsZW5ndGhcXG5cXHRcXHRcXHRpZiAobCA8IGopIHtcXG5cXHRcXHRcXHRcXHRsID0gajtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Zm9yIChpID0gQk1BWDsgaSAhPT0gMDsgaS0tKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGNbaV0gIT09IDApXFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGcgPSBpOyAvLyBtYXhpbXVtIGNvZGUgbGVuZ3RoXFxuXFx0XFx0XFx0aWYgKGwgPiBpKSB7XFxuXFx0XFx0XFx0XFx0bCA9IGk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdG1bMF0gPSBsO1xcblxcblxcdFxcdFxcdC8vIEFkanVzdCBsYXN0IGxlbmd0aCBjb3VudCB0byBmaWxsIG91dCBjb2RlcywgaWYgbmVlZGVkXFxuXFx0XFx0XFx0Zm9yICh5ID0gMSA8PCBqOyBqIDwgaTsgaisrLCB5IDw8PSAxKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCh5IC09IGNbal0pIDwgMCkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBaX0RBVEFfRVJST1I7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoKHkgLT0gY1tpXSkgPCAwKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIFpfREFUQV9FUlJPUjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Y1tpXSArPSB5O1xcblxcblxcdFxcdFxcdC8vIEdlbmVyYXRlIHN0YXJ0aW5nIG9mZnNldHMgaW50byB0aGUgdmFsdWUgdGFibGUgZm9yIGVhY2ggbGVuZ3RoXFxuXFx0XFx0XFx0eFsxXSA9IGogPSAwO1xcblxcdFxcdFxcdHAgPSAxO1xcblxcdFxcdFxcdHhwID0gMjtcXG5cXHRcXHRcXHR3aGlsZSAoLS1pICE9PSAwKSB7IC8vIG5vdGUgdGhhdCBpID09IGcgZnJvbSBhYm92ZVxcblxcdFxcdFxcdFxcdHhbeHBdID0gKGogKz0gY1twXSk7XFxuXFx0XFx0XFx0XFx0eHArKztcXG5cXHRcXHRcXHRcXHRwKys7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIE1ha2UgYSB0YWJsZSBvZiB2YWx1ZXMgaW4gb3JkZXIgb2YgYml0IGxlbmd0aHNcXG5cXHRcXHRcXHRpID0gMDtcXG5cXHRcXHRcXHRwID0gMDtcXG5cXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0aWYgKChqID0gYltiaW5kZXggKyBwXSkgIT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHR2W3hbal0rK10gPSBpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRwKys7XFxuXFx0XFx0XFx0fSB3aGlsZSAoKytpIDwgbik7XFxuXFx0XFx0XFx0biA9IHhbZ107IC8vIHNldCBuIHRvIGxlbmd0aCBvZiB2XFxuXFxuXFx0XFx0XFx0Ly8gR2VuZXJhdGUgdGhlIEh1ZmZtYW4gY29kZXMgYW5kIGZvciBlYWNoLCBtYWtlIHRoZSB0YWJsZSBlbnRyaWVzXFxuXFx0XFx0XFx0eFswXSA9IGkgPSAwOyAvLyBmaXJzdCBIdWZmbWFuIGNvZGUgaXMgemVyb1xcblxcdFxcdFxcdHAgPSAwOyAvLyBncmFiIHZhbHVlcyBpbiBiaXQgb3JkZXJcXG5cXHRcXHRcXHRoID0gLTE7IC8vIG5vIHRhYmxlcyB5ZXQtLWxldmVsIC0xXFxuXFx0XFx0XFx0dyA9IC1sOyAvLyBiaXRzIGRlY29kZWQgPT0gKGwgKiBoKVxcblxcdFxcdFxcdHVbMF0gPSAwOyAvLyBqdXN0IHRvIGtlZXAgY29tcGlsZXJzIGhhcHB5XFxuXFx0XFx0XFx0cSA9IDA7IC8vIGRpdHRvXFxuXFx0XFx0XFx0eiA9IDA7IC8vIGRpdHRvXFxuXFxuXFx0XFx0XFx0Ly8gZ28gdGhyb3VnaCB0aGUgYml0IGxlbmd0aHMgKGsgYWxyZWFkeSBpcyBiaXRzIGluIHNob3J0ZXN0IGNvZGUpXFxuXFx0XFx0XFx0Zm9yICg7IGsgPD0gZzsgaysrKSB7XFxuXFx0XFx0XFx0XFx0YSA9IGNba107XFxuXFx0XFx0XFx0XFx0d2hpbGUgKGEtLSAhPT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdC8vIGhlcmUgaSBpcyB0aGUgSHVmZm1hbiBjb2RlIG9mIGxlbmd0aCBrIGJpdHMgZm9yIHZhbHVlICpwXFxuXFx0XFx0XFx0XFx0XFx0Ly8gbWFrZSB0YWJsZXMgdXAgdG8gcmVxdWlyZWQgbGV2ZWxcXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoayA+IHcgKyBsKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aCsrO1xcblxcdFxcdFxcdFxcdFxcdFxcdHcgKz0gbDsgLy8gcHJldmlvdXMgdGFibGUgYWx3YXlzIGwgYml0c1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGNvbXB1dGUgbWluaW11bSBzaXplIHRhYmxlIGxlc3MgdGhhbiBvciBlcXVhbCB0byBsIGJpdHNcXG5cXHRcXHRcXHRcXHRcXHRcXHR6ID0gZyAtIHc7XFxuXFx0XFx0XFx0XFx0XFx0XFx0eiA9ICh6ID4gbCkgPyBsIDogejsgLy8gdGFibGUgc2l6ZSB1cHBlciBsaW1pdFxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICgoZiA9IDEgPDwgKGogPSBrIC0gdykpID4gYSArIDEpIHsgLy8gdHJ5IGEgay13IGJpdCB0YWJsZVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIHRvbyBmZXcgY29kZXMgZm9yXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gay13IGJpdCB0YWJsZVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGYgLT0gYSArIDE7IC8vIGRlZHVjdCBjb2RlcyBmcm9tIHBhdHRlcm5zIGxlZnRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR4cCA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGogPCB6KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0d2hpbGUgKCsraiA8IHopIHsgLy8gdHJ5IHNtYWxsZXIgdGFibGVzIHVwIHRvIHogYml0c1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICgoZiA8PD0gMSkgPD0gY1srK3hwXSlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhazsgLy8gZW5vdWdoIGNvZGVzIHRvIHVzZSB1cCBqIGJpdHNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRmIC09IGNbeHBdOyAvLyBlbHNlIGRlZHVjdCBjb2RlcyBmcm9tIHBhdHRlcm5zXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0eiA9IDEgPDwgajsgLy8gdGFibGUgZW50cmllcyBmb3Igai1iaXQgdGFibGVcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBhbGxvY2F0ZSBuZXcgdGFibGVcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoaG5bMF0gKyB6ID4gTUFOWSkgeyAvLyAobm90ZTogZG9lc24ndCBtYXR0ZXIgZm9yIGZpeGVkKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBaX0RBVEFfRVJST1I7IC8vIG92ZXJmbG93IG9mIE1BTllcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0dVtoXSA9IHEgPSAvKiBocCsgKi9oblswXTsgLy8gREVCVUdcXG5cXHRcXHRcXHRcXHRcXHRcXHRoblswXSArPSB6O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGNvbm5lY3QgdG8gbGFzdCB0YWJsZSwgaWYgdGhlcmUgaXMgb25lXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKGggIT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR4W2hdID0gaTsgLy8gc2F2ZSBwYXR0ZXJuIGZvciBiYWNraW5nIHVwXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0clswXSA9IC8qIChieXRlKSAqL2o7IC8vIGJpdHMgaW4gdGhpcyB0YWJsZVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJbMV0gPSAvKiAoYnl0ZSkgKi9sOyAvLyBiaXRzIHRvIGR1bXAgYmVmb3JlIHRoaXMgdGFibGVcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRqID0gaSA+Pj4gKHcgLSBsKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyWzJdID0gLyogKGludCkgKi8ocSAtIHVbaCAtIDFdIC0gaik7IC8vIG9mZnNldCB0byB0aGlzIHRhYmxlXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aHAuc2V0KHIsICh1W2ggLSAxXSArIGopICogMyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gdG9cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBsYXN0XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gdGFibGVcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRbMF0gPSBxOyAvLyBmaXJzdCB0YWJsZSBpcyByZXR1cm5lZCByZXN1bHRcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIHNldCB1cCB0YWJsZSBlbnRyeSBpbiByXFxuXFx0XFx0XFx0XFx0XFx0clsxXSA9IC8qIChieXRlKSAqLyhrIC0gdyk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHAgPj0gbikge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJbMF0gPSAxMjggKyA2NDsgLy8gb3V0IG9mIHZhbHVlcy0taW52YWxpZCBjb2RlXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICh2W3BdIDwgcykge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJbMF0gPSAvKiAoYnl0ZSkgKi8odltwXSA8IDI1NiA/IDAgOiAzMiArIDY0KTsgLy8gMjU2IGlzXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gZW5kLW9mLWJsb2NrXFxuXFx0XFx0XFx0XFx0XFx0XFx0clsyXSA9IHZbcCsrXTsgLy8gc2ltcGxlIGNvZGUgaXMganVzdCB0aGUgdmFsdWVcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJbMF0gPSAvKiAoYnl0ZSkgKi8oZVt2W3BdIC0gc10gKyAxNiArIDY0KTsgLy8gbm9uLXNpbXBsZS0tbG9va1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHVwIGluIGxpc3RzXFxuXFx0XFx0XFx0XFx0XFx0XFx0clsyXSA9IGRbdltwKytdIC0gc107XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIGZpbGwgY29kZS1saWtlIGVudHJpZXMgd2l0aCByXFxuXFx0XFx0XFx0XFx0XFx0ZiA9IDEgPDwgKGsgLSB3KTtcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKGogPSBpID4+PiB3OyBqIDwgejsgaiArPSBmKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aHAuc2V0KHIsIChxICsgaikgKiAzKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gYmFja3dhcmRzIGluY3JlbWVudCB0aGUgay1iaXQgY29kZSBpXFxuXFx0XFx0XFx0XFx0XFx0Zm9yIChqID0gMSA8PCAoayAtIDEpOyAoaSAmIGopICE9PSAwOyBqID4+Pj0gMSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGkgXj0gajtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aSBePSBqO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIGJhY2t1cCBvdmVyIGZpbmlzaGVkIHRhYmxlc1xcblxcdFxcdFxcdFxcdFxcdG1hc2sgPSAoMSA8PCB3KSAtIDE7IC8vIG5lZWRlZCBvbiBIUCwgY2MgLU8gYnVnXFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKChpICYgbWFzaykgIT0geFtoXSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGgtLTsgLy8gZG9uJ3QgbmVlZCB0byB1cGRhdGUgcVxcblxcdFxcdFxcdFxcdFxcdFxcdHcgLT0gbDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtYXNrID0gKDEgPDwgdykgLSAxO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8vIFJldHVybiBaX0JVRl9FUlJPUiBpZiB3ZSB3ZXJlIGdpdmVuIGFuIGluY29tcGxldGUgdGFibGVcXG5cXHRcXHRcXHRyZXR1cm4geSAhPT0gMCAmJiBnICE9IDEgPyBaX0JVRl9FUlJPUiA6IFpfT0s7XFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIGluaXRXb3JrQXJlYSh2c2l6ZSkge1xcblxcdFxcdFxcdHZhciBpO1xcblxcdFxcdFxcdGlmICghaG4pIHtcXG5cXHRcXHRcXHRcXHRobiA9IFtdOyAvLyBbXTsgLy9uZXcgQXJyYXkoMSk7XFxuXFx0XFx0XFx0XFx0diA9IFtdOyAvLyBuZXcgQXJyYXkodnNpemUpO1xcblxcdFxcdFxcdFxcdGMgPSBuZXcgSW50MzJBcnJheShCTUFYICsgMSk7IC8vIG5ldyBBcnJheShCTUFYICsgMSk7XFxuXFx0XFx0XFx0XFx0ciA9IFtdOyAvLyBuZXcgQXJyYXkoMyk7XFxuXFx0XFx0XFx0XFx0dSA9IG5ldyBJbnQzMkFycmF5KEJNQVgpOyAvLyBuZXcgQXJyYXkoQk1BWCk7XFxuXFx0XFx0XFx0XFx0eCA9IG5ldyBJbnQzMkFycmF5KEJNQVggKyAxKTsgLy8gbmV3IEFycmF5KEJNQVggKyAxKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHYubGVuZ3RoIDwgdnNpemUpIHtcXG5cXHRcXHRcXHRcXHR2ID0gW107IC8vIG5ldyBBcnJheSh2c2l6ZSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGZvciAoaSA9IDA7IGkgPCB2c2l6ZTsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0dltpXSA9IDA7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGZvciAoaSA9IDA7IGkgPCBCTUFYICsgMTsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0Y1tpXSA9IDA7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRyW2ldID0gMDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Ly8gZm9yKGludCBpPTA7IGk8Qk1BWDsgaSsrKXt1W2ldPTA7fVxcblxcdFxcdFxcdHUuc2V0KGMuc3ViYXJyYXkoMCwgQk1BWCksIDApO1xcblxcdFxcdFxcdC8vIGZvcihpbnQgaT0wOyBpPEJNQVgrMTsgaSsrKXt4W2ldPTA7fVxcblxcdFxcdFxcdHguc2V0KGMuc3ViYXJyYXkoMCwgQk1BWCArIDEpLCAwKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhhdC5pbmZsYXRlX3RyZWVzX2JpdHMgPSBmdW5jdGlvbihjLCAvLyAxOSBjb2RlIGxlbmd0aHNcXG5cXHRcXHRiYiwgLy8gYml0cyB0cmVlIGRlc2lyZWQvYWN0dWFsIGRlcHRoXFxuXFx0XFx0dGIsIC8vIGJpdHMgdHJlZSByZXN1bHRcXG5cXHRcXHRocCwgLy8gc3BhY2UgZm9yIHRyZWVzXFxuXFx0XFx0eiAvLyBmb3IgbWVzc2FnZXNcXG5cXHRcXHQpIHtcXG5cXHRcXHRcXHR2YXIgcmVzdWx0O1xcblxcdFxcdFxcdGluaXRXb3JrQXJlYSgxOSk7XFxuXFx0XFx0XFx0aG5bMF0gPSAwO1xcblxcdFxcdFxcdHJlc3VsdCA9IGh1ZnRfYnVpbGQoYywgMCwgMTksIDE5LCBudWxsLCBudWxsLCB0YiwgYmIsIGhwLCBobiwgdik7XFxuXFxuXFx0XFx0XFx0aWYgKHJlc3VsdCA9PSBaX0RBVEFfRVJST1IpIHtcXG5cXHRcXHRcXHRcXHR6Lm1zZyA9IFxcXCJvdmVyc3Vic2NyaWJlZCBkeW5hbWljIGJpdCBsZW5ndGhzIHRyZWVcXFwiO1xcblxcdFxcdFxcdH0gZWxzZSBpZiAocmVzdWx0ID09IFpfQlVGX0VSUk9SIHx8IGJiWzBdID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0ei5tc2cgPSBcXFwiaW5jb21wbGV0ZSBkeW5hbWljIGJpdCBsZW5ndGhzIHRyZWVcXFwiO1xcblxcdFxcdFxcdFxcdHJlc3VsdCA9IFpfREFUQV9FUlJPUjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIHJlc3VsdDtcXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoYXQuaW5mbGF0ZV90cmVlc19keW5hbWljID0gZnVuY3Rpb24obmwsIC8vIG51bWJlciBvZiBsaXRlcmFsL2xlbmd0aCBjb2Rlc1xcblxcdFxcdG5kLCAvLyBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXNcXG5cXHRcXHRjLCAvLyB0aGF0IG1hbnkgKHRvdGFsKSBjb2RlIGxlbmd0aHNcXG5cXHRcXHRibCwgLy8gbGl0ZXJhbCBkZXNpcmVkL2FjdHVhbCBiaXQgZGVwdGhcXG5cXHRcXHRiZCwgLy8gZGlzdGFuY2UgZGVzaXJlZC9hY3R1YWwgYml0IGRlcHRoXFxuXFx0XFx0dGwsIC8vIGxpdGVyYWwvbGVuZ3RoIHRyZWUgcmVzdWx0XFxuXFx0XFx0dGQsIC8vIGRpc3RhbmNlIHRyZWUgcmVzdWx0XFxuXFx0XFx0aHAsIC8vIHNwYWNlIGZvciB0cmVlc1xcblxcdFxcdHogLy8gZm9yIG1lc3NhZ2VzXFxuXFx0XFx0KSB7XFxuXFx0XFx0XFx0dmFyIHJlc3VsdDtcXG5cXG5cXHRcXHRcXHQvLyBidWlsZCBsaXRlcmFsL2xlbmd0aCB0cmVlXFxuXFx0XFx0XFx0aW5pdFdvcmtBcmVhKDI4OCk7XFxuXFx0XFx0XFx0aG5bMF0gPSAwO1xcblxcdFxcdFxcdHJlc3VsdCA9IGh1ZnRfYnVpbGQoYywgMCwgbmwsIDI1NywgY3BsZW5zLCBjcGxleHQsIHRsLCBibCwgaHAsIGhuLCB2KTtcXG5cXHRcXHRcXHRpZiAocmVzdWx0ICE9IFpfT0sgfHwgYmxbMF0gPT09IDApIHtcXG5cXHRcXHRcXHRcXHRpZiAocmVzdWx0ID09IFpfREFUQV9FUlJPUikge1xcblxcdFxcdFxcdFxcdFxcdHoubXNnID0gXFxcIm92ZXJzdWJzY3JpYmVkIGxpdGVyYWwvbGVuZ3RoIHRyZWVcXFwiO1xcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAocmVzdWx0ICE9IFpfTUVNX0VSUk9SKSB7XFxuXFx0XFx0XFx0XFx0XFx0ei5tc2cgPSBcXFwiaW5jb21wbGV0ZSBsaXRlcmFsL2xlbmd0aCB0cmVlXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRyZXN1bHQgPSBaX0RBVEFfRVJST1I7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiByZXN1bHQ7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGJ1aWxkIGRpc3RhbmNlIHRyZWVcXG5cXHRcXHRcXHRpbml0V29ya0FyZWEoMjg4KTtcXG5cXHRcXHRcXHRyZXN1bHQgPSBodWZ0X2J1aWxkKGMsIG5sLCBuZCwgMCwgY3BkaXN0LCBjcGRleHQsIHRkLCBiZCwgaHAsIGhuLCB2KTtcXG5cXG5cXHRcXHRcXHRpZiAocmVzdWx0ICE9IFpfT0sgfHwgKGJkWzBdID09PSAwICYmIG5sID4gMjU3KSkge1xcblxcdFxcdFxcdFxcdGlmIChyZXN1bHQgPT0gWl9EQVRBX0VSUk9SKSB7XFxuXFx0XFx0XFx0XFx0XFx0ei5tc2cgPSBcXFwib3ZlcnN1YnNjcmliZWQgZGlzdGFuY2UgdHJlZVxcXCI7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmIChyZXN1bHQgPT0gWl9CVUZfRVJST1IpIHtcXG5cXHRcXHRcXHRcXHRcXHR6Lm1zZyA9IFxcXCJpbmNvbXBsZXRlIGRpc3RhbmNlIHRyZWVcXFwiO1xcblxcdFxcdFxcdFxcdFxcdHJlc3VsdCA9IFpfREFUQV9FUlJPUjtcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKHJlc3VsdCAhPSBaX01FTV9FUlJPUikge1xcblxcdFxcdFxcdFxcdFxcdHoubXNnID0gXFxcImVtcHR5IGRpc3RhbmNlIHRyZWUgd2l0aCBsZW5ndGhzXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRyZXN1bHQgPSBaX0RBVEFfRVJST1I7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiByZXN1bHQ7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBaX09LO1xcblxcdFxcdH07XFxuXFxuXFx0fVxcblxcblxcdEluZlRyZWUuaW5mbGF0ZV90cmVlc19maXhlZCA9IGZ1bmN0aW9uKGJsLCAvLyBsaXRlcmFsIGRlc2lyZWQvYWN0dWFsIGJpdCBkZXB0aFxcblxcdGJkLCAvLyBkaXN0YW5jZSBkZXNpcmVkL2FjdHVhbCBiaXQgZGVwdGhcXG5cXHR0bCwvLyBsaXRlcmFsL2xlbmd0aCB0cmVlIHJlc3VsdFxcblxcdHRkLy8gZGlzdGFuY2UgdHJlZSByZXN1bHRcXG5cXHQpIHtcXG5cXHRcXHRibFswXSA9IGZpeGVkX2JsO1xcblxcdFxcdGJkWzBdID0gZml4ZWRfYmQ7XFxuXFx0XFx0dGxbMF0gPSBmaXhlZF90bDtcXG5cXHRcXHR0ZFswXSA9IGZpeGVkX3RkO1xcblxcdFxcdHJldHVybiBaX09LO1xcblxcdH07XFxuXFxuXFx0Ly8gSW5mQ29kZXNcXG5cXG5cXHQvLyB3YWl0aW5nIGZvciBcXFwiaTpcXFwiPWlucHV0LFxcblxcdC8vIFxcXCJvOlxcXCI9b3V0cHV0LFxcblxcdC8vIFxcXCJ4OlxcXCI9bm90aGluZ1xcblxcdHZhciBTVEFSVCA9IDA7IC8vIHg6IHNldCB1cCBmb3IgTEVOXFxuXFx0dmFyIExFTiA9IDE7IC8vIGk6IGdldCBsZW5ndGgvbGl0ZXJhbC9lb2IgbmV4dFxcblxcdHZhciBMRU5FWFQgPSAyOyAvLyBpOiBnZXR0aW5nIGxlbmd0aCBleHRyYSAoaGF2ZSBiYXNlKVxcblxcdHZhciBESVNUID0gMzsgLy8gaTogZ2V0IGRpc3RhbmNlIG5leHRcXG5cXHR2YXIgRElTVEVYVCA9IDQ7Ly8gaTogZ2V0dGluZyBkaXN0YW5jZSBleHRyYVxcblxcdHZhciBDT1BZID0gNTsgLy8gbzogY29weWluZyBieXRlcyBpbiB3aW5kb3csIHdhaXRpbmdcXG5cXHQvLyBmb3Igc3BhY2VcXG5cXHR2YXIgTElUID0gNjsgLy8gbzogZ290IGxpdGVyYWwsIHdhaXRpbmcgZm9yIG91dHB1dFxcblxcdC8vIHNwYWNlXFxuXFx0dmFyIFdBU0ggPSA3OyAvLyBvOiBnb3QgZW9iLCBwb3NzaWJseSBzdGlsbCBvdXRwdXRcXG5cXHQvLyB3YWl0aW5nXFxuXFx0dmFyIEVORCA9IDg7IC8vIHg6IGdvdCBlb2IgYW5kIGFsbCBkYXRhIGZsdXNoZWRcXG5cXHR2YXIgQkFEQ09ERSA9IDk7Ly8geDogZ290IGVycm9yXFxuXFxuXFx0ZnVuY3Rpb24gSW5mQ29kZXMoKSB7XFxuXFx0XFx0dmFyIHRoYXQgPSB0aGlzO1xcblxcblxcdFxcdHZhciBtb2RlOyAvLyBjdXJyZW50IGluZmxhdGVfY29kZXMgbW9kZVxcblxcblxcdFxcdC8vIG1vZGUgZGVwZW5kZW50IGluZm9ybWF0aW9uXFxuXFx0XFx0dmFyIGxlbiA9IDA7XFxuXFxuXFx0XFx0dmFyIHRyZWU7IC8vIHBvaW50ZXIgaW50byB0cmVlXFxuXFx0XFx0dmFyIHRyZWVfaW5kZXggPSAwO1xcblxcdFxcdHZhciBuZWVkID0gMDsgLy8gYml0cyBuZWVkZWRcXG5cXG5cXHRcXHR2YXIgbGl0ID0gMDtcXG5cXG5cXHRcXHQvLyBpZiBFWFQgb3IgQ09QWSwgd2hlcmUgYW5kIGhvdyBtdWNoXFxuXFx0XFx0dmFyIGdldCA9IDA7IC8vIGJpdHMgdG8gZ2V0IGZvciBleHRyYVxcblxcdFxcdHZhciBkaXN0ID0gMDsgLy8gZGlzdGFuY2UgYmFjayB0byBjb3B5IGZyb21cXG5cXG5cXHRcXHR2YXIgbGJpdHMgPSAwOyAvLyBsdHJlZSBiaXRzIGRlY29kZWQgcGVyIGJyYW5jaFxcblxcdFxcdHZhciBkYml0cyA9IDA7IC8vIGR0cmVlIGJpdHMgZGVjb2RlciBwZXIgYnJhbmNoXFxuXFx0XFx0dmFyIGx0cmVlOyAvLyBsaXRlcmFsL2xlbmd0aC9lb2IgdHJlZVxcblxcdFxcdHZhciBsdHJlZV9pbmRleCA9IDA7IC8vIGxpdGVyYWwvbGVuZ3RoL2VvYiB0cmVlXFxuXFx0XFx0dmFyIGR0cmVlOyAvLyBkaXN0YW5jZSB0cmVlXFxuXFx0XFx0dmFyIGR0cmVlX2luZGV4ID0gMDsgLy8gZGlzdGFuY2UgdHJlZVxcblxcblxcdFxcdC8vIENhbGxlZCB3aXRoIG51bWJlciBvZiBieXRlcyBsZWZ0IHRvIHdyaXRlIGluIHdpbmRvdyBhdCBsZWFzdCAyNThcXG5cXHRcXHQvLyAodGhlIG1heGltdW0gc3RyaW5nIGxlbmd0aCkgYW5kIG51bWJlciBvZiBpbnB1dCBieXRlcyBhdmFpbGFibGVcXG5cXHRcXHQvLyBhdCBsZWFzdCB0ZW4uIFRoZSB0ZW4gYnl0ZXMgYXJlIHNpeCBieXRlcyBmb3IgdGhlIGxvbmdlc3QgbGVuZ3RoL1xcblxcdFxcdC8vIGRpc3RhbmNlIHBhaXIgcGx1cyBmb3VyIGJ5dGVzIGZvciBvdmVybG9hZGluZyB0aGUgYml0IGJ1ZmZlci5cXG5cXG5cXHRcXHRmdW5jdGlvbiBpbmZsYXRlX2Zhc3QoYmwsIGJkLCB0bCwgdGxfaW5kZXgsIHRkLCB0ZF9pbmRleCwgcywgeikge1xcblxcdFxcdFxcdHZhciB0OyAvLyB0ZW1wb3JhcnkgcG9pbnRlclxcblxcdFxcdFxcdHZhciB0cDsgLy8gdGVtcG9yYXJ5IHBvaW50ZXJcXG5cXHRcXHRcXHR2YXIgdHBfaW5kZXg7IC8vIHRlbXBvcmFyeSBwb2ludGVyXFxuXFx0XFx0XFx0dmFyIGU7IC8vIGV4dHJhIGJpdHMgb3Igb3BlcmF0aW9uXFxuXFx0XFx0XFx0dmFyIGI7IC8vIGJpdCBidWZmZXJcXG5cXHRcXHRcXHR2YXIgazsgLy8gYml0cyBpbiBiaXQgYnVmZmVyXFxuXFx0XFx0XFx0dmFyIHA7IC8vIGlucHV0IGRhdGEgcG9pbnRlclxcblxcdFxcdFxcdHZhciBuOyAvLyBieXRlcyBhdmFpbGFibGUgdGhlcmVcXG5cXHRcXHRcXHR2YXIgcTsgLy8gb3V0cHV0IHdpbmRvdyB3cml0ZSBwb2ludGVyXFxuXFx0XFx0XFx0dmFyIG07IC8vIGJ5dGVzIHRvIGVuZCBvZiB3aW5kb3cgb3IgcmVhZCBwb2ludGVyXFxuXFx0XFx0XFx0dmFyIG1sOyAvLyBtYXNrIGZvciBsaXRlcmFsL2xlbmd0aCB0cmVlXFxuXFx0XFx0XFx0dmFyIG1kOyAvLyBtYXNrIGZvciBkaXN0YW5jZSB0cmVlXFxuXFx0XFx0XFx0dmFyIGM7IC8vIGJ5dGVzIHRvIGNvcHlcXG5cXHRcXHRcXHR2YXIgZDsgLy8gZGlzdGFuY2UgYmFjayB0byBjb3B5IGZyb21cXG5cXHRcXHRcXHR2YXIgcjsgLy8gY29weSBzb3VyY2UgcG9pbnRlclxcblxcblxcdFxcdFxcdHZhciB0cF9pbmRleF90XzM7IC8vICh0cF9pbmRleCt0KSozXFxuXFxuXFx0XFx0XFx0Ly8gbG9hZCBpbnB1dCwgb3V0cHV0LCBiaXQgdmFsdWVzXFxuXFx0XFx0XFx0cCA9IHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHRuID0gei5hdmFpbF9pbjtcXG5cXHRcXHRcXHRiID0gcy5iaXRiO1xcblxcdFxcdFxcdGsgPSBzLmJpdGs7XFxuXFx0XFx0XFx0cSA9IHMud3JpdGU7XFxuXFx0XFx0XFx0bSA9IHEgPCBzLnJlYWQgPyBzLnJlYWQgLSBxIC0gMSA6IHMuZW5kIC0gcTtcXG5cXG5cXHRcXHRcXHQvLyBpbml0aWFsaXplIG1hc2tzXFxuXFx0XFx0XFx0bWwgPSBpbmZsYXRlX21hc2tbYmxdO1xcblxcdFxcdFxcdG1kID0gaW5mbGF0ZV9tYXNrW2JkXTtcXG5cXG5cXHRcXHRcXHQvLyBkbyB1bnRpbCBub3QgZW5vdWdoIGlucHV0IG9yIG91dHB1dCBzcGFjZSBmb3IgZmFzdCBsb29wXFxuXFx0XFx0XFx0ZG8geyAvLyBhc3N1bWUgY2FsbGVkIHdpdGggbSA+PSAyNTggJiYgbiA+PSAxMFxcblxcdFxcdFxcdFxcdC8vIGdldCBsaXRlcmFsL2xlbmd0aCBjb2RlXFxuXFx0XFx0XFx0XFx0d2hpbGUgKGsgPCAoMjApKSB7IC8vIG1heCBiaXRzIGZvciBsaXRlcmFsL2xlbmd0aCBjb2RlXFxuXFx0XFx0XFx0XFx0XFx0bi0tO1xcblxcdFxcdFxcdFxcdFxcdGIgfD0gKHoucmVhZF9ieXRlKHArKykgJiAweGZmKSA8PCBrO1xcblxcdFxcdFxcdFxcdFxcdGsgKz0gODtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dCA9IGIgJiBtbDtcXG5cXHRcXHRcXHRcXHR0cCA9IHRsO1xcblxcdFxcdFxcdFxcdHRwX2luZGV4ID0gdGxfaW5kZXg7XFxuXFx0XFx0XFx0XFx0dHBfaW5kZXhfdF8zID0gKHRwX2luZGV4ICsgdCkgKiAzO1xcblxcdFxcdFxcdFxcdGlmICgoZSA9IHRwW3RwX2luZGV4X3RfM10pID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0YiA+Pj0gKHRwW3RwX2luZGV4X3RfMyArIDFdKTtcXG5cXHRcXHRcXHRcXHRcXHRrIC09ICh0cFt0cF9pbmRleF90XzMgKyAxXSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cy53aW5kb3dbcSsrXSA9IC8qIChieXRlKSAqL3RwW3RwX2luZGV4X3RfMyArIDJdO1xcblxcdFxcdFxcdFxcdFxcdG0tLTtcXG5cXHRcXHRcXHRcXHRcXHRjb250aW51ZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0ZG8ge1xcblxcblxcdFxcdFxcdFxcdFxcdGIgPj49ICh0cFt0cF9pbmRleF90XzMgKyAxXSk7XFxuXFx0XFx0XFx0XFx0XFx0ayAtPSAodHBbdHBfaW5kZXhfdF8zICsgMV0pO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICgoZSAmIDE2KSAhPT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGUgJj0gMTU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YyA9IHRwW3RwX2luZGV4X3RfMyArIDJdICsgKC8qIChpbnQpICovYiAmIGluZmxhdGVfbWFza1tlXSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YiA+Pj0gZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRrIC09IGU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gZGVjb2RlIGRpc3RhbmNlIGJhc2Ugb2YgYmxvY2sgdG8gY29weVxcblxcdFxcdFxcdFxcdFxcdFxcdHdoaWxlIChrIDwgKDE1KSkgeyAvLyBtYXggYml0cyBmb3IgZGlzdGFuY2UgY29kZVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG4tLTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRiIHw9ICh6LnJlYWRfYnl0ZShwKyspICYgMHhmZikgPDwgaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRrICs9IDg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdHQgPSBiICYgbWQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dHAgPSB0ZDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0cF9pbmRleCA9IHRkX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdFxcdHRwX2luZGV4X3RfMyA9ICh0cF9pbmRleCArIHQpICogMztcXG5cXHRcXHRcXHRcXHRcXHRcXHRlID0gdHBbdHBfaW5kZXhfdF8zXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRkbyB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YiA+Pj0gKHRwW3RwX2luZGV4X3RfMyArIDFdKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRrIC09ICh0cFt0cF9pbmRleF90XzMgKyAxXSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKChlICYgMTYpICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gZ2V0IGV4dHJhIGJpdHMgdG8gYWRkIHRvIGRpc3RhbmNlIGJhc2VcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRlICY9IDE1O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHdoaWxlIChrIDwgKGUpKSB7IC8vIGdldCBleHRyYSBiaXRzICh1cCB0byAxMylcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRuLS07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YiB8PSAoei5yZWFkX2J5dGUocCsrKSAmIDB4ZmYpIDw8IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ayArPSA4O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkID0gdHBbdHBfaW5kZXhfdF8zICsgMl0gKyAoYiAmIGluZmxhdGVfbWFza1tlXSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YiA+Pj0gKGUpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGsgLT0gKGUpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGRvIHRoZSBjb3B5XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bSAtPSBjO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChxID49IGQpIHsgLy8gb2Zmc2V0IGJlZm9yZSBkZXN0XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8ganVzdCBjb3B5XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ciA9IHEgLSBkO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChxIC0gciA+IDAgJiYgMiA+IChxIC0gcikpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzLndpbmRvd1txKytdID0gcy53aW5kb3dbcisrXTsgLy8gbWluaW11bVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGNvdW50IGlzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gdGhyZWUsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cy53aW5kb3dbcSsrXSA9IHMud2luZG93W3IrK107IC8vIHNvIHVucm9sbFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGxvb3AgYVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGxpdHRsZVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGMgLT0gMjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHMud2luZG93LnNldChzLndpbmRvdy5zdWJhcnJheShyLCByICsgMiksIHEpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHEgKz0gMjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyICs9IDI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YyAtPSAyO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2UgeyAvLyBlbHNlIG9mZnNldCBhZnRlciBkZXN0aW5hdGlvblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHIgPSBxIC0gZDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ciArPSBzLmVuZDsgLy8gZm9yY2UgcG9pbnRlciBpbiB3aW5kb3dcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9IHdoaWxlIChyIDwgMCk7IC8vIGNvdmVycyBpbnZhbGlkIGRpc3RhbmNlc1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGUgPSBzLmVuZCAtIHI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGMgPiBlKSB7IC8vIGlmIHNvdXJjZSBjcm9zc2VzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGMgLT0gZTsgLy8gd3JhcHBlZCBjb3B5XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHEgLSByID4gMCAmJiBlID4gKHEgLSByKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRvIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzLndpbmRvd1txKytdID0gcy53aW5kb3dbcisrXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9IHdoaWxlICgtLWUgIT09IDApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cy53aW5kb3cuc2V0KHMud2luZG93LnN1YmFycmF5KHIsIHIgKyBlKSwgcSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cSArPSBlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHIgKz0gZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRlID0gMDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ciA9IDA7IC8vIGNvcHkgcmVzdCBmcm9tIHN0YXJ0IG9mIHdpbmRvd1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gY29weSBhbGwgb3Igd2hhdCdzIGxlZnRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAocSAtIHIgPiAwICYmIGMgPiAocSAtIHIpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZG8ge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHMud2luZG93W3ErK10gPSBzLndpbmRvd1tyKytdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gd2hpbGUgKC0tYyAhPT0gMCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzLndpbmRvdy5zZXQocy53aW5kb3cuc3ViYXJyYXkociwgciArIGMpLCBxKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRxICs9IGM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ciArPSBjO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGMgPSAwO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKChlICYgNjQpID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dCArPSB0cFt0cF9pbmRleF90XzMgKyAyXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0ICs9IChiICYgaW5mbGF0ZV9tYXNrW2VdKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0cF9pbmRleF90XzMgPSAodHBfaW5kZXggKyB0KSAqIDM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZSA9IHRwW3RwX2luZGV4X3RfM107XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR6Lm1zZyA9IFxcXCJpbnZhbGlkIGRpc3RhbmNlIGNvZGVcXFwiO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGMgPSB6LmF2YWlsX2luIC0gbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjID0gKGsgPj4gMykgPCBjID8gayA+PiAzIDogYztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRuICs9IGM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cCAtPSBjO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGsgLT0gYyA8PCAzO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHMuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cy5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzLndyaXRlID0gcTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gWl9EQVRBX0VSUk9SO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9IHdoaWxlICh0cnVlKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKChlICYgNjQpID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dCArPSB0cFt0cF9pbmRleF90XzMgKyAyXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0ICs9IChiICYgaW5mbGF0ZV9tYXNrW2VdKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0cF9pbmRleF90XzMgPSAodHBfaW5kZXggKyB0KSAqIDM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKChlID0gdHBbdHBfaW5kZXhfdF8zXSkgPT09IDApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRiID4+PSAodHBbdHBfaW5kZXhfdF8zICsgMV0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGsgLT0gKHRwW3RwX2luZGV4X3RfMyArIDFdKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzLndpbmRvd1txKytdID0gLyogKGJ5dGUpICovdHBbdHBfaW5kZXhfdF8zICsgMl07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bS0tO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKChlICYgMzIpICE9PSAwKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YyA9IHouYXZhaWxfaW4gLSBuO1xcblxcdFxcdFxcdFxcdFxcdFxcdGMgPSAoayA+PiAzKSA8IGMgPyBrID4+IDMgOiBjO1xcblxcdFxcdFxcdFxcdFxcdFxcdG4gKz0gYztcXG5cXHRcXHRcXHRcXHRcXHRcXHRwIC09IGM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ayAtPSBjIDw8IDM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0cy5iaXRiID0gYjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzLmJpdGsgPSBrO1xcblxcdFxcdFxcdFxcdFxcdFxcdHouYXZhaWxfaW4gPSBuO1xcblxcdFxcdFxcdFxcdFxcdFxcdHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6Lm5leHRfaW5faW5kZXggPSBwO1xcblxcdFxcdFxcdFxcdFxcdFxcdHMud3JpdGUgPSBxO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBaX1NUUkVBTV9FTkQ7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6Lm1zZyA9IFxcXCJpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGVcXFwiO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGMgPSB6LmF2YWlsX2luIC0gbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjID0gKGsgPj4gMykgPCBjID8gayA+PiAzIDogYztcXG5cXHRcXHRcXHRcXHRcXHRcXHRuICs9IGM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cCAtPSBjO1xcblxcdFxcdFxcdFxcdFxcdFxcdGsgLT0gYyA8PCAzO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHMuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cy5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzLndyaXRlID0gcTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gWl9EQVRBX0VSUk9SO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9IHdoaWxlICh0cnVlKTtcXG5cXHRcXHRcXHR9IHdoaWxlIChtID49IDI1OCAmJiBuID49IDEwKTtcXG5cXG5cXHRcXHRcXHQvLyBub3QgZW5vdWdoIGlucHV0IG9yIG91dHB1dC0tcmVzdG9yZSBwb2ludGVycyBhbmQgcmV0dXJuXFxuXFx0XFx0XFx0YyA9IHouYXZhaWxfaW4gLSBuO1xcblxcdFxcdFxcdGMgPSAoayA+PiAzKSA8IGMgPyBrID4+IDMgOiBjO1xcblxcdFxcdFxcdG4gKz0gYztcXG5cXHRcXHRcXHRwIC09IGM7XFxuXFx0XFx0XFx0ayAtPSBjIDw8IDM7XFxuXFxuXFx0XFx0XFx0cy5iaXRiID0gYjtcXG5cXHRcXHRcXHRzLmJpdGsgPSBrO1xcblxcdFxcdFxcdHouYXZhaWxfaW4gPSBuO1xcblxcdFxcdFxcdHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHR6Lm5leHRfaW5faW5kZXggPSBwO1xcblxcdFxcdFxcdHMud3JpdGUgPSBxO1xcblxcblxcdFxcdFxcdHJldHVybiBaX09LO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGF0LmluaXQgPSBmdW5jdGlvbihibCwgYmQsIHRsLCB0bF9pbmRleCwgdGQsIHRkX2luZGV4KSB7XFxuXFx0XFx0XFx0bW9kZSA9IFNUQVJUO1xcblxcdFxcdFxcdGxiaXRzID0gLyogKGJ5dGUpICovYmw7XFxuXFx0XFx0XFx0ZGJpdHMgPSAvKiAoYnl0ZSkgKi9iZDtcXG5cXHRcXHRcXHRsdHJlZSA9IHRsO1xcblxcdFxcdFxcdGx0cmVlX2luZGV4ID0gdGxfaW5kZXg7XFxuXFx0XFx0XFx0ZHRyZWUgPSB0ZDtcXG5cXHRcXHRcXHRkdHJlZV9pbmRleCA9IHRkX2luZGV4O1xcblxcdFxcdFxcdHRyZWUgPSBudWxsO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhhdC5wcm9jID0gZnVuY3Rpb24ocywgeiwgcikge1xcblxcdFxcdFxcdHZhciBqOyAvLyB0ZW1wb3Jhcnkgc3RvcmFnZVxcblxcdFxcdFxcdHZhciB0aW5kZXg7IC8vIHRlbXBvcmFyeSBwb2ludGVyXFxuXFx0XFx0XFx0dmFyIGU7IC8vIGV4dHJhIGJpdHMgb3Igb3BlcmF0aW9uXFxuXFx0XFx0XFx0dmFyIGIgPSAwOyAvLyBiaXQgYnVmZmVyXFxuXFx0XFx0XFx0dmFyIGsgPSAwOyAvLyBiaXRzIGluIGJpdCBidWZmZXJcXG5cXHRcXHRcXHR2YXIgcCA9IDA7IC8vIGlucHV0IGRhdGEgcG9pbnRlclxcblxcdFxcdFxcdHZhciBuOyAvLyBieXRlcyBhdmFpbGFibGUgdGhlcmVcXG5cXHRcXHRcXHR2YXIgcTsgLy8gb3V0cHV0IHdpbmRvdyB3cml0ZSBwb2ludGVyXFxuXFx0XFx0XFx0dmFyIG07IC8vIGJ5dGVzIHRvIGVuZCBvZiB3aW5kb3cgb3IgcmVhZCBwb2ludGVyXFxuXFx0XFx0XFx0dmFyIGY7IC8vIHBvaW50ZXIgdG8gY29weSBzdHJpbmdzIGZyb21cXG5cXG5cXHRcXHRcXHQvLyBjb3B5IGlucHV0L291dHB1dCBpbmZvcm1hdGlvbiB0byBsb2NhbHMgKFVQREFURSBtYWNybyByZXN0b3JlcylcXG5cXHRcXHRcXHRwID0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdG4gPSB6LmF2YWlsX2luO1xcblxcdFxcdFxcdGIgPSBzLmJpdGI7XFxuXFx0XFx0XFx0ayA9IHMuYml0aztcXG5cXHRcXHRcXHRxID0gcy53cml0ZTtcXG5cXHRcXHRcXHRtID0gcSA8IHMucmVhZCA/IHMucmVhZCAtIHEgLSAxIDogcy5lbmQgLSBxO1xcblxcblxcdFxcdFxcdC8vIHByb2Nlc3MgaW5wdXQgYW5kIG91dHB1dCBiYXNlZCBvbiBjdXJyZW50IHN0YXRlXFxuXFx0XFx0XFx0d2hpbGUgKHRydWUpIHtcXG5cXHRcXHRcXHRcXHRzd2l0Y2ggKG1vZGUpIHtcXG5cXHRcXHRcXHRcXHQvLyB3YWl0aW5nIGZvciBcXFwiaTpcXFwiPWlucHV0LCBcXFwibzpcXFwiPW91dHB1dCwgXFxcIng6XFxcIj1ub3RoaW5nXFxuXFx0XFx0XFx0XFx0Y2FzZSBTVEFSVDogLy8geDogc2V0IHVwIGZvciBMRU5cXG5cXHRcXHRcXHRcXHRcXHRpZiAobSA+PSAyNTggJiYgbiA+PSAxMCkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHMuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cy5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzLndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyID0gaW5mbGF0ZV9mYXN0KGxiaXRzLCBkYml0cywgbHRyZWUsIGx0cmVlX2luZGV4LCBkdHJlZSwgZHRyZWVfaW5kZXgsIHMsIHopO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHAgPSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0biA9IHouYXZhaWxfaW47XFxuXFx0XFx0XFx0XFx0XFx0XFx0YiA9IHMuYml0YjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRrID0gcy5iaXRrO1xcblxcdFxcdFxcdFxcdFxcdFxcdHEgPSBzLndyaXRlO1xcblxcdFxcdFxcdFxcdFxcdFxcdG0gPSBxIDwgcy5yZWFkID8gcy5yZWFkIC0gcSAtIDEgOiBzLmVuZCAtIHE7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHIgIT0gWl9PSykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG1vZGUgPSByID09IFpfU1RSRUFNX0VORCA/IFdBU0ggOiBCQURDT0RFO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0bmVlZCA9IGxiaXRzO1xcblxcdFxcdFxcdFxcdFxcdHRyZWUgPSBsdHJlZTtcXG5cXHRcXHRcXHRcXHRcXHR0cmVlX2luZGV4ID0gbHRyZWVfaW5kZXg7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bW9kZSA9IExFTjtcXG5cXHRcXHRcXHRcXHRcXHQvKiBmYWxscyB0aHJvdWdoICovXFxuXFx0XFx0XFx0XFx0Y2FzZSBMRU46IC8vIGk6IGdldCBsZW5ndGgvbGl0ZXJhbC9lb2IgbmV4dFxcblxcdFxcdFxcdFxcdFxcdGogPSBuZWVkO1xcblxcblxcdFxcdFxcdFxcdFxcdHdoaWxlIChrIDwgKGopKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKG4gIT09IDApXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ciA9IFpfT0s7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cy5iaXRiID0gYjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzLmJpdGsgPSBrO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHouYXZhaWxfaW4gPSBuO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR6Lm5leHRfaW5faW5kZXggPSBwO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHMud3JpdGUgPSBxO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBzLmluZmxhdGVfZmx1c2goeiwgcik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdG4tLTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRiIHw9ICh6LnJlYWRfYnl0ZShwKyspICYgMHhmZikgPDwgaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRrICs9IDg7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHRpbmRleCA9ICh0cmVlX2luZGV4ICsgKGIgJiBpbmZsYXRlX21hc2tbal0pKSAqIDM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0YiA+Pj49ICh0cmVlW3RpbmRleCArIDFdKTtcXG5cXHRcXHRcXHRcXHRcXHRrIC09ICh0cmVlW3RpbmRleCArIDFdKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRlID0gdHJlZVt0aW5kZXhdO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmIChlID09PSAwKSB7IC8vIGxpdGVyYWxcXG5cXHRcXHRcXHRcXHRcXHRcXHRsaXQgPSB0cmVlW3RpbmRleCArIDJdO1xcblxcdFxcdFxcdFxcdFxcdFxcdG1vZGUgPSBMSVQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICgoZSAmIDE2KSAhPT0gMCkgeyAvLyBsZW5ndGhcXG5cXHRcXHRcXHRcXHRcXHRcXHRnZXQgPSBlICYgMTU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bGVuID0gdHJlZVt0aW5kZXggKyAyXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtb2RlID0gTEVORVhUO1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoKGUgJiA2NCkgPT09IDApIHsgLy8gbmV4dCB0YWJsZVxcblxcdFxcdFxcdFxcdFxcdFxcdG5lZWQgPSBlO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRyZWVfaW5kZXggPSB0aW5kZXggLyAzICsgdHJlZVt0aW5kZXggKyAyXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKChlICYgMzIpICE9PSAwKSB7IC8vIGVuZCBvZiBibG9ja1xcblxcdFxcdFxcdFxcdFxcdFxcdG1vZGUgPSBXQVNIO1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRtb2RlID0gQkFEQ09ERTsgLy8gaW52YWxpZCBjb2RlXFxuXFx0XFx0XFx0XFx0XFx0ei5tc2cgPSBcXFwiaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRyID0gWl9EQVRBX0VSUk9SO1xcblxcblxcdFxcdFxcdFxcdFxcdHMuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0cy5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRzLndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcblxcdFxcdFxcdFxcdGNhc2UgTEVORVhUOiAvLyBpOiBnZXR0aW5nIGxlbmd0aCBleHRyYSAoaGF2ZSBiYXNlKVxcblxcdFxcdFxcdFxcdFxcdGogPSBnZXQ7XFxuXFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKGsgPCAoaikpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAobiAhPT0gMClcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyID0gWl9PSztcXG5cXHRcXHRcXHRcXHRcXHRcXHRlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzLmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHMuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cy53cml0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0bi0tO1xcblxcdFxcdFxcdFxcdFxcdFxcdGIgfD0gKHoucmVhZF9ieXRlKHArKykgJiAweGZmKSA8PCBrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGsgKz0gODtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0bGVuICs9IChiICYgaW5mbGF0ZV9tYXNrW2pdKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRiID4+PSBqO1xcblxcdFxcdFxcdFxcdFxcdGsgLT0gajtcXG5cXG5cXHRcXHRcXHRcXHRcXHRuZWVkID0gZGJpdHM7XFxuXFx0XFx0XFx0XFx0XFx0dHJlZSA9IGR0cmVlO1xcblxcdFxcdFxcdFxcdFxcdHRyZWVfaW5kZXggPSBkdHJlZV9pbmRleDtcXG5cXHRcXHRcXHRcXHRcXHRtb2RlID0gRElTVDtcXG5cXHRcXHRcXHRcXHRcXHQvKiBmYWxscyB0aHJvdWdoICovXFxuXFx0XFx0XFx0XFx0Y2FzZSBESVNUOiAvLyBpOiBnZXQgZGlzdGFuY2UgbmV4dFxcblxcdFxcdFxcdFxcdFxcdGogPSBuZWVkO1xcblxcblxcdFxcdFxcdFxcdFxcdHdoaWxlIChrIDwgKGopKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKG4gIT09IDApXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ciA9IFpfT0s7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cy5iaXRiID0gYjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzLmJpdGsgPSBrO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHouYXZhaWxfaW4gPSBuO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR6Lm5leHRfaW5faW5kZXggPSBwO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHMud3JpdGUgPSBxO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBzLmluZmxhdGVfZmx1c2goeiwgcik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdG4tLTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRiIHw9ICh6LnJlYWRfYnl0ZShwKyspICYgMHhmZikgPDwgaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRrICs9IDg7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHRpbmRleCA9ICh0cmVlX2luZGV4ICsgKGIgJiBpbmZsYXRlX21hc2tbal0pKSAqIDM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0YiA+Pj0gdHJlZVt0aW5kZXggKyAxXTtcXG5cXHRcXHRcXHRcXHRcXHRrIC09IHRyZWVbdGluZGV4ICsgMV07XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZSA9ICh0cmVlW3RpbmRleF0pO1xcblxcdFxcdFxcdFxcdFxcdGlmICgoZSAmIDE2KSAhPT0gMCkgeyAvLyBkaXN0YW5jZVxcblxcdFxcdFxcdFxcdFxcdFxcdGdldCA9IGUgJiAxNTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRkaXN0ID0gdHJlZVt0aW5kZXggKyAyXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtb2RlID0gRElTVEVYVDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKChlICYgNjQpID09PSAwKSB7IC8vIG5leHQgdGFibGVcXG5cXHRcXHRcXHRcXHRcXHRcXHRuZWVkID0gZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0cmVlX2luZGV4ID0gdGluZGV4IC8gMyArIHRyZWVbdGluZGV4ICsgMl07XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdG1vZGUgPSBCQURDT0RFOyAvLyBpbnZhbGlkIGNvZGVcXG5cXHRcXHRcXHRcXHRcXHR6Lm1zZyA9IFxcXCJpbnZhbGlkIGRpc3RhbmNlIGNvZGVcXFwiO1xcblxcdFxcdFxcdFxcdFxcdHIgPSBaX0RBVEFfRVJST1I7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cy5iaXRiID0gYjtcXG5cXHRcXHRcXHRcXHRcXHRzLmJpdGsgPSBrO1xcblxcdFxcdFxcdFxcdFxcdHouYXZhaWxfaW4gPSBuO1xcblxcdFxcdFxcdFxcdFxcdHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHRcXHRcXHR6Lm5leHRfaW5faW5kZXggPSBwO1xcblxcdFxcdFxcdFxcdFxcdHMud3JpdGUgPSBxO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBzLmluZmxhdGVfZmx1c2goeiwgcik7XFxuXFxuXFx0XFx0XFx0XFx0Y2FzZSBESVNURVhUOiAvLyBpOiBnZXR0aW5nIGRpc3RhbmNlIGV4dHJhXFxuXFx0XFx0XFx0XFx0XFx0aiA9IGdldDtcXG5cXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoayA8IChqKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChuICE9PSAwKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHIgPSBaX09LO1xcblxcdFxcdFxcdFxcdFxcdFxcdGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHMuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cy5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzLndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRuLS07XFxuXFx0XFx0XFx0XFx0XFx0XFx0YiB8PSAoei5yZWFkX2J5dGUocCsrKSAmIDB4ZmYpIDw8IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ayArPSA4O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRkaXN0ICs9IChiICYgaW5mbGF0ZV9tYXNrW2pdKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRiID4+PSBqO1xcblxcdFxcdFxcdFxcdFxcdGsgLT0gajtcXG5cXG5cXHRcXHRcXHRcXHRcXHRtb2RlID0gQ09QWTtcXG5cXHRcXHRcXHRcXHRcXHQvKiBmYWxscyB0aHJvdWdoICovXFxuXFx0XFx0XFx0XFx0Y2FzZSBDT1BZOiAvLyBvOiBjb3B5aW5nIGJ5dGVzIGluIHdpbmRvdywgd2FpdGluZyBmb3Igc3BhY2VcXG5cXHRcXHRcXHRcXHRcXHRmID0gcSAtIGRpc3Q7XFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKGYgPCAwKSB7IC8vIG1vZHVsbyB3aW5kb3cgc2l6ZS1cXFwid2hpbGVcXFwiIGluc3RlYWRcXG5cXHRcXHRcXHRcXHRcXHRcXHRmICs9IHMuZW5kOyAvLyBvZiBcXFwiaWZcXFwiIGhhbmRsZXMgaW52YWxpZCBkaXN0YW5jZXNcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKGxlbiAhPT0gMCkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChtID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHEgPT0gcy5lbmQgJiYgcy5yZWFkICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cSA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bSA9IHEgPCBzLnJlYWQgPyBzLnJlYWQgLSBxIC0gMSA6IHMuZW5kIC0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKG0gPT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzLndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyID0gcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHEgPSBzLndyaXRlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG0gPSBxIDwgcy5yZWFkID8gcy5yZWFkIC0gcSAtIDEgOiBzLmVuZCAtIHE7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHEgPT0gcy5lbmQgJiYgcy5yZWFkICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cSA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bSA9IHEgPCBzLnJlYWQgPyBzLnJlYWQgLSBxIC0gMSA6IHMuZW5kIC0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKG0gPT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzLmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHMuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cy53cml0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRzLndpbmRvd1txKytdID0gcy53aW5kb3dbZisrXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtLS07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKGYgPT0gcy5lbmQpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZiA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bGVuLS07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdG1vZGUgPSBTVEFSVDtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRjYXNlIExJVDogLy8gbzogZ290IGxpdGVyYWwsIHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZVxcblxcdFxcdFxcdFxcdFxcdGlmIChtID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHEgPT0gcy5lbmQgJiYgcy5yZWFkICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cSA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bSA9IHEgPCBzLnJlYWQgPyBzLnJlYWQgLSBxIC0gMSA6IHMuZW5kIC0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKG0gPT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzLndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyID0gcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHEgPSBzLndyaXRlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG0gPSBxIDwgcy5yZWFkID8gcy5yZWFkIC0gcSAtIDEgOiBzLmVuZCAtIHE7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHEgPT0gcy5lbmQgJiYgcy5yZWFkICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cSA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bSA9IHEgPCBzLnJlYWQgPyBzLnJlYWQgLSBxIC0gMSA6IHMuZW5kIC0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKG0gPT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzLmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHMuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cy53cml0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRyID0gWl9PSztcXG5cXG5cXHRcXHRcXHRcXHRcXHRzLndpbmRvd1txKytdID0gLyogKGJ5dGUpICovbGl0O1xcblxcdFxcdFxcdFxcdFxcdG0tLTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRtb2RlID0gU1RBUlQ7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0Y2FzZSBXQVNIOiAvLyBvOiBnb3QgZW9iLCBwb3NzaWJseSBtb3JlIG91dHB1dFxcblxcdFxcdFxcdFxcdFxcdGlmIChrID4gNykgeyAvLyByZXR1cm4gdW51c2VkIGJ5dGUsIGlmIGFueVxcblxcdFxcdFxcdFxcdFxcdFxcdGsgLT0gODtcXG5cXHRcXHRcXHRcXHRcXHRcXHRuKys7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cC0tOyAvLyBjYW4gYWx3YXlzIHJldHVybiBvbmVcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0cy53cml0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0ciA9IHMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXHRcXHRcXHRcXHRcXHRxID0gcy53cml0ZTtcXG5cXHRcXHRcXHRcXHRcXHRtID0gcSA8IHMucmVhZCA/IHMucmVhZCAtIHEgLSAxIDogcy5lbmQgLSBxO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmIChzLnJlYWQgIT0gcy53cml0ZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHMuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cy5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzLndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRtb2RlID0gRU5EO1xcblxcdFxcdFxcdFxcdFxcdC8qIGZhbGxzIHRocm91Z2ggKi9cXG5cXHRcXHRcXHRcXHRjYXNlIEVORDpcXG5cXHRcXHRcXHRcXHRcXHRyID0gWl9TVFJFQU1fRU5EO1xcblxcdFxcdFxcdFxcdFxcdHMuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0cy5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRzLndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcblxcdFxcdFxcdFxcdGNhc2UgQkFEQ09ERTogLy8geDogZ290IGVycm9yXFxuXFxuXFx0XFx0XFx0XFx0XFx0ciA9IFpfREFUQV9FUlJPUjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRzLmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdHMuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0cy53cml0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXG5cXHRcXHRcXHRcXHRkZWZhdWx0OlxcblxcdFxcdFxcdFxcdFxcdHIgPSBaX1NUUkVBTV9FUlJPUjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRzLmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdHMuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0cy53cml0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhhdC5mcmVlID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0Ly8gWkZSRUUoeiwgYyk7XFxuXFx0XFx0fTtcXG5cXG5cXHR9XFxuXFxuXFx0Ly8gSW5mQmxvY2tzXFxuXFxuXFx0Ly8gVGFibGUgZm9yIGRlZmxhdGUgZnJvbSBQS1pJUCdzIGFwcG5vdGUudHh0LlxcblxcdHZhciBib3JkZXIgPSBbIC8vIE9yZGVyIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGUgbGVuZ3Roc1xcblxcdDE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTUgXTtcXG5cXG5cXHR2YXIgVFlQRSA9IDA7IC8vIGdldCB0eXBlIGJpdHMgKDMsIGluY2x1ZGluZyBlbmQgYml0KVxcblxcdHZhciBMRU5TID0gMTsgLy8gZ2V0IGxlbmd0aHMgZm9yIHN0b3JlZFxcblxcdHZhciBTVE9SRUQgPSAyOy8vIHByb2Nlc3Npbmcgc3RvcmVkIGJsb2NrXFxuXFx0dmFyIFRBQkxFID0gMzsgLy8gZ2V0IHRhYmxlIGxlbmd0aHNcXG5cXHR2YXIgQlRSRUUgPSA0OyAvLyBnZXQgYml0IGxlbmd0aHMgdHJlZSBmb3IgYSBkeW5hbWljXFxuXFx0Ly8gYmxvY2tcXG5cXHR2YXIgRFRSRUUgPSA1OyAvLyBnZXQgbGVuZ3RoLCBkaXN0YW5jZSB0cmVlcyBmb3IgYVxcblxcdC8vIGR5bmFtaWMgYmxvY2tcXG5cXHR2YXIgQ09ERVMgPSA2OyAvLyBwcm9jZXNzaW5nIGZpeGVkIG9yIGR5bmFtaWMgYmxvY2tcXG5cXHR2YXIgRFJZID0gNzsgLy8gb3V0cHV0IHJlbWFpbmluZyB3aW5kb3cgYnl0ZXNcXG5cXHR2YXIgRE9ORUxPQ0tTID0gODsgLy8gZmluaXNoZWQgbGFzdCBibG9jaywgZG9uZVxcblxcdHZhciBCQURCTE9DS1MgPSA5OyAvLyBvdCBhIGRhdGEgZXJyb3ItLXN0dWNrIGhlcmVcXG5cXG5cXHRmdW5jdGlvbiBJbmZCbG9ja3Moeiwgdykge1xcblxcdFxcdHZhciB0aGF0ID0gdGhpcztcXG5cXG5cXHRcXHR2YXIgbW9kZSA9IFRZUEU7IC8vIGN1cnJlbnQgaW5mbGF0ZV9ibG9jayBtb2RlXFxuXFxuXFx0XFx0dmFyIGxlZnQgPSAwOyAvLyBpZiBTVE9SRUQsIGJ5dGVzIGxlZnQgdG8gY29weVxcblxcblxcdFxcdHZhciB0YWJsZSA9IDA7IC8vIHRhYmxlIGxlbmd0aHMgKDE0IGJpdHMpXFxuXFx0XFx0dmFyIGluZGV4ID0gMDsgLy8gaW5kZXggaW50byBibGVucyAob3IgYm9yZGVyKVxcblxcdFxcdHZhciBibGVuczsgLy8gYml0IGxlbmd0aHMgb2YgY29kZXNcXG5cXHRcXHR2YXIgYmIgPSBbIDAgXTsgLy8gYml0IGxlbmd0aCB0cmVlIGRlcHRoXFxuXFx0XFx0dmFyIHRiID0gWyAwIF07IC8vIGJpdCBsZW5ndGggZGVjb2RpbmcgdHJlZVxcblxcblxcdFxcdHZhciBjb2RlcyA9IG5ldyBJbmZDb2RlcygpOyAvLyBpZiBDT0RFUywgY3VycmVudCBzdGF0ZVxcblxcblxcdFxcdHZhciBsYXN0ID0gMDsgLy8gdHJ1ZSBpZiB0aGlzIGJsb2NrIGlzIHRoZSBsYXN0IGJsb2NrXFxuXFxuXFx0XFx0dmFyIGh1ZnRzID0gbmV3IEludDMyQXJyYXkoTUFOWSAqIDMpOyAvLyBzaW5nbGUgbWFsbG9jIGZvciB0cmVlIHNwYWNlXFxuXFx0XFx0dmFyIGNoZWNrID0gMDsgLy8gY2hlY2sgb24gb3V0cHV0XFxuXFx0XFx0dmFyIGluZnRyZWUgPSBuZXcgSW5mVHJlZSgpO1xcblxcblxcdFxcdHRoYXQuYml0ayA9IDA7IC8vIGJpdHMgaW4gYml0IGJ1ZmZlclxcblxcdFxcdHRoYXQuYml0YiA9IDA7IC8vIGJpdCBidWZmZXJcXG5cXHRcXHR0aGF0LndpbmRvdyA9IG5ldyBVaW50OEFycmF5KHcpOyAvLyBzbGlkaW5nIHdpbmRvd1xcblxcdFxcdHRoYXQuZW5kID0gdzsgLy8gb25lIGJ5dGUgYWZ0ZXIgc2xpZGluZyB3aW5kb3dcXG5cXHRcXHR0aGF0LnJlYWQgPSAwOyAvLyB3aW5kb3cgcmVhZCBwb2ludGVyXFxuXFx0XFx0dGhhdC53cml0ZSA9IDA7IC8vIHdpbmRvdyB3cml0ZSBwb2ludGVyXFxuXFxuXFx0XFx0dGhhdC5yZXNldCA9IGZ1bmN0aW9uKHosIGMpIHtcXG5cXHRcXHRcXHRpZiAoYylcXG5cXHRcXHRcXHRcXHRjWzBdID0gY2hlY2s7XFxuXFx0XFx0XFx0Ly8gaWYgKG1vZGUgPT0gQlRSRUUgfHwgbW9kZSA9PSBEVFJFRSkge1xcblxcdFxcdFxcdC8vIH1cXG5cXHRcXHRcXHRpZiAobW9kZSA9PSBDT0RFUykge1xcblxcdFxcdFxcdFxcdGNvZGVzLmZyZWUoeik7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdG1vZGUgPSBUWVBFO1xcblxcdFxcdFxcdHRoYXQuYml0ayA9IDA7XFxuXFx0XFx0XFx0dGhhdC5iaXRiID0gMDtcXG5cXHRcXHRcXHR0aGF0LnJlYWQgPSB0aGF0LndyaXRlID0gMDtcXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoYXQucmVzZXQoeiwgbnVsbCk7XFxuXFxuXFx0XFx0Ly8gY29weSBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIHNsaWRpbmcgd2luZG93IHRvIHRoZSBvdXRwdXQgYXJlYVxcblxcdFxcdHRoYXQuaW5mbGF0ZV9mbHVzaCA9IGZ1bmN0aW9uKHosIHIpIHtcXG5cXHRcXHRcXHR2YXIgbjtcXG5cXHRcXHRcXHR2YXIgcDtcXG5cXHRcXHRcXHR2YXIgcTtcXG5cXG5cXHRcXHRcXHQvLyBsb2NhbCBjb3BpZXMgb2Ygc291cmNlIGFuZCBkZXN0aW5hdGlvbiBwb2ludGVyc1xcblxcdFxcdFxcdHAgPSB6Lm5leHRfb3V0X2luZGV4O1xcblxcdFxcdFxcdHEgPSB0aGF0LnJlYWQ7XFxuXFxuXFx0XFx0XFx0Ly8gY29tcHV0ZSBudW1iZXIgb2YgYnl0ZXMgdG8gY29weSBhcyBmYXIgYXMgZW5kIG9mIHdpbmRvd1xcblxcdFxcdFxcdG4gPSAvKiAoaW50KSAqLygocSA8PSB0aGF0LndyaXRlID8gdGhhdC53cml0ZSA6IHRoYXQuZW5kKSAtIHEpO1xcblxcdFxcdFxcdGlmIChuID4gei5hdmFpbF9vdXQpXFxuXFx0XFx0XFx0XFx0biA9IHouYXZhaWxfb3V0O1xcblxcdFxcdFxcdGlmIChuICE9PSAwICYmIHIgPT0gWl9CVUZfRVJST1IpXFxuXFx0XFx0XFx0XFx0ciA9IFpfT0s7XFxuXFxuXFx0XFx0XFx0Ly8gdXBkYXRlIGNvdW50ZXJzXFxuXFx0XFx0XFx0ei5hdmFpbF9vdXQgLT0gbjtcXG5cXHRcXHRcXHR6LnRvdGFsX291dCArPSBuO1xcblxcblxcdFxcdFxcdC8vIGNvcHkgYXMgZmFyIGFzIGVuZCBvZiB3aW5kb3dcXG5cXHRcXHRcXHR6Lm5leHRfb3V0LnNldCh0aGF0LndpbmRvdy5zdWJhcnJheShxLCBxICsgbiksIHApO1xcblxcdFxcdFxcdHAgKz0gbjtcXG5cXHRcXHRcXHRxICs9IG47XFxuXFxuXFx0XFx0XFx0Ly8gc2VlIGlmIG1vcmUgdG8gY29weSBhdCBiZWdpbm5pbmcgb2Ygd2luZG93XFxuXFx0XFx0XFx0aWYgKHEgPT0gdGhhdC5lbmQpIHtcXG5cXHRcXHRcXHRcXHQvLyB3cmFwIHBvaW50ZXJzXFxuXFx0XFx0XFx0XFx0cSA9IDA7XFxuXFx0XFx0XFx0XFx0aWYgKHRoYXQud3JpdGUgPT0gdGhhdC5lbmQpXFxuXFx0XFx0XFx0XFx0XFx0dGhhdC53cml0ZSA9IDA7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gY29tcHV0ZSBieXRlcyB0byBjb3B5XFxuXFx0XFx0XFx0XFx0biA9IHRoYXQud3JpdGUgLSBxO1xcblxcdFxcdFxcdFxcdGlmIChuID4gei5hdmFpbF9vdXQpXFxuXFx0XFx0XFx0XFx0XFx0biA9IHouYXZhaWxfb3V0O1xcblxcdFxcdFxcdFxcdGlmIChuICE9PSAwICYmIHIgPT0gWl9CVUZfRVJST1IpXFxuXFx0XFx0XFx0XFx0XFx0ciA9IFpfT0s7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gdXBkYXRlIGNvdW50ZXJzXFxuXFx0XFx0XFx0XFx0ei5hdmFpbF9vdXQgLT0gbjtcXG5cXHRcXHRcXHRcXHR6LnRvdGFsX291dCArPSBuO1xcblxcblxcdFxcdFxcdFxcdC8vIGNvcHlcXG5cXHRcXHRcXHRcXHR6Lm5leHRfb3V0LnNldCh0aGF0LndpbmRvdy5zdWJhcnJheShxLCBxICsgbiksIHApO1xcblxcdFxcdFxcdFxcdHAgKz0gbjtcXG5cXHRcXHRcXHRcXHRxICs9IG47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIHVwZGF0ZSBwb2ludGVyc1xcblxcdFxcdFxcdHoubmV4dF9vdXRfaW5kZXggPSBwO1xcblxcdFxcdFxcdHRoYXQucmVhZCA9IHE7XFxuXFxuXFx0XFx0XFx0Ly8gZG9uZVxcblxcdFxcdFxcdHJldHVybiByO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhhdC5wcm9jID0gZnVuY3Rpb24oeiwgcikge1xcblxcdFxcdFxcdHZhciB0OyAvLyB0ZW1wb3Jhcnkgc3RvcmFnZVxcblxcdFxcdFxcdHZhciBiOyAvLyBiaXQgYnVmZmVyXFxuXFx0XFx0XFx0dmFyIGs7IC8vIGJpdHMgaW4gYml0IGJ1ZmZlclxcblxcdFxcdFxcdHZhciBwOyAvLyBpbnB1dCBkYXRhIHBvaW50ZXJcXG5cXHRcXHRcXHR2YXIgbjsgLy8gYnl0ZXMgYXZhaWxhYmxlIHRoZXJlXFxuXFx0XFx0XFx0dmFyIHE7IC8vIG91dHB1dCB3aW5kb3cgd3JpdGUgcG9pbnRlclxcblxcdFxcdFxcdHZhciBtOyAvLyBieXRlcyB0byBlbmQgb2Ygd2luZG93IG9yIHJlYWQgcG9pbnRlclxcblxcblxcdFxcdFxcdHZhciBpO1xcblxcblxcdFxcdFxcdC8vIGNvcHkgaW5wdXQvb3V0cHV0IGluZm9ybWF0aW9uIHRvIGxvY2FscyAoVVBEQVRFIG1hY3JvIHJlc3RvcmVzKVxcblxcdFxcdFxcdC8vIHtcXG5cXHRcXHRcXHRwID0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdG4gPSB6LmF2YWlsX2luO1xcblxcdFxcdFxcdGIgPSB0aGF0LmJpdGI7XFxuXFx0XFx0XFx0ayA9IHRoYXQuYml0aztcXG5cXHRcXHRcXHQvLyB9XFxuXFx0XFx0XFx0Ly8ge1xcblxcdFxcdFxcdHEgPSB0aGF0LndyaXRlO1xcblxcdFxcdFxcdG0gPSAvKiAoaW50KSAqLyhxIDwgdGhhdC5yZWFkID8gdGhhdC5yZWFkIC0gcSAtIDEgOiB0aGF0LmVuZCAtIHEpO1xcblxcdFxcdFxcdC8vIH1cXG5cXG5cXHRcXHRcXHQvLyBwcm9jZXNzIGlucHV0IGJhc2VkIG9uIGN1cnJlbnQgc3RhdGVcXG5cXHRcXHRcXHQvLyBERUJVRyBkdHJlZVxcblxcdFxcdFxcdHdoaWxlICh0cnVlKSB7XFxuXFx0XFx0XFx0XFx0c3dpdGNoIChtb2RlKSB7XFxuXFx0XFx0XFx0XFx0Y2FzZSBUWVBFOlxcblxcblxcdFxcdFxcdFxcdFxcdHdoaWxlIChrIDwgKDMpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKG4gIT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyID0gWl9PSztcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGF0LndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhhdC5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRuLS07XFxuXFx0XFx0XFx0XFx0XFx0XFx0YiB8PSAoei5yZWFkX2J5dGUocCsrKSAmIDB4ZmYpIDw8IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ayArPSA4O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR0ID0gLyogKGludCkgKi8oYiAmIDcpO1xcblxcdFxcdFxcdFxcdFxcdGxhc3QgPSB0ICYgMTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRzd2l0Y2ggKHQgPj4+IDEpIHtcXG5cXHRcXHRcXHRcXHRcXHRjYXNlIDA6IC8vIHN0b3JlZFxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRiID4+Pj0gKDMpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGsgLT0gKDMpO1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR0ID0gayAmIDc7IC8vIGdvIHRvIGJ5dGUgYm91bmRhcnlcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YiA+Pj49ICh0KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRrIC09ICh0KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyB9XFxuXFx0XFx0XFx0XFx0XFx0XFx0bW9kZSA9IExFTlM7IC8vIGdldCBsZW5ndGggb2Ygc3RvcmVkIGJsb2NrXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAxOiAvLyBmaXhlZFxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgYmwgPSBbXTsgLy8gbmV3IEFycmF5KDEpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBiZCA9IFtdOyAvLyBuZXcgQXJyYXkoMSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHRsID0gWyBbXSBdOyAvLyBuZXcgQXJyYXkoMSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHRkID0gWyBbXSBdOyAvLyBuZXcgQXJyYXkoMSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0SW5mVHJlZS5pbmZsYXRlX3RyZWVzX2ZpeGVkKGJsLCBiZCwgdGwsIHRkKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjb2Rlcy5pbml0KGJsWzBdLCBiZFswXSwgdGxbMF0sIDAsIHRkWzBdLCAwKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyB9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8ge1xcblxcdFxcdFxcdFxcdFxcdFxcdGIgPj4+PSAoMyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ayAtPSAoMyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gfVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdG1vZGUgPSBDT0RFUztcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRjYXNlIDI6IC8vIGR5bmFtaWNcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YiA+Pj49ICgzKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRrIC09ICgzKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyB9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0bW9kZSA9IFRBQkxFO1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdGNhc2UgMzogLy8gaWxsZWdhbFxcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRiID4+Pj0gKDMpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGsgLT0gKDMpO1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRtb2RlID0gQkFEQkxPQ0tTO1xcblxcdFxcdFxcdFxcdFxcdFxcdHoubXNnID0gXFxcImludmFsaWQgYmxvY2sgdHlwZVxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ciA9IFpfREFUQV9FUlJPUjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhhdC53cml0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0Y2FzZSBMRU5TOlxcblxcblxcdFxcdFxcdFxcdFxcdHdoaWxlIChrIDwgKDMyKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChuICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ciA9IFpfT0s7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhhdC53cml0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0bi0tO1xcblxcdFxcdFxcdFxcdFxcdFxcdGIgfD0gKHoucmVhZF9ieXRlKHArKykgJiAweGZmKSA8PCBrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGsgKz0gODtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCgoKH5iKSA+Pj4gMTYpICYgMHhmZmZmKSAhPSAoYiAmIDB4ZmZmZikpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtb2RlID0gQkFEQkxPQ0tTO1xcblxcdFxcdFxcdFxcdFxcdFxcdHoubXNnID0gXFxcImludmFsaWQgc3RvcmVkIGJsb2NrIGxlbmd0aHNcXFwiO1xcblxcdFxcdFxcdFxcdFxcdFxcdHIgPSBaX0RBVEFfRVJST1I7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5iaXRiID0gYjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGsgPSBrO1xcblxcdFxcdFxcdFxcdFxcdFxcdHouYXZhaWxfaW4gPSBuO1xcblxcdFxcdFxcdFxcdFxcdFxcdHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6Lm5leHRfaW5faW5kZXggPSBwO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoYXQud3JpdGUgPSBxO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGxlZnQgPSAoYiAmIDB4ZmZmZik7XFxuXFx0XFx0XFx0XFx0XFx0YiA9IGsgPSAwOyAvLyBkdW1wIGJpdHNcXG5cXHRcXHRcXHRcXHRcXHRtb2RlID0gbGVmdCAhPT0gMCA/IFNUT1JFRCA6IChsYXN0ICE9PSAwID8gRFJZIDogVFlQRSk7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0Y2FzZSBTVE9SRUQ6XFxuXFx0XFx0XFx0XFx0XFx0aWYgKG4gPT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhhdC53cml0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKG0gPT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAocSA9PSB0aGF0LmVuZCAmJiB0aGF0LnJlYWQgIT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRxID0gMDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRtID0gLyogKGludCkgKi8ocSA8IHRoYXQucmVhZCA/IHRoYXQucmVhZCAtIHEgLSAxIDogdGhhdC5lbmQgLSBxKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKG0gPT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGF0LndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyID0gdGhhdC5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHEgPSB0aGF0LndyaXRlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG0gPSAvKiAoaW50KSAqLyhxIDwgdGhhdC5yZWFkID8gdGhhdC5yZWFkIC0gcSAtIDEgOiB0aGF0LmVuZCAtIHEpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChxID09IHRoYXQuZW5kICYmIHRoYXQucmVhZCAhPT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHEgPSAwO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG0gPSAvKiAoaW50KSAqLyhxIDwgdGhhdC5yZWFkID8gdGhhdC5yZWFkIC0gcSAtIDEgOiB0aGF0LmVuZCAtIHEpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAobSA9PT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGF0LndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhhdC5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHIgPSBaX09LO1xcblxcblxcdFxcdFxcdFxcdFxcdHQgPSBsZWZ0O1xcblxcdFxcdFxcdFxcdFxcdGlmICh0ID4gbilcXG5cXHRcXHRcXHRcXHRcXHRcXHR0ID0gbjtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodCA+IG0pXFxuXFx0XFx0XFx0XFx0XFx0XFx0dCA9IG07XFxuXFx0XFx0XFx0XFx0XFx0dGhhdC53aW5kb3cuc2V0KHoucmVhZF9idWYocCwgdCksIHEpO1xcblxcdFxcdFxcdFxcdFxcdHAgKz0gdDtcXG5cXHRcXHRcXHRcXHRcXHRuIC09IHQ7XFxuXFx0XFx0XFx0XFx0XFx0cSArPSB0O1xcblxcdFxcdFxcdFxcdFxcdG0gLT0gdDtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoKGxlZnQgLT0gdCkgIT09IDApXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0bW9kZSA9IGxhc3QgIT09IDAgPyBEUlkgOiBUWVBFO1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdGNhc2UgVEFCTEU6XFxuXFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKGsgPCAoMTQpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKG4gIT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyID0gWl9PSztcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGF0LndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhhdC5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRuLS07XFxuXFx0XFx0XFx0XFx0XFx0XFx0YiB8PSAoei5yZWFkX2J5dGUocCsrKSAmIDB4ZmYpIDw8IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ayArPSA4O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR0YWJsZSA9IHQgPSAoYiAmIDB4M2ZmZik7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCh0ICYgMHgxZikgPiAyOSB8fCAoKHQgPj4gNSkgJiAweDFmKSA+IDI5KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bW9kZSA9IEJBREJMT0NLUztcXG5cXHRcXHRcXHRcXHRcXHRcXHR6Lm1zZyA9IFxcXCJ0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9sc1xcXCI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ciA9IFpfREFUQV9FUlJPUjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhhdC53cml0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0dCA9IDI1OCArICh0ICYgMHgxZikgKyAoKHQgPj4gNSkgJiAweDFmKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIWJsZW5zIHx8IGJsZW5zLmxlbmd0aCA8IHQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRibGVucyA9IFtdOyAvLyBuZXcgQXJyYXkodCk7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKGkgPSAwOyBpIDwgdDsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YmxlbnNbaV0gPSAwO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8ge1xcblxcdFxcdFxcdFxcdFxcdGIgPj4+PSAoMTQpO1xcblxcdFxcdFxcdFxcdFxcdGsgLT0gKDE0KTtcXG5cXHRcXHRcXHRcXHRcXHQvLyB9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aW5kZXggPSAwO1xcblxcdFxcdFxcdFxcdFxcdG1vZGUgPSBCVFJFRTtcXG5cXHRcXHRcXHRcXHRcXHQvKiBmYWxscyB0aHJvdWdoICovXFxuXFx0XFx0XFx0XFx0Y2FzZSBCVFJFRTpcXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoaW5kZXggPCA0ICsgKHRhYmxlID4+PiAxMCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR3aGlsZSAoayA8ICgzKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChuICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ciA9IFpfT0s7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhhdC53cml0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bi0tO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGIgfD0gKHoucmVhZF9ieXRlKHArKykgJiAweGZmKSA8PCBrO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGsgKz0gODtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YmxlbnNbYm9yZGVyW2luZGV4KytdXSA9IGIgJiA3O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRiID4+Pj0gKDMpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGsgLT0gKDMpO1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKGluZGV4IDwgMTkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRibGVuc1tib3JkZXJbaW5kZXgrK11dID0gMDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0YmJbMF0gPSA3O1xcblxcdFxcdFxcdFxcdFxcdHQgPSBpbmZ0cmVlLmluZmxhdGVfdHJlZXNfYml0cyhibGVucywgYmIsIHRiLCBodWZ0cywgeik7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHQgIT0gWl9PSykge1xcblxcdFxcdFxcdFxcdFxcdFxcdHIgPSB0O1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChyID09IFpfREFUQV9FUlJPUikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJsZW5zID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRtb2RlID0gQkFEQkxPQ0tTO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhhdC53cml0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aW5kZXggPSAwO1xcblxcdFxcdFxcdFxcdFxcdG1vZGUgPSBEVFJFRTtcXG5cXHRcXHRcXHRcXHRcXHQvKiBmYWxscyB0aHJvdWdoICovXFxuXFx0XFx0XFx0XFx0Y2FzZSBEVFJFRTpcXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAodHJ1ZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHQgPSB0YWJsZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoaW5kZXggPj0gMjU4ICsgKHQgJiAweDFmKSArICgodCA+PiA1KSAmIDB4MWYpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBqLCBjO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHQgPSBiYlswXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR3aGlsZSAoayA8ICh0KSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChuICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ciA9IFpfT0s7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhhdC53cml0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bi0tO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGIgfD0gKHoucmVhZF9ieXRlKHArKykgJiAweGZmKSA8PCBrO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGsgKz0gODtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gaWYgKHRiWzBdID09IC0xKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gU3lzdGVtLmVyci5wcmludGxuKFxcXCJudWxsLi4uXFxcIik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gfVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdHQgPSBodWZ0c1sodGJbMF0gKyAoYiAmIGluZmxhdGVfbWFza1t0XSkpICogMyArIDFdO1xcblxcdFxcdFxcdFxcdFxcdFxcdGMgPSBodWZ0c1sodGJbMF0gKyAoYiAmIGluZmxhdGVfbWFza1t0XSkpICogMyArIDJdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChjIDwgMTYpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRiID4+Pj0gKHQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGsgLT0gKHQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJsZW5zW2luZGV4KytdID0gYztcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2UgeyAvLyBjID09IDE2Li4xOFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGkgPSBjID09IDE4ID8gNyA6IGMgLSAxNDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRqID0gYyA9PSAxOCA/IDExIDogMztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR3aGlsZSAoayA8ICh0ICsgaSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAobiAhPT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHIgPSBaX09LO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5iaXRiID0gYjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGsgPSBrO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHouYXZhaWxfaW4gPSBuO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR6Lm5leHRfaW5faW5kZXggPSBwO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoYXQud3JpdGUgPSBxO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG4tLTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRiIHw9ICh6LnJlYWRfYnl0ZShwKyspICYgMHhmZikgPDwgaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRrICs9IDg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGIgPj4+PSAodCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ayAtPSAodCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aiArPSAoYiAmIGluZmxhdGVfbWFza1tpXSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YiA+Pj49IChpKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRrIC09IChpKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpID0gaW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dCA9IHRhYmxlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChpICsgaiA+IDI1OCArICh0ICYgMHgxZikgKyAoKHQgPj4gNSkgJiAweDFmKSB8fCAoYyA9PSAxNiAmJiBpIDwgMSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRibGVucyA9IG51bGw7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bW9kZSA9IEJBREJMT0NLUztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR6Lm1zZyA9IFxcXCJpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0XFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyID0gWl9EQVRBX0VSUk9SO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGF0LndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhhdC5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjID0gYyA9PSAxNiA/IGJsZW5zW2kgLSAxXSA6IDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZG8ge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJsZW5zW2krK10gPSBjO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gd2hpbGUgKC0taiAhPT0gMCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aW5kZXggPSBpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGJbMF0gPSAtMTtcXG5cXHRcXHRcXHRcXHRcXHQvLyB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGJsXyA9IFtdOyAvLyBuZXcgQXJyYXkoMSk7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGJkXyA9IFtdOyAvLyBuZXcgQXJyYXkoMSk7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHRsXyA9IFtdOyAvLyBuZXcgQXJyYXkoMSk7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHRkXyA9IFtdOyAvLyBuZXcgQXJyYXkoMSk7XFxuXFx0XFx0XFx0XFx0XFx0YmxfWzBdID0gOTsgLy8gbXVzdCBiZSA8PSA5IGZvciBsb29rYWhlYWQgYXNzdW1wdGlvbnNcXG5cXHRcXHRcXHRcXHRcXHRiZF9bMF0gPSA2OyAvLyBtdXN0IGJlIDw9IDkgZm9yIGxvb2thaGVhZCBhc3N1bXB0aW9uc1xcblxcblxcdFxcdFxcdFxcdFxcdHQgPSB0YWJsZTtcXG5cXHRcXHRcXHRcXHRcXHR0ID0gaW5mdHJlZS5pbmZsYXRlX3RyZWVzX2R5bmFtaWMoMjU3ICsgKHQgJiAweDFmKSwgMSArICgodCA+PiA1KSAmIDB4MWYpLCBibGVucywgYmxfLCBiZF8sIHRsXywgdGRfLCBodWZ0cywgeik7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHQgIT0gWl9PSykge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICh0ID09IFpfREFUQV9FUlJPUikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJsZW5zID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRtb2RlID0gQkFEQkxPQ0tTO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRyID0gdDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhhdC53cml0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0Y29kZXMuaW5pdChibF9bMF0sIGJkX1swXSwgaHVmdHMsIHRsX1swXSwgaHVmdHMsIHRkX1swXSk7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gfVxcblxcdFxcdFxcdFxcdFxcdG1vZGUgPSBDT0RFUztcXG5cXHRcXHRcXHRcXHRcXHQvKiBmYWxscyB0aHJvdWdoICovXFxuXFx0XFx0XFx0XFx0Y2FzZSBDT0RFUzpcXG5cXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdHRoYXQuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0dGhhdC53cml0ZSA9IHE7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKChyID0gY29kZXMucHJvYyh0aGF0LCB6LCByKSkgIT0gWl9TVFJFQU1fRU5EKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0ciA9IFpfT0s7XFxuXFx0XFx0XFx0XFx0XFx0Y29kZXMuZnJlZSh6KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRwID0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdG4gPSB6LmF2YWlsX2luO1xcblxcdFxcdFxcdFxcdFxcdGIgPSB0aGF0LmJpdGI7XFxuXFx0XFx0XFx0XFx0XFx0ayA9IHRoYXQuYml0aztcXG5cXHRcXHRcXHRcXHRcXHRxID0gdGhhdC53cml0ZTtcXG5cXHRcXHRcXHRcXHRcXHRtID0gLyogKGludCkgKi8ocSA8IHRoYXQucmVhZCA/IHRoYXQucmVhZCAtIHEgLSAxIDogdGhhdC5lbmQgLSBxKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAobGFzdCA9PT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdG1vZGUgPSBUWVBFO1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRtb2RlID0gRFJZO1xcblxcdFxcdFxcdFxcdFxcdC8qIGZhbGxzIHRocm91Z2ggKi9cXG5cXHRcXHRcXHRcXHRjYXNlIERSWTpcXG5cXHRcXHRcXHRcXHRcXHR0aGF0LndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRyID0gdGhhdC5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdFxcdHEgPSB0aGF0LndyaXRlO1xcblxcdFxcdFxcdFxcdFxcdG0gPSAvKiAoaW50KSAqLyhxIDwgdGhhdC5yZWFkID8gdGhhdC5yZWFkIC0gcSAtIDEgOiB0aGF0LmVuZCAtIHEpO1xcblxcdFxcdFxcdFxcdFxcdGlmICh0aGF0LnJlYWQgIT0gdGhhdC53cml0ZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGF0LndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhhdC5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRtb2RlID0gRE9ORUxPQ0tTO1xcblxcdFxcdFxcdFxcdFxcdC8qIGZhbGxzIHRocm91Z2ggKi9cXG5cXHRcXHRcXHRcXHRjYXNlIERPTkVMT0NLUzpcXG5cXHRcXHRcXHRcXHRcXHRyID0gWl9TVFJFQU1fRU5EO1xcblxcblxcdFxcdFxcdFxcdFxcdHRoYXQuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0dGhhdC5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHR0aGF0LndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhhdC5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdGNhc2UgQkFEQkxPQ0tTOlxcblxcdFxcdFxcdFxcdFxcdHIgPSBaX0RBVEFfRVJST1I7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhhdC5iaXRiID0gYjtcXG5cXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGsgPSBrO1xcblxcdFxcdFxcdFxcdFxcdHouYXZhaWxfaW4gPSBuO1xcblxcdFxcdFxcdFxcdFxcdHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHRcXHRcXHR6Lm5leHRfaW5faW5kZXggPSBwO1xcblxcdFxcdFxcdFxcdFxcdHRoYXQud3JpdGUgPSBxO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxuXFxuXFx0XFx0XFx0XFx0ZGVmYXVsdDpcXG5cXHRcXHRcXHRcXHRcXHRyID0gWl9TVFJFQU1fRVJST1I7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhhdC5iaXRiID0gYjtcXG5cXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGsgPSBrO1xcblxcdFxcdFxcdFxcdFxcdHouYXZhaWxfaW4gPSBuO1xcblxcdFxcdFxcdFxcdFxcdHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHRcXHRcXHR6Lm5leHRfaW5faW5kZXggPSBwO1xcblxcdFxcdFxcdFxcdFxcdHRoYXQud3JpdGUgPSBxO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoYXQuZnJlZSA9IGZ1bmN0aW9uKHopIHtcXG5cXHRcXHRcXHR0aGF0LnJlc2V0KHosIG51bGwpO1xcblxcdFxcdFxcdHRoYXQud2luZG93ID0gbnVsbDtcXG5cXHRcXHRcXHRodWZ0cyA9IG51bGw7XFxuXFx0XFx0XFx0Ly8gWkZSRUUoeiwgcyk7XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGF0LnNldF9kaWN0aW9uYXJ5ID0gZnVuY3Rpb24oZCwgc3RhcnQsIG4pIHtcXG5cXHRcXHRcXHR0aGF0LndpbmRvdy5zZXQoZC5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBuKSwgMCk7XFxuXFx0XFx0XFx0dGhhdC5yZWFkID0gdGhhdC53cml0ZSA9IG47XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBSZXR1cm5zIHRydWUgaWYgaW5mbGF0ZSBpcyBjdXJyZW50bHkgYXQgdGhlIGVuZCBvZiBhIGJsb2NrIGdlbmVyYXRlZFxcblxcdFxcdC8vIGJ5IFpfU1lOQ19GTFVTSCBvciBaX0ZVTExfRkxVU0guXFxuXFx0XFx0dGhhdC5zeW5jX3BvaW50ID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0cmV0dXJuIG1vZGUgPT0gTEVOUyA/IDEgOiAwO1xcblxcdFxcdH07XFxuXFxuXFx0fVxcblxcblxcdC8vIEluZmxhdGVcXG5cXG5cXHQvLyBwcmVzZXQgZGljdGlvbmFyeSBmbGFnIGluIHpsaWIgaGVhZGVyXFxuXFx0dmFyIFBSRVNFVF9ESUNUID0gMHgyMDtcXG5cXG5cXHR2YXIgWl9ERUZMQVRFRCA9IDg7XFxuXFxuXFx0dmFyIE1FVEhPRCA9IDA7IC8vIHdhaXRpbmcgZm9yIG1ldGhvZCBieXRlXFxuXFx0dmFyIEZMQUcgPSAxOyAvLyB3YWl0aW5nIGZvciBmbGFnIGJ5dGVcXG5cXHR2YXIgRElDVDQgPSAyOyAvLyBmb3VyIGRpY3Rpb25hcnkgY2hlY2sgYnl0ZXMgdG8gZ29cXG5cXHR2YXIgRElDVDMgPSAzOyAvLyB0aHJlZSBkaWN0aW9uYXJ5IGNoZWNrIGJ5dGVzIHRvIGdvXFxuXFx0dmFyIERJQ1QyID0gNDsgLy8gdHdvIGRpY3Rpb25hcnkgY2hlY2sgYnl0ZXMgdG8gZ29cXG5cXHR2YXIgRElDVDEgPSA1OyAvLyBvbmUgZGljdGlvbmFyeSBjaGVjayBieXRlIHRvIGdvXFxuXFx0dmFyIERJQ1QwID0gNjsgLy8gd2FpdGluZyBmb3IgaW5mbGF0ZVNldERpY3Rpb25hcnlcXG5cXHR2YXIgQkxPQ0tTID0gNzsgLy8gZGVjb21wcmVzc2luZyBibG9ja3NcXG5cXHR2YXIgRE9ORSA9IDEyOyAvLyBmaW5pc2hlZCBjaGVjaywgZG9uZVxcblxcdHZhciBCQUQgPSAxMzsgLy8gZ290IGFuIGVycm9yLS1zdGF5IGhlcmVcXG5cXG5cXHR2YXIgbWFyayA9IFsgMCwgMCwgMHhmZiwgMHhmZiBdO1xcblxcblxcdGZ1bmN0aW9uIEluZmxhdGUoKSB7XFxuXFx0XFx0dmFyIHRoYXQgPSB0aGlzO1xcblxcblxcdFxcdHRoYXQubW9kZSA9IDA7IC8vIGN1cnJlbnQgaW5mbGF0ZSBtb2RlXFxuXFxuXFx0XFx0Ly8gbW9kZSBkZXBlbmRlbnQgaW5mb3JtYXRpb25cXG5cXHRcXHR0aGF0Lm1ldGhvZCA9IDA7IC8vIGlmIEZMQUdTLCBtZXRob2QgYnl0ZVxcblxcblxcdFxcdC8vIGlmIENIRUNLLCBjaGVjayB2YWx1ZXMgdG8gY29tcGFyZVxcblxcdFxcdHRoYXQud2FzID0gWyAwIF07IC8vIG5ldyBBcnJheSgxKTsgLy8gY29tcHV0ZWQgY2hlY2sgdmFsdWVcXG5cXHRcXHR0aGF0Lm5lZWQgPSAwOyAvLyBzdHJlYW0gY2hlY2sgdmFsdWVcXG5cXG5cXHRcXHQvLyBpZiBCQUQsIGluZmxhdGVTeW5jJ3MgbWFya2VyIGJ5dGVzIGNvdW50XFxuXFx0XFx0dGhhdC5tYXJrZXIgPSAwO1xcblxcblxcdFxcdC8vIG1vZGUgaW5kZXBlbmRlbnQgaW5mb3JtYXRpb25cXG5cXHRcXHR0aGF0LndiaXRzID0gMDsgLy8gbG9nMih3aW5kb3cgc2l6ZSkgKDguLjE1LCBkZWZhdWx0cyB0byAxNSlcXG5cXG5cXHRcXHQvLyB0aGlzLmJsb2NrczsgLy8gY3VycmVudCBpbmZsYXRlX2Jsb2NrcyBzdGF0ZVxcblxcblxcdFxcdGZ1bmN0aW9uIGluZmxhdGVSZXNldCh6KSB7XFxuXFx0XFx0XFx0aWYgKCF6IHx8ICF6LmlzdGF0ZSlcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxuXFxuXFx0XFx0XFx0ei50b3RhbF9pbiA9IHoudG90YWxfb3V0ID0gMDtcXG5cXHRcXHRcXHR6Lm1zZyA9IG51bGw7XFxuXFx0XFx0XFx0ei5pc3RhdGUubW9kZSA9IEJMT0NLUztcXG5cXHRcXHRcXHR6LmlzdGF0ZS5ibG9ja3MucmVzZXQoeiwgbnVsbCk7XFxuXFx0XFx0XFx0cmV0dXJuIFpfT0s7XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoYXQuaW5mbGF0ZUVuZCA9IGZ1bmN0aW9uKHopIHtcXG5cXHRcXHRcXHRpZiAodGhhdC5ibG9ja3MpXFxuXFx0XFx0XFx0XFx0dGhhdC5ibG9ja3MuZnJlZSh6KTtcXG5cXHRcXHRcXHR0aGF0LmJsb2NrcyA9IG51bGw7XFxuXFx0XFx0XFx0Ly8gWkZSRUUoeiwgei0+c3RhdGUpO1xcblxcdFxcdFxcdHJldHVybiBaX09LO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhhdC5pbmZsYXRlSW5pdCA9IGZ1bmN0aW9uKHosIHcpIHtcXG5cXHRcXHRcXHR6Lm1zZyA9IG51bGw7XFxuXFx0XFx0XFx0dGhhdC5ibG9ja3MgPSBudWxsO1xcblxcblxcdFxcdFxcdC8vIHNldCB3aW5kb3cgc2l6ZVxcblxcdFxcdFxcdGlmICh3IDwgOCB8fCB3ID4gMTUpIHtcXG5cXHRcXHRcXHRcXHR0aGF0LmluZmxhdGVFbmQoeik7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0aGF0LndiaXRzID0gdztcXG5cXG5cXHRcXHRcXHR6LmlzdGF0ZS5ibG9ja3MgPSBuZXcgSW5mQmxvY2tzKHosIDEgPDwgdyk7XFxuXFxuXFx0XFx0XFx0Ly8gcmVzZXQgc3RhdGVcXG5cXHRcXHRcXHRpbmZsYXRlUmVzZXQoeik7XFxuXFx0XFx0XFx0cmV0dXJuIFpfT0s7XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGF0LmluZmxhdGUgPSBmdW5jdGlvbih6LCBmKSB7XFxuXFx0XFx0XFx0dmFyIHI7XFxuXFx0XFx0XFx0dmFyIGI7XFxuXFxuXFx0XFx0XFx0aWYgKCF6IHx8ICF6LmlzdGF0ZSB8fCAhei5uZXh0X2luKVxcblxcdFxcdFxcdFxcdHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXG5cXHRcXHRcXHRmID0gZiA9PSBaX0ZJTklTSCA/IFpfQlVGX0VSUk9SIDogWl9PSztcXG5cXHRcXHRcXHRyID0gWl9CVUZfRVJST1I7XFxuXFx0XFx0XFx0d2hpbGUgKHRydWUpIHtcXG5cXHRcXHRcXHRcXHQvLyBTeXN0ZW0ub3V0LnByaW50bG4oXFxcIm1vZGU6IFxcXCIrei5pc3RhdGUubW9kZSk7XFxuXFx0XFx0XFx0XFx0c3dpdGNoICh6LmlzdGF0ZS5tb2RlKSB7XFxuXFx0XFx0XFx0XFx0Y2FzZSBNRVRIT0Q6XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHouYXZhaWxfaW4gPT09IDApXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHI7XFxuXFx0XFx0XFx0XFx0XFx0ciA9IGY7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbi0tO1xcblxcdFxcdFxcdFxcdFxcdHoudG90YWxfaW4rKztcXG5cXHRcXHRcXHRcXHRcXHRpZiAoKCh6LmlzdGF0ZS5tZXRob2QgPSB6LnJlYWRfYnl0ZSh6Lm5leHRfaW5faW5kZXgrKykpICYgMHhmKSAhPSBaX0RFRkxBVEVEKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5pc3RhdGUubW9kZSA9IEJBRDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6Lm1zZyA9IFxcXCJ1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZFxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5pc3RhdGUubWFya2VyID0gNTsgLy8gY2FuJ3QgdHJ5IGluZmxhdGVTeW5jXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICgoei5pc3RhdGUubWV0aG9kID4+IDQpICsgOCA+IHouaXN0YXRlLndiaXRzKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5pc3RhdGUubW9kZSA9IEJBRDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6Lm1zZyA9IFxcXCJpbnZhbGlkIHdpbmRvdyBzaXplXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LmlzdGF0ZS5tYXJrZXIgPSA1OyAvLyBjYW4ndCB0cnkgaW5mbGF0ZVN5bmNcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0ei5pc3RhdGUubW9kZSA9IEZMQUc7XFxuXFx0XFx0XFx0XFx0XFx0LyogZmFsbHMgdGhyb3VnaCAqL1xcblxcdFxcdFxcdFxcdGNhc2UgRkxBRzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoei5hdmFpbF9pbiA9PT0gMClcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcjtcXG5cXHRcXHRcXHRcXHRcXHRyID0gZjtcXG5cXG5cXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luLS07XFxuXFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbisrO1xcblxcdFxcdFxcdFxcdFxcdGIgPSAoei5yZWFkX2J5dGUoei5uZXh0X2luX2luZGV4KyspKSAmIDB4ZmY7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCgoKHouaXN0YXRlLm1ldGhvZCA8PCA4KSArIGIpICUgMzEpICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5pc3RhdGUubW9kZSA9IEJBRDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6Lm1zZyA9IFxcXCJpbmNvcnJlY3QgaGVhZGVyIGNoZWNrXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LmlzdGF0ZS5tYXJrZXIgPSA1OyAvLyBjYW4ndCB0cnkgaW5mbGF0ZVN5bmNcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKChiICYgUFJFU0VUX0RJQ1QpID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5pc3RhdGUubW9kZSA9IEJMT0NLUztcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0ei5pc3RhdGUubW9kZSA9IERJQ1Q0O1xcblxcdFxcdFxcdFxcdFxcdC8qIGZhbGxzIHRocm91Z2ggKi9cXG5cXHRcXHRcXHRcXHRjYXNlIERJQ1Q0OlxcblxcblxcdFxcdFxcdFxcdFxcdGlmICh6LmF2YWlsX2luID09PSAwKVxcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiByO1xcblxcdFxcdFxcdFxcdFxcdHIgPSBmO1xcblxcblxcdFxcdFxcdFxcdFxcdHouYXZhaWxfaW4tLTtcXG5cXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luKys7XFxuXFx0XFx0XFx0XFx0XFx0ei5pc3RhdGUubmVlZCA9ICgoei5yZWFkX2J5dGUoei5uZXh0X2luX2luZGV4KyspICYgMHhmZikgPDwgMjQpICYgMHhmZjAwMDAwMDtcXG5cXHRcXHRcXHRcXHRcXHR6LmlzdGF0ZS5tb2RlID0gRElDVDM7XFxuXFx0XFx0XFx0XFx0XFx0LyogZmFsbHMgdGhyb3VnaCAqL1xcblxcdFxcdFxcdFxcdGNhc2UgRElDVDM6XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHouYXZhaWxfaW4gPT09IDApXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHI7XFxuXFx0XFx0XFx0XFx0XFx0ciA9IGY7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbi0tO1xcblxcdFxcdFxcdFxcdFxcdHoudG90YWxfaW4rKztcXG5cXHRcXHRcXHRcXHRcXHR6LmlzdGF0ZS5uZWVkICs9ICgoei5yZWFkX2J5dGUoei5uZXh0X2luX2luZGV4KyspICYgMHhmZikgPDwgMTYpICYgMHhmZjAwMDA7XFxuXFx0XFx0XFx0XFx0XFx0ei5pc3RhdGUubW9kZSA9IERJQ1QyO1xcblxcdFxcdFxcdFxcdFxcdC8qIGZhbGxzIHRocm91Z2ggKi9cXG5cXHRcXHRcXHRcXHRjYXNlIERJQ1QyOlxcblxcblxcdFxcdFxcdFxcdFxcdGlmICh6LmF2YWlsX2luID09PSAwKVxcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiByO1xcblxcdFxcdFxcdFxcdFxcdHIgPSBmO1xcblxcblxcdFxcdFxcdFxcdFxcdHouYXZhaWxfaW4tLTtcXG5cXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luKys7XFxuXFx0XFx0XFx0XFx0XFx0ei5pc3RhdGUubmVlZCArPSAoKHoucmVhZF9ieXRlKHoubmV4dF9pbl9pbmRleCsrKSAmIDB4ZmYpIDw8IDgpICYgMHhmZjAwO1xcblxcdFxcdFxcdFxcdFxcdHouaXN0YXRlLm1vZGUgPSBESUNUMTtcXG5cXHRcXHRcXHRcXHRcXHQvKiBmYWxscyB0aHJvdWdoICovXFxuXFx0XFx0XFx0XFx0Y2FzZSBESUNUMTpcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoei5hdmFpbF9pbiA9PT0gMClcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcjtcXG5cXHRcXHRcXHRcXHRcXHRyID0gZjtcXG5cXG5cXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luLS07XFxuXFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbisrO1xcblxcdFxcdFxcdFxcdFxcdHouaXN0YXRlLm5lZWQgKz0gKHoucmVhZF9ieXRlKHoubmV4dF9pbl9pbmRleCsrKSAmIDB4ZmYpO1xcblxcdFxcdFxcdFxcdFxcdHouaXN0YXRlLm1vZGUgPSBESUNUMDtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gWl9ORUVEX0RJQ1Q7XFxuXFx0XFx0XFx0XFx0Y2FzZSBESUNUMDpcXG5cXHRcXHRcXHRcXHRcXHR6LmlzdGF0ZS5tb2RlID0gQkFEO1xcblxcdFxcdFxcdFxcdFxcdHoubXNnID0gXFxcIm5lZWQgZGljdGlvbmFyeVxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0ei5pc3RhdGUubWFya2VyID0gMDsgLy8gY2FuIHRyeSBpbmZsYXRlU3luY1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXG5cXHRcXHRcXHRcXHRjYXNlIEJMT0NLUzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRyID0gei5pc3RhdGUuYmxvY2tzLnByb2Moeiwgcik7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHIgPT0gWl9EQVRBX0VSUk9SKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5pc3RhdGUubW9kZSA9IEJBRDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LmlzdGF0ZS5tYXJrZXIgPSAwOyAvLyBjYW4gdHJ5IGluZmxhdGVTeW5jXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmIChyID09IFpfT0spIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyID0gZjtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHIgIT0gWl9TVFJFQU1fRU5EKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHI7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHIgPSBmO1xcblxcdFxcdFxcdFxcdFxcdHouaXN0YXRlLmJsb2Nrcy5yZXNldCh6LCB6LmlzdGF0ZS53YXMpO1xcblxcdFxcdFxcdFxcdFxcdHouaXN0YXRlLm1vZGUgPSBET05FO1xcblxcdFxcdFxcdFxcdFxcdC8qIGZhbGxzIHRocm91Z2ggKi9cXG5cXHRcXHRcXHRcXHRjYXNlIERPTkU6XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIFpfU1RSRUFNX0VORDtcXG5cXHRcXHRcXHRcXHRjYXNlIEJBRDpcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gWl9EQVRBX0VSUk9SO1xcblxcdFxcdFxcdFxcdGRlZmF1bHQ6XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGF0LmluZmxhdGVTZXREaWN0aW9uYXJ5ID0gZnVuY3Rpb24oeiwgZGljdGlvbmFyeSwgZGljdExlbmd0aCkge1xcblxcdFxcdFxcdHZhciBpbmRleCA9IDA7XFxuXFx0XFx0XFx0dmFyIGxlbmd0aCA9IGRpY3RMZW5ndGg7XFxuXFx0XFx0XFx0aWYgKCF6IHx8ICF6LmlzdGF0ZSB8fCB6LmlzdGF0ZS5tb2RlICE9IERJQ1QwKVxcblxcdFxcdFxcdFxcdHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXG5cXG5cXHRcXHRcXHRpZiAobGVuZ3RoID49ICgxIDw8IHouaXN0YXRlLndiaXRzKSkge1xcblxcdFxcdFxcdFxcdGxlbmd0aCA9ICgxIDw8IHouaXN0YXRlLndiaXRzKSAtIDE7XFxuXFx0XFx0XFx0XFx0aW5kZXggPSBkaWN0TGVuZ3RoIC0gbGVuZ3RoO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR6LmlzdGF0ZS5ibG9ja3Muc2V0X2RpY3Rpb25hcnkoZGljdGlvbmFyeSwgaW5kZXgsIGxlbmd0aCk7XFxuXFx0XFx0XFx0ei5pc3RhdGUubW9kZSA9IEJMT0NLUztcXG5cXHRcXHRcXHRyZXR1cm4gWl9PSztcXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoYXQuaW5mbGF0ZVN5bmMgPSBmdW5jdGlvbih6KSB7XFxuXFx0XFx0XFx0dmFyIG47IC8vIG51bWJlciBvZiBieXRlcyB0byBsb29rIGF0XFxuXFx0XFx0XFx0dmFyIHA7IC8vIHBvaW50ZXIgdG8gYnl0ZXNcXG5cXHRcXHRcXHR2YXIgbTsgLy8gbnVtYmVyIG9mIG1hcmtlciBieXRlcyBmb3VuZCBpbiBhIHJvd1xcblxcdFxcdFxcdHZhciByLCB3OyAvLyB0ZW1wb3JhcmllcyB0byBzYXZlIHRvdGFsX2luIGFuZCB0b3RhbF9vdXRcXG5cXG5cXHRcXHRcXHQvLyBzZXQgdXBcXG5cXHRcXHRcXHRpZiAoIXogfHwgIXouaXN0YXRlKVxcblxcdFxcdFxcdFxcdHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXG5cXHRcXHRcXHRpZiAoei5pc3RhdGUubW9kZSAhPSBCQUQpIHtcXG5cXHRcXHRcXHRcXHR6LmlzdGF0ZS5tb2RlID0gQkFEO1xcblxcdFxcdFxcdFxcdHouaXN0YXRlLm1hcmtlciA9IDA7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICgobiA9IHouYXZhaWxfaW4pID09PSAwKVxcblxcdFxcdFxcdFxcdHJldHVybiBaX0JVRl9FUlJPUjtcXG5cXHRcXHRcXHRwID0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdG0gPSB6LmlzdGF0ZS5tYXJrZXI7XFxuXFxuXFx0XFx0XFx0Ly8gc2VhcmNoXFxuXFx0XFx0XFx0d2hpbGUgKG4gIT09IDAgJiYgbSA8IDQpIHtcXG5cXHRcXHRcXHRcXHRpZiAoei5yZWFkX2J5dGUocCkgPT0gbWFya1ttXSkge1xcblxcdFxcdFxcdFxcdFxcdG0rKztcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKHoucmVhZF9ieXRlKHApICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0bSA9IDA7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRtID0gNCAtIG07XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHArKztcXG5cXHRcXHRcXHRcXHRuLS07XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIHJlc3RvcmVcXG5cXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHR6LmlzdGF0ZS5tYXJrZXIgPSBtO1xcblxcblxcdFxcdFxcdC8vIHJldHVybiBubyBqb3kgb3Igc2V0IHVwIHRvIHJlc3RhcnQgb24gYSBuZXcgYmxvY2tcXG5cXHRcXHRcXHRpZiAobSAhPSA0KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIFpfREFUQV9FUlJPUjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0ciA9IHoudG90YWxfaW47XFxuXFx0XFx0XFx0dyA9IHoudG90YWxfb3V0O1xcblxcdFxcdFxcdGluZmxhdGVSZXNldCh6KTtcXG5cXHRcXHRcXHR6LnRvdGFsX2luID0gcjtcXG5cXHRcXHRcXHR6LnRvdGFsX291dCA9IHc7XFxuXFx0XFx0XFx0ei5pc3RhdGUubW9kZSA9IEJMT0NLUztcXG5cXHRcXHRcXHRyZXR1cm4gWl9PSztcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIFJldHVybnMgdHJ1ZSBpZiBpbmZsYXRlIGlzIGN1cnJlbnRseSBhdCB0aGUgZW5kIG9mIGEgYmxvY2sgZ2VuZXJhdGVkXFxuXFx0XFx0Ly8gYnkgWl9TWU5DX0ZMVVNIIG9yIFpfRlVMTF9GTFVTSC4gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJ5IG9uZSBQUFBcXG5cXHRcXHQvLyBpbXBsZW1lbnRhdGlvbiB0byBwcm92aWRlIGFuIGFkZGl0aW9uYWwgc2FmZXR5IGNoZWNrLiBQUFAgdXNlc1xcblxcdFxcdC8vIFpfU1lOQ19GTFVTSFxcblxcdFxcdC8vIGJ1dCByZW1vdmVzIHRoZSBsZW5ndGggYnl0ZXMgb2YgdGhlIHJlc3VsdGluZyBlbXB0eSBzdG9yZWQgYmxvY2suIFdoZW5cXG5cXHRcXHQvLyBkZWNvbXByZXNzaW5nLCBQUFAgY2hlY2tzIHRoYXQgYXQgdGhlIGVuZCBvZiBpbnB1dCBwYWNrZXQsIGluZmxhdGUgaXNcXG5cXHRcXHQvLyB3YWl0aW5nIGZvciB0aGVzZSBsZW5ndGggYnl0ZXMuXFxuXFx0XFx0dGhhdC5pbmZsYXRlU3luY1BvaW50ID0gZnVuY3Rpb24oeikge1xcblxcdFxcdFxcdGlmICgheiB8fCAhei5pc3RhdGUgfHwgIXouaXN0YXRlLmJsb2NrcylcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxuXFx0XFx0XFx0cmV0dXJuIHouaXN0YXRlLmJsb2Nrcy5zeW5jX3BvaW50KCk7XFxuXFx0XFx0fTtcXG5cXHR9XFxuXFxuXFx0Ly8gWlN0cmVhbVxcblxcblxcdGZ1bmN0aW9uIFpTdHJlYW0oKSB7XFxuXFx0fVxcblxcblxcdFpTdHJlYW0ucHJvdG90eXBlID0ge1xcblxcdFxcdGluZmxhdGVJbml0IDogZnVuY3Rpb24oYml0cykge1xcblxcdFxcdFxcdHZhciB0aGF0ID0gdGhpcztcXG5cXHRcXHRcXHR0aGF0LmlzdGF0ZSA9IG5ldyBJbmZsYXRlKCk7XFxuXFx0XFx0XFx0aWYgKCFiaXRzKVxcblxcdFxcdFxcdFxcdGJpdHMgPSBNQVhfQklUUztcXG5cXHRcXHRcXHRyZXR1cm4gdGhhdC5pc3RhdGUuaW5mbGF0ZUluaXQodGhhdCwgYml0cyk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRpbmZsYXRlIDogZnVuY3Rpb24oZikge1xcblxcdFxcdFxcdHZhciB0aGF0ID0gdGhpcztcXG5cXHRcXHRcXHRpZiAoIXRoYXQuaXN0YXRlKVxcblxcdFxcdFxcdFxcdHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXG5cXHRcXHRcXHRyZXR1cm4gdGhhdC5pc3RhdGUuaW5mbGF0ZSh0aGF0LCBmKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdGluZmxhdGVFbmQgOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHR2YXIgdGhhdCA9IHRoaXM7XFxuXFx0XFx0XFx0aWYgKCF0aGF0LmlzdGF0ZSlcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxuXFx0XFx0XFx0dmFyIHJldCA9IHRoYXQuaXN0YXRlLmluZmxhdGVFbmQodGhhdCk7XFxuXFx0XFx0XFx0dGhhdC5pc3RhdGUgPSBudWxsO1xcblxcdFxcdFxcdHJldHVybiByZXQ7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRpbmZsYXRlU3luYyA6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHZhciB0aGF0ID0gdGhpcztcXG5cXHRcXHRcXHRpZiAoIXRoYXQuaXN0YXRlKVxcblxcdFxcdFxcdFxcdHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXG5cXHRcXHRcXHRyZXR1cm4gdGhhdC5pc3RhdGUuaW5mbGF0ZVN5bmModGhhdCk7XFxuXFx0XFx0fSxcXG5cXHRcXHRpbmZsYXRlU2V0RGljdGlvbmFyeSA6IGZ1bmN0aW9uKGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpIHtcXG5cXHRcXHRcXHR2YXIgdGhhdCA9IHRoaXM7XFxuXFx0XFx0XFx0aWYgKCF0aGF0LmlzdGF0ZSlcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxuXFx0XFx0XFx0cmV0dXJuIHRoYXQuaXN0YXRlLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoYXQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpO1xcblxcdFxcdH0sXFxuXFx0XFx0cmVhZF9ieXRlIDogZnVuY3Rpb24oc3RhcnQpIHtcXG5cXHRcXHRcXHR2YXIgdGhhdCA9IHRoaXM7XFxuXFx0XFx0XFx0cmV0dXJuIHRoYXQubmV4dF9pbi5zdWJhcnJheShzdGFydCwgc3RhcnQgKyAxKVswXTtcXG5cXHRcXHR9LFxcblxcdFxcdHJlYWRfYnVmIDogZnVuY3Rpb24oc3RhcnQsIHNpemUpIHtcXG5cXHRcXHRcXHR2YXIgdGhhdCA9IHRoaXM7XFxuXFx0XFx0XFx0cmV0dXJuIHRoYXQubmV4dF9pbi5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBzaXplKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQvLyBJbmZsYXRlclxcblxcblxcdGZ1bmN0aW9uIEluZmxhdGVyKCkge1xcblxcdFxcdHZhciB0aGF0ID0gdGhpcztcXG5cXHRcXHR2YXIgeiA9IG5ldyBaU3RyZWFtKCk7XFxuXFx0XFx0dmFyIGJ1ZnNpemUgPSA1MTI7XFxuXFx0XFx0dmFyIGZsdXNoID0gWl9OT19GTFVTSDtcXG5cXHRcXHR2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYnVmc2l6ZSk7XFxuXFx0XFx0dmFyIG5vbW9yZWlucHV0ID0gZmFsc2U7XFxuXFxuXFx0XFx0ei5pbmZsYXRlSW5pdCgpO1xcblxcdFxcdHoubmV4dF9vdXQgPSBidWY7XFxuXFxuXFx0XFx0dGhhdC5hcHBlbmQgPSBmdW5jdGlvbihkYXRhLCBvbnByb2dyZXNzKSB7XFxuXFx0XFx0XFx0dmFyIGVyciwgYnVmZmVycyA9IFtdLCBsYXN0SW5kZXggPSAwLCBidWZmZXJJbmRleCA9IDAsIGJ1ZmZlclNpemUgPSAwLCBhcnJheTtcXG5cXHRcXHRcXHRpZiAoZGF0YS5sZW5ndGggPT09IDApXFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IDA7XFxuXFx0XFx0XFx0ei5uZXh0X2luID0gZGF0YTtcXG5cXHRcXHRcXHR6LmF2YWlsX2luID0gZGF0YS5sZW5ndGg7XFxuXFx0XFx0XFx0ZG8ge1xcblxcdFxcdFxcdFxcdHoubmV4dF9vdXRfaW5kZXggPSAwO1xcblxcdFxcdFxcdFxcdHouYXZhaWxfb3V0ID0gYnVmc2l6ZTtcXG5cXHRcXHRcXHRcXHRpZiAoKHouYXZhaWxfaW4gPT09IDApICYmICghbm9tb3JlaW5wdXQpKSB7IC8vIGlmIGJ1ZmZlciBpcyBlbXB0eSBhbmQgbW9yZSBpbnB1dCBpcyBhdmFpbGFibGUsIHJlZmlsbCBpdFxcblxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0bm9tb3JlaW5wdXQgPSB0cnVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRlcnIgPSB6LmluZmxhdGUoZmx1c2gpO1xcblxcdFxcdFxcdFxcdGlmIChub21vcmVpbnB1dCAmJiAoZXJyID09PSBaX0JVRl9FUlJPUikpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoei5hdmFpbF9pbiAhPT0gMClcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoXFxcImluZmxhdGluZzogYmFkIGlucHV0XFxcIik7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmIChlcnIgIT09IFpfT0sgJiYgZXJyICE9PSBaX1NUUkVBTV9FTkQpXFxuXFx0XFx0XFx0XFx0XFx0dGhyb3cgbmV3IEVycm9yKFxcXCJpbmZsYXRpbmc6IFxcXCIgKyB6Lm1zZyk7XFxuXFx0XFx0XFx0XFx0aWYgKChub21vcmVpbnB1dCB8fCBlcnIgPT09IFpfU1RSRUFNX0VORCkgJiYgKHouYXZhaWxfaW4gPT09IGRhdGEubGVuZ3RoKSlcXG5cXHRcXHRcXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoXFxcImluZmxhdGluZzogYmFkIGlucHV0XFxcIik7XFxuXFx0XFx0XFx0XFx0aWYgKHoubmV4dF9vdXRfaW5kZXgpXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHoubmV4dF9vdXRfaW5kZXggPT09IGJ1ZnNpemUpXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnVmZmVycy5wdXNoKG5ldyBVaW50OEFycmF5KGJ1ZikpO1xcblxcdFxcdFxcdFxcdFxcdGVsc2VcXG5cXHRcXHRcXHRcXHRcXHRcXHRidWZmZXJzLnB1c2gobmV3IFVpbnQ4QXJyYXkoYnVmLnN1YmFycmF5KDAsIHoubmV4dF9vdXRfaW5kZXgpKSk7XFxuXFx0XFx0XFx0XFx0YnVmZmVyU2l6ZSArPSB6Lm5leHRfb3V0X2luZGV4O1xcblxcdFxcdFxcdFxcdGlmIChvbnByb2dyZXNzICYmIHoubmV4dF9pbl9pbmRleCA+IDAgJiYgei5uZXh0X2luX2luZGV4ICE9IGxhc3RJbmRleCkge1xcblxcdFxcdFxcdFxcdFxcdG9ucHJvZ3Jlc3Moei5uZXh0X2luX2luZGV4KTtcXG5cXHRcXHRcXHRcXHRcXHRsYXN0SW5kZXggPSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gd2hpbGUgKHouYXZhaWxfaW4gPiAwIHx8IHouYXZhaWxfb3V0ID09PSAwKTtcXG5cXHRcXHRcXHRhcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlclNpemUpO1xcblxcdFxcdFxcdGJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbihjaHVuaykge1xcblxcdFxcdFxcdFxcdGFycmF5LnNldChjaHVuaywgYnVmZmVySW5kZXgpO1xcblxcdFxcdFxcdFxcdGJ1ZmZlckluZGV4ICs9IGNodW5rLmxlbmd0aDtcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRyZXR1cm4gYXJyYXk7XFxuXFx0XFx0fTtcXG5cXHRcXHR0aGF0LmZsdXNoID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0ei5pbmZsYXRlRW5kKCk7XFxuXFx0XFx0fTtcXG5cXHR9XFxuXFxuXFx0Ly8gJ3ppcCcgbWF5IG5vdCBiZSBkZWZpbmVkIGluIHotd29ya2VyIGFuZCBzb21lIHRlc3RzXFxuXFx0dmFyIGVudiA9IGdsb2JhbC56aXAgfHwgZ2xvYmFsO1xcblxcdGVudi5JbmZsYXRlciA9IGVudi5fanpsaWJfSW5mbGF0ZXIgPSBJbmZsYXRlcjtcXG59KSh0aGlzKTtcXG5cIildXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHppcDtcblxuIiwiOyB2YXIgX19icm93c2VyaWZ5X3NoaW1fcmVxdWlyZV9fPXJlcXVpcmU7KGZ1bmN0aW9uIGJyb3dzZXJpZnlTaGltKG1vZHVsZSwgZXhwb3J0cywgcmVxdWlyZSwgZGVmaW5lLCBicm93c2VyaWZ5X3NoaW1fX2RlZmluZV9fbW9kdWxlX19leHBvcnRfXykge1xuLypcbiBDb3B5cmlnaHQgKGMpIDIwMTMgR2lsZGFzIExvcm1lYXUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuXG4gMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW5cbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuIDMuIFRoZSBuYW1lcyBvZiB0aGUgYXV0aG9ycyBtYXkgbm90IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzXG4gZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG5cbiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIGBgQVMgSVMnJyBBTkQgQU5ZIEVYUFJFU1NFRCBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsXG4gSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORFxuIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBKQ1JBRlQsXG4gSU5DLiBPUiBBTlkgQ09OVFJJQlVUT1JTIFRPIFRISVMgU09GVFdBUkUgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCxcbiBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4gTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsXG4gT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxuIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLFxuIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuKGZ1bmN0aW9uKG9iaikge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHR2YXIgRVJSX0JBRF9GT1JNQVQgPSBcIkZpbGUgZm9ybWF0IGlzIG5vdCByZWNvZ25pemVkLlwiO1xuXHR2YXIgRVJSX0NSQyA9IFwiQ1JDIGZhaWxlZC5cIjtcblx0dmFyIEVSUl9FTkNSWVBURUQgPSBcIkZpbGUgY29udGFpbnMgZW5jcnlwdGVkIGVudHJ5LlwiO1xuXHR2YXIgRVJSX1pJUDY0ID0gXCJGaWxlIGlzIHVzaW5nIFppcDY0ICg0Z2IrIGZpbGUgc2l6ZSkuXCI7XG5cdHZhciBFUlJfUkVBRCA9IFwiRXJyb3Igd2hpbGUgcmVhZGluZyB6aXAgZmlsZS5cIjtcblx0dmFyIEVSUl9XUklURSA9IFwiRXJyb3Igd2hpbGUgd3JpdGluZyB6aXAgZmlsZS5cIjtcblx0dmFyIEVSUl9XUklURV9EQVRBID0gXCJFcnJvciB3aGlsZSB3cml0aW5nIGZpbGUgZGF0YS5cIjtcblx0dmFyIEVSUl9SRUFEX0RBVEEgPSBcIkVycm9yIHdoaWxlIHJlYWRpbmcgZmlsZSBkYXRhLlwiO1xuXHR2YXIgRVJSX0RVUExJQ0FURURfTkFNRSA9IFwiRmlsZSBhbHJlYWR5IGV4aXN0cy5cIjtcblx0dmFyIENIVU5LX1NJWkUgPSA1MTIgKiAxMDI0O1xuXHRcblx0dmFyIFRFWFRfUExBSU4gPSBcInRleHQvcGxhaW5cIjtcblxuXHR2YXIgYXBwZW5kQUJWaWV3U3VwcG9ydGVkO1xuXHR0cnkge1xuXHRcdGFwcGVuZEFCVmlld1N1cHBvcnRlZCA9IG5ldyBCbG9iKFsgbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigwKSkgXSkuc2l6ZSA9PT0gMDtcblx0fSBjYXRjaCAoZSkge1xuXHR9XG5cblx0ZnVuY3Rpb24gQ3JjMzIoKSB7XG5cdFx0dGhpcy5jcmMgPSAtMTtcblx0fVxuXHRDcmMzMi5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKGRhdGEpIHtcblx0XHR2YXIgY3JjID0gdGhpcy5jcmMgfCAwLCB0YWJsZSA9IHRoaXMudGFibGU7XG5cdFx0Zm9yICh2YXIgb2Zmc2V0ID0gMCwgbGVuID0gZGF0YS5sZW5ndGggfCAwOyBvZmZzZXQgPCBsZW47IG9mZnNldCsrKVxuXHRcdFx0Y3JjID0gKGNyYyA+Pj4gOCkgXiB0YWJsZVsoY3JjIF4gZGF0YVtvZmZzZXRdKSAmIDB4RkZdO1xuXHRcdHRoaXMuY3JjID0gY3JjO1xuXHR9O1xuXHRDcmMzMi5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KCkge1xuXHRcdHJldHVybiB+dGhpcy5jcmM7XG5cdH07XG5cdENyYzMyLnByb3RvdHlwZS50YWJsZSA9IChmdW5jdGlvbigpIHtcblx0XHR2YXIgaSwgaiwgdCwgdGFibGUgPSBbXTsgLy8gVWludDMyQXJyYXkgaXMgYWN0dWFsbHkgc2xvd2VyIHRoYW4gW11cblx0XHRmb3IgKGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcblx0XHRcdHQgPSBpO1xuXHRcdFx0Zm9yIChqID0gMDsgaiA8IDg7IGorKylcblx0XHRcdFx0aWYgKHQgJiAxKVxuXHRcdFx0XHRcdHQgPSAodCA+Pj4gMSkgXiAweEVEQjg4MzIwO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0dCA9IHQgPj4+IDE7XG5cdFx0XHR0YWJsZVtpXSA9IHQ7XG5cdFx0fVxuXHRcdHJldHVybiB0YWJsZTtcblx0fSkoKTtcblx0XG5cdC8vIFwibm8tb3BcIiBjb2RlY1xuXHRmdW5jdGlvbiBOT09QKCkge31cblx0Tk9PUC5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKGJ5dGVzLCBvbnByb2dyZXNzKSB7XG5cdFx0cmV0dXJuIGJ5dGVzO1xuXHR9O1xuXHROT09QLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge307XG5cblx0ZnVuY3Rpb24gYmxvYlNsaWNlKGJsb2IsIGluZGV4LCBsZW5ndGgpIHtcblx0XHRpZiAoaW5kZXggPCAwIHx8IGxlbmd0aCA8IDAgfHwgaW5kZXggKyBsZW5ndGggPiBibG9iLnNpemUpXG5cdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0OicgKyBpbmRleCArICcsIGxlbmd0aDonICsgbGVuZ3RoICsgJywgc2l6ZTonICsgYmxvYi5zaXplKTtcblx0XHRpZiAoYmxvYi5zbGljZSlcblx0XHRcdHJldHVybiBibG9iLnNsaWNlKGluZGV4LCBpbmRleCArIGxlbmd0aCk7XG5cdFx0ZWxzZSBpZiAoYmxvYi53ZWJraXRTbGljZSlcblx0XHRcdHJldHVybiBibG9iLndlYmtpdFNsaWNlKGluZGV4LCBpbmRleCArIGxlbmd0aCk7XG5cdFx0ZWxzZSBpZiAoYmxvYi5tb3pTbGljZSlcblx0XHRcdHJldHVybiBibG9iLm1velNsaWNlKGluZGV4LCBpbmRleCArIGxlbmd0aCk7XG5cdFx0ZWxzZSBpZiAoYmxvYi5tc1NsaWNlKVxuXHRcdFx0cmV0dXJuIGJsb2IubXNTbGljZShpbmRleCwgaW5kZXggKyBsZW5ndGgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0RGF0YUhlbHBlcihieXRlTGVuZ3RoLCBieXRlcykge1xuXHRcdHZhciBkYXRhQnVmZmVyLCBkYXRhQXJyYXk7XG5cdFx0ZGF0YUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihieXRlTGVuZ3RoKTtcblx0XHRkYXRhQXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhQnVmZmVyKTtcblx0XHRpZiAoYnl0ZXMpXG5cdFx0XHRkYXRhQXJyYXkuc2V0KGJ5dGVzLCAwKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0YnVmZmVyIDogZGF0YUJ1ZmZlcixcblx0XHRcdGFycmF5IDogZGF0YUFycmF5LFxuXHRcdFx0dmlldyA6IG5ldyBEYXRhVmlldyhkYXRhQnVmZmVyKVxuXHRcdH07XG5cdH1cblxuXHQvLyBSZWFkZXJzXG5cdGZ1bmN0aW9uIFJlYWRlcigpIHtcblx0fVxuXG5cdGZ1bmN0aW9uIFRleHRSZWFkZXIodGV4dCkge1xuXHRcdHZhciB0aGF0ID0gdGhpcywgYmxvYlJlYWRlcjtcblxuXHRcdGZ1bmN0aW9uIGluaXQoY2FsbGJhY2ssIG9uZXJyb3IpIHtcblx0XHRcdHZhciBibG9iID0gbmV3IEJsb2IoWyB0ZXh0IF0sIHtcblx0XHRcdFx0dHlwZSA6IFRFWFRfUExBSU5cblx0XHRcdH0pO1xuXHRcdFx0YmxvYlJlYWRlciA9IG5ldyBCbG9iUmVhZGVyKGJsb2IpO1xuXHRcdFx0YmxvYlJlYWRlci5pbml0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGF0LnNpemUgPSBibG9iUmVhZGVyLnNpemU7XG5cdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHR9LCBvbmVycm9yKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWFkVWludDhBcnJheShpbmRleCwgbGVuZ3RoLCBjYWxsYmFjaywgb25lcnJvcikge1xuXHRcdFx0YmxvYlJlYWRlci5yZWFkVWludDhBcnJheShpbmRleCwgbGVuZ3RoLCBjYWxsYmFjaywgb25lcnJvcik7XG5cdFx0fVxuXG5cdFx0dGhhdC5zaXplID0gMDtcblx0XHR0aGF0LmluaXQgPSBpbml0O1xuXHRcdHRoYXQucmVhZFVpbnQ4QXJyYXkgPSByZWFkVWludDhBcnJheTtcblx0fVxuXHRUZXh0UmVhZGVyLnByb3RvdHlwZSA9IG5ldyBSZWFkZXIoKTtcblx0VGV4dFJlYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUZXh0UmVhZGVyO1xuXG5cdGZ1bmN0aW9uIERhdGE2NFVSSVJlYWRlcihkYXRhVVJJKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzLCBkYXRhU3RhcnQ7XG5cblx0XHRmdW5jdGlvbiBpbml0KGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgZGF0YUVuZCA9IGRhdGFVUkkubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKGRhdGFVUkkuY2hhckF0KGRhdGFFbmQgLSAxKSA9PSBcIj1cIilcblx0XHRcdFx0ZGF0YUVuZC0tO1xuXHRcdFx0ZGF0YVN0YXJ0ID0gZGF0YVVSSS5pbmRleE9mKFwiLFwiKSArIDE7XG5cdFx0XHR0aGF0LnNpemUgPSBNYXRoLmZsb29yKChkYXRhRW5kIC0gZGF0YVN0YXJ0KSAqIDAuNzUpO1xuXHRcdFx0Y2FsbGJhY2soKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWFkVWludDhBcnJheShpbmRleCwgbGVuZ3RoLCBjYWxsYmFjaykge1xuXHRcdFx0dmFyIGksIGRhdGEgPSBnZXREYXRhSGVscGVyKGxlbmd0aCk7XG5cdFx0XHR2YXIgc3RhcnQgPSBNYXRoLmZsb29yKGluZGV4IC8gMykgKiA0O1xuXHRcdFx0dmFyIGVuZCA9IE1hdGguY2VpbCgoaW5kZXggKyBsZW5ndGgpIC8gMykgKiA0O1xuXHRcdFx0dmFyIGJ5dGVzID0gb2JqLmF0b2IoZGF0YVVSSS5zdWJzdHJpbmcoc3RhcnQgKyBkYXRhU3RhcnQsIGVuZCArIGRhdGFTdGFydCkpO1xuXHRcdFx0dmFyIGRlbHRhID0gaW5kZXggLSBNYXRoLmZsb29yKHN0YXJ0IC8gNCkgKiAzO1xuXHRcdFx0Zm9yIChpID0gZGVsdGE7IGkgPCBkZWx0YSArIGxlbmd0aDsgaSsrKVxuXHRcdFx0XHRkYXRhLmFycmF5W2kgLSBkZWx0YV0gPSBieXRlcy5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0Y2FsbGJhY2soZGF0YS5hcnJheSk7XG5cdFx0fVxuXG5cdFx0dGhhdC5zaXplID0gMDtcblx0XHR0aGF0LmluaXQgPSBpbml0O1xuXHRcdHRoYXQucmVhZFVpbnQ4QXJyYXkgPSByZWFkVWludDhBcnJheTtcblx0fVxuXHREYXRhNjRVUklSZWFkZXIucHJvdG90eXBlID0gbmV3IFJlYWRlcigpO1xuXHREYXRhNjRVUklSZWFkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGF0YTY0VVJJUmVhZGVyO1xuXG5cdGZ1bmN0aW9uIEJsb2JSZWFkZXIoYmxvYikge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblxuXHRcdGZ1bmN0aW9uIGluaXQoY2FsbGJhY2spIHtcblx0XHRcdHRoYXQuc2l6ZSA9IGJsb2Iuc2l6ZTtcblx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVhZFVpbnQ4QXJyYXkoaW5kZXgsIGxlbmd0aCwgY2FsbGJhY2ssIG9uZXJyb3IpIHtcblx0XHRcdHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXHRcdFx0cmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0Y2FsbGJhY2sobmV3IFVpbnQ4QXJyYXkoZS50YXJnZXQucmVzdWx0KSk7XG5cdFx0XHR9O1xuXHRcdFx0cmVhZGVyLm9uZXJyb3IgPSBvbmVycm9yO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2JTbGljZShibG9iLCBpbmRleCwgbGVuZ3RoKSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdG9uZXJyb3IoZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhhdC5zaXplID0gMDtcblx0XHR0aGF0LmluaXQgPSBpbml0O1xuXHRcdHRoYXQucmVhZFVpbnQ4QXJyYXkgPSByZWFkVWludDhBcnJheTtcblx0fVxuXHRCbG9iUmVhZGVyLnByb3RvdHlwZSA9IG5ldyBSZWFkZXIoKTtcblx0QmxvYlJlYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCbG9iUmVhZGVyO1xuXG5cdC8vIFdyaXRlcnNcblxuXHRmdW5jdGlvbiBXcml0ZXIoKSB7XG5cdH1cblx0V3JpdGVyLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRjYWxsYmFjayh0aGlzLmRhdGEpO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIFRleHRXcml0ZXIoZW5jb2RpbmcpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXMsIGJsb2I7XG5cblx0XHRmdW5jdGlvbiBpbml0KGNhbGxiYWNrKSB7XG5cdFx0XHRibG9iID0gbmV3IEJsb2IoW10sIHtcblx0XHRcdFx0dHlwZSA6IFRFWFRfUExBSU5cblx0XHRcdH0pO1xuXHRcdFx0Y2FsbGJhY2soKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB3cml0ZVVpbnQ4QXJyYXkoYXJyYXksIGNhbGxiYWNrKSB7XG5cdFx0XHRibG9iID0gbmV3IEJsb2IoWyBibG9iLCBhcHBlbmRBQlZpZXdTdXBwb3J0ZWQgPyBhcnJheSA6IGFycmF5LmJ1ZmZlciBdLCB7XG5cdFx0XHRcdHR5cGUgOiBURVhUX1BMQUlOXG5cdFx0XHR9KTtcblx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0RGF0YShjYWxsYmFjaywgb25lcnJvcikge1xuXHRcdFx0dmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cdFx0XHRyZWFkZXIub25sb2FkID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRjYWxsYmFjayhlLnRhcmdldC5yZXN1bHQpO1xuXHRcdFx0fTtcblx0XHRcdHJlYWRlci5vbmVycm9yID0gb25lcnJvcjtcblx0XHRcdHJlYWRlci5yZWFkQXNUZXh0KGJsb2IsIGVuY29kaW5nKTtcblx0XHR9XG5cblx0XHR0aGF0LmluaXQgPSBpbml0O1xuXHRcdHRoYXQud3JpdGVVaW50OEFycmF5ID0gd3JpdGVVaW50OEFycmF5O1xuXHRcdHRoYXQuZ2V0RGF0YSA9IGdldERhdGE7XG5cdH1cblx0VGV4dFdyaXRlci5wcm90b3R5cGUgPSBuZXcgV3JpdGVyKCk7XG5cdFRleHRXcml0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGV4dFdyaXRlcjtcblxuXHRmdW5jdGlvbiBEYXRhNjRVUklXcml0ZXIoY29udGVudFR5cGUpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXMsIGRhdGEgPSBcIlwiLCBwZW5kaW5nID0gXCJcIjtcblxuXHRcdGZ1bmN0aW9uIGluaXQoY2FsbGJhY2spIHtcblx0XHRcdGRhdGEgKz0gXCJkYXRhOlwiICsgKGNvbnRlbnRUeXBlIHx8IFwiXCIpICsgXCI7YmFzZTY0LFwiO1xuXHRcdFx0Y2FsbGJhY2soKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB3cml0ZVVpbnQ4QXJyYXkoYXJyYXksIGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgaSwgZGVsdGEgPSBwZW5kaW5nLmxlbmd0aCwgZGF0YVN0cmluZyA9IHBlbmRpbmc7XG5cdFx0XHRwZW5kaW5nID0gXCJcIjtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCAoTWF0aC5mbG9vcigoZGVsdGEgKyBhcnJheS5sZW5ndGgpIC8gMykgKiAzKSAtIGRlbHRhOyBpKyspXG5cdFx0XHRcdGRhdGFTdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShhcnJheVtpXSk7XG5cdFx0XHRmb3IgKDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKVxuXHRcdFx0XHRwZW5kaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYXJyYXlbaV0pO1xuXHRcdFx0aWYgKGRhdGFTdHJpbmcubGVuZ3RoID4gMilcblx0XHRcdFx0ZGF0YSArPSBvYmouYnRvYShkYXRhU3RyaW5nKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0cGVuZGluZyA9IGRhdGFTdHJpbmc7XG5cdFx0XHRjYWxsYmFjaygpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldERhdGEoY2FsbGJhY2spIHtcblx0XHRcdGNhbGxiYWNrKGRhdGEgKyBvYmouYnRvYShwZW5kaW5nKSk7XG5cdFx0fVxuXG5cdFx0dGhhdC5pbml0ID0gaW5pdDtcblx0XHR0aGF0LndyaXRlVWludDhBcnJheSA9IHdyaXRlVWludDhBcnJheTtcblx0XHR0aGF0LmdldERhdGEgPSBnZXREYXRhO1xuXHR9XG5cdERhdGE2NFVSSVdyaXRlci5wcm90b3R5cGUgPSBuZXcgV3JpdGVyKCk7XG5cdERhdGE2NFVSSVdyaXRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEYXRhNjRVUklXcml0ZXI7XG5cblx0ZnVuY3Rpb24gQmxvYldyaXRlcihjb250ZW50VHlwZSkge1xuXHRcdHZhciBibG9iLCB0aGF0ID0gdGhpcztcblxuXHRcdGZ1bmN0aW9uIGluaXQoY2FsbGJhY2spIHtcblx0XHRcdGJsb2IgPSBuZXcgQmxvYihbXSwge1xuXHRcdFx0XHR0eXBlIDogY29udGVudFR5cGVcblx0XHRcdH0pO1xuXHRcdFx0Y2FsbGJhY2soKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB3cml0ZVVpbnQ4QXJyYXkoYXJyYXksIGNhbGxiYWNrKSB7XG5cdFx0XHRibG9iID0gbmV3IEJsb2IoWyBibG9iLCBhcHBlbmRBQlZpZXdTdXBwb3J0ZWQgPyBhcnJheSA6IGFycmF5LmJ1ZmZlciBdLCB7XG5cdFx0XHRcdHR5cGUgOiBjb250ZW50VHlwZVxuXHRcdFx0fSk7XG5cdFx0XHRjYWxsYmFjaygpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldERhdGEoY2FsbGJhY2spIHtcblx0XHRcdGNhbGxiYWNrKGJsb2IpO1xuXHRcdH1cblxuXHRcdHRoYXQuaW5pdCA9IGluaXQ7XG5cdFx0dGhhdC53cml0ZVVpbnQ4QXJyYXkgPSB3cml0ZVVpbnQ4QXJyYXk7XG5cdFx0dGhhdC5nZXREYXRhID0gZ2V0RGF0YTtcblx0fVxuXHRCbG9iV3JpdGVyLnByb3RvdHlwZSA9IG5ldyBXcml0ZXIoKTtcblx0QmxvYldyaXRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCbG9iV3JpdGVyO1xuXG5cdC8qKiBcblx0ICogaW5mbGF0ZS9kZWZsYXRlIGNvcmUgZnVuY3Rpb25zXG5cdCAqIEBwYXJhbSB3b3JrZXIge1dvcmtlcn0gd2ViIHdvcmtlciBmb3IgdGhlIHRhc2suXG5cdCAqIEBwYXJhbSBpbml0aWFsTWVzc2FnZSB7T2JqZWN0fSBpbml0aWFsIG1lc3NhZ2UgdG8gYmUgc2VudCB0byB0aGUgd29ya2VyLiBzaG91bGQgY29udGFpblxuXHQgKiAgIHNuKHNlcmlhbCBudW1iZXIgZm9yIGRpc3Rpbmd1aXNoaW5nIG11bHRpcGxlIHRhc2tzIHNlbnQgdG8gdGhlIHdvcmtlciksIGFuZCBjb2RlY0NsYXNzLlxuXHQgKiAgIFRoaXMgZnVuY3Rpb24gbWF5IGFkZCBtb3JlIHByb3BlcnRpZXMgYmVmb3JlIHNlbmRpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiBsYXVuY2hXb3JrZXJQcm9jZXNzKHdvcmtlciwgaW5pdGlhbE1lc3NhZ2UsIHJlYWRlciwgd3JpdGVyLCBvZmZzZXQsIHNpemUsIG9ucHJvZ3Jlc3MsIG9uZW5kLCBvbnJlYWRlcnJvciwgb253cml0ZWVycm9yKSB7XG5cdFx0dmFyIGNodW5rSW5kZXggPSAwLCBpbmRleCwgb3V0cHV0U2l6ZSwgc24gPSBpbml0aWFsTWVzc2FnZS5zbiwgY3JjO1xuXG5cdFx0ZnVuY3Rpb24gb25mbHVzaCgpIHtcblx0XHRcdHdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb25tZXNzYWdlLCBmYWxzZSk7XG5cdFx0XHRvbmVuZChvdXRwdXRTaXplLCBjcmMpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9ubWVzc2FnZShldmVudCkge1xuXHRcdFx0dmFyIG1lc3NhZ2UgPSBldmVudC5kYXRhLCBkYXRhID0gbWVzc2FnZS5kYXRhLCBlcnIgPSBtZXNzYWdlLmVycm9yO1xuXHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRlcnIudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnRXJyb3I6ICcgKyB0aGlzLm1lc3NhZ2U7IH07XG5cdFx0XHRcdG9ucmVhZGVycm9yKGVycik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmIChtZXNzYWdlLnNuICE9PSBzbilcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0aWYgKHR5cGVvZiBtZXNzYWdlLmNvZGVjVGltZSA9PT0gJ251bWJlcicpXG5cdFx0XHRcdHdvcmtlci5jb2RlY1RpbWUgKz0gbWVzc2FnZS5jb2RlY1RpbWU7IC8vIHNob3VsZCBiZSBiZWZvcmUgb25mbHVzaCgpXG5cdFx0XHRpZiAodHlwZW9mIG1lc3NhZ2UuY3JjVGltZSA9PT0gJ251bWJlcicpXG5cdFx0XHRcdHdvcmtlci5jcmNUaW1lICs9IG1lc3NhZ2UuY3JjVGltZTtcblxuXHRcdFx0c3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcblx0XHRcdFx0Y2FzZSAnYXBwZW5kJzpcblx0XHRcdFx0XHRpZiAoZGF0YSkge1xuXHRcdFx0XHRcdFx0b3V0cHV0U2l6ZSArPSBkYXRhLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdyaXRlci53cml0ZVVpbnQ4QXJyYXkoZGF0YSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHN0ZXAoKTtcblx0XHRcdFx0XHRcdH0sIG9ud3JpdGVlcnJvcik7XG5cdFx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0XHRzdGVwKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2ZsdXNoJzpcblx0XHRcdFx0XHRjcmMgPSBtZXNzYWdlLmNyYztcblx0XHRcdFx0XHRpZiAoZGF0YSkge1xuXHRcdFx0XHRcdFx0b3V0cHV0U2l6ZSArPSBkYXRhLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdyaXRlci53cml0ZVVpbnQ4QXJyYXkoZGF0YSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdG9uZmx1c2goKTtcblx0XHRcdFx0XHRcdH0sIG9ud3JpdGVlcnJvcik7XG5cdFx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0XHRvbmZsdXNoKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ3Byb2dyZXNzJzpcblx0XHRcdFx0XHRpZiAob25wcm9ncmVzcylcblx0XHRcdFx0XHRcdG9ucHJvZ3Jlc3MoaW5kZXggKyBtZXNzYWdlLmxvYWRlZCwgc2l6ZSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2ltcG9ydFNjcmlwdHMnOiAvL25vIG5lZWQgdG8gaGFuZGxlIGhlcmVcblx0XHRcdFx0Y2FzZSAnbmV3VGFzayc6XG5cdFx0XHRcdGNhc2UgJ2VjaG8nOlxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGNvbnNvbGUud2FybignemlwLmpzOmxhdW5jaFdvcmtlclByb2Nlc3M6IHVua25vd24gbWVzc2FnZTogJywgbWVzc2FnZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc3RlcCgpIHtcblx0XHRcdGluZGV4ID0gY2h1bmtJbmRleCAqIENIVU5LX1NJWkU7XG5cdFx0XHQvLyB1c2UgYDw9YCBpbnN0ZWFkIG9mIGA8YCwgYmVjYXVzZSBgc2l6ZWAgbWF5IGJlIDAuXG5cdFx0XHRpZiAoaW5kZXggPD0gc2l6ZSkge1xuXHRcdFx0XHRyZWFkZXIucmVhZFVpbnQ4QXJyYXkob2Zmc2V0ICsgaW5kZXgsIE1hdGgubWluKENIVU5LX1NJWkUsIHNpemUgLSBpbmRleCksIGZ1bmN0aW9uKGFycmF5KSB7XG5cdFx0XHRcdFx0aWYgKG9ucHJvZ3Jlc3MpXG5cdFx0XHRcdFx0XHRvbnByb2dyZXNzKGluZGV4LCBzaXplKTtcblx0XHRcdFx0XHR2YXIgbXNnID0gaW5kZXggPT09IDAgPyBpbml0aWFsTWVzc2FnZSA6IHtzbiA6IHNufTtcblx0XHRcdFx0XHRtc2cudHlwZSA9ICdhcHBlbmQnO1xuXHRcdFx0XHRcdG1zZy5kYXRhID0gYXJyYXk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gcG9zdGluZyBhIG1lc3NhZ2Ugd2l0aCB0cmFuc2ZlcmFibGVzIHdpbGwgZmFpbCBvbiBJRTEwXG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHdvcmtlci5wb3N0TWVzc2FnZShtc2csIFthcnJheS5idWZmZXJdKTtcblx0XHRcdFx0XHR9IGNhdGNoKGV4KSB7XG5cdFx0XHRcdFx0XHR3b3JrZXIucG9zdE1lc3NhZ2UobXNnKTsgLy8gcmV0cnkgd2l0aG91dCB0cmFuc2ZlcmFibGVzXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNodW5rSW5kZXgrKztcblx0XHRcdFx0fSwgb25yZWFkZXJyb3IpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d29ya2VyLnBvc3RNZXNzYWdlKHtcblx0XHRcdFx0XHRzbjogc24sXG5cdFx0XHRcdFx0dHlwZTogJ2ZsdXNoJ1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRvdXRwdXRTaXplID0gMDtcblx0XHR3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG9ubWVzc2FnZSwgZmFsc2UpO1xuXHRcdHN0ZXAoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGxhdW5jaFByb2Nlc3MocHJvY2VzcywgcmVhZGVyLCB3cml0ZXIsIG9mZnNldCwgc2l6ZSwgY3JjVHlwZSwgb25wcm9ncmVzcywgb25lbmQsIG9ucmVhZGVycm9yLCBvbndyaXRlZXJyb3IpIHtcblx0XHR2YXIgY2h1bmtJbmRleCA9IDAsIGluZGV4LCBvdXRwdXRTaXplID0gMCxcblx0XHRcdGNyY0lucHV0ID0gY3JjVHlwZSA9PT0gJ2lucHV0Jyxcblx0XHRcdGNyY091dHB1dCA9IGNyY1R5cGUgPT09ICdvdXRwdXQnLFxuXHRcdFx0Y3JjID0gbmV3IENyYzMyKCk7XG5cdFx0ZnVuY3Rpb24gc3RlcCgpIHtcblx0XHRcdHZhciBvdXRwdXREYXRhO1xuXHRcdFx0aW5kZXggPSBjaHVua0luZGV4ICogQ0hVTktfU0laRTtcblx0XHRcdGlmIChpbmRleCA8IHNpemUpXG5cdFx0XHRcdHJlYWRlci5yZWFkVWludDhBcnJheShvZmZzZXQgKyBpbmRleCwgTWF0aC5taW4oQ0hVTktfU0laRSwgc2l6ZSAtIGluZGV4KSwgZnVuY3Rpb24oaW5wdXREYXRhKSB7XG5cdFx0XHRcdFx0dmFyIG91dHB1dERhdGE7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdG91dHB1dERhdGEgPSBwcm9jZXNzLmFwcGVuZChpbnB1dERhdGEsIGZ1bmN0aW9uKGxvYWRlZCkge1xuXHRcdFx0XHRcdFx0XHRpZiAob25wcm9ncmVzcylcblx0XHRcdFx0XHRcdFx0XHRvbnByb2dyZXNzKGluZGV4ICsgbG9hZGVkLCBzaXplKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdG9ucmVhZGVycm9yKGUpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAob3V0cHV0RGF0YSkge1xuXHRcdFx0XHRcdFx0b3V0cHV0U2l6ZSArPSBvdXRwdXREYXRhLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdyaXRlci53cml0ZVVpbnQ4QXJyYXkob3V0cHV0RGF0YSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdGNodW5rSW5kZXgrKztcblx0XHRcdFx0XHRcdFx0c2V0VGltZW91dChzdGVwLCAxKTtcblx0XHRcdFx0XHRcdH0sIG9ud3JpdGVlcnJvcik7XG5cdFx0XHRcdFx0XHRpZiAoY3JjT3V0cHV0KVxuXHRcdFx0XHRcdFx0XHRjcmMuYXBwZW5kKG91dHB1dERhdGEpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjaHVua0luZGV4Kys7XG5cdFx0XHRcdFx0XHRzZXRUaW1lb3V0KHN0ZXAsIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoY3JjSW5wdXQpXG5cdFx0XHRcdFx0XHRjcmMuYXBwZW5kKGlucHV0RGF0YSk7XG5cdFx0XHRcdFx0aWYgKG9ucHJvZ3Jlc3MpXG5cdFx0XHRcdFx0XHRvbnByb2dyZXNzKGluZGV4LCBzaXplKTtcblx0XHRcdFx0fSwgb25yZWFkZXJyb3IpO1xuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0b3V0cHV0RGF0YSA9IHByb2Nlc3MuZmx1c2goKTtcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdG9ucmVhZGVycm9yKGUpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAob3V0cHV0RGF0YSkge1xuXHRcdFx0XHRcdGlmIChjcmNPdXRwdXQpXG5cdFx0XHRcdFx0XHRjcmMuYXBwZW5kKG91dHB1dERhdGEpO1xuXHRcdFx0XHRcdG91dHB1dFNpemUgKz0gb3V0cHV0RGF0YS5sZW5ndGg7XG5cdFx0XHRcdFx0d3JpdGVyLndyaXRlVWludDhBcnJheShvdXRwdXREYXRhLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdG9uZW5kKG91dHB1dFNpemUsIGNyYy5nZXQoKSk7XG5cdFx0XHRcdFx0fSwgb253cml0ZWVycm9yKTtcblx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0b25lbmQob3V0cHV0U2l6ZSwgY3JjLmdldCgpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRzdGVwKCk7XG5cdH1cblxuXHRmdW5jdGlvbiBpbmZsYXRlKHdvcmtlciwgc24sIHJlYWRlciwgd3JpdGVyLCBvZmZzZXQsIHNpemUsIGNvbXB1dGVDcmMzMiwgb25lbmQsIG9ucHJvZ3Jlc3MsIG9ucmVhZGVycm9yLCBvbndyaXRlZXJyb3IpIHtcblx0XHR2YXIgY3JjVHlwZSA9IGNvbXB1dGVDcmMzMiA/ICdvdXRwdXQnIDogJ25vbmUnO1xuXHRcdGlmIChvYmouemlwLnVzZVdlYldvcmtlcnMpIHtcblx0XHRcdHZhciBpbml0aWFsTWVzc2FnZSA9IHtcblx0XHRcdFx0c246IHNuLFxuXHRcdFx0XHRjb2RlY0NsYXNzOiAnSW5mbGF0ZXInLFxuXHRcdFx0XHRjcmNUeXBlOiBjcmNUeXBlLFxuXHRcdFx0fTtcblx0XHRcdGxhdW5jaFdvcmtlclByb2Nlc3Mod29ya2VyLCBpbml0aWFsTWVzc2FnZSwgcmVhZGVyLCB3cml0ZXIsIG9mZnNldCwgc2l6ZSwgb25wcm9ncmVzcywgb25lbmQsIG9ucmVhZGVycm9yLCBvbndyaXRlZXJyb3IpO1xuXHRcdH0gZWxzZVxuXHRcdFx0bGF1bmNoUHJvY2VzcyhuZXcgb2JqLnppcC5JbmZsYXRlcigpLCByZWFkZXIsIHdyaXRlciwgb2Zmc2V0LCBzaXplLCBjcmNUeXBlLCBvbnByb2dyZXNzLCBvbmVuZCwgb25yZWFkZXJyb3IsIG9ud3JpdGVlcnJvcik7XG5cdH1cblxuXHRmdW5jdGlvbiBkZWZsYXRlKHdvcmtlciwgc24sIHJlYWRlciwgd3JpdGVyLCBsZXZlbCwgb25lbmQsIG9ucHJvZ3Jlc3MsIG9ucmVhZGVycm9yLCBvbndyaXRlZXJyb3IpIHtcblx0XHR2YXIgY3JjVHlwZSA9ICdpbnB1dCc7XG5cdFx0aWYgKG9iai56aXAudXNlV2ViV29ya2Vycykge1xuXHRcdFx0dmFyIGluaXRpYWxNZXNzYWdlID0ge1xuXHRcdFx0XHRzbjogc24sXG5cdFx0XHRcdG9wdGlvbnM6IHtsZXZlbDogbGV2ZWx9LFxuXHRcdFx0XHRjb2RlY0NsYXNzOiAnRGVmbGF0ZXInLFxuXHRcdFx0XHRjcmNUeXBlOiBjcmNUeXBlLFxuXHRcdFx0fTtcblx0XHRcdGxhdW5jaFdvcmtlclByb2Nlc3Mod29ya2VyLCBpbml0aWFsTWVzc2FnZSwgcmVhZGVyLCB3cml0ZXIsIDAsIHJlYWRlci5zaXplLCBvbnByb2dyZXNzLCBvbmVuZCwgb25yZWFkZXJyb3IsIG9ud3JpdGVlcnJvcik7XG5cdFx0fSBlbHNlXG5cdFx0XHRsYXVuY2hQcm9jZXNzKG5ldyBvYmouemlwLkRlZmxhdGVyKCksIHJlYWRlciwgd3JpdGVyLCAwLCByZWFkZXIuc2l6ZSwgY3JjVHlwZSwgb25wcm9ncmVzcywgb25lbmQsIG9ucmVhZGVycm9yLCBvbndyaXRlZXJyb3IpO1xuXHR9XG5cblx0ZnVuY3Rpb24gY29weSh3b3JrZXIsIHNuLCByZWFkZXIsIHdyaXRlciwgb2Zmc2V0LCBzaXplLCBjb21wdXRlQ3JjMzIsIG9uZW5kLCBvbnByb2dyZXNzLCBvbnJlYWRlcnJvciwgb253cml0ZWVycm9yKSB7XG5cdFx0dmFyIGNyY1R5cGUgPSAnaW5wdXQnO1xuXHRcdGlmIChvYmouemlwLnVzZVdlYldvcmtlcnMgJiYgY29tcHV0ZUNyYzMyKSB7XG5cdFx0XHR2YXIgaW5pdGlhbE1lc3NhZ2UgPSB7XG5cdFx0XHRcdHNuOiBzbixcblx0XHRcdFx0Y29kZWNDbGFzczogJ05PT1AnLFxuXHRcdFx0XHRjcmNUeXBlOiBjcmNUeXBlLFxuXHRcdFx0fTtcblx0XHRcdGxhdW5jaFdvcmtlclByb2Nlc3Mod29ya2VyLCBpbml0aWFsTWVzc2FnZSwgcmVhZGVyLCB3cml0ZXIsIG9mZnNldCwgc2l6ZSwgb25wcm9ncmVzcywgb25lbmQsIG9ucmVhZGVycm9yLCBvbndyaXRlZXJyb3IpO1xuXHRcdH0gZWxzZVxuXHRcdFx0bGF1bmNoUHJvY2VzcyhuZXcgTk9PUCgpLCByZWFkZXIsIHdyaXRlciwgb2Zmc2V0LCBzaXplLCBjcmNUeXBlLCBvbnByb2dyZXNzLCBvbmVuZCwgb25yZWFkZXJyb3IsIG9ud3JpdGVlcnJvcik7XG5cdH1cblxuXHQvLyBaaXBSZWFkZXJcblxuXHRmdW5jdGlvbiBkZWNvZGVBU0NJSShzdHIpIHtcblx0XHR2YXIgaSwgb3V0ID0gXCJcIiwgY2hhckNvZGUsIGV4dGVuZGVkQVNDSUkgPSBbICdcXHUwMEM3JywgJ1xcdTAwRkMnLCAnXFx1MDBFOScsICdcXHUwMEUyJywgJ1xcdTAwRTQnLCAnXFx1MDBFMCcsICdcXHUwMEU1JywgJ1xcdTAwRTcnLCAnXFx1MDBFQScsICdcXHUwMEVCJyxcblx0XHRcdFx0J1xcdTAwRTgnLCAnXFx1MDBFRicsICdcXHUwMEVFJywgJ1xcdTAwRUMnLCAnXFx1MDBDNCcsICdcXHUwMEM1JywgJ1xcdTAwQzknLCAnXFx1MDBFNicsICdcXHUwMEM2JywgJ1xcdTAwRjQnLCAnXFx1MDBGNicsICdcXHUwMEYyJywgJ1xcdTAwRkInLCAnXFx1MDBGOScsXG5cdFx0XHRcdCdcXHUwMEZGJywgJ1xcdTAwRDYnLCAnXFx1MDBEQycsICdcXHUwMEY4JywgJ1xcdTAwQTMnLCAnXFx1MDBEOCcsICdcXHUwMEQ3JywgJ1xcdTAxOTInLCAnXFx1MDBFMScsICdcXHUwMEVEJywgJ1xcdTAwRjMnLCAnXFx1MDBGQScsICdcXHUwMEYxJywgJ1xcdTAwRDEnLFxuXHRcdFx0XHQnXFx1MDBBQScsICdcXHUwMEJBJywgJ1xcdTAwQkYnLCAnXFx1MDBBRScsICdcXHUwMEFDJywgJ1xcdTAwQkQnLCAnXFx1MDBCQycsICdcXHUwMEExJywgJ1xcdTAwQUInLCAnXFx1MDBCQicsICdfJywgJ18nLCAnXycsICdcXHUwMEE2JywgJ1xcdTAwQTYnLFxuXHRcdFx0XHQnXFx1MDBDMScsICdcXHUwMEMyJywgJ1xcdTAwQzAnLCAnXFx1MDBBOScsICdcXHUwMEE2JywgJ1xcdTAwQTYnLCAnKycsICcrJywgJ1xcdTAwQTInLCAnXFx1MDBBNScsICcrJywgJysnLCAnLScsICctJywgJysnLCAnLScsICcrJywgJ1xcdTAwRTMnLFxuXHRcdFx0XHQnXFx1MDBDMycsICcrJywgJysnLCAnLScsICctJywgJ1xcdTAwQTYnLCAnLScsICcrJywgJ1xcdTAwQTQnLCAnXFx1MDBGMCcsICdcXHUwMEQwJywgJ1xcdTAwQ0EnLCAnXFx1MDBDQicsICdcXHUwMEM4JywgJ2knLCAnXFx1MDBDRCcsICdcXHUwMENFJyxcblx0XHRcdFx0J1xcdTAwQ0YnLCAnKycsICcrJywgJ18nLCAnXycsICdcXHUwMEE2JywgJ1xcdTAwQ0MnLCAnXycsICdcXHUwMEQzJywgJ1xcdTAwREYnLCAnXFx1MDBENCcsICdcXHUwMEQyJywgJ1xcdTAwRjUnLCAnXFx1MDBENScsICdcXHUwMEI1JywgJ1xcdTAwRkUnLFxuXHRcdFx0XHQnXFx1MDBERScsICdcXHUwMERBJywgJ1xcdTAwREInLCAnXFx1MDBEOScsICdcXHUwMEZEJywgJ1xcdTAwREQnLCAnXFx1MDBBRicsICdcXHUwMEI0JywgJ1xcdTAwQUQnLCAnXFx1MDBCMScsICdfJywgJ1xcdTAwQkUnLCAnXFx1MDBCNicsICdcXHUwMEE3Jyxcblx0XHRcdFx0J1xcdTAwRjcnLCAnXFx1MDBCOCcsICdcXHUwMEIwJywgJ1xcdTAwQTgnLCAnXFx1MDBCNycsICdcXHUwMEI5JywgJ1xcdTAwQjMnLCAnXFx1MDBCMicsICdfJywgJyAnIF07XG5cdFx0Zm9yIChpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChpKSAmIDB4RkY7XG5cdFx0XHRpZiAoY2hhckNvZGUgPiAxMjcpXG5cdFx0XHRcdG91dCArPSBleHRlbmRlZEFTQ0lJW2NoYXJDb2RlIC0gMTI4XTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0b3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuXHRcdH1cblx0XHRyZXR1cm4gb3V0O1xuXHR9XG5cblx0ZnVuY3Rpb24gZGVjb2RlVVRGOChzdHJpbmcpIHtcblx0XHRyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShzdHJpbmcpKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFN0cmluZyhieXRlcykge1xuXHRcdHZhciBpLCBzdHIgPSBcIlwiO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKylcblx0XHRcdHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldKTtcblx0XHRyZXR1cm4gc3RyO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0RGF0ZSh0aW1lUmF3KSB7XG5cdFx0dmFyIGRhdGUgPSAodGltZVJhdyAmIDB4ZmZmZjAwMDApID4+IDE2LCB0aW1lID0gdGltZVJhdyAmIDB4MDAwMGZmZmY7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBuZXcgRGF0ZSgxOTgwICsgKChkYXRlICYgMHhGRTAwKSA+PiA5KSwgKChkYXRlICYgMHgwMUUwKSA+PiA1KSAtIDEsIGRhdGUgJiAweDAwMUYsICh0aW1lICYgMHhGODAwKSA+PiAxMSwgKHRpbWUgJiAweDA3RTApID4+IDUsXG5cdFx0XHRcdFx0KHRpbWUgJiAweDAwMUYpICogMiwgMCk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHJlYWRDb21tb25IZWFkZXIoZW50cnksIGRhdGEsIGluZGV4LCBjZW50cmFsRGlyZWN0b3J5LCBvbmVycm9yKSB7XG5cdFx0ZW50cnkudmVyc2lvbiA9IGRhdGEudmlldy5nZXRVaW50MTYoaW5kZXgsIHRydWUpO1xuXHRcdGVudHJ5LmJpdEZsYWcgPSBkYXRhLnZpZXcuZ2V0VWludDE2KGluZGV4ICsgMiwgdHJ1ZSk7XG5cdFx0ZW50cnkuY29tcHJlc3Npb25NZXRob2QgPSBkYXRhLnZpZXcuZ2V0VWludDE2KGluZGV4ICsgNCwgdHJ1ZSk7XG5cdFx0ZW50cnkubGFzdE1vZERhdGVSYXcgPSBkYXRhLnZpZXcuZ2V0VWludDMyKGluZGV4ICsgNiwgdHJ1ZSk7XG5cdFx0ZW50cnkubGFzdE1vZERhdGUgPSBnZXREYXRlKGVudHJ5Lmxhc3RNb2REYXRlUmF3KTtcblx0XHRpZiAoKGVudHJ5LmJpdEZsYWcgJiAweDAxKSA9PT0gMHgwMSkge1xuXHRcdFx0b25lcnJvcihFUlJfRU5DUllQVEVEKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKGNlbnRyYWxEaXJlY3RvcnkgfHwgKGVudHJ5LmJpdEZsYWcgJiAweDAwMDgpICE9IDB4MDAwOCkge1xuXHRcdFx0ZW50cnkuY3JjMzIgPSBkYXRhLnZpZXcuZ2V0VWludDMyKGluZGV4ICsgMTAsIHRydWUpO1xuXHRcdFx0ZW50cnkuY29tcHJlc3NlZFNpemUgPSBkYXRhLnZpZXcuZ2V0VWludDMyKGluZGV4ICsgMTQsIHRydWUpO1xuXHRcdFx0ZW50cnkudW5jb21wcmVzc2VkU2l6ZSA9IGRhdGEudmlldy5nZXRVaW50MzIoaW5kZXggKyAxOCwgdHJ1ZSk7XG5cdFx0fVxuXHRcdGlmIChlbnRyeS5jb21wcmVzc2VkU2l6ZSA9PT0gMHhGRkZGRkZGRiB8fCBlbnRyeS51bmNvbXByZXNzZWRTaXplID09PSAweEZGRkZGRkZGKSB7XG5cdFx0XHRvbmVycm9yKEVSUl9aSVA2NCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGVudHJ5LmZpbGVuYW1lTGVuZ3RoID0gZGF0YS52aWV3LmdldFVpbnQxNihpbmRleCArIDIyLCB0cnVlKTtcblx0XHRlbnRyeS5leHRyYUZpZWxkTGVuZ3RoID0gZGF0YS52aWV3LmdldFVpbnQxNihpbmRleCArIDI0LCB0cnVlKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZVppcFJlYWRlcihyZWFkZXIsIGNhbGxiYWNrLCBvbmVycm9yKSB7XG5cdFx0dmFyIGluZmxhdGVTTiA9IDA7XG5cblx0XHRmdW5jdGlvbiBFbnRyeSgpIHtcblx0XHR9XG5cblx0XHRFbnRyeS5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uKHdyaXRlciwgb25lbmQsIG9ucHJvZ3Jlc3MsIGNoZWNrQ3JjMzIpIHtcblx0XHRcdHZhciB0aGF0ID0gdGhpcztcblxuXHRcdFx0ZnVuY3Rpb24gdGVzdENyYzMyKGNyYzMyKSB7XG5cdFx0XHRcdHZhciBkYXRhQ3JjMzIgPSBnZXREYXRhSGVscGVyKDQpO1xuXHRcdFx0XHRkYXRhQ3JjMzIudmlldy5zZXRVaW50MzIoMCwgY3JjMzIpO1xuXHRcdFx0XHRyZXR1cm4gdGhhdC5jcmMzMiA9PSBkYXRhQ3JjMzIudmlldy5nZXRVaW50MzIoMCk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGdldFdyaXRlckRhdGEodW5jb21wcmVzc2VkU2l6ZSwgY3JjMzIpIHtcblx0XHRcdFx0aWYgKGNoZWNrQ3JjMzIgJiYgIXRlc3RDcmMzMihjcmMzMikpXG5cdFx0XHRcdFx0b25lcnJvcihFUlJfQ1JDKTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHdyaXRlci5nZXREYXRhKGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0XHRcdG9uZW5kKGRhdGEpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBvbnJlYWRlcnJvcihlcnIpIHtcblx0XHRcdFx0b25lcnJvcihlcnIgfHwgRVJSX1JFQURfREFUQSk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIG9ud3JpdGVlcnJvcihlcnIpIHtcblx0XHRcdFx0b25lcnJvcihlcnIgfHwgRVJSX1dSSVRFX0RBVEEpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZWFkZXIucmVhZFVpbnQ4QXJyYXkodGhhdC5vZmZzZXQsIDMwLCBmdW5jdGlvbihieXRlcykge1xuXHRcdFx0XHR2YXIgZGF0YSA9IGdldERhdGFIZWxwZXIoYnl0ZXMubGVuZ3RoLCBieXRlcyksIGRhdGFPZmZzZXQ7XG5cdFx0XHRcdGlmIChkYXRhLnZpZXcuZ2V0VWludDMyKDApICE9IDB4NTA0YjAzMDQpIHtcblx0XHRcdFx0XHRvbmVycm9yKEVSUl9CQURfRk9STUFUKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0cmVhZENvbW1vbkhlYWRlcih0aGF0LCBkYXRhLCA0LCBmYWxzZSwgb25lcnJvcik7XG5cdFx0XHRcdGRhdGFPZmZzZXQgPSB0aGF0Lm9mZnNldCArIDMwICsgdGhhdC5maWxlbmFtZUxlbmd0aCArIHRoYXQuZXh0cmFGaWVsZExlbmd0aDtcblx0XHRcdFx0d3JpdGVyLmluaXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKHRoYXQuY29tcHJlc3Npb25NZXRob2QgPT09IDApXG5cdFx0XHRcdFx0XHRjb3B5KHRoYXQuX3dvcmtlciwgaW5mbGF0ZVNOKyssIHJlYWRlciwgd3JpdGVyLCBkYXRhT2Zmc2V0LCB0aGF0LmNvbXByZXNzZWRTaXplLCBjaGVja0NyYzMyLCBnZXRXcml0ZXJEYXRhLCBvbnByb2dyZXNzLCBvbnJlYWRlcnJvciwgb253cml0ZWVycm9yKTtcblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRpbmZsYXRlKHRoYXQuX3dvcmtlciwgaW5mbGF0ZVNOKyssIHJlYWRlciwgd3JpdGVyLCBkYXRhT2Zmc2V0LCB0aGF0LmNvbXByZXNzZWRTaXplLCBjaGVja0NyYzMyLCBnZXRXcml0ZXJEYXRhLCBvbnByb2dyZXNzLCBvbnJlYWRlcnJvciwgb253cml0ZWVycm9yKTtcblx0XHRcdFx0fSwgb253cml0ZWVycm9yKTtcblx0XHRcdH0sIG9ucmVhZGVycm9yKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gc2Vla0VPQ0RSKGVvY2RyQ2FsbGJhY2spIHtcblx0XHRcdC8vIFwiRW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IHJlY29yZFwiIGlzIHRoZSBsYXN0IHBhcnQgb2YgYSB6aXAgYXJjaGl2ZSwgYW5kIGlzIGF0IGxlYXN0IDIyIGJ5dGVzIGxvbmcuXG5cdFx0XHQvLyBaaXAgZmlsZSBjb21tZW50IGlzIHRoZSBsYXN0IHBhcnQgb2YgRU9DRFIgYW5kIGhhcyBtYXggbGVuZ3RoIG9mIDY0S0IsXG5cdFx0XHQvLyBzbyB3ZSBvbmx5IGhhdmUgdG8gc2VhcmNoIHRoZSBsYXN0IDY0SyArIDIyIGJ5dGVzIG9mIGEgYXJjaGl2ZSBmb3IgRU9DRFIgc2lnbmF0dXJlICgweDA2MDU0YjUwKS5cblx0XHRcdHZhciBFT0NEUl9NSU4gPSAyMjtcblx0XHRcdGlmIChyZWFkZXIuc2l6ZSA8IEVPQ0RSX01JTikge1xuXHRcdFx0XHRvbmVycm9yKEVSUl9CQURfRk9STUFUKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIFpJUF9DT01NRU5UX01BWCA9IDI1NiAqIDI1NiwgRU9DRFJfTUFYID0gRU9DRFJfTUlOICsgWklQX0NPTU1FTlRfTUFYO1xuXG5cdFx0XHQvLyBJbiBtb3N0IGNhc2VzLCB0aGUgRU9DRFIgaXMgRU9DRFJfTUlOIGJ5dGVzIGxvbmdcblx0XHRcdGRvU2VlayhFT0NEUl9NSU4sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBJZiBub3QgZm91bmQsIHRyeSB3aXRoaW4gRU9DRFJfTUFYIGJ5dGVzXG5cdFx0XHRcdGRvU2VlayhNYXRoLm1pbihFT0NEUl9NQVgsIHJlYWRlci5zaXplKSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0b25lcnJvcihFUlJfQkFEX0ZPUk1BVCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIHNlZWsgbGFzdCBsZW5ndGggYnl0ZXMgb2YgZmlsZSBmb3IgRU9DRFJcblx0XHRcdGZ1bmN0aW9uIGRvU2VlayhsZW5ndGgsIGVvY2RyTm90Rm91bmRDYWxsYmFjaykge1xuXHRcdFx0XHRyZWFkZXIucmVhZFVpbnQ4QXJyYXkocmVhZGVyLnNpemUgLSBsZW5ndGgsIGxlbmd0aCwgZnVuY3Rpb24oYnl0ZXMpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gYnl0ZXMubGVuZ3RoIC0gRU9DRFJfTUlOOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRcdFx0aWYgKGJ5dGVzW2ldID09PSAweDUwICYmIGJ5dGVzW2kgKyAxXSA9PT0gMHg0YiAmJiBieXRlc1tpICsgMl0gPT09IDB4MDUgJiYgYnl0ZXNbaSArIDNdID09PSAweDA2KSB7XG5cdFx0XHRcdFx0XHRcdGVvY2RyQ2FsbGJhY2sobmV3IERhdGFWaWV3KGJ5dGVzLmJ1ZmZlciwgaSwgRU9DRFJfTUlOKSk7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZW9jZHJOb3RGb3VuZENhbGxiYWNrKCk7XG5cdFx0XHRcdH0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdG9uZXJyb3IoRVJSX1JFQUQpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgemlwUmVhZGVyID0ge1xuXHRcdFx0Z2V0RW50cmllcyA6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0XHRcdHZhciB3b3JrZXIgPSB0aGlzLl93b3JrZXI7XG5cdFx0XHRcdC8vIGxvb2sgZm9yIEVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSByZWNvcmRcblx0XHRcdFx0c2Vla0VPQ0RSKGZ1bmN0aW9uKGRhdGFWaWV3KSB7XG5cdFx0XHRcdFx0dmFyIGRhdGFsZW5ndGgsIGZpbGVzbGVuZ3RoO1xuXHRcdFx0XHRcdGRhdGFsZW5ndGggPSBkYXRhVmlldy5nZXRVaW50MzIoMTYsIHRydWUpO1xuXHRcdFx0XHRcdGZpbGVzbGVuZ3RoID0gZGF0YVZpZXcuZ2V0VWludDE2KDgsIHRydWUpO1xuXHRcdFx0XHRcdGlmIChkYXRhbGVuZ3RoIDwgMCB8fCBkYXRhbGVuZ3RoID49IHJlYWRlci5zaXplKSB7XG5cdFx0XHRcdFx0XHRvbmVycm9yKEVSUl9CQURfRk9STUFUKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVhZGVyLnJlYWRVaW50OEFycmF5KGRhdGFsZW5ndGgsIHJlYWRlci5zaXplIC0gZGF0YWxlbmd0aCwgZnVuY3Rpb24oYnl0ZXMpIHtcblx0XHRcdFx0XHRcdHZhciBpLCBpbmRleCA9IDAsIGVudHJpZXMgPSBbXSwgZW50cnksIGZpbGVuYW1lLCBjb21tZW50LCBkYXRhID0gZ2V0RGF0YUhlbHBlcihieXRlcy5sZW5ndGgsIGJ5dGVzKTtcblx0XHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBmaWxlc2xlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdGVudHJ5ID0gbmV3IEVudHJ5KCk7XG5cdFx0XHRcdFx0XHRcdGVudHJ5Ll93b3JrZXIgPSB3b3JrZXI7XG5cdFx0XHRcdFx0XHRcdGlmIChkYXRhLnZpZXcuZ2V0VWludDMyKGluZGV4KSAhPSAweDUwNGIwMTAyKSB7XG5cdFx0XHRcdFx0XHRcdFx0b25lcnJvcihFUlJfQkFEX0ZPUk1BVCk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJlYWRDb21tb25IZWFkZXIoZW50cnksIGRhdGEsIGluZGV4ICsgNiwgdHJ1ZSwgb25lcnJvcik7XG5cdFx0XHRcdFx0XHRcdGVudHJ5LmNvbW1lbnRMZW5ndGggPSBkYXRhLnZpZXcuZ2V0VWludDE2KGluZGV4ICsgMzIsIHRydWUpO1xuXHRcdFx0XHRcdFx0XHRlbnRyeS5kaXJlY3RvcnkgPSAoKGRhdGEudmlldy5nZXRVaW50OChpbmRleCArIDM4KSAmIDB4MTApID09IDB4MTApO1xuXHRcdFx0XHRcdFx0XHRlbnRyeS5vZmZzZXQgPSBkYXRhLnZpZXcuZ2V0VWludDMyKGluZGV4ICsgNDIsIHRydWUpO1xuXHRcdFx0XHRcdFx0XHRmaWxlbmFtZSA9IGdldFN0cmluZyhkYXRhLmFycmF5LnN1YmFycmF5KGluZGV4ICsgNDYsIGluZGV4ICsgNDYgKyBlbnRyeS5maWxlbmFtZUxlbmd0aCkpO1xuXHRcdFx0XHRcdFx0XHRlbnRyeS5maWxlbmFtZSA9ICgoZW50cnkuYml0RmxhZyAmIDB4MDgwMCkgPT09IDB4MDgwMCkgPyBkZWNvZGVVVEY4KGZpbGVuYW1lKSA6IGRlY29kZUFTQ0lJKGZpbGVuYW1lKTtcblx0XHRcdFx0XHRcdFx0aWYgKCFlbnRyeS5kaXJlY3RvcnkgJiYgZW50cnkuZmlsZW5hbWUuY2hhckF0KGVudHJ5LmZpbGVuYW1lLmxlbmd0aCAtIDEpID09IFwiL1wiKVxuXHRcdFx0XHRcdFx0XHRcdGVudHJ5LmRpcmVjdG9yeSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGNvbW1lbnQgPSBnZXRTdHJpbmcoZGF0YS5hcnJheS5zdWJhcnJheShpbmRleCArIDQ2ICsgZW50cnkuZmlsZW5hbWVMZW5ndGggKyBlbnRyeS5leHRyYUZpZWxkTGVuZ3RoLCBpbmRleCArIDQ2XG5cdFx0XHRcdFx0XHRcdFx0XHQrIGVudHJ5LmZpbGVuYW1lTGVuZ3RoICsgZW50cnkuZXh0cmFGaWVsZExlbmd0aCArIGVudHJ5LmNvbW1lbnRMZW5ndGgpKTtcblx0XHRcdFx0XHRcdFx0ZW50cnkuY29tbWVudCA9ICgoZW50cnkuYml0RmxhZyAmIDB4MDgwMCkgPT09IDB4MDgwMCkgPyBkZWNvZGVVVEY4KGNvbW1lbnQpIDogZGVjb2RlQVNDSUkoY29tbWVudCk7XG5cdFx0XHRcdFx0XHRcdGVudHJpZXMucHVzaChlbnRyeSk7XG5cdFx0XHRcdFx0XHRcdGluZGV4ICs9IDQ2ICsgZW50cnkuZmlsZW5hbWVMZW5ndGggKyBlbnRyeS5leHRyYUZpZWxkTGVuZ3RoICsgZW50cnkuY29tbWVudExlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNhbGxiYWNrKGVudHJpZXMpO1xuXHRcdFx0XHRcdH0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0b25lcnJvcihFUlJfUkVBRCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHRcdGNsb3NlIDogZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRcdFx0aWYgKHRoaXMuX3dvcmtlcikge1xuXHRcdFx0XHRcdHRoaXMuX3dvcmtlci50ZXJtaW5hdGUoKTtcblx0XHRcdFx0XHR0aGlzLl93b3JrZXIgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjYWxsYmFjaylcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0fSxcblx0XHRcdF93b3JrZXI6IG51bGxcblx0XHR9O1xuXG5cdFx0aWYgKCFvYmouemlwLnVzZVdlYldvcmtlcnMpXG5cdFx0XHRjYWxsYmFjayh6aXBSZWFkZXIpO1xuXHRcdGVsc2Uge1xuXHRcdFx0Y3JlYXRlV29ya2VyKCdpbmZsYXRlcicsXG5cdFx0XHRcdGZ1bmN0aW9uKHdvcmtlcikge1xuXHRcdFx0XHRcdHppcFJlYWRlci5fd29ya2VyID0gd29ya2VyO1xuXHRcdFx0XHRcdGNhbGxiYWNrKHppcFJlYWRlcik7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmN0aW9uKGVycikge1xuXHRcdFx0XHRcdG9uZXJyb3IoZXJyKTtcblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblxuXHQvLyBaaXBXcml0ZXJcblxuXHRmdW5jdGlvbiBlbmNvZGVVVEY4KHN0cmluZykge1xuXHRcdHJldHVybiB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyaW5nKSk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRCeXRlcyhzdHIpIHtcblx0XHR2YXIgaSwgYXJyYXkgPSBbXTtcblx0XHRmb3IgKGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKVxuXHRcdFx0YXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSk7XG5cdFx0cmV0dXJuIGFycmF5O1xuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlWmlwV3JpdGVyKHdyaXRlciwgY2FsbGJhY2ssIG9uZXJyb3IsIGRvbnREZWZsYXRlKSB7XG5cdFx0dmFyIGZpbGVzID0ge30sIGZpbGVuYW1lcyA9IFtdLCBkYXRhbGVuZ3RoID0gMDtcblx0XHR2YXIgZGVmbGF0ZVNOID0gMDtcblxuXHRcdGZ1bmN0aW9uIG9ud3JpdGVlcnJvcihlcnIpIHtcblx0XHRcdG9uZXJyb3IoZXJyIHx8IEVSUl9XUklURSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25yZWFkZXJyb3IoZXJyKSB7XG5cdFx0XHRvbmVycm9yKGVyciB8fCBFUlJfUkVBRF9EQVRBKTtcblx0XHR9XG5cblx0XHR2YXIgemlwV3JpdGVyID0ge1xuXHRcdFx0YWRkIDogZnVuY3Rpb24obmFtZSwgcmVhZGVyLCBvbmVuZCwgb25wcm9ncmVzcywgb3B0aW9ucykge1xuXHRcdFx0XHR2YXIgaGVhZGVyLCBmaWxlbmFtZSwgZGF0ZTtcblx0XHRcdFx0dmFyIHdvcmtlciA9IHRoaXMuX3dvcmtlcjtcblxuXHRcdFx0XHRmdW5jdGlvbiB3cml0ZUhlYWRlcihjYWxsYmFjaykge1xuXHRcdFx0XHRcdHZhciBkYXRhO1xuXHRcdFx0XHRcdGRhdGUgPSBvcHRpb25zLmxhc3RNb2REYXRlIHx8IG5ldyBEYXRlKCk7XG5cdFx0XHRcdFx0aGVhZGVyID0gZ2V0RGF0YUhlbHBlcigyNik7XG5cdFx0XHRcdFx0ZmlsZXNbbmFtZV0gPSB7XG5cdFx0XHRcdFx0XHRoZWFkZXJBcnJheSA6IGhlYWRlci5hcnJheSxcblx0XHRcdFx0XHRcdGRpcmVjdG9yeSA6IG9wdGlvbnMuZGlyZWN0b3J5LFxuXHRcdFx0XHRcdFx0ZmlsZW5hbWUgOiBmaWxlbmFtZSxcblx0XHRcdFx0XHRcdG9mZnNldCA6IGRhdGFsZW5ndGgsXG5cdFx0XHRcdFx0XHRjb21tZW50IDogZ2V0Qnl0ZXMoZW5jb2RlVVRGOChvcHRpb25zLmNvbW1lbnQgfHwgXCJcIikpXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRoZWFkZXIudmlldy5zZXRVaW50MzIoMCwgMHgxNDAwMDgwOCk7XG5cdFx0XHRcdFx0aWYgKG9wdGlvbnMudmVyc2lvbilcblx0XHRcdFx0XHRcdGhlYWRlci52aWV3LnNldFVpbnQ4KDAsIG9wdGlvbnMudmVyc2lvbik7XG5cdFx0XHRcdFx0aWYgKCFkb250RGVmbGF0ZSAmJiBvcHRpb25zLmxldmVsICE9PSAwICYmICFvcHRpb25zLmRpcmVjdG9yeSlcblx0XHRcdFx0XHRcdGhlYWRlci52aWV3LnNldFVpbnQxNig0LCAweDA4MDApO1xuXHRcdFx0XHRcdGhlYWRlci52aWV3LnNldFVpbnQxNig2LCAoKChkYXRlLmdldEhvdXJzKCkgPDwgNikgfCBkYXRlLmdldE1pbnV0ZXMoKSkgPDwgNSkgfCBkYXRlLmdldFNlY29uZHMoKSAvIDIsIHRydWUpO1xuXHRcdFx0XHRcdGhlYWRlci52aWV3LnNldFVpbnQxNig4LCAoKCgoZGF0ZS5nZXRGdWxsWWVhcigpIC0gMTk4MCkgPDwgNCkgfCAoZGF0ZS5nZXRNb250aCgpICsgMSkpIDw8IDUpIHwgZGF0ZS5nZXREYXRlKCksIHRydWUpO1xuXHRcdFx0XHRcdGhlYWRlci52aWV3LnNldFVpbnQxNigyMiwgZmlsZW5hbWUubGVuZ3RoLCB0cnVlKTtcblx0XHRcdFx0XHRkYXRhID0gZ2V0RGF0YUhlbHBlcigzMCArIGZpbGVuYW1lLmxlbmd0aCk7XG5cdFx0XHRcdFx0ZGF0YS52aWV3LnNldFVpbnQzMigwLCAweDUwNGIwMzA0KTtcblx0XHRcdFx0XHRkYXRhLmFycmF5LnNldChoZWFkZXIuYXJyYXksIDQpO1xuXHRcdFx0XHRcdGRhdGEuYXJyYXkuc2V0KGZpbGVuYW1lLCAzMCk7XG5cdFx0XHRcdFx0ZGF0YWxlbmd0aCArPSBkYXRhLmFycmF5Lmxlbmd0aDtcblx0XHRcdFx0XHR3cml0ZXIud3JpdGVVaW50OEFycmF5KGRhdGEuYXJyYXksIGNhbGxiYWNrLCBvbndyaXRlZXJyb3IpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZnVuY3Rpb24gd3JpdGVGb290ZXIoY29tcHJlc3NlZExlbmd0aCwgY3JjMzIpIHtcblx0XHRcdFx0XHR2YXIgZm9vdGVyID0gZ2V0RGF0YUhlbHBlcigxNik7XG5cdFx0XHRcdFx0ZGF0YWxlbmd0aCArPSBjb21wcmVzc2VkTGVuZ3RoIHx8IDA7XG5cdFx0XHRcdFx0Zm9vdGVyLnZpZXcuc2V0VWludDMyKDAsIDB4NTA0YjA3MDgpO1xuXHRcdFx0XHRcdGlmICh0eXBlb2YgY3JjMzIgIT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0XHRcdFx0aGVhZGVyLnZpZXcuc2V0VWludDMyKDEwLCBjcmMzMiwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRmb290ZXIudmlldy5zZXRVaW50MzIoNCwgY3JjMzIsIHRydWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocmVhZGVyKSB7XG5cdFx0XHRcdFx0XHRmb290ZXIudmlldy5zZXRVaW50MzIoOCwgY29tcHJlc3NlZExlbmd0aCwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRoZWFkZXIudmlldy5zZXRVaW50MzIoMTQsIGNvbXByZXNzZWRMZW5ndGgsIHRydWUpO1xuXHRcdFx0XHRcdFx0Zm9vdGVyLnZpZXcuc2V0VWludDMyKDEyLCByZWFkZXIuc2l6ZSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRoZWFkZXIudmlldy5zZXRVaW50MzIoMTgsIHJlYWRlci5zaXplLCB0cnVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d3JpdGVyLndyaXRlVWludDhBcnJheShmb290ZXIuYXJyYXksIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0ZGF0YWxlbmd0aCArPSAxNjtcblx0XHRcdFx0XHRcdG9uZW5kKCk7XG5cdFx0XHRcdFx0fSwgb253cml0ZWVycm9yKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZ1bmN0aW9uIHdyaXRlRmlsZSgpIHtcblx0XHRcdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRcdFx0XHRuYW1lID0gbmFtZS50cmltKCk7XG5cdFx0XHRcdFx0aWYgKG9wdGlvbnMuZGlyZWN0b3J5ICYmIG5hbWUuY2hhckF0KG5hbWUubGVuZ3RoIC0gMSkgIT0gXCIvXCIpXG5cdFx0XHRcdFx0XHRuYW1lICs9IFwiL1wiO1xuXHRcdFx0XHRcdGlmIChmaWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuXHRcdFx0XHRcdFx0b25lcnJvcihFUlJfRFVQTElDQVRFRF9OQU1FKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZmlsZW5hbWUgPSBnZXRCeXRlcyhlbmNvZGVVVEY4KG5hbWUpKTtcblx0XHRcdFx0XHRmaWxlbmFtZXMucHVzaChuYW1lKTtcblx0XHRcdFx0XHR3cml0ZUhlYWRlcihmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmIChyZWFkZXIpXG5cdFx0XHRcdFx0XHRcdGlmIChkb250RGVmbGF0ZSB8fCBvcHRpb25zLmxldmVsID09PSAwKVxuXHRcdFx0XHRcdFx0XHRcdGNvcHkod29ya2VyLCBkZWZsYXRlU04rKywgcmVhZGVyLCB3cml0ZXIsIDAsIHJlYWRlci5zaXplLCB0cnVlLCB3cml0ZUZvb3Rlciwgb25wcm9ncmVzcywgb25yZWFkZXJyb3IsIG9ud3JpdGVlcnJvcik7XG5cdFx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0XHRkZWZsYXRlKHdvcmtlciwgZGVmbGF0ZVNOKyssIHJlYWRlciwgd3JpdGVyLCBvcHRpb25zLmxldmVsLCB3cml0ZUZvb3Rlciwgb25wcm9ncmVzcywgb25yZWFkZXJyb3IsIG9ud3JpdGVlcnJvcik7XG5cdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdHdyaXRlRm9vdGVyKCk7XG5cdFx0XHRcdFx0fSwgb253cml0ZWVycm9yKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChyZWFkZXIpXG5cdFx0XHRcdFx0cmVhZGVyLmluaXQod3JpdGVGaWxlLCBvbnJlYWRlcnJvcik7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHR3cml0ZUZpbGUoKTtcblx0XHRcdH0sXG5cdFx0XHRjbG9zZSA6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0XHRcdGlmICh0aGlzLl93b3JrZXIpIHtcblx0XHRcdFx0XHR0aGlzLl93b3JrZXIudGVybWluYXRlKCk7XG5cdFx0XHRcdFx0dGhpcy5fd29ya2VyID0gbnVsbDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBkYXRhLCBsZW5ndGggPSAwLCBpbmRleCA9IDAsIGluZGV4RmlsZW5hbWUsIGZpbGU7XG5cdFx0XHRcdGZvciAoaW5kZXhGaWxlbmFtZSA9IDA7IGluZGV4RmlsZW5hbWUgPCBmaWxlbmFtZXMubGVuZ3RoOyBpbmRleEZpbGVuYW1lKyspIHtcblx0XHRcdFx0XHRmaWxlID0gZmlsZXNbZmlsZW5hbWVzW2luZGV4RmlsZW5hbWVdXTtcblx0XHRcdFx0XHRsZW5ndGggKz0gNDYgKyBmaWxlLmZpbGVuYW1lLmxlbmd0aCArIGZpbGUuY29tbWVudC5sZW5ndGg7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YSA9IGdldERhdGFIZWxwZXIobGVuZ3RoICsgMjIpO1xuXHRcdFx0XHRmb3IgKGluZGV4RmlsZW5hbWUgPSAwOyBpbmRleEZpbGVuYW1lIDwgZmlsZW5hbWVzLmxlbmd0aDsgaW5kZXhGaWxlbmFtZSsrKSB7XG5cdFx0XHRcdFx0ZmlsZSA9IGZpbGVzW2ZpbGVuYW1lc1tpbmRleEZpbGVuYW1lXV07XG5cdFx0XHRcdFx0ZGF0YS52aWV3LnNldFVpbnQzMihpbmRleCwgMHg1MDRiMDEwMik7XG5cdFx0XHRcdFx0ZGF0YS52aWV3LnNldFVpbnQxNihpbmRleCArIDQsIDB4MTQwMCk7XG5cdFx0XHRcdFx0ZGF0YS5hcnJheS5zZXQoZmlsZS5oZWFkZXJBcnJheSwgaW5kZXggKyA2KTtcblx0XHRcdFx0XHRkYXRhLnZpZXcuc2V0VWludDE2KGluZGV4ICsgMzIsIGZpbGUuY29tbWVudC5sZW5ndGgsIHRydWUpO1xuXHRcdFx0XHRcdGlmIChmaWxlLmRpcmVjdG9yeSlcblx0XHRcdFx0XHRcdGRhdGEudmlldy5zZXRVaW50OChpbmRleCArIDM4LCAweDEwKTtcblx0XHRcdFx0XHRkYXRhLnZpZXcuc2V0VWludDMyKGluZGV4ICsgNDIsIGZpbGUub2Zmc2V0LCB0cnVlKTtcblx0XHRcdFx0XHRkYXRhLmFycmF5LnNldChmaWxlLmZpbGVuYW1lLCBpbmRleCArIDQ2KTtcblx0XHRcdFx0XHRkYXRhLmFycmF5LnNldChmaWxlLmNvbW1lbnQsIGluZGV4ICsgNDYgKyBmaWxlLmZpbGVuYW1lLmxlbmd0aCk7XG5cdFx0XHRcdFx0aW5kZXggKz0gNDYgKyBmaWxlLmZpbGVuYW1lLmxlbmd0aCArIGZpbGUuY29tbWVudC5sZW5ndGg7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YS52aWV3LnNldFVpbnQzMihpbmRleCwgMHg1MDRiMDUwNik7XG5cdFx0XHRcdGRhdGEudmlldy5zZXRVaW50MTYoaW5kZXggKyA4LCBmaWxlbmFtZXMubGVuZ3RoLCB0cnVlKTtcblx0XHRcdFx0ZGF0YS52aWV3LnNldFVpbnQxNihpbmRleCArIDEwLCBmaWxlbmFtZXMubGVuZ3RoLCB0cnVlKTtcblx0XHRcdFx0ZGF0YS52aWV3LnNldFVpbnQzMihpbmRleCArIDEyLCBsZW5ndGgsIHRydWUpO1xuXHRcdFx0XHRkYXRhLnZpZXcuc2V0VWludDMyKGluZGV4ICsgMTYsIGRhdGFsZW5ndGgsIHRydWUpO1xuXHRcdFx0XHR3cml0ZXIud3JpdGVVaW50OEFycmF5KGRhdGEuYXJyYXksIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHdyaXRlci5nZXREYXRhKGNhbGxiYWNrKTtcblx0XHRcdFx0fSwgb253cml0ZWVycm9yKTtcblx0XHRcdH0sXG5cdFx0XHRfd29ya2VyOiBudWxsXG5cdFx0fTtcblxuXHRcdGlmICghb2JqLnppcC51c2VXZWJXb3JrZXJzKVxuXHRcdFx0Y2FsbGJhY2soemlwV3JpdGVyKTtcblx0XHRlbHNlIHtcblx0XHRcdGNyZWF0ZVdvcmtlcignZGVmbGF0ZXInLFxuXHRcdFx0XHRmdW5jdGlvbih3b3JrZXIpIHtcblx0XHRcdFx0XHR6aXBXcml0ZXIuX3dvcmtlciA9IHdvcmtlcjtcblx0XHRcdFx0XHRjYWxsYmFjayh6aXBXcml0ZXIpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRmdW5jdGlvbihlcnIpIHtcblx0XHRcdFx0XHRvbmVycm9yKGVycik7XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gcmVzb2x2ZVVSTHModXJscykge1xuXHRcdHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuXHRcdHJldHVybiB1cmxzLm1hcChmdW5jdGlvbih1cmwpIHtcblx0XHRcdGEuaHJlZiA9IHVybDtcblx0XHRcdHJldHVybiBhLmhyZWY7XG5cdFx0fSk7XG5cdH1cblxuXHR2YXIgREVGQVVMVF9XT1JLRVJfU0NSSVBUUyA9IHtcblx0XHRkZWZsYXRlcjogWyd6LXdvcmtlci5qcycsICdkZWZsYXRlLmpzJ10sXG5cdFx0aW5mbGF0ZXI6IFsnei13b3JrZXIuanMnLCAnaW5mbGF0ZS5qcyddXG5cdH07XG5cdGZ1bmN0aW9uIGNyZWF0ZVdvcmtlcih0eXBlLCBjYWxsYmFjaywgb25lcnJvcikge1xuXHRcdGlmIChvYmouemlwLndvcmtlclNjcmlwdHMgIT09IG51bGwgJiYgb2JqLnppcC53b3JrZXJTY3JpcHRzUGF0aCAhPT0gbnVsbCkge1xuXHRcdFx0b25lcnJvcihuZXcgRXJyb3IoJ0VpdGhlciB6aXAud29ya2VyU2NyaXB0cyBvciB6aXAud29ya2VyU2NyaXB0c1BhdGggbWF5IGJlIHNldCwgbm90IGJvdGguJykpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgc2NyaXB0cztcblx0XHRpZiAob2JqLnppcC53b3JrZXJTY3JpcHRzKSB7XG5cdFx0XHRzY3JpcHRzID0gb2JqLnppcC53b3JrZXJTY3JpcHRzW3R5cGVdO1xuXHRcdFx0aWYgKCFBcnJheS5pc0FycmF5KHNjcmlwdHMpKSB7XG5cdFx0XHRcdG9uZXJyb3IobmV3IEVycm9yKCd6aXAud29ya2VyU2NyaXB0cy4nICsgdHlwZSArICcgaXMgbm90IGFuIGFycmF5IScpKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0c2NyaXB0cyA9IHJlc29sdmVVUkxzKHNjcmlwdHMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzY3JpcHRzID0gREVGQVVMVF9XT1JLRVJfU0NSSVBUU1t0eXBlXS5zbGljZSgwKTtcblx0XHRcdHNjcmlwdHNbMF0gPSAob2JqLnppcC53b3JrZXJTY3JpcHRzUGF0aCB8fCAnJykgKyBzY3JpcHRzWzBdO1xuXHRcdH1cblx0XHR2YXIgd29ya2VyID0gbmV3IFdvcmtlcihzY3JpcHRzWzBdKTtcblx0XHQvLyByZWNvcmQgdG90YWwgY29uc3VtZWQgdGltZSBieSBpbmZsYXRlci9kZWZsYXRlci9jcmMzMiBpbiB0aGlzIHdvcmtlclxuXHRcdHdvcmtlci5jb2RlY1RpbWUgPSB3b3JrZXIuY3JjVGltZSA9IDA7XG5cdFx0d29ya2VyLnBvc3RNZXNzYWdlKHsgdHlwZTogJ2ltcG9ydFNjcmlwdHMnLCBzY3JpcHRzOiBzY3JpcHRzLnNsaWNlKDEpIH0pO1xuXHRcdHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb25tZXNzYWdlKTtcblx0XHRmdW5jdGlvbiBvbm1lc3NhZ2UoZXYpIHtcblx0XHRcdHZhciBtc2cgPSBldi5kYXRhO1xuXHRcdFx0aWYgKG1zZy5lcnJvcikge1xuXHRcdFx0XHR3b3JrZXIudGVybWluYXRlKCk7IC8vIHNob3VsZCBiZWZvcmUgb25lcnJvcigpLCBiZWNhdXNlIG9uZXJyb3IoKSBtYXkgdGhyb3cuXG5cdFx0XHRcdG9uZXJyb3IobXNnLmVycm9yKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG1zZy50eXBlID09PSAnaW1wb3J0U2NyaXB0cycpIHtcblx0XHRcdFx0d29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbm1lc3NhZ2UpO1xuXHRcdFx0XHR3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvckhhbmRsZXIpO1xuXHRcdFx0XHRjYWxsYmFjayh3b3JrZXIpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBjYXRjaCBlbnRyeSBzY3JpcHQgbG9hZGluZyBlcnJvciBhbmQgb3RoZXIgdW5oYW5kbGVkIGVycm9yc1xuXHRcdHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9ySGFuZGxlcik7XG5cdFx0ZnVuY3Rpb24gZXJyb3JIYW5kbGVyKGVycikge1xuXHRcdFx0d29ya2VyLnRlcm1pbmF0ZSgpO1xuXHRcdFx0b25lcnJvcihlcnIpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIG9uZXJyb3JfZGVmYXVsdChlcnJvcikge1xuXHRcdGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuXHR9XG5cdG9iai56aXAgPSB7XG5cdFx0UmVhZGVyIDogUmVhZGVyLFxuXHRcdFdyaXRlciA6IFdyaXRlcixcblx0XHRCbG9iUmVhZGVyIDogQmxvYlJlYWRlcixcblx0XHREYXRhNjRVUklSZWFkZXIgOiBEYXRhNjRVUklSZWFkZXIsXG5cdFx0VGV4dFJlYWRlciA6IFRleHRSZWFkZXIsXG5cdFx0QmxvYldyaXRlciA6IEJsb2JXcml0ZXIsXG5cdFx0RGF0YTY0VVJJV3JpdGVyIDogRGF0YTY0VVJJV3JpdGVyLFxuXHRcdFRleHRXcml0ZXIgOiBUZXh0V3JpdGVyLFxuXHRcdGNyZWF0ZVJlYWRlciA6IGZ1bmN0aW9uKHJlYWRlciwgY2FsbGJhY2ssIG9uZXJyb3IpIHtcblx0XHRcdG9uZXJyb3IgPSBvbmVycm9yIHx8IG9uZXJyb3JfZGVmYXVsdDtcblxuXHRcdFx0cmVhZGVyLmluaXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNyZWF0ZVppcFJlYWRlcihyZWFkZXIsIGNhbGxiYWNrLCBvbmVycm9yKTtcblx0XHRcdH0sIG9uZXJyb3IpO1xuXHRcdH0sXG5cdFx0Y3JlYXRlV3JpdGVyIDogZnVuY3Rpb24od3JpdGVyLCBjYWxsYmFjaywgb25lcnJvciwgZG9udERlZmxhdGUpIHtcblx0XHRcdG9uZXJyb3IgPSBvbmVycm9yIHx8IG9uZXJyb3JfZGVmYXVsdDtcblx0XHRcdGRvbnREZWZsYXRlID0gISFkb250RGVmbGF0ZTtcblxuXHRcdFx0d3JpdGVyLmluaXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNyZWF0ZVppcFdyaXRlcih3cml0ZXIsIGNhbGxiYWNrLCBvbmVycm9yLCBkb250RGVmbGF0ZSk7XG5cdFx0XHR9LCBvbmVycm9yKTtcblx0XHR9LFxuXHRcdHVzZVdlYldvcmtlcnMgOiB0cnVlLFxuXHRcdC8qKlxuXHRcdCAqIERpcmVjdG9yeSBjb250YWluaW5nIHRoZSBkZWZhdWx0IHdvcmtlciBzY3JpcHRzICh6LXdvcmtlci5qcywgZGVmbGF0ZS5qcywgYW5kIGluZmxhdGUuanMpLCByZWxhdGl2ZSB0byBjdXJyZW50IGJhc2UgdXJsLlxuXHRcdCAqIEUuZy46IHppcC53b3JrZXJTY3JpcHRzID0gJy4vJztcblx0XHQgKi9cblx0XHR3b3JrZXJTY3JpcHRzUGF0aCA6IG51bGwsXG5cdFx0LyoqXG5cdFx0ICogQWR2YW5jZWQgb3B0aW9uIHRvIGNvbnRyb2wgd2hpY2ggc2NyaXB0cyBhcmUgbG9hZGVkIGluIHRoZSBXZWIgd29ya2VyLiBJZiB0aGlzIG9wdGlvbiBpcyBzcGVjaWZpZWQsIHRoZW4gd29ya2VyU2NyaXB0c1BhdGggbXVzdCBub3QgYmUgc2V0LlxuXHRcdCAqIHdvcmtlclNjcmlwdHMuZGVmbGF0ZXIvd29ya2VyU2NyaXB0cy5pbmZsYXRlciBzaG91bGQgYmUgYXJyYXlzIG9mIHVybHMgdG8gc2NyaXB0cyBmb3IgZGVmbGF0ZXIvaW5mbGF0ZXIsIHJlc3BlY3RpdmVseS5cblx0XHQgKiBTY3JpcHRzIGluIHRoZSBhcnJheSBhcmUgZXhlY3V0ZWQgaW4gb3JkZXIsIGFuZCB0aGUgZmlyc3Qgb25lIHNob3VsZCBiZSB6LXdvcmtlci5qcywgd2hpY2ggaXMgdXNlZCB0byBzdGFydCB0aGUgd29ya2VyLlxuXHRcdCAqIEFsbCB1cmxzIGFyZSByZWxhdGl2ZSB0byBjdXJyZW50IGJhc2UgdXJsLlxuXHRcdCAqIEUuZy46XG5cdFx0ICogemlwLndvcmtlclNjcmlwdHMgPSB7XG5cdFx0ICogICBkZWZsYXRlcjogWyd6LXdvcmtlci5qcycsICdkZWZsYXRlLmpzJ10sXG5cdFx0ICogICBpbmZsYXRlcjogWyd6LXdvcmtlci5qcycsICdpbmZsYXRlLmpzJ11cblx0XHQgKiB9O1xuXHRcdCAqL1xuXHRcdHdvcmtlclNjcmlwdHMgOiBudWxsLFxuXHR9O1xuXG59KSh0aGlzKTtcblxuOyBicm93c2VyaWZ5X3NoaW1fX2RlZmluZV9fbW9kdWxlX19leHBvcnRfXyh0eXBlb2YgemlwICE9IFwidW5kZWZpbmVkXCIgPyB6aXAgOiB3aW5kb3cuemlwKTtcblxufSkuY2FsbChnbG9iYWwsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZnVuY3Rpb24gZGVmaW5lRXhwb3J0KGV4KSB7IG1vZHVsZS5leHBvcnRzID0gZXg7IH0pO1xuIl19
